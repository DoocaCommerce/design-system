var x0 = Object.defineProperty;
var w0 = (a, e, t) => e in a ? x0(a, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : a[e] = t;
var je = (a, e, t) => (w0(a, typeof e != "symbol" ? e + "" : e, t), t);
import { defineComponent as j, computed as ge, openBlock as M, createElementBlock as D, normalizeStyle as wt, toDisplayString as ne, ref as Z, reactive as Wr, onMounted as at, normalizeClass as he, createElementVNode as I, createBlock as q, createCommentVNode as X, createVNode as B, render as Tm, resolveDynamicComponent as Ut, withCtx as U, renderSlot as te, createTextVNode as ye, getCurrentInstance as yt, useSlots as oa, nextTick as $s, withDirectives as Ze, unref as et, createSlots as dd, withKeys as eh, Fragment as ke, renderList as Ae, withModifiers as Xt, watchEffect as Lt, Teleport as Am, mergeProps as al, vModelCheckbox as S0, version as k0, watch as zt, shallowRef as Ci, useCssVars as ol, watchPostEffect as Du, onUnmounted as $m, vShow as bt, vModelSelect as _0, resolveComponent as ud, inject as la, provide as C0, withMemo as T0, useAttrs as A0, onBeforeMount as $0, normalizeProps as E0 } from "vue";
function P0(a, e) {
  for (var t = 0; t < e.length; t++) {
    const i = e[t];
    if (typeof i != "string" && !Array.isArray(i)) {
      for (const s in i)
        if (s !== "default" && !(s in a)) {
          const n = Object.getOwnPropertyDescriptor(i, s);
          n && Object.defineProperty(a, s, n.get ? n : {
            enumerable: !0,
            get: () => i[s]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(a, Symbol.toStringTag, { value: "Module" }));
}
const Pe = j({
  __name: "Icon",
  props: {
    filled: { type: Boolean },
    name: {},
    size: { default: 16 }
  },
  setup(a) {
    const e = a, t = ge(() => {
      let i = {};
      return e.filled && (i.fontVariationSettings = "'FILL' 1"), e.size && (i.fontSize = e.size + "px", i.height = e.size + "px"), i;
    });
    return (i, s) => (M(), D("i", {
      class: "ui-icon material-symbols-outlined",
      style: wt(t.value)
    }, ne(i.name), 5));
  }
});
const L0 = { class: "ui-toast-body" }, M0 = ["innerHTML"], D0 = j({
  __name: "Toast",
  props: {
    className: {},
    closeable: { type: Boolean },
    duration: { default: 2e3 },
    id: {},
    message: {},
    variant: { default: "default" }
  },
  setup(a) {
    const e = a, t = Z(!1), i = Wr({
      option: {},
      showing: !1,
      timer: null
    }), s = ge(() => {
      let l = [];
      return e.variant && l.push(`-variant-${e.variant}`), l;
    }), n = () => {
      t.value = !0, i.timer = null, i.showing = !1, s.value.push("-leave"), setTimeout(() => {
        if (e.id) {
          const l = document.getElementById(e.id);
          l && document.body.removeChild(l);
        }
      }, 300);
    };
    at(() => {
      o(), i.showing = !0;
    });
    const o = () => {
      e.duration > 0 && (i.timer = setTimeout(() => {
        t.value || n();
      }, e.duration));
    };
    return (l, c) => (M(), D("div", {
      class: he(["ui-toast", s.value])
    }, [
      I("div", L0, [
        I("div", { innerHTML: l.message }, null, 8, M0)
      ]),
      l.closeable ? (M(), q(Pe, {
        key: 0,
        class: "ui-toast-close",
        name: "close",
        onClick: n
      })) : X("", !0)
    ], 2));
  }
}), R0 = {
  horizontalPosition: "center",
  verticalPosition: "bottom",
  transition: "slide-down",
  duration: 3e3,
  message: "",
  closeable: !1
};
let I0 = 1;
const Jl = (a, e = {}) => {
  let t = null, i = null;
  const s = "ui-toast-" + I0++;
  t = document.createElement("div"), t.id = s, i = B(
    D0,
    {
      ...R0,
      ...e,
      message: a,
      id: s,
      variant: e.type
    },
    null
  ), Tm(i, t), document.body.appendChild(t);
}, Q0 = {
  open: Jl,
  success(a) {
    Jl(a, { type: "success" });
  },
  danger(a) {
    Jl(a, { type: "critical" });
  }
};
const dn = j({
  __name: "Spinner",
  props: {
    border: { default: 3 },
    color: {},
    size: { default: 22 },
    variant: {}
  },
  setup(a) {
    const e = a, t = ge(() => {
      let s = [];
      return e.variant && s.push(`-variant-${e.variant}`), s;
    }), i = ge(() => {
      let s = {};
      return e.border && (s.borderWidth = e.border + "px"), e.color && (s.color = e.color), e.size && (s.width = e.size + "px"), s;
    });
    return (s, n) => (M(), D("div", {
      class: he(["ui-spinner", t.value]),
      style: wt(i.value)
    }, null, 6));
  }
});
const N0 = { class: "ui-button-content" }, F0 = {
  key: 2,
  class: "ui-button-label"
}, Le = j({
  __name: "Button",
  props: {
    variant: {},
    label: {},
    leadingIcon: {},
    trailingIcon: {},
    size: { default: "md" },
    href: {},
    flush: {},
    block: { type: Boolean },
    to: {},
    spinnerBorder: { default: 2 },
    type: { default: "button" },
    loading: { type: Boolean },
    outline: { type: Boolean },
    disclosure: { type: Boolean },
    target: {},
    disabled: { type: Boolean }
  },
  setup(a) {
    const e = a, t = ge(() => e.to ? "router-link" : e.href ? "a" : "BUTTON"), i = ge(() => [
      e.size ? `-${e.size}` : "",
      e.variant ? `-${e.variant}` : "-default",
      e.leadingIcon ? "-icon" : "",
      e.flush ? `-flush-${e.flush}` : "",
      e.block ? "-block" : "",
      e.outline ? "-outline" : "",
      e.disclosure ? "-disclosure" : "",
      (e.trailingIcon || e.leadingIcon) && !e.label ? "-only-icon" : ""
    ]), s = ge(() => e.disclosure ? "arrow_drop_down" : e.trailingIcon);
    return (n, o) => (M(), q(Ut(t.value), {
      class: he(["ui-button", [i.value, { "-loading": n.loading, "-disabled": n.disabled }]]),
      type: n.type,
      disabled: n.disabled,
      to: n.to,
      href: n.href,
      target: n.target
    }, {
      default: U(() => [
        I("div", N0, [
          n.leadingIcon ? (M(), q(Pe, {
            key: 0,
            name: n.leadingIcon
          }, null, 8, ["name"])) : X("", !0),
          n.loading ? (M(), q(dn, {
            key: 1,
            size: 16,
            border: n.spinnerBorder
          }, null, 8, ["border"])) : X("", !0),
          n.label || n.$slots.default ? (M(), D("div", F0, [
            te(n.$slots, "default", {}, () => [
              ye(ne(n.label), 1)
            ])
          ])) : X("", !0),
          s.value ? (M(), q(Pe, {
            key: 3,
            name: s.value
          }, null, 8, ["name"])) : X("", !0)
        ])
      ]),
      _: 3
    }, 8, ["type", "class", "disabled", "to", "href", "target"]));
  }
});
/*! maska v2.1.11 | (c) Alexander Shabunevich | Released under the MIT license */
var W0 = Object.defineProperty, B0 = (a, e, t) => e in a ? W0(a, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : a[e] = t, Pr = (a, e, t) => (B0(a, typeof e != "symbol" ? e + "" : e, t), t);
const Ru = {
  "#": { pattern: /[0-9]/ },
  "@": { pattern: /[a-zA-Z]/ },
  "*": { pattern: /[a-zA-Z0-9]/ }
};
class Iu {
  constructor(e = {}) {
    Pr(this, "opts", {}), Pr(this, "memo", /* @__PURE__ */ new Map());
    const t = { ...e };
    if (t.tokens != null) {
      t.tokens = t.tokensReplace ? { ...t.tokens } : { ...Ru, ...t.tokens };
      for (const i of Object.values(t.tokens))
        typeof i.pattern == "string" && (i.pattern = new RegExp(i.pattern));
    } else
      t.tokens = Ru;
    Array.isArray(t.mask) && (t.mask.length > 1 ? t.mask = [...t.mask].sort((i, s) => i.length - s.length) : t.mask = t.mask[0] ?? ""), t.mask === "" && (t.mask = null), this.opts = t;
  }
  masked(e) {
    return this.process(e, this.findMask(e));
  }
  unmasked(e) {
    return this.process(e, this.findMask(e), !1);
  }
  isEager() {
    return this.opts.eager === !0;
  }
  isReversed() {
    return this.opts.reversed === !0;
  }
  completed(e) {
    const t = this.findMask(e);
    if (this.opts.mask == null || t == null)
      return !1;
    const i = this.process(e, t).length;
    return typeof this.opts.mask == "string" ? i >= this.opts.mask.length : typeof this.opts.mask == "function" ? i >= t.length : this.opts.mask.filter((s) => i >= s.length).length === this.opts.mask.length;
  }
  findMask(e) {
    const t = this.opts.mask;
    if (t == null)
      return null;
    if (typeof t == "string")
      return t;
    if (typeof t == "function")
      return t(e);
    const i = this.process(e, t.slice(-1).pop() ?? "", !1);
    return t.find((s) => this.process(e, s, !1).length >= i.length) ?? "";
  }
  escapeMask(e) {
    const t = [], i = [];
    return e.split("").forEach((s, n) => {
      s === "!" && e[n - 1] !== "!" ? i.push(n - i.length) : t.push(s);
    }), { mask: t.join(""), escaped: i };
  }
  process(e, t, i = !0) {
    if (t == null)
      return e;
    const s = `value=${e},mask=${t},masked=${i ? 1 : 0}`;
    if (this.memo.has(s))
      return this.memo.get(s);
    const { mask: n, escaped: o } = this.escapeMask(t), l = [], c = this.opts.tokens != null ? this.opts.tokens : {}, d = this.isReversed() ? -1 : 1, f = this.isReversed() ? "unshift" : "push", p = this.isReversed() ? 0 : n.length - 1, m = this.isReversed() ? () => u > -1 && g > -1 : () => u < n.length && g < e.length, v = (O) => !this.isReversed() && O <= p || this.isReversed() && O >= p;
    let r, h = -1, u = this.isReversed() ? n.length - 1 : 0, g = this.isReversed() ? e.length - 1 : 0, b = !1;
    for (; m(); ) {
      const O = n.charAt(u), x = c[O], S = (x == null ? void 0 : x.transform) != null ? x.transform(e.charAt(g)) : e.charAt(g);
      if (!o.includes(u) && x != null ? (S.match(x.pattern) != null ? (l[f](S), x.repeated ? (h === -1 ? h = u : u === p && u !== h && (u = h - d), p === h && (u -= d)) : x.multiple && (b = !0, u -= d), u += d) : x.multiple ? b && (u += d, g -= d, b = !1) : S === r ? r = void 0 : x.optional && (u += d, g -= d), g += d) : (i && !this.isEager() && l[f](O), S === O && !this.isEager() ? g += d : r = O, this.isEager() || (u += d)), this.isEager())
        for (; v(u) && (c[n.charAt(u)] == null || o.includes(u)); )
          i ? l[f](n.charAt(u)) : n.charAt(u) === e.charAt(g) && (g += d), u += d;
    }
    return this.memo.set(s, l.join("")), this.memo.get(s);
  }
}
const Em = (a) => JSON.parse(a.replaceAll("'", '"')), Qu = (a, e = {}) => {
  const t = { ...e };
  return a.dataset.maska != null && a.dataset.maska !== "" && (t.mask = z0(a.dataset.maska)), a.dataset.maskaEager != null && (t.eager = ec(a.dataset.maskaEager)), a.dataset.maskaReversed != null && (t.reversed = ec(a.dataset.maskaReversed)), a.dataset.maskaTokensReplace != null && (t.tokensReplace = ec(a.dataset.maskaTokensReplace)), a.dataset.maskaTokens != null && (t.tokens = X0(a.dataset.maskaTokens)), t;
}, ec = (a) => a !== "" ? !!JSON.parse(a) : !0, z0 = (a) => a.startsWith("[") && a.endsWith("]") ? Em(a) : a, X0 = (a) => {
  if (a.startsWith("{") && a.endsWith("}"))
    return Em(a);
  const e = {};
  return a.split("|").forEach((t) => {
    const i = t.split(":");
    e[i[0]] = {
      pattern: new RegExp(i[1]),
      optional: i[2] === "optional",
      multiple: i[2] === "multiple",
      repeated: i[2] === "repeated"
    };
  }), e;
};
class Y0 {
  constructor(e, t = {}) {
    Pr(this, "items", /* @__PURE__ */ new Map()), Pr(this, "beforeinputEvent", (i) => {
      const s = i.target, n = this.items.get(s);
      n.isEager() && "inputType" in i && i.inputType.startsWith("delete") && n.unmasked(s.value).length <= 1 && this.setMaskedValue(s, "");
    }), Pr(this, "inputEvent", (i) => {
      if (i instanceof CustomEvent && i.type === "input" && i.detail != null && typeof i.detail == "object" && "masked" in i.detail)
        return;
      const s = i.target, n = this.items.get(s), o = s.value, l = s.selectionStart, c = s.selectionEnd;
      let d = o;
      if (n.isEager()) {
        const f = n.masked(o), p = n.unmasked(o);
        p === "" && "data" in i && i.data != null ? d = i.data : p !== n.unmasked(f) && (d = p);
      }
      if (this.setMaskedValue(s, d), "inputType" in i && (i.inputType.startsWith("delete") || l != null && l < o.length))
        try {
          s.setSelectionRange(l, c);
        } catch {
        }
    }), this.options = t, typeof e == "string" ? this.init(
      Array.from(document.querySelectorAll(e)),
      this.getMaskOpts(t)
    ) : this.init(
      "length" in e ? Array.from(e) : [e],
      this.getMaskOpts(t)
    );
  }
  destroy() {
    for (const e of this.items.keys())
      e.removeEventListener("input", this.inputEvent), e.removeEventListener("beforeinput", this.beforeinputEvent);
    this.items.clear();
  }
  needUpdateOptions(e, t) {
    const i = this.items.get(e), s = new Iu(Qu(e, this.getMaskOpts(t)));
    return JSON.stringify(i.opts) !== JSON.stringify(s.opts);
  }
  needUpdateValue(e) {
    const t = e.dataset.maskaValue;
    return t == null && e.value !== "" || t != null && t !== e.value;
  }
  getMaskOpts(e) {
    const { onMaska: t, preProcess: i, postProcess: s, ...n } = e;
    return n;
  }
  init(e, t) {
    for (const i of e) {
      const s = new Iu(Qu(i, t));
      this.items.set(i, s), i.value !== "" && this.setMaskedValue(i, i.value), i.addEventListener("input", this.inputEvent), i.addEventListener("beforeinput", this.beforeinputEvent);
    }
  }
  setMaskedValue(e, t) {
    const i = this.items.get(e);
    this.options.preProcess != null && (t = this.options.preProcess(t));
    const s = i.masked(t), n = i.unmasked(i.isEager() ? s : t), o = i.completed(t), l = { masked: s, unmasked: n, completed: o };
    t = s, this.options.postProcess != null && (t = this.options.postProcess(t)), e.value = t, e.dataset.maskaValue = t, this.options.onMaska != null && (Array.isArray(this.options.onMaska) ? this.options.onMaska.forEach((c) => c(l)) : this.options.onMaska(l)), e.dispatchEvent(new CustomEvent("maska", { detail: l })), e.dispatchEvent(new CustomEvent("input", { detail: l }));
  }
}
const th = /* @__PURE__ */ new WeakMap(), V0 = (a) => {
  setTimeout(() => {
    var e;
    ((e = th.get(a)) == null ? void 0 : e.needUpdateValue(a)) === !0 && a.dispatchEvent(new CustomEvent("input"));
  });
}, H0 = (a, e) => {
  const t = a instanceof HTMLInputElement ? a : a.querySelector("input"), i = { ...e.arg };
  if (t == null || (t == null ? void 0 : t.type) === "file")
    return;
  V0(t);
  const s = th.get(t);
  if (s != null) {
    if (!s.needUpdateOptions(t, i))
      return;
    s.destroy();
  }
  if (e.value != null) {
    const n = e.value, o = (l) => {
      n.masked = l.masked, n.unmasked = l.unmasked, n.completed = l.completed;
    };
    i.onMaska = i.onMaska == null ? o : Array.isArray(i.onMaska) ? [...i.onMaska, o] : [i.onMaska, o];
  }
  th.set(t, new Y0(t, i));
}, Pm = {
  mounted(a, e) {
    Nu(a, e);
  },
  updated(a, e) {
    Nu(a, e);
  }
};
function Nu(a, e) {
  const t = e.arg || "top", i = e.value || "Tooltip text";
  a.setAttribute("position", t), a.setAttribute("tooltip", i);
}
const G0 = {
  key: 0,
  class: "form-wrapper-label"
}, j0 = ["for", "innerHTML"], U0 = {
  key: 0,
  class: "form-wrapper-label-icon"
}, Z0 = { class: "ui-form-wrapper-main" }, q0 = { class: "form-wrapper-content-item form-wrapper-content-bx" }, K0 = { class: "form-wrapper-notched" }, J0 = /* @__PURE__ */ I("div", { class: "form-wrapper-notched-prepend" }, null, -1), ew = {
  key: 0,
  class: "form-wrapper-notched-label"
}, tw = ["for", "innerHTML"], iw = /* @__PURE__ */ I("div", { class: "form-wrapper-notched-append" }, null, -1), sw = { class: "trailing-wrapper" }, nw = {
  key: 1,
  class: "trailing-icon-text"
}, rw = {
  key: 1,
  class: "form-control-loader"
}, aw = {
  key: 0,
  class: "form-wrapper-append"
}, ow = {
  key: 1,
  class: "form-invalid-feedback"
}, ca = j({
  __name: "FormWrapper",
  props: {
    leadingIcon: {},
    trailingIcon: {},
    labelInfo: {},
    trailingText: {},
    state: { type: Boolean },
    loading: { type: Boolean },
    last: { type: Boolean },
    float: { type: Boolean },
    disabled: { type: Boolean },
    invalidFeedback: {},
    autofocus: { type: Boolean },
    size: {},
    label: {},
    id: {}
  },
  setup(a) {
    var l;
    const e = a, t = Z(), i = Z(e.id || `__VID__${(l = yt()) == null ? void 0 : l.uid}`), s = oa();
    at(() => {
      $s(() => {
        var d;
        const c = (d = t.value) == null ? void 0 : d.querySelectorAll("input, textarea, select");
        c && c[0] && (c[0].setAttribute("id", i.value), e.autofocus && c[0].focus(), e.float && c[0].setAttribute("placeholder", " "));
      });
    });
    const n = ge(() => [
      "ui-form-wrapper",
      e.leadingIcon && "-with-leading-icon",
      e.trailingIcon && "-with-trailing-icon",
      e.loading && "-loading",
      e.last && "-last",
      (e.disabled || e.loading) && "-disabled",
      e.float && "-float",
      e.size && `-${e.size}`
    ]), o = ge(() => e.state === !0 ? "-valid" : e.state === !1 ? "-invalid" : "");
    return (c, d) => (M(), D("div", {
      ref_key: "elementRef",
      ref: t,
      class: he([...n.value, o.value])
    }, [
      !c.float && e.label ? (M(), D("div", G0, [
        I("label", {
          class: "form-control-label",
          for: i.value,
          innerHTML: e.label
        }, null, 8, j0),
        c.labelInfo ? Ze((M(), D("span", U0, [
          B(Pe, {
            name: "help",
            class: "icon",
            size: 14
          })
        ])), [
          [et(Pm), c.labelInfo, "top"]
        ]) : X("", !0)
      ])) : X("", !0),
      I("div", Z0, [
        I("div", q0, [
          c.leadingIcon ? (M(), q(Pe, {
            key: 0,
            class: "leading-icon",
            name: c.leadingIcon,
            size: 20
          }, null, 8, ["name"])) : X("", !0),
          te(c.$slots, "default"),
          I("div", K0, [
            J0,
            c.float ? (M(), D("div", ew, [
              I("label", {
                class: "form-wrapper-label",
                for: i.value,
                innerHTML: e.label
              }, null, 8, tw)
            ])) : X("", !0),
            iw
          ]),
          I("div", sw, [
            c.trailingIcon && !c.loading ? (M(), q(Pe, {
              key: 0,
              class: "trailing-icon",
              name: c.trailingIcon,
              size: 20
            }, null, 8, ["name"])) : X("", !0),
            c.trailingText ? (M(), D("span", nw, ne(c.trailingText), 1)) : X("", !0),
            te(c.$slots, "trailingIcon")
          ]),
          c.loading ? (M(), D("div", rw, [
            B(dn, { class: "form-control-loader-spinner" })
          ])) : X("", !0)
        ]),
        et(s).append ? (M(), D("div", aw, [
          te(c.$slots, "append")
        ])) : X("", !0)
      ]),
      c.state === !1 && c.invalidFeedback ? (M(), D("div", ow, ne(c.invalidFeedback), 1)) : X("", !0)
    ], 2));
  }
}), lw = ["mask", "data-maska-tokens", "value", "placeholder", "type", "step", "inputmode", "autocomplete", "disabled", "minlength", "maxlength", "pattern", "autofocus", "readonly", "tabindex", "name", "title", "id", "max", "min", "required"], cw = {
  key: 0,
  class: "actions"
}, hi = j({
  __name: "FormTextfield",
  props: {
    leadingIcon: {},
    trailingIcon: {},
    labelInfo: {},
    trailingText: {},
    state: { type: Boolean, default: void 0 },
    invalidFeedback: {},
    loading: { type: Boolean },
    last: { type: Boolean },
    float: { type: Boolean },
    modelValue: {},
    label: {},
    id: {},
    placeholder: {},
    step: {},
    tabindex: {},
    inputmode: {},
    size: {},
    pattern: {},
    title: {},
    name: {},
    clearable: { type: Boolean },
    autocomplete: {},
    minlength: {},
    maxlength: {},
    autofocus: { type: Boolean },
    disabled: { type: Boolean },
    required: { type: Boolean },
    readonly: { type: Boolean },
    type: {},
    mask: {},
    raw: {},
    actions: {},
    max: {},
    min: {},
    dataMaskaTokens: {}
  },
  emits: ["update:modelValue", "update", "focus", "blur", "keydown", "keydownEnter", "clear", "updateRaw"],
  setup(a, { emit: e }) {
    const t = a, i = e, s = ge(() => [t.size ? `-${t.size}` : ""]), n = ge(() => ({
      mask: t.mask,
      eager: !1
    })), o = (v) => {
      const h = v.target.value;
      i("update:modelValue", h), i("update", h);
    }, l = (v) => {
      const r = v.target;
      t.modelValue != r.value.replace(/\.|-/g, "") && (o(v), i("updateRaw", r.dataset.maskRawValue));
    }, c = (v) => {
      i("focus", v);
    }, d = (v) => {
      i("blur", v);
    }, f = (v) => {
      i("keydown", v);
    }, p = (v) => {
      i("keydownEnter", v);
    }, m = () => {
      i("clear"), i("update:modelValue", null), i("update", null);
    };
    return (v, r) => (M(), q(ca, {
      id: v.id,
      leadingIcon: v.leadingIcon,
      trailingIcon: v.trailingIcon,
      trailingText: v.trailingText,
      label: v.label,
      loading: v.loading,
      last: v.last,
      disabled: v.disabled,
      float: v.float,
      state: v.state,
      labelInfo: v.labelInfo,
      autofocus: v.autofocus,
      size: v.size,
      invalidFeedback: v.invalidFeedback,
      class: "ui-form-textfield"
    }, dd({
      default: U(() => [
        te(v.$slots, "before"),
        Ze(I("input", {
          class: he(["form-control", s.value]),
          mask: v.mask,
          "data-maska-tokens": v.dataMaskaTokens,
          onFocus: c,
          onBlur: d,
          onKeydown: [
            f,
            eh(p, ["enter"])
          ],
          onMaska: l,
          value: v.modelValue,
          placeholder: v.float ? "" : v.placeholder,
          type: v.type,
          step: v.step,
          inputmode: v.inputmode,
          autocomplete: v.autocomplete,
          disabled: v.disabled,
          minlength: v.minlength,
          maxlength: v.maxlength,
          pattern: v.pattern,
          autofocus: v.autofocus,
          readonly: v.readonly,
          tabindex: v.tabindex,
          name: v.name,
          title: v.title,
          id: v.id,
          max: v.max,
          min: v.min,
          required: v.required
        }, null, 42, lw), [
          [et(H0), void 0, n.value]
        ]),
        te(v.$slots, "after"),
        v.clearable && v.modelValue ? (M(), D("div", {
          key: 0,
          class: "close",
          onClick: m
        }, [
          B(Pe, {
            name: "cancel",
            filled: "",
            size: "24"
          })
        ])) : X("", !0)
      ]),
      _: 2
    }, [
      v.$slots.append || v.actions ? {
        name: "append",
        fn: U(() => [
          v.actions ? (M(), D("div", cw, [
            (M(!0), D(ke, null, Ae(v.actions, (h) => (M(), q(Le, {
              key: h.label,
              variant: h.variant,
              type: h.type,
              label: h.label,
              leadingIcon: h.leadingIcon,
              onClick: h.onAction
            }, null, 8, ["variant", "type", "label", "leadingIcon", "onClick"]))), 128))
          ])) : X("", !0),
          te(v.$slots, "append")
        ]),
        key: "0"
      } : void 0
    ]), 1032, ["id", "leadingIcon", "trailingIcon", "trailingText", "label", "loading", "last", "disabled", "float", "state", "labelInfo", "autofocus", "size", "invalidFeedback"]));
  }
});
const hw = {
  key: 0,
  class: "ui-dialog-header"
}, dw = ["innerHTML"], uw = { class: "ui-dialog-body" }, fw = ["innerHTML"], pw = {
  key: 0,
  class: "ui-dialog-prompt mt-5"
}, gw = {
  key: 1,
  class: "ui-dialog-footer"
}, mw = j({
  __name: "Dialog",
  props: {
    id: {},
    title: {},
    hideFooter: { type: Boolean },
    message: {},
    onCallback: {},
    onClose: {},
    closeOnBackdrop: { type: Boolean },
    promptLabel: {},
    promptType: { default: "text" },
    promptPlaceholder: {},
    cancelLabel: { default: "Cancelar" },
    destructLabel: { default: "Deletar" },
    destructVariant: { default: "danger" },
    destructIcon: {},
    type: {},
    opened: { type: Boolean },
    hideCancel: { type: Boolean }
  },
  emits: ["close", "callback"],
  setup(a, { expose: e, emit: t }) {
    const i = a, s = t, n = Z(!1), o = Z([]), l = Z(!1), c = Z({}), d = Z(), f = Wr({
      option: {},
      showing: !1,
      timer: null
    }), p = Z(), m = Wr({
      destructLabel: i.destructLabel,
      destructIcon: i.destructIcon,
      destructVariant: i.destructVariant
    }), v = (b) => {
      document.body.classList.remove("dialog-open"), window.removeEventListener("keydown", u, !1), n.value = !0, f.timer = null, f.showing = !1, s("close", b), b && s("callback", b), setTimeout(() => {
        if (i.id) {
          const O = document.getElementById(i.id);
          O && document.body.removeChild(O);
        }
      }, 300);
    }, r = () => {
      v(d.value || !0);
    }, h = () => {
      i.closeOnBackdrop ? v() : (c.value.transform = "scale(1.03)", setTimeout(() => {
        c.value.transform = "scale(1)";
      }, 100));
    };
    i.type == "prompt" && (l.value = !0);
    const u = (b) => {
      b.key == "Escape" && h();
    }, g = () => {
      f.showing = !0, window.addEventListener("keydown", u, !1), document.body.classList.add("dialog-open"), $s(() => {
        p.value.focus();
      });
    };
    return at(() => {
      i.opened && g();
    }), e({
      open: g
    }), (b, O) => f.showing ? (M(), D("div", {
      key: 0,
      class: he(["ui-dialog -show", o.value]),
      tabindex: "0",
      ref_key: "dialogRef",
      ref: p
    }, [
      I("div", {
        class: "ui-dialog-wrapper",
        style: wt(c.value)
      }, [
        I("div", {
          class: "ui-dialog-overlay",
          onClick: h
        }),
        I("form", {
          class: "ui-dialog-content",
          onSubmit: Xt(r, ["prevent"]),
          ref: "form"
        }, [
          b.title ? (M(), D("div", hw, [
            I("h4", {
              class: "title",
              innerHTML: b.title
            }, null, 8, dw)
          ])) : X("", !0),
          I("div", uw, [
            te(b.$slots, "default"),
            I("div", {
              innerHTML: b.message,
              class: "ui-dialog-message"
            }, null, 8, fw),
            l.value ? (M(), D("div", pw, [
              B(hi, {
                label: b.promptLabel,
                placeholder: b.promptPlaceholder,
                type: b.promptType,
                modelValue: d.value,
                "onUpdate:modelValue": O[0] || (O[0] = (x) => d.value = x),
                size: "sm",
                id: "prompt",
                required: "",
                last: ""
              }, null, 8, ["label", "placeholder", "type", "modelValue"])
            ])) : X("", !0)
          ]),
          b.hideFooter ? X("", !0) : (M(), D("div", gw, [
            B(Le, {
              leadingIcon: m.destructIcon,
              variant: b.destructVariant,
              type: "submit",
              class: "btn-destruct",
              tabindex: "0"
            }, {
              default: U(() => [
                ye(ne(m.destructLabel), 1)
              ]),
              _: 1
            }, 8, ["leadingIcon", "variant"]),
            b.type != "confirm" && !b.hideCancel ? (M(), q(Le, {
              key: 0,
              onClick: O[1] || (O[1] = () => v(!1)),
              class: "ui-dialog-btn-cancel"
            }, {
              default: U(() => [
                ye(ne(b.cancelLabel), 1)
              ]),
              _: 1
            })) : X("", !0)
          ]))
        ], 544)
      ], 4)
    ], 2)) : X("", !0);
  }
}), bw = {
  opened: !0
};
let vw = 1;
const Da = (a = {}) => {
  let e = null, t = null;
  const i = "ui-dialog-" + vw++;
  e = document.createElement("div"), e.id = i, t = B(mw, {
    ...bw,
    ...a,
    id: i
  }), Tm(t, e), document.body.appendChild(e);
}, fd = {
  open: Da,
  delete(a = {}) {
    a.destructLabel = "Deletar", a.destructIcon = "delete", a.destructVariant = "danger", Da(a);
  },
  prompt(a = {}) {
    a = {
      type: "prompt",
      destructVariant: "danger",
      destructLabel: "Confirmar",
      ...a
    }, Da(a);
  },
  confirm(a = {}) {
    a.type = "confirm", a.destructLabel = a.destructLabel || "Confirmar", a.destructIcon = "check", a.destructVariant = "success", a.hideCancel = !0, Da(a);
  }
};
const gt = (a, e) => {
  const t = a.__vccOpts || a;
  for (const [i, s] of e)
    t[i] = s;
  return t;
}, yw = {}, Ow = { class: "ui-description-list" };
function xw(a, e) {
  return M(), D("div", Ow, [
    te(a.$slots, "default")
  ]);
}
const rH = /* @__PURE__ */ gt(yw, [["render", xw]]), ww = { class: "ui-description-list-item" }, Sw = { class: "ui-description-list-item-label" }, kw = {
  key: 0,
  class: "ui-description-list-item-description"
}, aH = j({
  __name: "DescriptionListItem",
  props: {
    label: {},
    description: {}
  },
  setup(a) {
    return (e, t) => (M(), D("div", ww, [
      I("div", Sw, ne(e.label), 1),
      e.$slots.default ? (M(), D("div", kw, [
        te(e.$slots, "default", {}, () => [
          ye(ne(e.description), 1)
        ])
      ])) : X("", !0)
    ]));
  }
});
const Lm = j({
  __name: "Stack",
  props: {
    distribution: {},
    spacing: {},
    alignment: {},
    vertical: { type: Boolean },
    wrap: { type: Boolean },
    columns: {},
    horizontal: { type: Boolean }
  },
  setup(a) {
    const e = a, t = ge(() => [
      e.distribution !== "default" && e.distribution != null && `-distribute-${e.distribution}`,
      e.spacing !== "default" && e.spacing != null && `-spacing-${e.spacing}`,
      e.vertical == !0 && "-vertical",
      e.alignment && `-align-${e.alignment}`,
      e.wrap == null || e.wrap == !1 && "-no-wrap",
      e.horizontal && "-sm-horizontal",
      e.columns && e.columns > 1 && "-custom-grid"
    ]), i = ge(() => {
      const s = {};
      return e.columns && window.innerWidth > 800 && (s.gridTemplateColumns = `repeat(${e.columns}, 1fr)`), s;
    });
    return (s, n) => (M(), D("div", {
      class: he(["ui-stack", t.value]),
      style: wt(i.value)
    }, [
      te(s.$slots, "default")
    ], 6));
  }
});
const _w = {}, Cw = { class: "ui-button-group" };
function Tw(a, e) {
  return M(), D("div", Cw, [
    te(a.$slots, "default")
  ]);
}
const oH = /* @__PURE__ */ gt(_w, [["render", Tw]]);
const Aw = { class: "ui-alert-content" }, $w = {
  key: 0,
  class: "ui-alert-title"
}, Ew = { class: "ui-alert-text" }, ih = j({
  __name: "Alert",
  props: {
    title: {},
    variant: {},
    icon: {},
    dismissible: { type: Boolean },
    show: { type: Boolean },
    center: { type: Boolean },
    label: {}
  },
  emits: ["dismissed"],
  setup(a, { emit: e }) {
    const t = a, i = e, s = Z(!!t.show), n = {
      success: "check_circle",
      danger: "error",
      warning: "warning"
    }, o = () => {
      s.value = !1, i("dismissed");
    }, l = ge(() => {
      let d = [];
      return t.variant && d.push(`-${t.variant}`), t.center && d.push("-center"), t.dismissible && d.push("-dismissible"), d;
    }), c = ge(() => {
      let d = t.icon;
      return !t.icon && t.variant && (d = n[t.variant]), d;
    });
    return Lt(() => {
      s.value = !!t.show;
    }), (d, f) => s.value ? (M(), D("div", {
      key: 0,
      class: he(["ui-alert", l.value])
    }, [
      c.value ? (M(), q(Pe, {
        key: 0,
        class: "ui-alert-icon",
        filled: "",
        name: c.value,
        size: "24"
      }, null, 8, ["name"])) : X("", !0),
      I("div", Aw, [
        d.title ? (M(), D("h5", $w, ne(d.title), 1)) : X("", !0),
        I("div", Ew, [
          te(d.$slots, "default", {}, () => [
            ye(ne(d.label), 1)
          ])
        ])
      ]),
      d.dismissible ? (M(), D("button", {
        key: 1,
        type: "button",
        class: "ui-alert-close",
        onClick: o
      }, [
        B(Pe, { name: "close" })
      ])) : X("", !0)
    ], 2)) : X("", !0);
  }
});
const Ti = j({
  __name: "IconButton",
  props: {
    icon: {},
    variant: {},
    size: { default: "md" },
    fab: { type: Boolean },
    disabled: { type: Boolean },
    onColor: { type: Boolean },
    customClass: {}
  },
  setup(a) {
    const e = a, t = Z(["ui-icon-button", e.customClass]), i = ge(() => {
      switch (e.size) {
        case "sm":
          return 16;
        case "md":
          return 24;
        case "lg":
          return 24;
      }
    });
    return (s, n) => (M(), q(Le, {
      class: he([t.value, s.fab ? "-fab" : "", s.onColor ? "-on-color" : ""]),
      size: s.size,
      variant: s.variant,
      disabled: s.disabled
    }, {
      default: U(() => [
        B(Pe, {
          name: s.icon,
          size: i.value
        }, null, 8, ["name", "size"])
      ]),
      _: 1
    }, 8, ["class", "size", "variant", "disabled"]));
  }
});
const Pw = ["id"], Lw = { class: "header-wrapper" }, Mw = { class: "title" }, Dw = {
  key: 0,
  class: "d-block text-muted mb-0"
}, Rw = { class: "ui-aside-body" }, Iw = {
  key: 0,
  class: "ui-aside-footer"
}, Qw = {
  key: 1,
  class: "ui-aside-footer"
}, ll = j({
  __name: "Aside",
  props: {
    modelValue: { type: Boolean },
    title: {},
    subtitle: {},
    scrollable: { type: Boolean },
    noCloseOnBackdrop: { type: Boolean },
    size: {},
    tag: {},
    inner: { type: Boolean },
    primaryAction: {},
    secondaryActions: {},
    scrollableContentId: {}
  },
  emits: ["update:modelValue", "open", "close", "save"],
  setup(a, { emit: e }) {
    const t = e, i = a, s = oa(), n = Z(!1), o = i.size ? `-${i.size}` : "-md", l = (v = "default") => !!s[v], c = () => {
      window.removeEventListener("keydown", m, !1), document.body.classList.remove("aside-open"), setTimeout(() => {
        t("close"), n.value = !1;
      }, 300);
    }, d = () => {
      n.value = !0, window.addEventListener("keydown", m, !1), document.body.classList.add("aside-open"), t("open");
    }, f = () => {
      i.noCloseOnBackdrop || t("update:modelValue", !1);
    }, p = () => t("update:modelValue", !1), m = (v) => {
      v.key == "Escape" && f();
    };
    return Lt(() => {
      i.modelValue ? d() : c();
    }), (v, r) => (M(), q(Am, { to: "body" }, [
      (M(), q(Ut(v.tag ? v.tag : "div"), {
        class: "ui-aside",
        onSubmit: r[0] || (r[0] = Xt((h) => v.$emit("save"), ["prevent"]))
      }, {
        default: U(() => [
          n.value ? (M(), D("div", {
            key: 0,
            class: he(["ui-aside-wrapper", [
              et(o),
              {
                "-hide": !v.modelValue,
                "-scrollable": v.scrollable,
                "-inner": v.inner
              }
            ]])
          }, [
            I("div", {
              class: he(["ui-aside-overlay", { "-close": !v.noCloseOnBackdrop }]),
              onClick: f
            }, null, 2),
            I("div", {
              class: "ui-aside-content",
              id: v.scrollableContentId
            }, [
              I("div", {
                class: "ui-aside-header",
                style: wt(v.subtitle ? "align-items: flex-start" : "align-items: center")
              }, [
                I("div", Lw, [
                  I("h4", Mw, ne(v.title), 1),
                  v.subtitle ? (M(), D("p", Dw, ne(v.subtitle), 1)) : X("", !0)
                ]),
                B(Ti, {
                  onClick: p,
                  id: "btn-close",
                  icon: "close",
                  variant: "plain",
                  type: "rounded"
                })
              ], 4),
              I("div", Rw, [
                te(v.$slots, "default")
              ]),
              v.primaryAction ? (M(), D("div", Iw, [
                B(Le, {
                  type: "submit",
                  onClick: v.primaryAction.onAction,
                  label: v.primaryAction.label,
                  disabled: v.primaryAction.disabled,
                  variant: v.primaryAction.variant ?? "primary",
                  form: v.primaryAction.form
                }, null, 8, ["onClick", "label", "disabled", "variant", "form"]),
                (M(!0), D(ke, null, Ae(v.secondaryActions, (h) => (M(), q(Le, {
                  type: "button",
                  onClick: h.onAction,
                  label: h.label
                }, null, 8, ["onClick", "label"]))), 256))
              ])) : X("", !0),
              l("footer") ? (M(), D("div", Qw, [
                te(v.$slots, "footer")
              ])) : X("", !0)
            ], 8, Pw)
          ], 2)) : X("", !0)
        ]),
        _: 3
      }, 32))
    ]));
  }
});
const Nw = { class: "ui-link-content" }, Ai = j({
  __name: "Link",
  props: {
    disabled: { type: Boolean },
    external: { type: Boolean },
    href: {},
    label: {},
    to: {},
    wrapText: { type: Boolean }
  },
  setup(a) {
    const e = a, t = ge(() => e.to ? "router-link" : "a"), i = ge(() => {
      let n = [];
      return e.external && n.push("-external"), e.disabled && n.push("-disabled"), e.wrapText && n.push("-wrap"), n;
    }), s = ge(() => {
      let n = {};
      return e.href && Object.assign(n, { href: e.href }), e.to && Object.assign(n, { to: e.to }), e.external && Object.assign(n, { target: "_blank" }), n;
    });
    return (n, o) => (M(), q(Ut(t.value), al({
      class: ["ui-link", i.value]
    }, s.value), {
      default: U(() => [
        I("span", Nw, [
          te(n.$slots, "default", {}, () => [
            ye(ne(n.label), 1)
          ])
        ]),
        n.external ? (M(), q(Pe, {
          key: 0,
          name: "open_in_new",
          class: "ui-link-icon",
          size: 14
        })) : X("", !0)
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Fw = { class: "ui-aside-section" }, Ww = {
  key: 0,
  class: "ui-aside-section-header"
}, Bw = { class: "ui-aside-section-title" }, zw = {
  key: 0,
  class: "ui-aside-section-actions"
}, Fu = j({
  __name: "AsideSection",
  props: {
    title: {},
    actions: {}
  },
  setup(a) {
    return (e, t) => (M(), D("div", Fw, [
      e.title ? (M(), D("div", Ww, [
        I("h6", Bw, ne(e.title), 1),
        e.actions ? (M(), D("div", zw, [
          (M(!0), D(ke, null, Ae(e.actions, (i) => (M(), q(Ai, {
            key: i.label,
            onClick: i.onAction
          }, {
            default: U(() => [
              ye(ne(i.label), 1)
            ]),
            _: 2
          }, 1032, ["onClick"]))), 128))
        ])) : X("", !0)
      ])) : X("", !0),
      te(e.$slots, "default")
    ]));
  }
});
const Xw = j({
  __name: "Badge",
  props: {
    label: {},
    pill: { type: Boolean },
    size: { default: "md" },
    variant: { default: "default" }
  },
  setup(a) {
    const e = a, t = ge(() => {
      let i = [];
      return e.pill && i.push("-pill"), e.size && i.push(`-size-${e.size}`), e.variant && i.push(`-variant-${e.variant}`), i;
    });
    return (i, s) => (M(), D("span", {
      class: he(["ui-badge", t.value])
    }, [
      te(i.$slots, "default", {}, () => [
        ye(ne(i.label), 1)
      ])
    ], 2));
  }
});
const Yw = ["for"], Vw = ["id", "value", "tabindex", "required", "indeterminate", "name", "disabled"], Hw = /* @__PURE__ */ I("span", { class: "ui-form-checkbox-checkmark" }, null, -1), Gw = {
  key: 0,
  class: "ui-form-checkbox-text"
}, ir = j({
  __name: "FormCheckbox",
  props: {
    modelValue: {},
    value: {},
    switch: { type: Boolean },
    label: {},
    id: {},
    name: {},
    tabindex: {},
    required: { type: Boolean },
    indeterminate: { type: Boolean },
    noEvents: { type: Boolean },
    disabled: { type: Boolean }
  },
  emits: ["update:modelValue", "update"],
  setup(a, { emit: e }) {
    var c;
    const t = e, i = a, s = i.id ?? `ui-form-checkbox-${(c = yt()) == null ? void 0 : c.uid}`, n = ge(() => [
      i.switch ? "-switch" : "",
      i.disabled ? "-disabled" : "",
      i.noEvents ? "-no-events" : ""
    ]), o = ge({
      get() {
        return i.modelValue;
      },
      set(d) {
        l(d);
      }
    }), l = (d) => {
      t("update", d), t("update:modelValue", d);
    };
    return (d, f) => (M(), D("label", {
      class: he(["ui-form-checkbox", n.value]),
      for: et(s)
    }, [
      Ze(I("input", {
        "onUpdate:modelValue": f[0] || (f[0] = (p) => o.value = p),
        type: "checkbox",
        id: et(s),
        value: d.value,
        tabindex: d.tabindex,
        required: d.required,
        indeterminate: d.indeterminate,
        name: d.name,
        disabled: d.disabled,
        "true-value": !0,
        "on:update:modelValue": l
      }, null, 40, Vw), [
        [S0, o.value]
      ]),
      Hw,
      d.label || d.$slots.default ? (M(), D("div", Gw, [
        te(d.$slots, "default", {}, () => [
          ye(ne(d.label), 1)
        ])
      ])) : X("", !0)
    ], 10, Yw));
  }
}), jw = ["value", "inputmode", "autocomplete", "autofocus", "disabled", "minlength", "maxlength", "pattern", "placeholder", "readonly", "tabindex", "name", "title", "id", "required", "rows"], lH = j({
  __name: "FormTextarea",
  props: {
    leadingIcon: {},
    trailingIcon: {},
    state: { type: Boolean, default: void 0 },
    loading: { type: Boolean },
    last: { type: Boolean },
    float: { type: Boolean },
    invalidFeedback: {},
    modelValue: {},
    rows: { default: 4 },
    label: {},
    placeholder: {},
    tabindex: {},
    inputmode: {},
    id: {},
    pattern: {},
    title: {},
    name: {},
    autocomplete: {},
    minlength: {},
    maxlength: {},
    autofocus: { type: Boolean },
    disabled: { type: Boolean },
    required: { type: Boolean },
    readonly: { type: Boolean },
    labelInfo: {}
  },
  emits: ["update:modelValue", "update"],
  setup(a, { emit: e }) {
    const t = e, i = a, s = ge(() => [i.state === !0 ? "-valid" : i.state === !1 ? "-invalid" : ""]), n = (o) => {
      const l = o.target;
      t("update:modelValue", l.value), t("update", l.value);
    };
    return (o, l) => (M(), q(ca, {
      id: o.id,
      leadingIcon: o.leadingIcon,
      trailingIcon: o.trailingIcon,
      label: o.label,
      loading: o.loading,
      last: o.last,
      disabled: o.disabled,
      float: o.float,
      state: o.state,
      labelInfo: o.labelInfo,
      invalidFeedback: o.invalidFeedback
    }, {
      default: U(() => [
        I("textarea", {
          class: he(["form-control", s.value]),
          onInput: n,
          value: o.modelValue,
          inputmode: o.inputmode,
          autocomplete: o.autocomplete,
          autofocus: o.autofocus,
          disabled: o.disabled,
          minlength: o.minlength,
          maxlength: o.maxlength,
          pattern: o.pattern,
          placeholder: o.placeholder,
          readonly: o.readonly,
          tabindex: o.tabindex,
          name: o.name,
          title: o.title,
          id: o.id,
          required: o.required,
          rows: o.rows
        }, null, 42, jw)
      ]),
      _: 1
    }, 8, ["id", "leadingIcon", "trailingIcon", "label", "loading", "last", "disabled", "float", "state", "labelInfo", "invalidFeedback"]));
  }
});
const Uw = ["modelValue", "value", "tabindex", "required", "name", "disabled", "checked"], Zw = /* @__PURE__ */ I("span", { class: "ui-form-radio-checkmark" }, null, -1), qw = {
  key: 0,
  class: "ui-form-radio-text"
}, Mm = j({
  __name: "FormRadio",
  props: {
    modelValue: {},
    value: { default: !0 },
    label: {},
    name: {},
    required: { type: Boolean },
    disabled: { type: Boolean },
    tabindex: {}
  },
  emits: ["update:modelValue", "update"],
  setup(a, { emit: e }) {
    var l;
    const t = a, i = e, s = `ui-form-radio-${(l = yt()) == null ? void 0 : l.uid}`, n = ge(() => JSON.stringify(t.value) == JSON.stringify(t.modelValue)), o = (c) => {
      i("update:modelValue", c), i("update", c);
    };
    return (c, d) => (M(), D("label", {
      class: he(["ui-form-radio", { "-disabled": c.disabled }]),
      for: s
    }, [
      I("input", {
        type: "radio",
        id: s,
        modelValue: c.modelValue,
        value: c.value,
        tabindex: c.tabindex,
        required: c.required,
        name: c.name,
        disabled: c.disabled,
        checked: n.value,
        onInput: d[0] || (d[0] = (f) => o(c.value))
      }, null, 40, Uw),
      Zw,
      c.label || c.$slots.default ? (M(), D("div", qw, [
        te(c.$slots, "default", {}, () => [
          ye(ne(c.label), 1)
        ])
      ])) : X("", !0)
    ], 2));
  }
});
const Kw = ["min", "max", "value", "step", "name", "required", "disabled"], cH = j({
  __name: "FormRange",
  props: {
    modelValue: {},
    required: { type: Boolean },
    name: {},
    min: {},
    max: {},
    step: {},
    width: {},
    disabled: { type: Boolean }
  },
  emits: ["update:modelValue"],
  setup(a, { emit: e }) {
    var m;
    const t = a, i = `ui-form-range-${(m = yt()) == null ? void 0 : m.uid}`, s = Z(!1), n = e, o = ge({
      get() {
        return t.modelValue;
      },
      set(v) {
        c(v);
      }
    }), l = ge(() => {
      const v = {};
      return t.width && (v.width = t.width + "px"), v;
    }), c = (v) => {
      n("update:modelValue", v);
    }, d = (v) => {
      const r = v.target;
      c(r.value), s.value = !1;
    };
    function f(v, r) {
      const h = v.value, u = v.min ? v.min : 0, g = v.max ? v.max : 100, b = (Number(h) - Number(u)) * 100 / (Number(g) - Number(u));
      r.innerHTML = h, r.style.left = `calc(${b}%)`;
    }
    return at(() => {
      document.querySelectorAll(".ui-slider").forEach((r) => {
        const h = r.querySelector(".ui-slider-range"), u = r.querySelector(".ui-slider-bubble");
        h && u && (h.addEventListener("input", () => {
          f(h, u);
        }), f(h, u));
      });
    }), (v, r) => (M(), D("label", {
      class: "ui-slider",
      for: i,
      style: wt(l.value)
    }, [
      I("input", {
        type: "range",
        min: v.min,
        max: v.max,
        value: o.value,
        step: v.step,
        id: i,
        name: v.name,
        required: v.required,
        class: "ui-slider-range",
        onChange: d,
        onMousedown: r[0] || (r[0] = (h) => s.value = !0),
        disabled: v.disabled
      }, null, 40, Kw),
      I("output", {
        class: he(["ui-slider-bubble", { "-active": s.value }])
      }, null, 2)
    ], 4));
  }
}), Jw = {
  class: "form-control-label",
  style: { display: "block" }
}, pd = j({
  __name: "FormLabel",
  props: {
    label: {}
  },
  setup(a) {
    return (e, t) => (M(), D("label", Jw, [
      te(e.$slots, "default", {}, () => [
        ye(ne(e.label), 1)
      ])
    ]));
  }
});
/**
 * Vue Currency Input 3.1.0
 * (c) 2018-2024 Matthias Stiller
 * @license MIT
 */
var Ss;
(function(a) {
  a.symbol = "symbol", a.narrowSymbol = "narrowSymbol", a.code = "code", a.name = "name", a.hidden = "hidden";
})(Ss || (Ss = {}));
var Hs;
(function(a) {
  a.precision = "precision", a.thousands = "thousands", a.millions = "millions", a.billions = "billions";
})(Hs || (Hs = {}));
const co = (a) => a.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), Dm = (a) => a.replace(/^0+(0$|[^0])/, "$1"), tc = (a, e) => (a.match(new RegExp(co(e), "g")) || []).length, e1 = (a, e) => a.substring(0, a.indexOf(e)), Rm = [
  ",",
  ".",
  "٫",
  "。"
], Wu = "(0|[1-9]\\d*)";
class t1 {
  constructor(e) {
    var t, i, s, n, o, l;
    const { currency: c, currencyDisplay: d, locale: f, precision: p, accountingSign: m, useGrouping: v } = e;
    this.locale = f, this.options = {
      currency: c,
      useGrouping: v,
      style: "currency",
      currencySign: m ? "accounting" : void 0,
      currencyDisplay: d !== Ss.hidden ? d : void 0
    };
    const r = new Intl.NumberFormat(f, this.options), h = r.formatToParts(123456);
    this.currency = (t = h.find(({ type: b }) => b === "currency")) === null || t === void 0 ? void 0 : t.value, this.digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map((b) => b.toLocaleString(f)), this.decimalSymbol = (i = h.find(({ type: b }) => b === "decimal")) === null || i === void 0 ? void 0 : i.value, this.groupingSymbol = (s = h.find(({ type: b }) => b === "group")) === null || s === void 0 ? void 0 : s.value, this.minusSign = (n = r.formatToParts(-1).find(({ type: b }) => b === "minusSign")) === null || n === void 0 ? void 0 : n.value, this.decimalSymbol === void 0 ? this.minimumFractionDigits = this.maximumFractionDigits = 0 : typeof p == "number" ? this.minimumFractionDigits = this.maximumFractionDigits = p : (this.minimumFractionDigits = (o = p == null ? void 0 : p.min) !== null && o !== void 0 ? o : r.resolvedOptions().minimumFractionDigits, this.maximumFractionDigits = (l = p == null ? void 0 : p.max) !== null && l !== void 0 ? l : r.resolvedOptions().maximumFractionDigits);
    const u = (b) => e1(b, this.digits[1]), g = (b) => b.substring(b.lastIndexOf(this.decimalSymbol ? this.digits[0] : this.digits[1]) + 1);
    this.prefix = u(r.format(1)), this.suffix = g(r.format(1)), this.negativePrefix = u(r.format(-1)), this.negativeSuffix = g(r.format(-1));
  }
  parse(e) {
    if (e) {
      const t = this.isNegative(e);
      e = this.normalizeDigits(e), e = this.stripCurrency(e, t), e = this.stripSignLiterals(e);
      const i = this.decimalSymbol ? `(?:${co(this.decimalSymbol)}(\\d*))?` : "", s = this.stripGroupingSeparator(e).match(new RegExp(`^${Wu}${i}$`));
      if (s && this.isValidIntegerFormat(this.decimalSymbol ? e.split(this.decimalSymbol)[0] : e, Number(s[1])))
        return +`${t ? "-" : ""}${this.onlyDigits(s[1])}.${this.onlyDigits(s[2] || "")}`;
    }
    return null;
  }
  isValidIntegerFormat(e, t) {
    const i = { ...this.options, minimumFractionDigits: 0 };
    return [
      this.stripCurrency(this.normalizeDigits(t.toLocaleString(this.locale, { ...i, useGrouping: !0 })), !1),
      this.stripCurrency(this.normalizeDigits(t.toLocaleString(this.locale, { ...i, useGrouping: !1 })), !1)
    ].includes(e);
  }
  format(e, t = {
    minimumFractionDigits: this.minimumFractionDigits,
    maximumFractionDigits: this.maximumFractionDigits
  }) {
    return e != null ? e.toLocaleString(this.locale, { ...this.options, ...t }) : "";
  }
  toFraction(e) {
    return `${this.digits[0]}${this.decimalSymbol}${this.onlyLocaleDigits(e.substring(1)).substring(0, this.maximumFractionDigits)}`;
  }
  isFractionIncomplete(e) {
    return !!this.normalizeDigits(this.stripGroupingSeparator(e)).match(new RegExp(`^${Wu}${co(this.decimalSymbol)}$`));
  }
  isNegative(e) {
    return e.startsWith(this.negativePrefix) || this.minusSign === void 0 && (e.startsWith("(") || e.startsWith("-")) || this.minusSign !== void 0 && e.replace("-", this.minusSign).startsWith(this.minusSign);
  }
  insertCurrency(e, t) {
    return `${t ? this.negativePrefix : this.prefix}${e}${t ? this.negativeSuffix : this.suffix}`;
  }
  stripGroupingSeparator(e) {
    return this.groupingSymbol !== void 0 ? e.replace(new RegExp(co(this.groupingSymbol), "g"), "") : e;
  }
  stripSignLiterals(e) {
    return this.minusSign !== void 0 ? e.replace("-", this.minusSign).replace(this.minusSign, "") : e.replace(/[-()]/g, "");
  }
  stripCurrency(e, t) {
    return e.replace(t ? this.negativePrefix : this.prefix, "").replace(t ? this.negativeSuffix : this.suffix, "");
  }
  normalizeDecimalSeparator(e, t) {
    return Rm.forEach((i) => {
      e = e.substring(0, t) + e.substring(t).replace(i, this.decimalSymbol);
    }), e;
  }
  normalizeDigits(e) {
    return this.digits[0] !== "0" && this.digits.forEach((t, i) => {
      e = e.replace(new RegExp(t, "g"), String(i));
    }), e;
  }
  onlyDigits(e) {
    return this.normalizeDigits(e).replace(/\D+/g, "");
  }
  onlyLocaleDigits(e) {
    return e.replace(new RegExp(`[^${this.digits.join("")}]*`, "g"), "");
  }
}
class Im {
  constructor(e) {
    this.currencyFormat = e;
  }
}
class i1 extends Im {
  conformToMask(e, t = "") {
    const i = this.currencyFormat.isNegative(e), s = (r) => r === "" && i && !(this.currencyFormat.minusSign === void 0 ? t === this.currencyFormat.negativePrefix + this.currencyFormat.negativeSuffix : t === this.currencyFormat.negativePrefix), n = (r) => {
      if (s(r))
        return "";
      if (this.currencyFormat.maximumFractionDigits > 0) {
        if (this.currencyFormat.isFractionIncomplete(r))
          return r;
        if (r.startsWith(this.currencyFormat.decimalSymbol))
          return this.currencyFormat.toFraction(r);
      }
      return null;
    };
    let o = e;
    o = this.currencyFormat.stripCurrency(o, i), o = this.currencyFormat.stripSignLiterals(o);
    const l = n(o);
    if (l != null)
      return this.currencyFormat.insertCurrency(l, i);
    const [c, ...d] = o.split(this.currencyFormat.decimalSymbol), f = Dm(this.currencyFormat.onlyDigits(c)), p = this.currencyFormat.onlyDigits(d.join("")).substring(0, this.currencyFormat.maximumFractionDigits), m = d.length > 0 && p.length === 0, v = f === "" && i && (this.currencyFormat.minusSign === void 0 ? t === e.slice(0, -2) + this.currencyFormat.negativeSuffix : t === e.slice(0, -1));
    return m || v || s(f) ? t : f.match(/\d+/) ? {
      numberValue: +`${i ? "-" : ""}${f}.${p}`,
      fractionDigits: p
    } : "";
  }
}
class s1 extends Im {
  conformToMask(e, t = "") {
    if (e === "" || this.currencyFormat.parse(t) === 0 && this.currencyFormat.stripCurrency(t, !0).slice(0, -1) === this.currencyFormat.stripCurrency(e, !0))
      return "";
    const i = this.currencyFormat.isNegative(e), s = this.currencyFormat.stripSignLiterals(e) === "" ? -0 : +`${i ? "-" : ""}${Dm(this.currencyFormat.onlyDigits(e))}` / Math.pow(10, this.currencyFormat.maximumFractionDigits);
    return {
      numberValue: s,
      fractionDigits: s.toFixed(this.currencyFormat.maximumFractionDigits).slice(-this.currencyFormat.maximumFractionDigits)
    };
  }
}
const n1 = {
  locale: void 0,
  currency: void 0,
  currencyDisplay: void 0,
  hideGroupingSeparatorOnFocus: !0,
  hideCurrencySymbolOnFocus: !0,
  hideNegligibleDecimalDigitsOnFocus: !0,
  precision: void 0,
  autoDecimalDigits: !1,
  valueRange: void 0,
  useGrouping: void 0,
  valueScaling: void 0
};
class r1 {
  constructor(e) {
    this.el = e.el, this.onInput = e.onInput, this.onChange = e.onChange, this.addEventListener(), this.init(e.options);
  }
  setOptions(e) {
    this.init(e), this.format(this.currencyFormat.format(this.validateValueRange(this.numberValue))), this.onChange(this.getValue());
  }
  getValue() {
    return { number: this.valueScaling && this.numberValue != null ? this.toInteger(this.numberValue, this.valueScaling) : this.numberValue, formatted: this.formattedValue };
  }
  setValue(e) {
    const t = this.valueScaling !== void 0 && e != null ? this.toFloat(e, this.valueScaling) : e;
    t !== this.numberValue && (this.format(this.currencyFormat.format(this.validateValueRange(t))), this.onChange(this.getValue()));
  }
  init(e) {
    this.options = {
      ...n1,
      ...e
    }, this.options.autoDecimalDigits && (this.options.hideNegligibleDecimalDigitsOnFocus = !1), this.el.getAttribute("inputmode") || this.el.setAttribute("inputmode", this.options.autoDecimalDigits ? "numeric" : "decimal"), this.currencyFormat = new t1(this.options), this.numberMask = this.options.autoDecimalDigits ? new s1(this.currencyFormat) : new i1(this.currencyFormat);
    const t = {
      [Hs.precision]: this.currencyFormat.maximumFractionDigits,
      [Hs.thousands]: 3,
      [Hs.millions]: 6,
      [Hs.billions]: 9
    };
    this.valueScaling = this.options.valueScaling ? t[this.options.valueScaling] : void 0, this.valueScalingFractionDigits = this.valueScaling !== void 0 && this.options.valueScaling !== Hs.precision ? this.valueScaling + this.currencyFormat.maximumFractionDigits : this.currencyFormat.maximumFractionDigits, this.minValue = this.getMinValue(), this.maxValue = this.getMaxValue();
  }
  getMinValue() {
    var e, t;
    let i = this.toFloat(-Number.MAX_SAFE_INTEGER);
    return ((e = this.options.valueRange) === null || e === void 0 ? void 0 : e.min) !== void 0 && (i = Math.max((t = this.options.valueRange) === null || t === void 0 ? void 0 : t.min, this.toFloat(-Number.MAX_SAFE_INTEGER))), i;
  }
  getMaxValue() {
    var e, t;
    let i = this.toFloat(Number.MAX_SAFE_INTEGER);
    return ((e = this.options.valueRange) === null || e === void 0 ? void 0 : e.max) !== void 0 && (i = Math.min((t = this.options.valueRange) === null || t === void 0 ? void 0 : t.max, this.toFloat(Number.MAX_SAFE_INTEGER))), i;
  }
  toFloat(e, t) {
    return e / Math.pow(10, t ?? this.valueScalingFractionDigits);
  }
  toInteger(e, t) {
    return Number(e.toFixed(t ?? this.valueScalingFractionDigits).split(".").join(""));
  }
  validateValueRange(e) {
    return e != null ? Math.min(Math.max(e, this.minValue), this.maxValue) : e;
  }
  format(e, t = !1) {
    if (e != null) {
      this.decimalSymbolInsertedAt !== void 0 && (e = this.currencyFormat.normalizeDecimalSeparator(e, this.decimalSymbolInsertedAt), this.decimalSymbolInsertedAt = void 0);
      const i = this.numberMask.conformToMask(e, this.formattedValue);
      let s;
      if (typeof i == "object") {
        const { numberValue: n, fractionDigits: o } = i;
        let { maximumFractionDigits: l, minimumFractionDigits: c } = this.currencyFormat;
        this.focus ? c = t ? o.replace(/0+$/, "").length : Math.min(l, o.length) : Number.isInteger(n) && !this.options.autoDecimalDigits && (this.options.precision === void 0 || c === 0) && (c = l = 0), s = this.toInteger(Math.abs(n)) > Number.MAX_SAFE_INTEGER ? this.formattedValue : this.currencyFormat.format(n, {
          useGrouping: this.options.useGrouping !== !1 && !(this.focus && this.options.hideGroupingSeparatorOnFocus),
          minimumFractionDigits: c,
          maximumFractionDigits: l
        });
      } else
        s = i;
      this.maxValue <= 0 && !this.currencyFormat.isNegative(s) && this.currencyFormat.parse(s) !== 0 && (s = s.replace(this.currencyFormat.prefix, this.currencyFormat.negativePrefix)), this.minValue >= 0 && (s = s.replace(this.currencyFormat.negativePrefix, this.currencyFormat.prefix)), (this.options.currencyDisplay === Ss.hidden || this.focus && this.options.hideCurrencySymbolOnFocus) && (s = s.replace(this.currencyFormat.negativePrefix, this.currencyFormat.minusSign !== void 0 ? this.currencyFormat.minusSign : "(").replace(this.currencyFormat.negativeSuffix, this.currencyFormat.minusSign !== void 0 ? "" : ")").replace(this.currencyFormat.prefix, "").replace(this.currencyFormat.suffix, "")), this.el.value = s, this.numberValue = this.currencyFormat.parse(s);
    } else
      this.el.value = "", this.numberValue = null;
    this.formattedValue = this.el.value, this.onInput(this.getValue());
  }
  addEventListener() {
    this.el.addEventListener("input", (e) => {
      const { value: t, selectionStart: i } = this.el, s = e;
      if (i && s.data && Rm.includes(s.data) && (this.decimalSymbolInsertedAt = i - 1), this.format(t), this.focus && i != null) {
        const n = () => {
          const { prefix: o, suffix: l, decimalSymbol: c, maximumFractionDigits: d, groupingSymbol: f } = this.currencyFormat;
          let p = t.length - i;
          const m = this.formattedValue.length;
          if (this.currencyFormat.minusSign === void 0 && (t.startsWith("(") || t.startsWith("-")) && !t.endsWith(")"))
            return m - this.currencyFormat.negativeSuffix.length > 1 ? this.formattedValue.substring(i).length : 1;
          if (this.formattedValue.substring(i, 1) === f && tc(this.formattedValue, f) === tc(t, f) + 1)
            return m - p - 1;
          if (m < p)
            return i;
          if (c !== void 0 && t.indexOf(c) !== -1) {
            const v = t.indexOf(c) + 1;
            if (Math.abs(m - t.length) > 1 && i <= v)
              return this.formattedValue.indexOf(c) + 1;
            !this.options.autoDecimalDigits && i > v && this.currencyFormat.onlyDigits(t.substring(v)).length - 1 === d && (p -= 1);
          }
          return this.options.hideCurrencySymbolOnFocus || this.options.currencyDisplay === Ss.hidden ? m - p : Math.max(m - Math.max(p, l.length), o.length);
        };
        this.setCaretPosition(n());
      }
    }), this.el.addEventListener("focus", () => {
      this.focus = !0, this.numberValueOnFocus = this.numberValue, setTimeout(() => {
        const { value: e, selectionStart: t, selectionEnd: i } = this.el;
        if (this.format(e, this.options.hideNegligibleDecimalDigitsOnFocus), t != null && i != null && Math.abs(t - i) > 0)
          this.setCaretPosition(0, this.el.value.length);
        else if (t != null) {
          const s = this.getCaretPositionOnFocus(e, t);
          this.setCaretPosition(s);
        }
      });
    }), this.el.addEventListener("blur", () => {
      this.focus = !1, this.format(this.currencyFormat.format(this.validateValueRange(this.numberValue))), this.numberValueOnFocus !== this.numberValue && this.onChange(this.getValue());
    });
  }
  getCaretPositionOnFocus(e, t) {
    if (this.numberValue == null)
      return t;
    const { prefix: i, negativePrefix: s, suffix: n, negativeSuffix: o, groupingSymbol: l, currency: c } = this.currencyFormat, d = this.numberValue < 0, f = d ? s : i, p = f.length;
    if (this.options.hideCurrencySymbolOnFocus || this.options.currencyDisplay === Ss.hidden) {
      if (d) {
        if (t <= 1)
          return 1;
        if (e.endsWith(")") && t > e.indexOf(")"))
          return this.formattedValue.length - 1;
      }
    } else {
      const v = d ? o.length : n.length;
      if (t >= e.length - v)
        return this.formattedValue.length - v;
      if (t < p)
        return p;
    }
    let m = t;
    return this.options.hideCurrencySymbolOnFocus && this.options.currencyDisplay !== Ss.hidden && t >= p && c !== void 0 && f.includes(c) && (m -= p, d && (m += 1)), this.options.hideGroupingSeparatorOnFocus && l !== void 0 && (m -= tc(e.substring(0, t), l)), m;
  }
  setCaretPosition(e, t = e) {
    this.el.setSelectionRange(e, t);
  }
}
const a1 = (a) => a != null && a.matches("input") ? a : a == null ? void 0 : a.querySelector("input");
function o1(a, e) {
  var t, i, s, n;
  let o;
  const l = Z(null), c = Z(null), d = Z(null), f = yt(), p = (f == null ? void 0 : f.emit) || ((i = (t = f == null ? void 0 : f.proxy) === null || t === void 0 ? void 0 : t.$emit) === null || i === void 0 ? void 0 : i.bind(f == null ? void 0 : f.proxy)), m = (f == null ? void 0 : f.props) || ((s = f == null ? void 0 : f.proxy) === null || s === void 0 ? void 0 : s.$props), v = k0.startsWith("3"), r = v && ((n = f == null ? void 0 : f.attrs.modelModifiers) === null || n === void 0 ? void 0 : n.lazy), h = ge(() => m == null ? void 0 : m[v ? "modelValue" : "value"]), u = v ? "update:modelValue" : "input", g = r ? "update:modelValue" : "change";
  return zt(l, (b) => {
    var O;
    if (b) {
      const x = a1((O = b == null ? void 0 : b.$el) !== null && O !== void 0 ? O : b);
      x ? (o = new r1({
        el: x,
        options: a,
        onInput: (S) => {
          !r && e !== !1 && h.value !== S.number && (p == null || p(u, S.number)), d.value = S.number, c.value = S.formatted;
        },
        onChange: (S) => {
          e !== !1 && (p == null || p(g, S.number));
        }
      }), o.setValue(h.value)) : console.error('No input element found. Please make sure that the "inputRef" template ref is properly assigned.');
    } else
      o = null;
  }), {
    inputRef: l,
    numberValue: d,
    formattedValue: c,
    setValue: (b) => o == null ? void 0 : o.setValue(b),
    setOptions: (b) => o == null ? void 0 : o.setOptions(b)
  };
}
const l1 = ["min", "step", "placeholder", "disabled", "required", "readonly", "autocomplete"], hH = j({
  __name: "FormCurrency",
  props: {
    leadingIcon: {},
    trailingIcon: {},
    labelInfo: {},
    state: { type: Boolean, default: void 0 },
    invalidFeedback: {},
    loading: { type: Boolean },
    last: { type: Boolean },
    float: { type: Boolean },
    modelValue: {},
    label: {},
    placeholder: { default: "0.00" },
    size: {},
    id: {},
    autocomplete: {},
    min: {},
    max: { default: 999999.99 },
    step: {},
    autofocus: { type: Boolean },
    disabled: { type: Boolean },
    required: { type: Boolean },
    readonly: { type: Boolean },
    options: {}
  },
  emits: ["update:modelValue", "change"],
  setup(a, { emit: e }) {
    const t = e, i = a, s = Z(i.autofocus ?? !1), n = ge(() => [
      "form-control",
      i.state === !0 ? "-valid" : i.state === !1 ? "-invalid" : ""
    ]), o = {
      ...i.options,
      locale: "pt-BR",
      currency: "BRL",
      currencyDisplay: Ss.symbol,
      hideCurrencySymbolOnFocus: !1,
      hideGroupingSeparatorOnFocus: !1,
      hideNegligibleDecimalDigitsOnFocus: !1,
      autoDecimalDigits: !0,
      autoSign: !0,
      useGrouping: !0,
      accountingSign: !1,
      valueRange: {
        min: i.min,
        max: i.max
      }
    }, { inputRef: l, setValue: c } = o1(o);
    return zt(
      () => i.modelValue,
      (d) => {
        d !== null && c(parseFloat(d));
      },
      { immediate: !0 }
    ), zt(
      () => s.value,
      (d) => {
        d && t("change", d);
      },
      { immediate: !0 }
    ), (d, f) => (M(), q(ca, {
      id: d.id,
      leadingIcon: d.leadingIcon,
      trailingIcon: d.trailingIcon,
      label: d.label,
      loading: d.loading,
      last: d.last,
      disabled: d.disabled,
      labelInfo: d.labelInfo,
      float: d.float,
      state: d.state,
      size: d.size,
      invalidFeedback: d.invalidFeedback
    }, {
      default: U(() => [
        I("input", {
          min: d.min,
          step: d.step,
          ref_key: "inputRef",
          ref: l,
          class: he(n.value),
          placeholder: d.float ? "" : d.placeholder,
          onFocus: f[0] || (f[0] = (p) => s.value = !0),
          onBlur: f[1] || (f[1] = (p) => s.value = !1),
          disabled: d.disabled,
          required: d.required,
          readonly: d.readonly,
          autocomplete: d.autocomplete
        }, null, 42, l1)
      ]),
      _: 1
    }, 8, ["id", "leadingIcon", "trailingIcon", "label", "loading", "last", "disabled", "labelInfo", "float", "state", "size", "invalidFeedback"]));
  }
});
const dH = j({
  __name: "Divider",
  props: {
    height: { default: "2px" },
    margin: {},
    transparent: { type: Boolean }
  },
  setup(a) {
    const e = a, t = ge(() => {
      let s = [];
      return e.transparent && s.push("-transparent"), s;
    }), i = ge(() => {
      let s = {};
      return e.margin && (s.marginBottom = e.margin, s.marginTop = e.margin), e.height && (s.height = e.height), s;
    });
    return (s, n) => (M(), D("hr", {
      class: he(["ui-divider", t.value]),
      style: wt(i.value)
    }, null, 6));
  }
});
var c1 = typeof global == "object" && global && global.Object === Object && global;
const Qm = c1;
var h1 = typeof self == "object" && self && self.Object === Object && self, d1 = Qm || h1 || Function("return this")();
const Vi = d1;
var u1 = Vi.Symbol;
const vi = u1;
var Nm = Object.prototype, f1 = Nm.hasOwnProperty, p1 = Nm.toString, pr = vi ? vi.toStringTag : void 0;
function g1(a) {
  var e = f1.call(a, pr), t = a[pr];
  try {
    a[pr] = void 0;
    var i = !0;
  } catch {
  }
  var s = p1.call(a);
  return i && (e ? a[pr] = t : delete a[pr]), s;
}
var m1 = Object.prototype, b1 = m1.toString;
function v1(a) {
  return b1.call(a);
}
var y1 = "[object Null]", O1 = "[object Undefined]", Bu = vi ? vi.toStringTag : void 0;
function Rs(a) {
  return a == null ? a === void 0 ? O1 : y1 : Bu && Bu in Object(a) ? g1(a) : v1(a);
}
function $i(a) {
  return a != null && typeof a == "object";
}
var x1 = "[object Symbol]";
function cl(a) {
  return typeof a == "symbol" || $i(a) && Rs(a) == x1;
}
function Fm(a, e) {
  for (var t = -1, i = a == null ? 0 : a.length, s = Array(i); ++t < i; )
    s[t] = e(a[t], t, a);
  return s;
}
var w1 = Array.isArray;
const Pt = w1;
var S1 = 1 / 0, zu = vi ? vi.prototype : void 0, Xu = zu ? zu.toString : void 0;
function Wm(a) {
  if (typeof a == "string")
    return a;
  if (Pt(a))
    return Fm(a, Wm) + "";
  if (cl(a))
    return Xu ? Xu.call(a) : "";
  var e = a + "";
  return e == "0" && 1 / a == -S1 ? "-0" : e;
}
var k1 = /\s/;
function _1(a) {
  for (var e = a.length; e-- && k1.test(a.charAt(e)); )
    ;
  return e;
}
var C1 = /^\s+/;
function T1(a) {
  return a && a.slice(0, _1(a) + 1).replace(C1, "");
}
function ni(a) {
  var e = typeof a;
  return a != null && (e == "object" || e == "function");
}
var Yu = 0 / 0, A1 = /^[-+]0x[0-9a-f]+$/i, $1 = /^0b[01]+$/i, E1 = /^0o[0-7]+$/i, P1 = parseInt;
function L1(a) {
  if (typeof a == "number")
    return a;
  if (cl(a))
    return Yu;
  if (ni(a)) {
    var e = typeof a.valueOf == "function" ? a.valueOf() : a;
    a = ni(e) ? e + "" : e;
  }
  if (typeof a != "string")
    return a === 0 ? a : +a;
  a = T1(a);
  var t = $1.test(a);
  return t || E1.test(a) ? P1(a.slice(2), t ? 2 : 8) : A1.test(a) ? Yu : +a;
}
var Vu = 1 / 0, M1 = 17976931348623157e292;
function D1(a) {
  if (!a)
    return a === 0 ? a : 0;
  if (a = L1(a), a === Vu || a === -Vu) {
    var e = a < 0 ? -1 : 1;
    return e * M1;
  }
  return a === a ? a : 0;
}
function Bm(a) {
  var e = D1(a), t = e % 1;
  return e === e ? t ? e - t : e : 0;
}
function hl(a) {
  return a;
}
var R1 = "[object AsyncFunction]", I1 = "[object Function]", Q1 = "[object GeneratorFunction]", N1 = "[object Proxy]";
function ha(a) {
  if (!ni(a))
    return !1;
  var e = Rs(a);
  return e == I1 || e == Q1 || e == R1 || e == N1;
}
var F1 = Vi["__core-js_shared__"];
const ic = F1;
var Hu = function() {
  var a = /[^.]+$/.exec(ic && ic.keys && ic.keys.IE_PROTO || "");
  return a ? "Symbol(src)_1." + a : "";
}();
function W1(a) {
  return !!Hu && Hu in a;
}
var B1 = Function.prototype, z1 = B1.toString;
function un(a) {
  if (a != null) {
    try {
      return z1.call(a);
    } catch {
    }
    try {
      return a + "";
    } catch {
    }
  }
  return "";
}
var X1 = /[\\^$.*+?()[\]{}|]/g, Y1 = /^\[object .+?Constructor\]$/, V1 = Function.prototype, H1 = Object.prototype, G1 = V1.toString, j1 = H1.hasOwnProperty, U1 = RegExp(
  "^" + G1.call(j1).replace(X1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Z1(a) {
  if (!ni(a) || W1(a))
    return !1;
  var e = ha(a) ? U1 : Y1;
  return e.test(un(a));
}
function q1(a, e) {
  return a == null ? void 0 : a[e];
}
function fn(a, e) {
  var t = q1(a, e);
  return Z1(t) ? t : void 0;
}
var K1 = fn(Vi, "WeakMap");
const sh = K1;
var Gu = Object.create, J1 = function() {
  function a() {
  }
  return function(e) {
    if (!ni(e))
      return {};
    if (Gu)
      return Gu(e);
    a.prototype = e;
    var t = new a();
    return a.prototype = void 0, t;
  };
}();
const eS = J1;
function tS(a, e, t) {
  switch (t.length) {
    case 0:
      return a.call(e);
    case 1:
      return a.call(e, t[0]);
    case 2:
      return a.call(e, t[0], t[1]);
    case 3:
      return a.call(e, t[0], t[1], t[2]);
  }
  return a.apply(e, t);
}
function iS() {
}
function zm(a, e) {
  var t = -1, i = a.length;
  for (e || (e = Array(i)); ++t < i; )
    e[t] = a[t];
  return e;
}
var sS = 800, nS = 16, rS = Date.now;
function aS(a) {
  var e = 0, t = 0;
  return function() {
    var i = rS(), s = nS - (i - t);
    if (t = i, s > 0) {
      if (++e >= sS)
        return arguments[0];
    } else
      e = 0;
    return a.apply(void 0, arguments);
  };
}
function oS(a) {
  return function() {
    return a;
  };
}
var lS = function() {
  try {
    var a = fn(Object, "defineProperty");
    return a({}, "", {}), a;
  } catch {
  }
}();
const So = lS;
var cS = So ? function(a, e) {
  return So(a, "toString", {
    configurable: !0,
    enumerable: !1,
    value: oS(e),
    writable: !0
  });
} : hl;
const hS = cS;
var dS = aS(hS);
const Xm = dS;
function Ym(a, e) {
  for (var t = -1, i = a == null ? 0 : a.length; ++t < i && e(a[t], t, a) !== !1; )
    ;
  return a;
}
function Vm(a, e, t, i) {
  for (var s = a.length, n = t + (i ? 1 : -1); i ? n-- : ++n < s; )
    if (e(a[n], n, a))
      return n;
  return -1;
}
function uS(a) {
  return a !== a;
}
function fS(a, e, t) {
  for (var i = t - 1, s = a.length; ++i < s; )
    if (a[i] === e)
      return i;
  return -1;
}
function Hm(a, e, t) {
  return e === e ? fS(a, e, t) : Vm(a, uS, t);
}
function pS(a, e) {
  var t = a == null ? 0 : a.length;
  return !!t && Hm(a, e, 0) > -1;
}
var gS = 9007199254740991, mS = /^(?:0|[1-9]\d*)$/;
function gd(a, e) {
  var t = typeof a;
  return e = e ?? gS, !!e && (t == "number" || t != "symbol" && mS.test(a)) && a > -1 && a % 1 == 0 && a < e;
}
function Gm(a, e, t) {
  e == "__proto__" && So ? So(a, e, {
    configurable: !0,
    enumerable: !0,
    value: t,
    writable: !0
  }) : a[e] = t;
}
function md(a, e) {
  return a === e || a !== a && e !== e;
}
var bS = Object.prototype, vS = bS.hasOwnProperty;
function bd(a, e, t) {
  var i = a[e];
  (!(vS.call(a, e) && md(i, t)) || t === void 0 && !(e in a)) && Gm(a, e, t);
}
function da(a, e, t, i) {
  var s = !t;
  t || (t = {});
  for (var n = -1, o = e.length; ++n < o; ) {
    var l = e[n], c = i ? i(t[l], a[l], l, t, a) : void 0;
    c === void 0 && (c = a[l]), s ? Gm(t, l, c) : bd(t, l, c);
  }
  return t;
}
var ju = Math.max;
function jm(a, e, t) {
  return e = ju(e === void 0 ? a.length - 1 : e, 0), function() {
    for (var i = arguments, s = -1, n = ju(i.length - e, 0), o = Array(n); ++s < n; )
      o[s] = i[e + s];
    s = -1;
    for (var l = Array(e + 1); ++s < e; )
      l[s] = i[s];
    return l[e] = t(o), tS(a, this, l);
  };
}
function yS(a, e) {
  return Xm(jm(a, e, hl), a + "");
}
var OS = 9007199254740991;
function vd(a) {
  return typeof a == "number" && a > -1 && a % 1 == 0 && a <= OS;
}
function ua(a) {
  return a != null && vd(a.length) && !ha(a);
}
var xS = Object.prototype;
function yd(a) {
  var e = a && a.constructor, t = typeof e == "function" && e.prototype || xS;
  return a === t;
}
function wS(a, e) {
  for (var t = -1, i = Array(a); ++t < a; )
    i[t] = e(t);
  return i;
}
var SS = "[object Arguments]";
function Uu(a) {
  return $i(a) && Rs(a) == SS;
}
var Um = Object.prototype, kS = Um.hasOwnProperty, _S = Um.propertyIsEnumerable, CS = Uu(function() {
  return arguments;
}()) ? Uu : function(a) {
  return $i(a) && kS.call(a, "callee") && !_S.call(a, "callee");
};
const Od = CS;
function TS() {
  return !1;
}
var Zm = typeof exports == "object" && exports && !exports.nodeType && exports, Zu = Zm && typeof module == "object" && module && !module.nodeType && module, AS = Zu && Zu.exports === Zm, qu = AS ? Vi.Buffer : void 0, $S = qu ? qu.isBuffer : void 0, ES = $S || TS;
const ko = ES;
var PS = "[object Arguments]", LS = "[object Array]", MS = "[object Boolean]", DS = "[object Date]", RS = "[object Error]", IS = "[object Function]", QS = "[object Map]", NS = "[object Number]", FS = "[object Object]", WS = "[object RegExp]", BS = "[object Set]", zS = "[object String]", XS = "[object WeakMap]", YS = "[object ArrayBuffer]", VS = "[object DataView]", HS = "[object Float32Array]", GS = "[object Float64Array]", jS = "[object Int8Array]", US = "[object Int16Array]", ZS = "[object Int32Array]", qS = "[object Uint8Array]", KS = "[object Uint8ClampedArray]", JS = "[object Uint16Array]", ek = "[object Uint32Array]", Ve = {};
Ve[HS] = Ve[GS] = Ve[jS] = Ve[US] = Ve[ZS] = Ve[qS] = Ve[KS] = Ve[JS] = Ve[ek] = !0;
Ve[PS] = Ve[LS] = Ve[YS] = Ve[MS] = Ve[VS] = Ve[DS] = Ve[RS] = Ve[IS] = Ve[QS] = Ve[NS] = Ve[FS] = Ve[WS] = Ve[BS] = Ve[zS] = Ve[XS] = !1;
function tk(a) {
  return $i(a) && vd(a.length) && !!Ve[Rs(a)];
}
function xd(a) {
  return function(e) {
    return a(e);
  };
}
var qm = typeof exports == "object" && exports && !exports.nodeType && exports, Lr = qm && typeof module == "object" && module && !module.nodeType && module, ik = Lr && Lr.exports === qm, sc = ik && Qm.process, sk = function() {
  try {
    var a = Lr && Lr.require && Lr.require("util").types;
    return a || sc && sc.binding && sc.binding("util");
  } catch {
  }
}();
const Bn = sk;
var Ku = Bn && Bn.isTypedArray, nk = Ku ? xd(Ku) : tk;
const Km = nk;
var rk = Object.prototype, ak = rk.hasOwnProperty;
function Jm(a, e) {
  var t = Pt(a), i = !t && Od(a), s = !t && !i && ko(a), n = !t && !i && !s && Km(a), o = t || i || s || n, l = o ? wS(a.length, String) : [], c = l.length;
  for (var d in a)
    (e || ak.call(a, d)) && !(o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (d == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    s && (d == "offset" || d == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    n && (d == "buffer" || d == "byteLength" || d == "byteOffset") || // Skip index properties.
    gd(d, c))) && l.push(d);
  return l;
}
function eb(a, e) {
  return function(t) {
    return a(e(t));
  };
}
var ok = eb(Object.keys, Object);
const lk = ok;
var ck = Object.prototype, hk = ck.hasOwnProperty;
function dk(a) {
  if (!yd(a))
    return lk(a);
  var e = [];
  for (var t in Object(a))
    hk.call(a, t) && t != "constructor" && e.push(t);
  return e;
}
function Is(a) {
  return ua(a) ? Jm(a) : dk(a);
}
function uk(a) {
  var e = [];
  if (a != null)
    for (var t in Object(a))
      e.push(t);
  return e;
}
var fk = Object.prototype, pk = fk.hasOwnProperty;
function gk(a) {
  if (!ni(a))
    return uk(a);
  var e = yd(a), t = [];
  for (var i in a)
    i == "constructor" && (e || !pk.call(a, i)) || t.push(i);
  return t;
}
function wd(a) {
  return ua(a) ? Jm(a, !0) : gk(a);
}
var mk = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, bk = /^\w*$/;
function Sd(a, e) {
  if (Pt(a))
    return !1;
  var t = typeof a;
  return t == "number" || t == "symbol" || t == "boolean" || a == null || cl(a) ? !0 : bk.test(a) || !mk.test(a) || e != null && a in Object(e);
}
var vk = fn(Object, "create");
const Br = vk;
function yk() {
  this.__data__ = Br ? Br(null) : {}, this.size = 0;
}
function Ok(a) {
  var e = this.has(a) && delete this.__data__[a];
  return this.size -= e ? 1 : 0, e;
}
var xk = "__lodash_hash_undefined__", wk = Object.prototype, Sk = wk.hasOwnProperty;
function kk(a) {
  var e = this.__data__;
  if (Br) {
    var t = e[a];
    return t === xk ? void 0 : t;
  }
  return Sk.call(e, a) ? e[a] : void 0;
}
var _k = Object.prototype, Ck = _k.hasOwnProperty;
function Tk(a) {
  var e = this.__data__;
  return Br ? e[a] !== void 0 : Ck.call(e, a);
}
var Ak = "__lodash_hash_undefined__";
function $k(a, e) {
  var t = this.__data__;
  return this.size += this.has(a) ? 0 : 1, t[a] = Br && e === void 0 ? Ak : e, this;
}
function sn(a) {
  var e = -1, t = a == null ? 0 : a.length;
  for (this.clear(); ++e < t; ) {
    var i = a[e];
    this.set(i[0], i[1]);
  }
}
sn.prototype.clear = yk;
sn.prototype.delete = Ok;
sn.prototype.get = kk;
sn.prototype.has = Tk;
sn.prototype.set = $k;
function Ek() {
  this.__data__ = [], this.size = 0;
}
function dl(a, e) {
  for (var t = a.length; t--; )
    if (md(a[t][0], e))
      return t;
  return -1;
}
var Pk = Array.prototype, Lk = Pk.splice;
function Mk(a) {
  var e = this.__data__, t = dl(e, a);
  if (t < 0)
    return !1;
  var i = e.length - 1;
  return t == i ? e.pop() : Lk.call(e, t, 1), --this.size, !0;
}
function Dk(a) {
  var e = this.__data__, t = dl(e, a);
  return t < 0 ? void 0 : e[t][1];
}
function Rk(a) {
  return dl(this.__data__, a) > -1;
}
function Ik(a, e) {
  var t = this.__data__, i = dl(t, a);
  return i < 0 ? (++this.size, t.push([a, e])) : t[i][1] = e, this;
}
function ls(a) {
  var e = -1, t = a == null ? 0 : a.length;
  for (this.clear(); ++e < t; ) {
    var i = a[e];
    this.set(i[0], i[1]);
  }
}
ls.prototype.clear = Ek;
ls.prototype.delete = Mk;
ls.prototype.get = Dk;
ls.prototype.has = Rk;
ls.prototype.set = Ik;
var Qk = fn(Vi, "Map");
const zr = Qk;
function Nk() {
  this.size = 0, this.__data__ = {
    hash: new sn(),
    map: new (zr || ls)(),
    string: new sn()
  };
}
function Fk(a) {
  var e = typeof a;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? a !== "__proto__" : a === null;
}
function ul(a, e) {
  var t = a.__data__;
  return Fk(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map;
}
function Wk(a) {
  var e = ul(this, a).delete(a);
  return this.size -= e ? 1 : 0, e;
}
function Bk(a) {
  return ul(this, a).get(a);
}
function zk(a) {
  return ul(this, a).has(a);
}
function Xk(a, e) {
  var t = ul(this, a), i = t.size;
  return t.set(a, e), this.size += t.size == i ? 0 : 1, this;
}
function cs(a) {
  var e = -1, t = a == null ? 0 : a.length;
  for (this.clear(); ++e < t; ) {
    var i = a[e];
    this.set(i[0], i[1]);
  }
}
cs.prototype.clear = Nk;
cs.prototype.delete = Wk;
cs.prototype.get = Bk;
cs.prototype.has = zk;
cs.prototype.set = Xk;
var Yk = "Expected a function";
function kd(a, e) {
  if (typeof a != "function" || e != null && typeof e != "function")
    throw new TypeError(Yk);
  var t = function() {
    var i = arguments, s = e ? e.apply(this, i) : i[0], n = t.cache;
    if (n.has(s))
      return n.get(s);
    var o = a.apply(this, i);
    return t.cache = n.set(s, o) || n, o;
  };
  return t.cache = new (kd.Cache || cs)(), t;
}
kd.Cache = cs;
var Vk = 500;
function Hk(a) {
  var e = kd(a, function(i) {
    return t.size === Vk && t.clear(), i;
  }), t = e.cache;
  return e;
}
var Gk = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, jk = /\\(\\)?/g, Uk = Hk(function(a) {
  var e = [];
  return a.charCodeAt(0) === 46 && e.push(""), a.replace(Gk, function(t, i, s, n) {
    e.push(s ? n.replace(jk, "$1") : i || t);
  }), e;
});
const Zk = Uk;
function qk(a) {
  return a == null ? "" : Wm(a);
}
function sr(a, e) {
  return Pt(a) ? a : Sd(a, e) ? [a] : Zk(qk(a));
}
var Kk = 1 / 0;
function nr(a) {
  if (typeof a == "string" || cl(a))
    return a;
  var e = a + "";
  return e == "0" && 1 / a == -Kk ? "-0" : e;
}
function fl(a, e) {
  e = sr(e, a);
  for (var t = 0, i = e.length; a != null && t < i; )
    a = a[nr(e[t++])];
  return t && t == i ? a : void 0;
}
function Jk(a, e, t) {
  var i = a == null ? void 0 : fl(a, e);
  return i === void 0 ? t : i;
}
function pl(a, e) {
  for (var t = -1, i = e.length, s = a.length; ++t < i; )
    a[s + t] = e[t];
  return a;
}
var Ju = vi ? vi.isConcatSpreadable : void 0;
function e_(a) {
  return Pt(a) || Od(a) || !!(Ju && a && a[Ju]);
}
function gl(a, e, t, i, s) {
  var n = -1, o = a.length;
  for (t || (t = e_), s || (s = []); ++n < o; ) {
    var l = a[n];
    e > 0 && t(l) ? e > 1 ? gl(l, e - 1, t, i, s) : pl(s, l) : i || (s[s.length] = l);
  }
  return s;
}
function t_(a) {
  var e = a == null ? 0 : a.length;
  return e ? gl(a, 1) : [];
}
function tb(a) {
  return Xm(jm(a, void 0, t_), a + "");
}
var i_ = eb(Object.getPrototypeOf, Object);
const _d = i_;
var s_ = "[object Object]", n_ = Function.prototype, r_ = Object.prototype, ib = n_.toString, a_ = r_.hasOwnProperty, o_ = ib.call(Object);
function l_(a) {
  if (!$i(a) || Rs(a) != s_)
    return !1;
  var e = _d(a);
  if (e === null)
    return !0;
  var t = a_.call(e, "constructor") && e.constructor;
  return typeof t == "function" && t instanceof t && ib.call(t) == o_;
}
function c_(a, e, t) {
  var i = -1, s = a.length;
  e < 0 && (e = -e > s ? 0 : s + e), t = t > s ? s : t, t < 0 && (t += s), s = e > t ? 0 : t - e >>> 0, e >>>= 0;
  for (var n = Array(s); ++i < s; )
    n[i] = a[i + e];
  return n;
}
function h_() {
  this.__data__ = new ls(), this.size = 0;
}
function d_(a) {
  var e = this.__data__, t = e.delete(a);
  return this.size = e.size, t;
}
function u_(a) {
  return this.__data__.get(a);
}
function f_(a) {
  return this.__data__.has(a);
}
var p_ = 200;
function g_(a, e) {
  var t = this.__data__;
  if (t instanceof ls) {
    var i = t.__data__;
    if (!zr || i.length < p_ - 1)
      return i.push([a, e]), this.size = ++t.size, this;
    t = this.__data__ = new cs(i);
  }
  return t.set(a, e), this.size = t.size, this;
}
function zi(a) {
  var e = this.__data__ = new ls(a);
  this.size = e.size;
}
zi.prototype.clear = h_;
zi.prototype.delete = d_;
zi.prototype.get = u_;
zi.prototype.has = f_;
zi.prototype.set = g_;
function m_(a, e) {
  return a && da(e, Is(e), a);
}
function b_(a, e) {
  return a && da(e, wd(e), a);
}
var sb = typeof exports == "object" && exports && !exports.nodeType && exports, ef = sb && typeof module == "object" && module && !module.nodeType && module, v_ = ef && ef.exports === sb, tf = v_ ? Vi.Buffer : void 0, sf = tf ? tf.allocUnsafe : void 0;
function y_(a, e) {
  if (e)
    return a.slice();
  var t = a.length, i = sf ? sf(t) : new a.constructor(t);
  return a.copy(i), i;
}
function O_(a, e) {
  for (var t = -1, i = a == null ? 0 : a.length, s = 0, n = []; ++t < i; ) {
    var o = a[t];
    e(o, t, a) && (n[s++] = o);
  }
  return n;
}
function nb() {
  return [];
}
var x_ = Object.prototype, w_ = x_.propertyIsEnumerable, nf = Object.getOwnPropertySymbols, S_ = nf ? function(a) {
  return a == null ? [] : (a = Object(a), O_(nf(a), function(e) {
    return w_.call(a, e);
  }));
} : nb;
const Cd = S_;
function k_(a, e) {
  return da(a, Cd(a), e);
}
var __ = Object.getOwnPropertySymbols, C_ = __ ? function(a) {
  for (var e = []; a; )
    pl(e, Cd(a)), a = _d(a);
  return e;
} : nb;
const rb = C_;
function T_(a, e) {
  return da(a, rb(a), e);
}
function ab(a, e, t) {
  var i = e(a);
  return Pt(a) ? i : pl(i, t(a));
}
function nh(a) {
  return ab(a, Is, Cd);
}
function ob(a) {
  return ab(a, wd, rb);
}
var A_ = fn(Vi, "DataView");
const rh = A_;
var $_ = fn(Vi, "Promise");
const ah = $_;
var E_ = fn(Vi, "Set");
const Mn = E_;
var rf = "[object Map]", P_ = "[object Object]", af = "[object Promise]", of = "[object Set]", lf = "[object WeakMap]", cf = "[object DataView]", L_ = un(rh), M_ = un(zr), D_ = un(ah), R_ = un(Mn), I_ = un(sh), Vs = Rs;
(rh && Vs(new rh(new ArrayBuffer(1))) != cf || zr && Vs(new zr()) != rf || ah && Vs(ah.resolve()) != af || Mn && Vs(new Mn()) != of || sh && Vs(new sh()) != lf) && (Vs = function(a) {
  var e = Rs(a), t = e == P_ ? a.constructor : void 0, i = t ? un(t) : "";
  if (i)
    switch (i) {
      case L_:
        return cf;
      case M_:
        return rf;
      case D_:
        return af;
      case R_:
        return of;
      case I_:
        return lf;
    }
  return e;
});
const Xr = Vs;
var Q_ = Object.prototype, N_ = Q_.hasOwnProperty;
function F_(a) {
  var e = a.length, t = new a.constructor(e);
  return e && typeof a[0] == "string" && N_.call(a, "index") && (t.index = a.index, t.input = a.input), t;
}
var W_ = Vi.Uint8Array;
const _o = W_;
function Td(a) {
  var e = new a.constructor(a.byteLength);
  return new _o(e).set(new _o(a)), e;
}
function B_(a, e) {
  var t = e ? Td(a.buffer) : a.buffer;
  return new a.constructor(t, a.byteOffset, a.byteLength);
}
var z_ = /\w*$/;
function X_(a) {
  var e = new a.constructor(a.source, z_.exec(a));
  return e.lastIndex = a.lastIndex, e;
}
var hf = vi ? vi.prototype : void 0, df = hf ? hf.valueOf : void 0;
function Y_(a) {
  return df ? Object(df.call(a)) : {};
}
function V_(a, e) {
  var t = e ? Td(a.buffer) : a.buffer;
  return new a.constructor(t, a.byteOffset, a.length);
}
var H_ = "[object Boolean]", G_ = "[object Date]", j_ = "[object Map]", U_ = "[object Number]", Z_ = "[object RegExp]", q_ = "[object Set]", K_ = "[object String]", J_ = "[object Symbol]", eC = "[object ArrayBuffer]", tC = "[object DataView]", iC = "[object Float32Array]", sC = "[object Float64Array]", nC = "[object Int8Array]", rC = "[object Int16Array]", aC = "[object Int32Array]", oC = "[object Uint8Array]", lC = "[object Uint8ClampedArray]", cC = "[object Uint16Array]", hC = "[object Uint32Array]";
function dC(a, e, t) {
  var i = a.constructor;
  switch (e) {
    case eC:
      return Td(a);
    case H_:
    case G_:
      return new i(+a);
    case tC:
      return B_(a, t);
    case iC:
    case sC:
    case nC:
    case rC:
    case aC:
    case oC:
    case lC:
    case cC:
    case hC:
      return V_(a, t);
    case j_:
      return new i();
    case U_:
    case K_:
      return new i(a);
    case Z_:
      return X_(a);
    case q_:
      return new i();
    case J_:
      return Y_(a);
  }
}
function uC(a) {
  return typeof a.constructor == "function" && !yd(a) ? eS(_d(a)) : {};
}
var fC = "[object Map]";
function pC(a) {
  return $i(a) && Xr(a) == fC;
}
var uf = Bn && Bn.isMap, gC = uf ? xd(uf) : pC;
const mC = gC;
var bC = "[object Set]";
function vC(a) {
  return $i(a) && Xr(a) == bC;
}
var ff = Bn && Bn.isSet, yC = ff ? xd(ff) : vC;
const OC = yC;
var xC = 1, wC = 2, SC = 4, lb = "[object Arguments]", kC = "[object Array]", _C = "[object Boolean]", CC = "[object Date]", TC = "[object Error]", cb = "[object Function]", AC = "[object GeneratorFunction]", $C = "[object Map]", EC = "[object Number]", hb = "[object Object]", PC = "[object RegExp]", LC = "[object Set]", MC = "[object String]", DC = "[object Symbol]", RC = "[object WeakMap]", IC = "[object ArrayBuffer]", QC = "[object DataView]", NC = "[object Float32Array]", FC = "[object Float64Array]", WC = "[object Int8Array]", BC = "[object Int16Array]", zC = "[object Int32Array]", XC = "[object Uint8Array]", YC = "[object Uint8ClampedArray]", VC = "[object Uint16Array]", HC = "[object Uint32Array]", Xe = {};
Xe[lb] = Xe[kC] = Xe[IC] = Xe[QC] = Xe[_C] = Xe[CC] = Xe[NC] = Xe[FC] = Xe[WC] = Xe[BC] = Xe[zC] = Xe[$C] = Xe[EC] = Xe[hb] = Xe[PC] = Xe[LC] = Xe[MC] = Xe[DC] = Xe[XC] = Xe[YC] = Xe[VC] = Xe[HC] = !0;
Xe[TC] = Xe[cb] = Xe[RC] = !1;
function Dn(a, e, t, i, s, n) {
  var o, l = e & xC, c = e & wC, d = e & SC;
  if (t && (o = s ? t(a, i, s, n) : t(a)), o !== void 0)
    return o;
  if (!ni(a))
    return a;
  var f = Pt(a);
  if (f) {
    if (o = F_(a), !l)
      return zm(a, o);
  } else {
    var p = Xr(a), m = p == cb || p == AC;
    if (ko(a))
      return y_(a, l);
    if (p == hb || p == lb || m && !s) {
      if (o = c || m ? {} : uC(a), !l)
        return c ? T_(a, b_(o, a)) : k_(a, m_(o, a));
    } else {
      if (!Xe[p])
        return s ? a : {};
      o = dC(a, p, l);
    }
  }
  n || (n = new zi());
  var v = n.get(a);
  if (v)
    return v;
  n.set(a, o), OC(a) ? a.forEach(function(u) {
    o.add(Dn(u, e, t, u, a, n));
  }) : mC(a) && a.forEach(function(u, g) {
    o.set(g, Dn(u, e, t, g, a, n));
  });
  var r = d ? c ? ob : nh : c ? wd : Is, h = f ? void 0 : r(a);
  return Ym(h || a, function(u, g) {
    h && (g = u, u = a[g]), bd(o, g, Dn(u, e, t, g, a, n));
  }), o;
}
var GC = 4;
function Tn(a) {
  return Dn(a, GC);
}
var jC = 1, UC = 4;
function zn(a) {
  return Dn(a, jC | UC);
}
function ZC() {
  var a = arguments.length;
  if (!a)
    return [];
  for (var e = Array(a - 1), t = arguments[0], i = a; i--; )
    e[i - 1] = arguments[i];
  return pl(Pt(t) ? zm(t) : [t], gl(e, 1));
}
var qC = "__lodash_hash_undefined__";
function KC(a) {
  return this.__data__.set(a, qC), this;
}
function JC(a) {
  return this.__data__.has(a);
}
function Yr(a) {
  var e = -1, t = a == null ? 0 : a.length;
  for (this.__data__ = new cs(); ++e < t; )
    this.add(a[e]);
}
Yr.prototype.add = Yr.prototype.push = KC;
Yr.prototype.has = JC;
function eT(a, e) {
  for (var t = -1, i = a == null ? 0 : a.length; ++t < i; )
    if (e(a[t], t, a))
      return !0;
  return !1;
}
function db(a, e) {
  return a.has(e);
}
var tT = 1, iT = 2;
function ub(a, e, t, i, s, n) {
  var o = t & tT, l = a.length, c = e.length;
  if (l != c && !(o && c > l))
    return !1;
  var d = n.get(a), f = n.get(e);
  if (d && f)
    return d == e && f == a;
  var p = -1, m = !0, v = t & iT ? new Yr() : void 0;
  for (n.set(a, e), n.set(e, a); ++p < l; ) {
    var r = a[p], h = e[p];
    if (i)
      var u = o ? i(h, r, p, e, a, n) : i(r, h, p, a, e, n);
    if (u !== void 0) {
      if (u)
        continue;
      m = !1;
      break;
    }
    if (v) {
      if (!eT(e, function(g, b) {
        if (!db(v, b) && (r === g || s(r, g, t, i, n)))
          return v.push(b);
      })) {
        m = !1;
        break;
      }
    } else if (!(r === h || s(r, h, t, i, n))) {
      m = !1;
      break;
    }
  }
  return n.delete(a), n.delete(e), m;
}
function sT(a) {
  var e = -1, t = Array(a.size);
  return a.forEach(function(i, s) {
    t[++e] = [s, i];
  }), t;
}
function Ad(a) {
  var e = -1, t = Array(a.size);
  return a.forEach(function(i) {
    t[++e] = i;
  }), t;
}
var nT = 1, rT = 2, aT = "[object Boolean]", oT = "[object Date]", lT = "[object Error]", cT = "[object Map]", hT = "[object Number]", dT = "[object RegExp]", uT = "[object Set]", fT = "[object String]", pT = "[object Symbol]", gT = "[object ArrayBuffer]", mT = "[object DataView]", pf = vi ? vi.prototype : void 0, nc = pf ? pf.valueOf : void 0;
function bT(a, e, t, i, s, n, o) {
  switch (t) {
    case mT:
      if (a.byteLength != e.byteLength || a.byteOffset != e.byteOffset)
        return !1;
      a = a.buffer, e = e.buffer;
    case gT:
      return !(a.byteLength != e.byteLength || !n(new _o(a), new _o(e)));
    case aT:
    case oT:
    case hT:
      return md(+a, +e);
    case lT:
      return a.name == e.name && a.message == e.message;
    case dT:
    case fT:
      return a == e + "";
    case cT:
      var l = sT;
    case uT:
      var c = i & nT;
      if (l || (l = Ad), a.size != e.size && !c)
        return !1;
      var d = o.get(a);
      if (d)
        return d == e;
      i |= rT, o.set(a, e);
      var f = ub(l(a), l(e), i, s, n, o);
      return o.delete(a), f;
    case pT:
      if (nc)
        return nc.call(a) == nc.call(e);
  }
  return !1;
}
var vT = 1, yT = Object.prototype, OT = yT.hasOwnProperty;
function xT(a, e, t, i, s, n) {
  var o = t & vT, l = nh(a), c = l.length, d = nh(e), f = d.length;
  if (c != f && !o)
    return !1;
  for (var p = c; p--; ) {
    var m = l[p];
    if (!(o ? m in e : OT.call(e, m)))
      return !1;
  }
  var v = n.get(a), r = n.get(e);
  if (v && r)
    return v == e && r == a;
  var h = !0;
  n.set(a, e), n.set(e, a);
  for (var u = o; ++p < c; ) {
    m = l[p];
    var g = a[m], b = e[m];
    if (i)
      var O = o ? i(b, g, m, e, a, n) : i(g, b, m, a, e, n);
    if (!(O === void 0 ? g === b || s(g, b, t, i, n) : O)) {
      h = !1;
      break;
    }
    u || (u = m == "constructor");
  }
  if (h && !u) {
    var x = a.constructor, S = e.constructor;
    x != S && "constructor" in a && "constructor" in e && !(typeof x == "function" && x instanceof x && typeof S == "function" && S instanceof S) && (h = !1);
  }
  return n.delete(a), n.delete(e), h;
}
var wT = 1, gf = "[object Arguments]", mf = "[object Array]", Ra = "[object Object]", ST = Object.prototype, bf = ST.hasOwnProperty;
function kT(a, e, t, i, s, n) {
  var o = Pt(a), l = Pt(e), c = o ? mf : Xr(a), d = l ? mf : Xr(e);
  c = c == gf ? Ra : c, d = d == gf ? Ra : d;
  var f = c == Ra, p = d == Ra, m = c == d;
  if (m && ko(a)) {
    if (!ko(e))
      return !1;
    o = !0, f = !1;
  }
  if (m && !f)
    return n || (n = new zi()), o || Km(a) ? ub(a, e, t, i, s, n) : bT(a, e, c, t, i, s, n);
  if (!(t & wT)) {
    var v = f && bf.call(a, "__wrapped__"), r = p && bf.call(e, "__wrapped__");
    if (v || r) {
      var h = v ? a.value() : a, u = r ? e.value() : e;
      return n || (n = new zi()), s(h, u, t, i, n);
    }
  }
  return m ? (n || (n = new zi()), xT(a, e, t, i, s, n)) : !1;
}
function ml(a, e, t, i, s) {
  return a === e ? !0 : a == null || e == null || !$i(a) && !$i(e) ? a !== a && e !== e : kT(a, e, t, i, ml, s);
}
var _T = 1, CT = 2;
function TT(a, e, t, i) {
  var s = t.length, n = s, o = !i;
  if (a == null)
    return !n;
  for (a = Object(a); s--; ) {
    var l = t[s];
    if (o && l[2] ? l[1] !== a[l[0]] : !(l[0] in a))
      return !1;
  }
  for (; ++s < n; ) {
    l = t[s];
    var c = l[0], d = a[c], f = l[1];
    if (o && l[2]) {
      if (d === void 0 && !(c in a))
        return !1;
    } else {
      var p = new zi();
      if (i)
        var m = i(d, f, c, a, e, p);
      if (!(m === void 0 ? ml(f, d, _T | CT, i, p) : m))
        return !1;
    }
  }
  return !0;
}
function fb(a) {
  return a === a && !ni(a);
}
function AT(a) {
  for (var e = Is(a), t = e.length; t--; ) {
    var i = e[t], s = a[i];
    e[t] = [i, s, fb(s)];
  }
  return e;
}
function pb(a, e) {
  return function(t) {
    return t == null ? !1 : t[a] === e && (e !== void 0 || a in Object(t));
  };
}
function $T(a) {
  var e = AT(a);
  return e.length == 1 && e[0][2] ? pb(e[0][0], e[0][1]) : function(t) {
    return t === a || TT(t, a, e);
  };
}
function ET(a, e) {
  return a != null && e in Object(a);
}
function PT(a, e, t) {
  e = sr(e, a);
  for (var i = -1, s = e.length, n = !1; ++i < s; ) {
    var o = nr(e[i]);
    if (!(n = a != null && t(a, o)))
      break;
    a = a[o];
  }
  return n || ++i != s ? n : (s = a == null ? 0 : a.length, !!s && vd(s) && gd(o, s) && (Pt(a) || Od(a)));
}
function gb(a, e) {
  return a != null && PT(a, e, ET);
}
var LT = 1, MT = 2;
function DT(a, e) {
  return Sd(a) && fb(e) ? pb(nr(a), e) : function(t) {
    var i = Jk(t, a);
    return i === void 0 && i === e ? gb(t, a) : ml(e, i, LT | MT);
  };
}
function RT(a) {
  return function(e) {
    return e == null ? void 0 : e[a];
  };
}
function IT(a) {
  return function(e) {
    return fl(e, a);
  };
}
function QT(a) {
  return Sd(a) ? RT(nr(a)) : IT(a);
}
function mb(a) {
  return typeof a == "function" ? a : a == null ? hl : typeof a == "object" ? Pt(a) ? DT(a[0], a[1]) : $T(a) : QT(a);
}
function NT(a) {
  return function(e, t, i) {
    for (var s = -1, n = Object(e), o = i(e), l = o.length; l--; ) {
      var c = o[a ? l : ++s];
      if (t(n[c], c, n) === !1)
        break;
    }
    return e;
  };
}
var FT = NT();
const WT = FT;
function BT(a, e) {
  return a && WT(a, e, Is);
}
function zT(a, e) {
  return function(t, i) {
    if (t == null)
      return t;
    if (!ua(t))
      return a(t, i);
    for (var s = t.length, n = e ? s : -1, o = Object(t); (e ? n-- : ++n < s) && i(o[n], n, o) !== !1; )
      ;
    return t;
  };
}
var XT = zT(BT);
const VT = XT;
function HT(a) {
  return $i(a) && ua(a);
}
function GT(a, e, t) {
  for (var i = -1, s = a == null ? 0 : a.length; ++i < s; )
    if (t(e, a[i]))
      return !0;
  return !1;
}
function jT(a) {
  var e = a == null ? 0 : a.length;
  return e ? a[e - 1] : void 0;
}
function UT(a) {
  return typeof a == "function" ? a : hl;
}
function gi(a, e) {
  var t = Pt(a) ? Ym : VT;
  return t(a, UT(e));
}
function ZT(a) {
  return function(e, t, i) {
    var s = Object(e);
    if (!ua(e)) {
      var n = mb(t);
      e = Is(e), t = function(l) {
        return n(s[l], l, s);
      };
    }
    var o = a(e, t, i);
    return o > -1 ? s[n ? e[o] : o] : void 0;
  };
}
var qT = Math.max;
function KT(a, e, t) {
  var i = a == null ? 0 : a.length;
  if (!i)
    return -1;
  var s = t == null ? 0 : Bm(t);
  return s < 0 && (s = qT(i + s, 0)), Vm(a, mb(e), s);
}
var JT = ZT(KT);
const Mr = JT;
function eA(a) {
  return a && a.length ? a[0] : void 0;
}
var tA = Math.max;
function rc(a, e, t) {
  var i = a == null ? 0 : a.length;
  if (!i)
    return -1;
  var s = t == null ? 0 : Bm(t);
  return s < 0 && (s = tA(i + s, 0)), Hm(a, e, s);
}
function iA(a, e) {
  return e.length < 2 ? a : fl(a, c_(e, 0, -1));
}
function sA(a, e) {
  return ml(a, e);
}
var nA = "[object Number]";
function rA(a) {
  return typeof a == "number" || $i(a) && Rs(a) == nA;
}
function aA(a, e) {
  return e = sr(e, a), a = iA(a, e), a == null || delete a[nr(jT(e))];
}
function oA(a) {
  return l_(a) ? void 0 : a;
}
var lA = 1, cA = 2, hA = 4, dA = tb(function(a, e) {
  var t = {};
  if (a == null)
    return t;
  var i = !1;
  e = Fm(e, function(n) {
    return n = sr(n, a), i || (i = n.length > 1), n;
  }), da(a, ob(a), t), i && (t = Dn(t, lA | cA | hA, oA));
  for (var s = e.length; s--; )
    aA(t, e[s]);
  return t;
});
const Vr = dA;
function uA(a, e, t, i) {
  if (!ni(a))
    return a;
  e = sr(e, a);
  for (var s = -1, n = e.length, o = n - 1, l = a; l != null && ++s < n; ) {
    var c = nr(e[s]), d = t;
    if (c === "__proto__" || c === "constructor" || c === "prototype")
      return a;
    if (s != o) {
      var f = l[c];
      d = i ? i(f, c, l) : void 0, d === void 0 && (d = ni(f) ? f : gd(e[s + 1]) ? [] : {});
    }
    bd(l, c, d), l = l[c];
  }
  return a;
}
function fA(a, e, t) {
  for (var i = -1, s = e.length, n = {}; ++i < s; ) {
    var o = e[i], l = fl(a, o);
    t(l, o) && uA(n, sr(o, a), l);
  }
  return n;
}
function pA(a, e) {
  return fA(a, e, function(t, i) {
    return gb(a, i);
  });
}
var gA = tb(function(a, e) {
  return a == null ? {} : pA(a, e);
});
const mA = gA;
var bA = 1 / 0, vA = Mn && 1 / Ad(new Mn([, -0]))[1] == bA ? function(a) {
  return new Mn(a);
} : iS;
const yA = vA;
var OA = 200;
function xA(a, e, t) {
  var i = -1, s = pS, n = a.length, o = !0, l = [], c = l;
  if (t)
    o = !1, s = GT;
  else if (n >= OA) {
    var d = e ? null : yA(a);
    if (d)
      return Ad(d);
    o = !1, s = db, c = new Yr();
  } else
    c = e ? [] : l;
  e:
    for (; ++i < n; ) {
      var f = a[i], p = e ? e(f) : f;
      if (f = t || f !== 0 ? f : 0, o && p === p) {
        for (var m = c.length; m--; )
          if (c[m] === p)
            continue e;
        e && c.push(p), l.push(f);
      } else
        s(c, p, t) || (c !== l && c.push(p), l.push(f));
    }
  return l;
}
var wA = yS(function(a) {
  return xA(gl(a, 1, HT, !0));
});
const SA = wA;
var kA = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function _A(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
var bb = { exports: {} };
/*! choices.js v10.2.0 | © 2022 Josh Johnson | https://github.com/jshjohnson/Choices#readme */
(function(a, e) {
  (function(i, s) {
    a.exports = s();
  })(window, function() {
    return (
      /******/
      function() {
        var t = {
          /***/
          282: (
            /***/
            function(o, l, c) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              }), l.clearChoices = l.activateChoices = l.filterChoices = l.addChoice = void 0;
              var d = c(883), f = function(r) {
                var h = r.value, u = r.label, g = r.id, b = r.groupId, O = r.disabled, x = r.elementId, S = r.customProperties, k = r.placeholder, C = r.keyCode;
                return {
                  type: d.ACTION_TYPES.ADD_CHOICE,
                  value: h,
                  label: u,
                  id: g,
                  groupId: b,
                  disabled: O,
                  elementId: x,
                  customProperties: S,
                  placeholder: k,
                  keyCode: C
                };
              };
              l.addChoice = f;
              var p = function(r) {
                return {
                  type: d.ACTION_TYPES.FILTER_CHOICES,
                  results: r
                };
              };
              l.filterChoices = p;
              var m = function(r) {
                return r === void 0 && (r = !0), {
                  type: d.ACTION_TYPES.ACTIVATE_CHOICES,
                  active: r
                };
              };
              l.activateChoices = m;
              var v = function() {
                return {
                  type: d.ACTION_TYPES.CLEAR_CHOICES
                };
              };
              l.clearChoices = v;
            }
          ),
          /***/
          783: (
            /***/
            function(o, l, c) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              }), l.addGroup = void 0;
              var d = c(883), f = function(p) {
                var m = p.value, v = p.id, r = p.active, h = p.disabled;
                return {
                  type: d.ACTION_TYPES.ADD_GROUP,
                  value: m,
                  id: v,
                  active: r,
                  disabled: h
                };
              };
              l.addGroup = f;
            }
          ),
          /***/
          464: (
            /***/
            function(o, l, c) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              }), l.highlightItem = l.removeItem = l.addItem = void 0;
              var d = c(883), f = function(v) {
                var r = v.value, h = v.label, u = v.id, g = v.choiceId, b = v.groupId, O = v.customProperties, x = v.placeholder, S = v.keyCode;
                return {
                  type: d.ACTION_TYPES.ADD_ITEM,
                  value: r,
                  label: h,
                  id: u,
                  choiceId: g,
                  groupId: b,
                  customProperties: O,
                  placeholder: x,
                  keyCode: S
                };
              };
              l.addItem = f;
              var p = function(v, r) {
                return {
                  type: d.ACTION_TYPES.REMOVE_ITEM,
                  id: v,
                  choiceId: r
                };
              };
              l.removeItem = p;
              var m = function(v, r) {
                return {
                  type: d.ACTION_TYPES.HIGHLIGHT_ITEM,
                  id: v,
                  highlighted: r
                };
              };
              l.highlightItem = m;
            }
          ),
          /***/
          137: (
            /***/
            function(o, l, c) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              }), l.setIsLoading = l.resetTo = l.clearAll = void 0;
              var d = c(883), f = function() {
                return {
                  type: d.ACTION_TYPES.CLEAR_ALL
                };
              };
              l.clearAll = f;
              var p = function(v) {
                return {
                  type: d.ACTION_TYPES.RESET_TO,
                  state: v
                };
              };
              l.resetTo = p;
              var m = function(v) {
                return {
                  type: d.ACTION_TYPES.SET_IS_LOADING,
                  isLoading: v
                };
              };
              l.setIsLoading = m;
            }
          ),
          /***/
          373: (
            /***/
            function(o, l, c) {
              var d = this && this.__spreadArray || function(E, A, y) {
                if (y || arguments.length === 2)
                  for (var w = 0, T = A.length, P; w < T; w++)
                    (P || !(w in A)) && (P || (P = Array.prototype.slice.call(A, 0, w)), P[w] = A[w]);
                return E.concat(P || Array.prototype.slice.call(A));
              }, f = this && this.__importDefault || function(E) {
                return E && E.__esModule ? E : {
                  default: E
                };
              };
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
              var p = f(c(996)), m = f(c(221)), v = c(282), r = c(783), h = c(464), u = c(137), g = c(520), b = c(883), O = c(789), x = c(799), S = c(655), k = f(c(744)), C = f(c(686)), _ = "-ms-scroll-limit" in document.documentElement.style && "-ms-ime-align" in document.documentElement.style, $ = {}, L = (
                /** @class */
                function() {
                  function E(A, y) {
                    A === void 0 && (A = "[data-choice]"), y === void 0 && (y = {});
                    var w = this;
                    y.allowHTML === void 0 && console.warn("Deprecation warning: allowHTML will default to false in a future release. To render HTML in Choices, you will need to set it to true. Setting allowHTML will suppress this message."), this.config = p.default.all(
                      [O.DEFAULT_CONFIG, E.defaults.options, y],
                      // When merging array configs, replace with a copy of the userConfig array,
                      // instead of concatenating with the default array
                      {
                        arrayMerge: function(G, de) {
                          return d([], de, !0);
                        }
                      }
                    );
                    var T = (0, x.diff)(this.config, O.DEFAULT_CONFIG);
                    T.length && console.warn("Unknown config option(s) passed", T.join(", "));
                    var P = typeof A == "string" ? document.querySelector(A) : A;
                    if (!(P instanceof HTMLInputElement || P instanceof HTMLSelectElement))
                      throw TypeError("Expected one of the following types text|select-one|select-multiple");
                    if (this._isTextElement = P.type === b.TEXT_TYPE, this._isSelectOneElement = P.type === b.SELECT_ONE_TYPE, this._isSelectMultipleElement = P.type === b.SELECT_MULTIPLE_TYPE, this._isSelectElement = this._isSelectOneElement || this._isSelectMultipleElement, this.config.searchEnabled = this._isSelectMultipleElement || this.config.searchEnabled, ["auto", "always"].includes("".concat(this.config.renderSelectedChoices)) || (this.config.renderSelectedChoices = "auto"), y.addItemFilter && typeof y.addItemFilter != "function") {
                      var R = y.addItemFilter instanceof RegExp ? y.addItemFilter : new RegExp(y.addItemFilter);
                      this.config.addItemFilter = R.test.bind(R);
                    }
                    if (this._isTextElement ? this.passedElement = new g.WrappedInput({
                      element: P,
                      classNames: this.config.classNames,
                      delimiter: this.config.delimiter
                    }) : this.passedElement = new g.WrappedSelect({
                      element: P,
                      classNames: this.config.classNames,
                      template: function(G) {
                        return w._templates.option(G);
                      }
                    }), this.initialised = !1, this._store = new k.default(), this._initialState = S.defaultState, this._currentState = S.defaultState, this._prevState = S.defaultState, this._currentValue = "", this._canSearch = !!this.config.searchEnabled, this._isScrollingOnIe = !1, this._highlightPosition = 0, this._wasTap = !0, this._placeholderValue = this._generatePlaceholderValue(), this._baseId = (0, x.generateId)(this.passedElement.element, "choices-"), this._direction = this.passedElement.dir, !this._direction) {
                      var Q = window.getComputedStyle(this.passedElement.element).direction, z = window.getComputedStyle(document.documentElement).direction;
                      Q !== z && (this._direction = Q);
                    }
                    if (this._idNames = {
                      itemChoice: "item-choice"
                    }, this._isSelectElement && (this._presetGroups = this.passedElement.optionGroups, this._presetOptions = this.passedElement.options), this._presetChoices = this.config.choices, this._presetItems = this.config.items, this.passedElement.value && this._isTextElement) {
                      var W = this.passedElement.value.split(this.config.delimiter);
                      this._presetItems = this._presetItems.concat(W);
                    }
                    if (this.passedElement.options && this.passedElement.options.forEach(function(G) {
                      w._presetChoices.push({
                        value: G.value,
                        label: G.innerHTML,
                        selected: !!G.selected,
                        disabled: G.disabled || G.parentNode.disabled,
                        placeholder: G.value === "" || G.hasAttribute("placeholder"),
                        customProperties: (0, x.parseCustomProperties)(G.dataset.customProperties)
                      });
                    }), this._render = this._render.bind(this), this._onFocus = this._onFocus.bind(this), this._onBlur = this._onBlur.bind(this), this._onKeyUp = this._onKeyUp.bind(this), this._onKeyDown = this._onKeyDown.bind(this), this._onClick = this._onClick.bind(this), this._onTouchMove = this._onTouchMove.bind(this), this._onTouchEnd = this._onTouchEnd.bind(this), this._onMouseDown = this._onMouseDown.bind(this), this._onMouseOver = this._onMouseOver.bind(this), this._onFormReset = this._onFormReset.bind(this), this._onSelectKey = this._onSelectKey.bind(this), this._onEnterKey = this._onEnterKey.bind(this), this._onEscapeKey = this._onEscapeKey.bind(this), this._onDirectionKey = this._onDirectionKey.bind(this), this._onDeleteKey = this._onDeleteKey.bind(this), this.passedElement.isActive) {
                      this.config.silent || console.warn("Trying to initialise Choices on element already initialised", {
                        element: A
                      }), this.initialised = !0;
                      return;
                    }
                    this.init();
                  }
                  return Object.defineProperty(E, "defaults", {
                    get: function() {
                      return Object.preventExtensions({
                        get options() {
                          return $;
                        },
                        get templates() {
                          return C.default;
                        }
                      });
                    },
                    enumerable: !1,
                    configurable: !0
                  }), E.prototype.init = function() {
                    if (!this.initialised) {
                      this._createTemplates(), this._createElements(), this._createStructure(), this._store.subscribe(this._render), this._render(), this._addEventListeners();
                      var A = !this.config.addItems || this.passedElement.element.hasAttribute("disabled");
                      A && this.disable(), this.initialised = !0;
                      var y = this.config.callbackOnInit;
                      y && typeof y == "function" && y.call(this);
                    }
                  }, E.prototype.destroy = function() {
                    this.initialised && (this._removeEventListeners(), this.passedElement.reveal(), this.containerOuter.unwrap(this.passedElement.element), this.clearStore(), this._isSelectElement && (this.passedElement.options = this._presetOptions), this._templates = C.default, this.initialised = !1);
                  }, E.prototype.enable = function() {
                    return this.passedElement.isDisabled && this.passedElement.enable(), this.containerOuter.isDisabled && (this._addEventListeners(), this.input.enable(), this.containerOuter.enable()), this;
                  }, E.prototype.disable = function() {
                    return this.passedElement.isDisabled || this.passedElement.disable(), this.containerOuter.isDisabled || (this._removeEventListeners(), this.input.disable(), this.containerOuter.disable()), this;
                  }, E.prototype.highlightItem = function(A, y) {
                    if (y === void 0 && (y = !0), !A || !A.id)
                      return this;
                    var w = A.id, T = A.groupId, P = T === void 0 ? -1 : T, R = A.value, Q = R === void 0 ? "" : R, z = A.label, W = z === void 0 ? "" : z, G = P >= 0 ? this._store.getGroupById(P) : null;
                    return this._store.dispatch((0, h.highlightItem)(w, !0)), y && this.passedElement.triggerEvent(b.EVENTS.highlightItem, {
                      id: w,
                      value: Q,
                      label: W,
                      groupValue: G && G.value ? G.value : null
                    }), this;
                  }, E.prototype.unhighlightItem = function(A) {
                    if (!A || !A.id)
                      return this;
                    var y = A.id, w = A.groupId, T = w === void 0 ? -1 : w, P = A.value, R = P === void 0 ? "" : P, Q = A.label, z = Q === void 0 ? "" : Q, W = T >= 0 ? this._store.getGroupById(T) : null;
                    return this._store.dispatch((0, h.highlightItem)(y, !1)), this.passedElement.triggerEvent(b.EVENTS.highlightItem, {
                      id: y,
                      value: R,
                      label: z,
                      groupValue: W && W.value ? W.value : null
                    }), this;
                  }, E.prototype.highlightAll = function() {
                    var A = this;
                    return this._store.items.forEach(function(y) {
                      return A.highlightItem(y);
                    }), this;
                  }, E.prototype.unhighlightAll = function() {
                    var A = this;
                    return this._store.items.forEach(function(y) {
                      return A.unhighlightItem(y);
                    }), this;
                  }, E.prototype.removeActiveItemsByValue = function(A) {
                    var y = this;
                    return this._store.activeItems.filter(function(w) {
                      return w.value === A;
                    }).forEach(function(w) {
                      return y._removeItem(w);
                    }), this;
                  }, E.prototype.removeActiveItems = function(A) {
                    var y = this;
                    return this._store.activeItems.filter(function(w) {
                      var T = w.id;
                      return T !== A;
                    }).forEach(function(w) {
                      return y._removeItem(w);
                    }), this;
                  }, E.prototype.removeHighlightedItems = function(A) {
                    var y = this;
                    return A === void 0 && (A = !1), this._store.highlightedActiveItems.forEach(function(w) {
                      y._removeItem(w), A && y._triggerChange(w.value);
                    }), this;
                  }, E.prototype.showDropdown = function(A) {
                    var y = this;
                    return this.dropdown.isActive ? this : (requestAnimationFrame(function() {
                      y.dropdown.show(), y.containerOuter.open(y.dropdown.distanceFromTopWindow), !A && y._canSearch && y.input.focus(), y.passedElement.triggerEvent(b.EVENTS.showDropdown, {});
                    }), this);
                  }, E.prototype.hideDropdown = function(A) {
                    var y = this;
                    return this.dropdown.isActive ? (requestAnimationFrame(function() {
                      y.dropdown.hide(), y.containerOuter.close(), !A && y._canSearch && (y.input.removeActiveDescendant(), y.input.blur()), y.passedElement.triggerEvent(b.EVENTS.hideDropdown, {});
                    }), this) : this;
                  }, E.prototype.getValue = function(A) {
                    A === void 0 && (A = !1);
                    var y = this._store.activeItems.reduce(function(w, T) {
                      var P = A ? T.value : T;
                      return w.push(P), w;
                    }, []);
                    return this._isSelectOneElement ? y[0] : y;
                  }, E.prototype.setValue = function(A) {
                    var y = this;
                    return this.initialised ? (A.forEach(function(w) {
                      return y._setChoiceOrItem(w);
                    }), this) : this;
                  }, E.prototype.setChoiceByValue = function(A) {
                    var y = this;
                    if (!this.initialised || this._isTextElement)
                      return this;
                    var w = Array.isArray(A) ? A : [A];
                    return w.forEach(function(T) {
                      return y._findAndSelectChoiceByValue(T);
                    }), this;
                  }, E.prototype.setChoices = function(A, y, w, T) {
                    var P = this;
                    if (A === void 0 && (A = []), y === void 0 && (y = "value"), w === void 0 && (w = "label"), T === void 0 && (T = !1), !this.initialised)
                      throw new ReferenceError("setChoices was called on a non-initialized instance of Choices");
                    if (!this._isSelectElement)
                      throw new TypeError("setChoices can't be used with INPUT based Choices");
                    if (typeof y != "string" || !y)
                      throw new TypeError("value parameter must be a name of 'value' field in passed objects");
                    if (T && this.clearChoices(), typeof A == "function") {
                      var R = A(this);
                      if (typeof Promise == "function" && R instanceof Promise)
                        return new Promise(function(Q) {
                          return requestAnimationFrame(Q);
                        }).then(function() {
                          return P._handleLoadingState(!0);
                        }).then(function() {
                          return R;
                        }).then(function(Q) {
                          return P.setChoices(Q, y, w, T);
                        }).catch(function(Q) {
                          P.config.silent || console.error(Q);
                        }).then(function() {
                          return P._handleLoadingState(!1);
                        }).then(function() {
                          return P;
                        });
                      if (!Array.isArray(R))
                        throw new TypeError(".setChoices first argument function must return either array of choices or Promise, got: ".concat(typeof R));
                      return this.setChoices(R, y, w, !1);
                    }
                    if (!Array.isArray(A))
                      throw new TypeError(".setChoices must be called either with array of choices with a function resulting into Promise of array of choices");
                    return this.containerOuter.removeLoadingState(), this._startLoading(), A.forEach(function(Q) {
                      if (Q.choices)
                        P._addGroup({
                          id: Q.id ? parseInt("".concat(Q.id), 10) : null,
                          group: Q,
                          valueKey: y,
                          labelKey: w
                        });
                      else {
                        var z = Q;
                        P._addChoice({
                          value: z[y],
                          label: z[w],
                          isSelected: !!z.selected,
                          isDisabled: !!z.disabled,
                          placeholder: !!z.placeholder,
                          customProperties: z.customProperties
                        });
                      }
                    }), this._stopLoading(), this;
                  }, E.prototype.clearChoices = function() {
                    return this._store.dispatch((0, v.clearChoices)()), this;
                  }, E.prototype.clearStore = function() {
                    return this._store.dispatch((0, u.clearAll)()), this;
                  }, E.prototype.clearInput = function() {
                    var A = !this._isSelectOneElement;
                    return this.input.clear(A), !this._isTextElement && this._canSearch && (this._isSearching = !1, this._store.dispatch((0, v.activateChoices)(!0))), this;
                  }, E.prototype._render = function() {
                    if (!this._store.isLoading()) {
                      this._currentState = this._store.state;
                      var A = this._currentState.choices !== this._prevState.choices || this._currentState.groups !== this._prevState.groups || this._currentState.items !== this._prevState.items, y = this._isSelectElement, w = this._currentState.items !== this._prevState.items;
                      A && (y && this._renderChoices(), w && this._renderItems(), this._prevState = this._currentState);
                    }
                  }, E.prototype._renderChoices = function() {
                    var A = this, y = this._store, w = y.activeGroups, T = y.activeChoices, P = document.createDocumentFragment();
                    if (this.choiceList.clear(), this.config.resetScrollPosition && requestAnimationFrame(function() {
                      return A.choiceList.scrollToTop();
                    }), w.length >= 1 && !this._isSearching) {
                      var R = T.filter(function(de) {
                        return de.placeholder === !0 && de.groupId === -1;
                      });
                      R.length >= 1 && (P = this._createChoicesFragment(R, P)), P = this._createGroupsFragment(w, T, P);
                    } else
                      T.length >= 1 && (P = this._createChoicesFragment(T, P));
                    if (P.childNodes && P.childNodes.length > 0) {
                      var Q = this._store.activeItems, z = this._canAddItem(Q, this.input.value);
                      if (z.response)
                        this.choiceList.append(P), this._highlightChoice();
                      else {
                        var W = this._getTemplate("notice", z.notice);
                        this.choiceList.append(W);
                      }
                    } else {
                      var G = void 0, W = void 0;
                      this._isSearching ? (W = typeof this.config.noResultsText == "function" ? this.config.noResultsText() : this.config.noResultsText, G = this._getTemplate("notice", W, "no-results")) : (W = typeof this.config.noChoicesText == "function" ? this.config.noChoicesText() : this.config.noChoicesText, G = this._getTemplate("notice", W, "no-choices")), this.choiceList.append(G);
                    }
                  }, E.prototype._renderItems = function() {
                    var A = this._store.activeItems || [];
                    this.itemList.clear();
                    var y = this._createItemsFragment(A);
                    y.childNodes && this.itemList.append(y);
                  }, E.prototype._createGroupsFragment = function(A, y, w) {
                    var T = this;
                    w === void 0 && (w = document.createDocumentFragment());
                    var P = function(R) {
                      return y.filter(function(Q) {
                        return T._isSelectOneElement ? Q.groupId === R.id : Q.groupId === R.id && (T.config.renderSelectedChoices === "always" || !Q.selected);
                      });
                    };
                    return this.config.shouldSort && A.sort(this.config.sorter), A.forEach(function(R) {
                      var Q = P(R);
                      if (Q.length >= 1) {
                        var z = T._getTemplate("choiceGroup", R);
                        w.appendChild(z), T._createChoicesFragment(Q, w, !0);
                      }
                    }), w;
                  }, E.prototype._createChoicesFragment = function(A, y, w) {
                    var T = this;
                    y === void 0 && (y = document.createDocumentFragment()), w === void 0 && (w = !1);
                    var P = this.config, R = P.renderSelectedChoices, Q = P.searchResultLimit, z = P.renderChoiceLimit, W = this._isSearching ? x.sortByScore : this.config.sorter, G = function(ot) {
                      var Ge = R === "auto" ? T._isSelectOneElement || !ot.selected : !0;
                      if (Ge) {
                        var qt = T._getTemplate("choice", ot, T.config.itemSelectText);
                        y.appendChild(qt);
                      }
                    }, de = A;
                    R === "auto" && !this._isSelectOneElement && (de = A.filter(function(ot) {
                      return !ot.selected;
                    }));
                    var xe = de.reduce(function(ot, Ge) {
                      return Ge.placeholder ? ot.placeholderChoices.push(Ge) : ot.normalChoices.push(Ge), ot;
                    }, {
                      placeholderChoices: [],
                      normalChoices: []
                    }), ie = xe.placeholderChoices, fe = xe.normalChoices;
                    (this.config.shouldSort || this._isSearching) && fe.sort(W);
                    var $e = de.length, Me = this._isSelectOneElement ? d(d([], ie, !0), fe, !0) : fe;
                    this._isSearching ? $e = Q : z && z > 0 && !w && ($e = z);
                    for (var Ie = 0; Ie < $e; Ie += 1)
                      Me[Ie] && G(Me[Ie]);
                    return y;
                  }, E.prototype._createItemsFragment = function(A, y) {
                    var w = this;
                    y === void 0 && (y = document.createDocumentFragment());
                    var T = this.config, P = T.shouldSortItems, R = T.sorter, Q = T.removeItemButton;
                    P && !this._isSelectOneElement && A.sort(R), this._isTextElement ? this.passedElement.value = A.map(function(W) {
                      var G = W.value;
                      return G;
                    }).join(this.config.delimiter) : this.passedElement.options = A;
                    var z = function(W) {
                      var G = w._getTemplate("item", W, Q);
                      y.appendChild(G);
                    };
                    return A.forEach(z), y;
                  }, E.prototype._triggerChange = function(A) {
                    A != null && this.passedElement.triggerEvent(b.EVENTS.change, {
                      value: A
                    });
                  }, E.prototype._selectPlaceholderChoice = function(A) {
                    this._addItem({
                      value: A.value,
                      label: A.label,
                      choiceId: A.id,
                      groupId: A.groupId,
                      placeholder: A.placeholder
                    }), this._triggerChange(A.value);
                  }, E.prototype._handleButtonAction = function(A, y) {
                    if (!(!A || !y || !this.config.removeItems || !this.config.removeItemButton)) {
                      var w = y.parentNode && y.parentNode.dataset.id, T = w && A.find(function(P) {
                        return P.id === parseInt(w, 10);
                      });
                      T && (this._removeItem(T), this._triggerChange(T.value), this._isSelectOneElement && this._store.placeholderChoice && this._selectPlaceholderChoice(this._store.placeholderChoice));
                    }
                  }, E.prototype._handleItemAction = function(A, y, w) {
                    var T = this;
                    if (w === void 0 && (w = !1), !(!A || !y || !this.config.removeItems || this._isSelectOneElement)) {
                      var P = y.dataset.id;
                      A.forEach(function(R) {
                        R.id === parseInt("".concat(P), 10) && !R.highlighted ? T.highlightItem(R) : !w && R.highlighted && T.unhighlightItem(R);
                      }), this.input.focus();
                    }
                  }, E.prototype._handleChoiceAction = function(A, y) {
                    if (!(!A || !y)) {
                      var w = y.dataset.id, T = w && this._store.getChoiceById(w);
                      if (T) {
                        var P = A[0] && A[0].keyCode ? A[0].keyCode : void 0, R = this.dropdown.isActive;
                        if (T.keyCode = P, this.passedElement.triggerEvent(b.EVENTS.choice, {
                          choice: T
                        }), !T.selected && !T.disabled) {
                          var Q = this._canAddItem(A, T.value);
                          Q.response && (this._addItem({
                            value: T.value,
                            label: T.label,
                            choiceId: T.id,
                            groupId: T.groupId,
                            customProperties: T.customProperties,
                            placeholder: T.placeholder,
                            keyCode: T.keyCode
                          }), this._triggerChange(T.value));
                        }
                        this.clearInput(), R && this._isSelectOneElement && (this.hideDropdown(!0), this.containerOuter.focus());
                      }
                    }
                  }, E.prototype._handleBackspace = function(A) {
                    if (!(!this.config.removeItems || !A)) {
                      var y = A[A.length - 1], w = A.some(function(T) {
                        return T.highlighted;
                      });
                      this.config.editItems && !w && y ? (this.input.value = y.value, this.input.setWidth(), this._removeItem(y), this._triggerChange(y.value)) : (w || this.highlightItem(y, !1), this.removeHighlightedItems(!0));
                    }
                  }, E.prototype._startLoading = function() {
                    this._store.dispatch((0, u.setIsLoading)(!0));
                  }, E.prototype._stopLoading = function() {
                    this._store.dispatch((0, u.setIsLoading)(!1));
                  }, E.prototype._handleLoadingState = function(A) {
                    A === void 0 && (A = !0);
                    var y = this.itemList.getChild(".".concat(this.config.classNames.placeholder));
                    A ? (this.disable(), this.containerOuter.addLoadingState(), this._isSelectOneElement ? y ? y.innerHTML = this.config.loadingText : (y = this._getTemplate("placeholder", this.config.loadingText), y && this.itemList.append(y)) : this.input.placeholder = this.config.loadingText) : (this.enable(), this.containerOuter.removeLoadingState(), this._isSelectOneElement ? y && (y.innerHTML = this._placeholderValue || "") : this.input.placeholder = this._placeholderValue || "");
                  }, E.prototype._handleSearch = function(A) {
                    if (this.input.isFocussed) {
                      var y = this._store.choices, w = this.config, T = w.searchFloor, P = w.searchChoices, R = y.some(function(z) {
                        return !z.active;
                      });
                      if (A !== null && typeof A < "u" && A.length >= T) {
                        var Q = P ? this._searchChoices(A) : 0;
                        this.passedElement.triggerEvent(b.EVENTS.search, {
                          value: A,
                          resultCount: Q
                        });
                      } else
                        R && (this._isSearching = !1, this._store.dispatch((0, v.activateChoices)(!0)));
                    }
                  }, E.prototype._canAddItem = function(A, y) {
                    var w = !0, T = typeof this.config.addItemText == "function" ? this.config.addItemText(y) : this.config.addItemText;
                    if (!this._isSelectOneElement) {
                      var P = (0, x.existsInArray)(A, y);
                      this.config.maxItemCount > 0 && this.config.maxItemCount <= A.length && (w = !1, T = typeof this.config.maxItemText == "function" ? this.config.maxItemText(this.config.maxItemCount) : this.config.maxItemText), !this.config.duplicateItemsAllowed && P && w && (w = !1, T = typeof this.config.uniqueItemText == "function" ? this.config.uniqueItemText(y) : this.config.uniqueItemText), this._isTextElement && this.config.addItems && w && typeof this.config.addItemFilter == "function" && !this.config.addItemFilter(y) && (w = !1, T = typeof this.config.customAddItemText == "function" ? this.config.customAddItemText(y) : this.config.customAddItemText);
                    }
                    return {
                      response: w,
                      notice: T
                    };
                  }, E.prototype._searchChoices = function(A) {
                    var y = typeof A == "string" ? A.trim() : A, w = typeof this._currentValue == "string" ? this._currentValue.trim() : this._currentValue;
                    if (y.length < 1 && y === "".concat(w, " "))
                      return 0;
                    var T = this._store.searchableChoices, P = y, R = Object.assign(this.config.fuseOptions, {
                      keys: d([], this.config.searchFields, !0),
                      includeMatches: !0
                    }), Q = new m.default(T, R), z = Q.search(P);
                    return this._currentValue = y, this._highlightPosition = 0, this._isSearching = !0, this._store.dispatch((0, v.filterChoices)(z)), z.length;
                  }, E.prototype._addEventListeners = function() {
                    var A = document.documentElement;
                    A.addEventListener("touchend", this._onTouchEnd, !0), this.containerOuter.element.addEventListener("keydown", this._onKeyDown, !0), this.containerOuter.element.addEventListener("mousedown", this._onMouseDown, !0), A.addEventListener("click", this._onClick, {
                      passive: !0
                    }), A.addEventListener("touchmove", this._onTouchMove, {
                      passive: !0
                    }), this.dropdown.element.addEventListener("mouseover", this._onMouseOver, {
                      passive: !0
                    }), this._isSelectOneElement && (this.containerOuter.element.addEventListener("focus", this._onFocus, {
                      passive: !0
                    }), this.containerOuter.element.addEventListener("blur", this._onBlur, {
                      passive: !0
                    })), this.input.element.addEventListener("keyup", this._onKeyUp, {
                      passive: !0
                    }), this.input.element.addEventListener("focus", this._onFocus, {
                      passive: !0
                    }), this.input.element.addEventListener("blur", this._onBlur, {
                      passive: !0
                    }), this.input.element.form && this.input.element.form.addEventListener("reset", this._onFormReset, {
                      passive: !0
                    }), this.input.addEventListeners();
                  }, E.prototype._removeEventListeners = function() {
                    var A = document.documentElement;
                    A.removeEventListener("touchend", this._onTouchEnd, !0), this.containerOuter.element.removeEventListener("keydown", this._onKeyDown, !0), this.containerOuter.element.removeEventListener("mousedown", this._onMouseDown, !0), A.removeEventListener("click", this._onClick), A.removeEventListener("touchmove", this._onTouchMove), this.dropdown.element.removeEventListener("mouseover", this._onMouseOver), this._isSelectOneElement && (this.containerOuter.element.removeEventListener("focus", this._onFocus), this.containerOuter.element.removeEventListener("blur", this._onBlur)), this.input.element.removeEventListener("keyup", this._onKeyUp), this.input.element.removeEventListener("focus", this._onFocus), this.input.element.removeEventListener("blur", this._onBlur), this.input.element.form && this.input.element.form.removeEventListener("reset", this._onFormReset), this.input.removeEventListeners();
                  }, E.prototype._onKeyDown = function(A) {
                    var y = A.keyCode, w = this._store.activeItems, T = this.input.isFocussed, P = this.dropdown.isActive, R = this.itemList.hasChildren(), Q = String.fromCharCode(y), z = /[^\x00-\x1F]/.test(Q), W = b.KEY_CODES.BACK_KEY, G = b.KEY_CODES.DELETE_KEY, de = b.KEY_CODES.ENTER_KEY, xe = b.KEY_CODES.A_KEY, ie = b.KEY_CODES.ESC_KEY, fe = b.KEY_CODES.UP_KEY, $e = b.KEY_CODES.DOWN_KEY, Me = b.KEY_CODES.PAGE_UP_KEY, Ie = b.KEY_CODES.PAGE_DOWN_KEY;
                    switch (!this._isTextElement && !P && z && (this.showDropdown(), this.input.isFocussed || (this.input.value += A.key.toLowerCase())), y) {
                      case xe:
                        return this._onSelectKey(A, R);
                      case de:
                        return this._onEnterKey(A, w, P);
                      case ie:
                        return this._onEscapeKey(P);
                      case fe:
                      case Me:
                      case $e:
                      case Ie:
                        return this._onDirectionKey(A, P);
                      case G:
                      case W:
                        return this._onDeleteKey(A, w, T);
                    }
                  }, E.prototype._onKeyUp = function(A) {
                    var y = A.target, w = A.keyCode, T = this.input.value, P = this._store.activeItems, R = this._canAddItem(P, T), Q = b.KEY_CODES.BACK_KEY, z = b.KEY_CODES.DELETE_KEY;
                    if (this._isTextElement) {
                      var W = R.notice && T;
                      if (W) {
                        var G = this._getTemplate("notice", R.notice);
                        this.dropdown.element.innerHTML = G.outerHTML, this.showDropdown(!0);
                      } else
                        this.hideDropdown(!0);
                    } else {
                      var de = w === Q || w === z, xe = de && y && !y.value, ie = !this._isTextElement && this._isSearching, fe = this._canSearch && R.response;
                      xe && ie ? (this._isSearching = !1, this._store.dispatch((0, v.activateChoices)(!0))) : fe && this._handleSearch(this.input.rawValue);
                    }
                    this._canSearch = this.config.searchEnabled;
                  }, E.prototype._onSelectKey = function(A, y) {
                    var w = A.ctrlKey, T = A.metaKey, P = w || T;
                    if (P && y) {
                      this._canSearch = !1;
                      var R = this.config.removeItems && !this.input.value && this.input.element === document.activeElement;
                      R && this.highlightAll();
                    }
                  }, E.prototype._onEnterKey = function(A, y, w) {
                    var T = A.target, P = b.KEY_CODES.ENTER_KEY, R = T && T.hasAttribute("data-button");
                    if (this._isTextElement && T && T.value) {
                      var Q = this.input.value, z = this._canAddItem(y, Q);
                      z.response && (this.hideDropdown(!0), this._addItem({
                        value: Q
                      }), this._triggerChange(Q), this.clearInput());
                    }
                    if (R && (this._handleButtonAction(y, T), A.preventDefault()), w) {
                      var W = this.dropdown.getChild(".".concat(this.config.classNames.highlightedState));
                      W && (y[0] && (y[0].keyCode = P), this._handleChoiceAction(y, W)), A.preventDefault();
                    } else
                      this._isSelectOneElement && (this.showDropdown(), A.preventDefault());
                  }, E.prototype._onEscapeKey = function(A) {
                    A && (this.hideDropdown(!0), this.containerOuter.focus());
                  }, E.prototype._onDirectionKey = function(A, y) {
                    var w = A.keyCode, T = A.metaKey, P = b.KEY_CODES.DOWN_KEY, R = b.KEY_CODES.PAGE_UP_KEY, Q = b.KEY_CODES.PAGE_DOWN_KEY;
                    if (y || this._isSelectOneElement) {
                      this.showDropdown(), this._canSearch = !1;
                      var z = w === P || w === Q ? 1 : -1, W = T || w === Q || w === R, G = "[data-choice-selectable]", de = void 0;
                      if (W)
                        z > 0 ? de = this.dropdown.element.querySelector("".concat(G, ":last-of-type")) : de = this.dropdown.element.querySelector(G);
                      else {
                        var xe = this.dropdown.element.querySelector(".".concat(this.config.classNames.highlightedState));
                        xe ? de = (0, x.getAdjacentEl)(xe, G, z) : de = this.dropdown.element.querySelector(G);
                      }
                      de && ((0, x.isScrolledIntoView)(de, this.choiceList.element, z) || this.choiceList.scrollToChildElement(de, z), this._highlightChoice(de)), A.preventDefault();
                    }
                  }, E.prototype._onDeleteKey = function(A, y, w) {
                    var T = A.target;
                    !this._isSelectOneElement && !T.value && w && (this._handleBackspace(y), A.preventDefault());
                  }, E.prototype._onTouchMove = function() {
                    this._wasTap && (this._wasTap = !1);
                  }, E.prototype._onTouchEnd = function(A) {
                    var y = (A || A.touches[0]).target, w = this._wasTap && this.containerOuter.element.contains(y);
                    if (w) {
                      var T = y === this.containerOuter.element || y === this.containerInner.element;
                      T && (this._isTextElement ? this.input.focus() : this._isSelectMultipleElement && this.showDropdown()), A.stopPropagation();
                    }
                    this._wasTap = !0;
                  }, E.prototype._onMouseDown = function(A) {
                    var y = A.target;
                    if (y instanceof HTMLElement) {
                      if (_ && this.choiceList.element.contains(y)) {
                        var w = this.choiceList.element.firstElementChild, T = this._direction === "ltr" ? A.offsetX >= w.offsetWidth : A.offsetX < w.offsetLeft;
                        this._isScrollingOnIe = T;
                      }
                      if (y !== this.input.element) {
                        var P = y.closest("[data-button],[data-item],[data-choice]");
                        if (P instanceof HTMLElement) {
                          var R = A.shiftKey, Q = this._store.activeItems, z = P.dataset;
                          "button" in z ? this._handleButtonAction(Q, P) : "item" in z ? this._handleItemAction(Q, P, R) : "choice" in z && this._handleChoiceAction(Q, P);
                        }
                        A.preventDefault();
                      }
                    }
                  }, E.prototype._onMouseOver = function(A) {
                    var y = A.target;
                    y instanceof HTMLElement && "choice" in y.dataset && this._highlightChoice(y);
                  }, E.prototype._onClick = function(A) {
                    var y = A.target, w = this.containerOuter.element.contains(y);
                    if (w)
                      !this.dropdown.isActive && !this.containerOuter.isDisabled ? this._isTextElement ? document.activeElement !== this.input.element && this.input.focus() : (this.showDropdown(), this.containerOuter.focus()) : this._isSelectOneElement && y !== this.input.element && !this.dropdown.element.contains(y) && this.hideDropdown();
                    else {
                      var T = this._store.highlightedActiveItems.length > 0;
                      T && this.unhighlightAll(), this.containerOuter.removeFocusState(), this.hideDropdown(!0);
                    }
                  }, E.prototype._onFocus = function(A) {
                    var y, w = this, T = A.target, P = T && this.containerOuter.element.contains(T);
                    if (P) {
                      var R = (y = {}, y[b.TEXT_TYPE] = function() {
                        T === w.input.element && w.containerOuter.addFocusState();
                      }, y[b.SELECT_ONE_TYPE] = function() {
                        w.containerOuter.addFocusState(), T === w.input.element && w.showDropdown(!0);
                      }, y[b.SELECT_MULTIPLE_TYPE] = function() {
                        T === w.input.element && (w.showDropdown(!0), w.containerOuter.addFocusState());
                      }, y);
                      R[this.passedElement.element.type]();
                    }
                  }, E.prototype._onBlur = function(A) {
                    var y, w = this, T = A.target, P = T && this.containerOuter.element.contains(T);
                    if (P && !this._isScrollingOnIe) {
                      var R = this._store.activeItems, Q = R.some(function(W) {
                        return W.highlighted;
                      }), z = (y = {}, y[b.TEXT_TYPE] = function() {
                        T === w.input.element && (w.containerOuter.removeFocusState(), Q && w.unhighlightAll(), w.hideDropdown(!0));
                      }, y[b.SELECT_ONE_TYPE] = function() {
                        w.containerOuter.removeFocusState(), (T === w.input.element || T === w.containerOuter.element && !w._canSearch) && w.hideDropdown(!0);
                      }, y[b.SELECT_MULTIPLE_TYPE] = function() {
                        T === w.input.element && (w.containerOuter.removeFocusState(), w.hideDropdown(!0), Q && w.unhighlightAll());
                      }, y);
                      z[this.passedElement.element.type]();
                    } else
                      this._isScrollingOnIe = !1, this.input.element.focus();
                  }, E.prototype._onFormReset = function() {
                    this._store.dispatch((0, u.resetTo)(this._initialState));
                  }, E.prototype._highlightChoice = function(A) {
                    var y = this;
                    A === void 0 && (A = null);
                    var w = Array.from(this.dropdown.element.querySelectorAll("[data-choice-selectable]"));
                    if (w.length) {
                      var T = A, P = Array.from(this.dropdown.element.querySelectorAll(".".concat(this.config.classNames.highlightedState)));
                      P.forEach(function(R) {
                        R.classList.remove(y.config.classNames.highlightedState), R.setAttribute("aria-selected", "false");
                      }), T ? this._highlightPosition = w.indexOf(T) : (w.length > this._highlightPosition ? T = w[this._highlightPosition] : T = w[w.length - 1], T || (T = w[0])), T.classList.add(this.config.classNames.highlightedState), T.setAttribute("aria-selected", "true"), this.passedElement.triggerEvent(b.EVENTS.highlightChoice, {
                        el: T
                      }), this.dropdown.isActive && (this.input.setActiveDescendant(T.id), this.containerOuter.setActiveDescendant(T.id));
                    }
                  }, E.prototype._addItem = function(A) {
                    var y = A.value, w = A.label, T = w === void 0 ? null : w, P = A.choiceId, R = P === void 0 ? -1 : P, Q = A.groupId, z = Q === void 0 ? -1 : Q, W = A.customProperties, G = W === void 0 ? {} : W, de = A.placeholder, xe = de === void 0 ? !1 : de, ie = A.keyCode, fe = ie === void 0 ? -1 : ie, $e = typeof y == "string" ? y.trim() : y, Me = this._store.items, Ie = T || $e, ot = R || -1, Ge = z >= 0 ? this._store.getGroupById(z) : null, qt = Me ? Me.length + 1 : 1;
                    this.config.prependValue && ($e = this.config.prependValue + $e.toString()), this.config.appendValue && ($e += this.config.appendValue.toString()), this._store.dispatch((0, h.addItem)({
                      value: $e,
                      label: Ie,
                      id: qt,
                      choiceId: ot,
                      groupId: z,
                      customProperties: G,
                      placeholder: xe,
                      keyCode: fe
                    })), this._isSelectOneElement && this.removeActiveItems(qt), this.passedElement.triggerEvent(b.EVENTS.addItem, {
                      id: qt,
                      value: $e,
                      label: Ie,
                      customProperties: G,
                      groupValue: Ge && Ge.value ? Ge.value : null,
                      keyCode: fe
                    });
                  }, E.prototype._removeItem = function(A) {
                    var y = A.id, w = A.value, T = A.label, P = A.customProperties, R = A.choiceId, Q = A.groupId, z = Q && Q >= 0 ? this._store.getGroupById(Q) : null;
                    !y || !R || (this._store.dispatch((0, h.removeItem)(y, R)), this.passedElement.triggerEvent(b.EVENTS.removeItem, {
                      id: y,
                      value: w,
                      label: T,
                      customProperties: P,
                      groupValue: z && z.value ? z.value : null
                    }));
                  }, E.prototype._addChoice = function(A) {
                    var y = A.value, w = A.label, T = w === void 0 ? null : w, P = A.isSelected, R = P === void 0 ? !1 : P, Q = A.isDisabled, z = Q === void 0 ? !1 : Q, W = A.groupId, G = W === void 0 ? -1 : W, de = A.customProperties, xe = de === void 0 ? {} : de, ie = A.placeholder, fe = ie === void 0 ? !1 : ie, $e = A.keyCode, Me = $e === void 0 ? -1 : $e;
                    if (!(typeof y > "u" || y === null)) {
                      var Ie = this._store.choices, ot = T || y, Ge = Ie ? Ie.length + 1 : 1, qt = "".concat(this._baseId, "-").concat(this._idNames.itemChoice, "-").concat(Ge);
                      this._store.dispatch((0, v.addChoice)({
                        id: Ge,
                        groupId: G,
                        elementId: qt,
                        value: y,
                        label: ot,
                        disabled: z,
                        customProperties: xe,
                        placeholder: fe,
                        keyCode: Me
                      })), R && this._addItem({
                        value: y,
                        label: ot,
                        choiceId: Ge,
                        customProperties: xe,
                        placeholder: fe,
                        keyCode: Me
                      });
                    }
                  }, E.prototype._addGroup = function(A) {
                    var y = this, w = A.group, T = A.id, P = A.valueKey, R = P === void 0 ? "value" : P, Q = A.labelKey, z = Q === void 0 ? "label" : Q, W = (0, x.isType)("Object", w) ? w.choices : Array.from(w.getElementsByTagName("OPTION")), G = T || Math.floor((/* @__PURE__ */ new Date()).valueOf() * Math.random()), de = w.disabled ? w.disabled : !1;
                    if (W) {
                      this._store.dispatch((0, r.addGroup)({
                        value: w.label,
                        id: G,
                        active: !0,
                        disabled: de
                      }));
                      var xe = function(ie) {
                        var fe = ie.disabled || ie.parentNode && ie.parentNode.disabled;
                        y._addChoice({
                          value: ie[R],
                          label: (0, x.isType)("Object", ie) ? ie[z] : ie.innerHTML,
                          isSelected: ie.selected,
                          isDisabled: fe,
                          groupId: G,
                          customProperties: ie.customProperties,
                          placeholder: ie.placeholder
                        });
                      };
                      W.forEach(xe);
                    } else
                      this._store.dispatch((0, r.addGroup)({
                        value: w.label,
                        id: w.id,
                        active: !1,
                        disabled: w.disabled
                      }));
                  }, E.prototype._getTemplate = function(A) {
                    for (var y, w = [], T = 1; T < arguments.length; T++)
                      w[T - 1] = arguments[T];
                    return (y = this._templates[A]).call.apply(y, d([this, this.config], w, !1));
                  }, E.prototype._createTemplates = function() {
                    var A = this.config.callbackOnCreateTemplates, y = {};
                    A && typeof A == "function" && (y = A.call(this, x.strToEl)), this._templates = (0, p.default)(C.default, y);
                  }, E.prototype._createElements = function() {
                    this.containerOuter = new g.Container({
                      element: this._getTemplate("containerOuter", this._direction, this._isSelectElement, this._isSelectOneElement, this.config.searchEnabled, this.passedElement.element.type, this.config.labelId),
                      classNames: this.config.classNames,
                      type: this.passedElement.element.type,
                      position: this.config.position
                    }), this.containerInner = new g.Container({
                      element: this._getTemplate("containerInner"),
                      classNames: this.config.classNames,
                      type: this.passedElement.element.type,
                      position: this.config.position
                    }), this.input = new g.Input({
                      element: this._getTemplate("input", this._placeholderValue),
                      classNames: this.config.classNames,
                      type: this.passedElement.element.type,
                      preventPaste: !this.config.paste
                    }), this.choiceList = new g.List({
                      element: this._getTemplate("choiceList", this._isSelectOneElement)
                    }), this.itemList = new g.List({
                      element: this._getTemplate("itemList", this._isSelectOneElement)
                    }), this.dropdown = new g.Dropdown({
                      element: this._getTemplate("dropdown"),
                      classNames: this.config.classNames,
                      type: this.passedElement.element.type
                    });
                  }, E.prototype._createStructure = function() {
                    this.passedElement.conceal(), this.containerInner.wrap(this.passedElement.element), this.containerOuter.wrap(this.containerInner.element), this._isSelectOneElement ? this.input.placeholder = this.config.searchPlaceholderValue || "" : this._placeholderValue && (this.input.placeholder = this._placeholderValue, this.input.setWidth()), this.containerOuter.element.appendChild(this.containerInner.element), this.containerOuter.element.appendChild(this.dropdown.element), this.containerInner.element.appendChild(this.itemList.element), this._isTextElement || this.dropdown.element.appendChild(this.choiceList.element), this._isSelectOneElement ? this.config.searchEnabled && this.dropdown.element.insertBefore(this.input.element, this.dropdown.element.firstChild) : this.containerInner.element.appendChild(this.input.element), this._isSelectElement && (this._highlightPosition = 0, this._isSearching = !1, this._startLoading(), this._presetGroups.length ? this._addPredefinedGroups(this._presetGroups) : this._addPredefinedChoices(this._presetChoices), this._stopLoading()), this._isTextElement && this._addPredefinedItems(this._presetItems);
                  }, E.prototype._addPredefinedGroups = function(A) {
                    var y = this, w = this.passedElement.placeholderOption;
                    w && w.parentNode && w.parentNode.tagName === "SELECT" && this._addChoice({
                      value: w.value,
                      label: w.innerHTML,
                      isSelected: w.selected,
                      isDisabled: w.disabled,
                      placeholder: !0
                    }), A.forEach(function(T) {
                      return y._addGroup({
                        group: T,
                        id: T.id || null
                      });
                    });
                  }, E.prototype._addPredefinedChoices = function(A) {
                    var y = this;
                    this.config.shouldSort && A.sort(this.config.sorter);
                    var w = A.some(function(P) {
                      return P.selected;
                    }), T = A.findIndex(function(P) {
                      return P.disabled === void 0 || !P.disabled;
                    });
                    A.forEach(function(P, R) {
                      var Q = P.value, z = Q === void 0 ? "" : Q, W = P.label, G = P.customProperties, de = P.placeholder;
                      if (y._isSelectElement)
                        if (P.choices)
                          y._addGroup({
                            group: P,
                            id: P.id || null
                          });
                        else {
                          var xe = y._isSelectOneElement && !w && R === T, ie = xe ? !0 : P.selected, fe = P.disabled;
                          y._addChoice({
                            value: z,
                            label: W,
                            isSelected: !!ie,
                            isDisabled: !!fe,
                            placeholder: !!de,
                            customProperties: G
                          });
                        }
                      else
                        y._addChoice({
                          value: z,
                          label: W,
                          isSelected: !!P.selected,
                          isDisabled: !!P.disabled,
                          placeholder: !!P.placeholder,
                          customProperties: G
                        });
                    });
                  }, E.prototype._addPredefinedItems = function(A) {
                    var y = this;
                    A.forEach(function(w) {
                      typeof w == "object" && w.value && y._addItem({
                        value: w.value,
                        label: w.label,
                        choiceId: w.id,
                        customProperties: w.customProperties,
                        placeholder: w.placeholder
                      }), typeof w == "string" && y._addItem({
                        value: w
                      });
                    });
                  }, E.prototype._setChoiceOrItem = function(A) {
                    var y = this, w = (0, x.getType)(A).toLowerCase(), T = {
                      object: function() {
                        A.value && (y._isTextElement ? y._addItem({
                          value: A.value,
                          label: A.label,
                          choiceId: A.id,
                          customProperties: A.customProperties,
                          placeholder: A.placeholder
                        }) : y._addChoice({
                          value: A.value,
                          label: A.label,
                          isSelected: !0,
                          isDisabled: !1,
                          customProperties: A.customProperties,
                          placeholder: A.placeholder
                        }));
                      },
                      string: function() {
                        y._isTextElement ? y._addItem({
                          value: A
                        }) : y._addChoice({
                          value: A,
                          label: A,
                          isSelected: !0,
                          isDisabled: !1
                        });
                      }
                    };
                    T[w]();
                  }, E.prototype._findAndSelectChoiceByValue = function(A) {
                    var y = this, w = this._store.choices, T = w.find(function(P) {
                      return y.config.valueComparer(P.value, A);
                    });
                    T && !T.selected && this._addItem({
                      value: T.value,
                      label: T.label,
                      choiceId: T.id,
                      groupId: T.groupId,
                      customProperties: T.customProperties,
                      placeholder: T.placeholder,
                      keyCode: T.keyCode
                    });
                  }, E.prototype._generatePlaceholderValue = function() {
                    if (this._isSelectElement && this.passedElement.placeholderOption) {
                      var A = this.passedElement.placeholderOption;
                      return A ? A.text : null;
                    }
                    var y = this.config, w = y.placeholder, T = y.placeholderValue, P = this.passedElement.element.dataset;
                    if (w) {
                      if (T)
                        return T;
                      if (P.placeholder)
                        return P.placeholder;
                    }
                    return null;
                  }, E;
                }()
              );
              l.default = L;
            }
          ),
          /***/
          613: (
            /***/
            function(o, l, c) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
              var d = c(799), f = c(883), p = (
                /** @class */
                function() {
                  function m(v) {
                    var r = v.element, h = v.type, u = v.classNames, g = v.position;
                    this.element = r, this.classNames = u, this.type = h, this.position = g, this.isOpen = !1, this.isFlipped = !1, this.isFocussed = !1, this.isDisabled = !1, this.isLoading = !1, this._onFocus = this._onFocus.bind(this), this._onBlur = this._onBlur.bind(this);
                  }
                  return m.prototype.addEventListeners = function() {
                    this.element.addEventListener("focus", this._onFocus), this.element.addEventListener("blur", this._onBlur);
                  }, m.prototype.removeEventListeners = function() {
                    this.element.removeEventListener("focus", this._onFocus), this.element.removeEventListener("blur", this._onBlur);
                  }, m.prototype.shouldFlip = function(v) {
                    if (typeof v != "number")
                      return !1;
                    var r = !1;
                    return this.position === "auto" ? r = !window.matchMedia("(min-height: ".concat(v + 1, "px)")).matches : this.position === "top" && (r = !0), r;
                  }, m.prototype.setActiveDescendant = function(v) {
                    this.element.setAttribute("aria-activedescendant", v);
                  }, m.prototype.removeActiveDescendant = function() {
                    this.element.removeAttribute("aria-activedescendant");
                  }, m.prototype.open = function(v) {
                    this.element.classList.add(this.classNames.openState), this.element.setAttribute("aria-expanded", "true"), this.isOpen = !0, this.shouldFlip(v) && (this.element.classList.add(this.classNames.flippedState), this.isFlipped = !0);
                  }, m.prototype.close = function() {
                    this.element.classList.remove(this.classNames.openState), this.element.setAttribute("aria-expanded", "false"), this.removeActiveDescendant(), this.isOpen = !1, this.isFlipped && (this.element.classList.remove(this.classNames.flippedState), this.isFlipped = !1);
                  }, m.prototype.focus = function() {
                    this.isFocussed || this.element.focus();
                  }, m.prototype.addFocusState = function() {
                    this.element.classList.add(this.classNames.focusState);
                  }, m.prototype.removeFocusState = function() {
                    this.element.classList.remove(this.classNames.focusState);
                  }, m.prototype.enable = function() {
                    this.element.classList.remove(this.classNames.disabledState), this.element.removeAttribute("aria-disabled"), this.type === f.SELECT_ONE_TYPE && this.element.setAttribute("tabindex", "0"), this.isDisabled = !1;
                  }, m.prototype.disable = function() {
                    this.element.classList.add(this.classNames.disabledState), this.element.setAttribute("aria-disabled", "true"), this.type === f.SELECT_ONE_TYPE && this.element.setAttribute("tabindex", "-1"), this.isDisabled = !0;
                  }, m.prototype.wrap = function(v) {
                    (0, d.wrap)(v, this.element);
                  }, m.prototype.unwrap = function(v) {
                    this.element.parentNode && (this.element.parentNode.insertBefore(v, this.element), this.element.parentNode.removeChild(this.element));
                  }, m.prototype.addLoadingState = function() {
                    this.element.classList.add(this.classNames.loadingState), this.element.setAttribute("aria-busy", "true"), this.isLoading = !0;
                  }, m.prototype.removeLoadingState = function() {
                    this.element.classList.remove(this.classNames.loadingState), this.element.removeAttribute("aria-busy"), this.isLoading = !1;
                  }, m.prototype._onFocus = function() {
                    this.isFocussed = !0;
                  }, m.prototype._onBlur = function() {
                    this.isFocussed = !1;
                  }, m;
                }()
              );
              l.default = p;
            }
          ),
          /***/
          217: (
            /***/
            function(o, l) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
              var c = (
                /** @class */
                function() {
                  function d(f) {
                    var p = f.element, m = f.type, v = f.classNames;
                    this.element = p, this.classNames = v, this.type = m, this.isActive = !1;
                  }
                  return Object.defineProperty(d.prototype, "distanceFromTopWindow", {
                    /**
                     * Bottom position of dropdown in viewport coordinates
                     */
                    get: function() {
                      return this.element.getBoundingClientRect().bottom;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), d.prototype.getChild = function(f) {
                    return this.element.querySelector(f);
                  }, d.prototype.show = function() {
                    return this.element.classList.add(this.classNames.activeState), this.element.setAttribute("aria-expanded", "true"), this.isActive = !0, this;
                  }, d.prototype.hide = function() {
                    return this.element.classList.remove(this.classNames.activeState), this.element.setAttribute("aria-expanded", "false"), this.isActive = !1, this;
                  }, d;
                }()
              );
              l.default = c;
            }
          ),
          /***/
          520: (
            /***/
            function(o, l, c) {
              var d = this && this.__importDefault || function(u) {
                return u && u.__esModule ? u : {
                  default: u
                };
              };
              Object.defineProperty(l, "__esModule", {
                value: !0
              }), l.WrappedSelect = l.WrappedInput = l.List = l.Input = l.Container = l.Dropdown = void 0;
              var f = d(c(217));
              l.Dropdown = f.default;
              var p = d(c(613));
              l.Container = p.default;
              var m = d(c(11));
              l.Input = m.default;
              var v = d(c(624));
              l.List = v.default;
              var r = d(c(541));
              l.WrappedInput = r.default;
              var h = d(c(982));
              l.WrappedSelect = h.default;
            }
          ),
          /***/
          11: (
            /***/
            function(o, l, c) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
              var d = c(799), f = c(883), p = (
                /** @class */
                function() {
                  function m(v) {
                    var r = v.element, h = v.type, u = v.classNames, g = v.preventPaste;
                    this.element = r, this.type = h, this.classNames = u, this.preventPaste = g, this.isFocussed = this.element.isEqualNode(document.activeElement), this.isDisabled = r.disabled, this._onPaste = this._onPaste.bind(this), this._onInput = this._onInput.bind(this), this._onFocus = this._onFocus.bind(this), this._onBlur = this._onBlur.bind(this);
                  }
                  return Object.defineProperty(m.prototype, "placeholder", {
                    set: function(v) {
                      this.element.placeholder = v;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(m.prototype, "value", {
                    get: function() {
                      return (0, d.sanitise)(this.element.value);
                    },
                    set: function(v) {
                      this.element.value = v;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(m.prototype, "rawValue", {
                    get: function() {
                      return this.element.value;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), m.prototype.addEventListeners = function() {
                    this.element.addEventListener("paste", this._onPaste), this.element.addEventListener("input", this._onInput, {
                      passive: !0
                    }), this.element.addEventListener("focus", this._onFocus, {
                      passive: !0
                    }), this.element.addEventListener("blur", this._onBlur, {
                      passive: !0
                    });
                  }, m.prototype.removeEventListeners = function() {
                    this.element.removeEventListener("input", this._onInput), this.element.removeEventListener("paste", this._onPaste), this.element.removeEventListener("focus", this._onFocus), this.element.removeEventListener("blur", this._onBlur);
                  }, m.prototype.enable = function() {
                    this.element.removeAttribute("disabled"), this.isDisabled = !1;
                  }, m.prototype.disable = function() {
                    this.element.setAttribute("disabled", ""), this.isDisabled = !0;
                  }, m.prototype.focus = function() {
                    this.isFocussed || this.element.focus();
                  }, m.prototype.blur = function() {
                    this.isFocussed && this.element.blur();
                  }, m.prototype.clear = function(v) {
                    return v === void 0 && (v = !0), this.element.value && (this.element.value = ""), v && this.setWidth(), this;
                  }, m.prototype.setWidth = function() {
                    var v = this.element, r = v.style, h = v.value, u = v.placeholder;
                    r.minWidth = "".concat(u.length + 1, "ch"), r.width = "".concat(h.length + 1, "ch");
                  }, m.prototype.setActiveDescendant = function(v) {
                    this.element.setAttribute("aria-activedescendant", v);
                  }, m.prototype.removeActiveDescendant = function() {
                    this.element.removeAttribute("aria-activedescendant");
                  }, m.prototype._onInput = function() {
                    this.type !== f.SELECT_ONE_TYPE && this.setWidth();
                  }, m.prototype._onPaste = function(v) {
                    this.preventPaste && v.preventDefault();
                  }, m.prototype._onFocus = function() {
                    this.isFocussed = !0;
                  }, m.prototype._onBlur = function() {
                    this.isFocussed = !1;
                  }, m;
                }()
              );
              l.default = p;
            }
          ),
          /***/
          624: (
            /***/
            function(o, l, c) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
              var d = c(883), f = (
                /** @class */
                function() {
                  function p(m) {
                    var v = m.element;
                    this.element = v, this.scrollPos = this.element.scrollTop, this.height = this.element.offsetHeight;
                  }
                  return p.prototype.clear = function() {
                    this.element.innerHTML = "";
                  }, p.prototype.append = function(m) {
                    this.element.appendChild(m);
                  }, p.prototype.getChild = function(m) {
                    return this.element.querySelector(m);
                  }, p.prototype.hasChildren = function() {
                    return this.element.hasChildNodes();
                  }, p.prototype.scrollToTop = function() {
                    this.element.scrollTop = 0;
                  }, p.prototype.scrollToChildElement = function(m, v) {
                    var r = this;
                    if (m) {
                      var h = this.element.offsetHeight, u = this.element.scrollTop + h, g = m.offsetHeight, b = m.offsetTop + g, O = v > 0 ? this.element.scrollTop + b - u : m.offsetTop;
                      requestAnimationFrame(function() {
                        r._animateScroll(O, v);
                      });
                    }
                  }, p.prototype._scrollDown = function(m, v, r) {
                    var h = (r - m) / v, u = h > 1 ? h : 1;
                    this.element.scrollTop = m + u;
                  }, p.prototype._scrollUp = function(m, v, r) {
                    var h = (m - r) / v, u = h > 1 ? h : 1;
                    this.element.scrollTop = m - u;
                  }, p.prototype._animateScroll = function(m, v) {
                    var r = this, h = d.SCROLLING_SPEED, u = this.element.scrollTop, g = !1;
                    v > 0 ? (this._scrollDown(u, h, m), u < m && (g = !0)) : (this._scrollUp(u, h, m), u > m && (g = !0)), g && requestAnimationFrame(function() {
                      r._animateScroll(m, v);
                    });
                  }, p;
                }()
              );
              l.default = f;
            }
          ),
          /***/
          730: (
            /***/
            function(o, l, c) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
              var d = c(799), f = (
                /** @class */
                function() {
                  function p(m) {
                    var v = m.element, r = m.classNames;
                    if (this.element = v, this.classNames = r, !(v instanceof HTMLInputElement) && !(v instanceof HTMLSelectElement))
                      throw new TypeError("Invalid element passed");
                    this.isDisabled = !1;
                  }
                  return Object.defineProperty(p.prototype, "isActive", {
                    get: function() {
                      return this.element.dataset.choice === "active";
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(p.prototype, "dir", {
                    get: function() {
                      return this.element.dir;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(p.prototype, "value", {
                    get: function() {
                      return this.element.value;
                    },
                    set: function(m) {
                      this.element.value = m;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), p.prototype.conceal = function() {
                    this.element.classList.add(this.classNames.input), this.element.hidden = !0, this.element.tabIndex = -1;
                    var m = this.element.getAttribute("style");
                    m && this.element.setAttribute("data-choice-orig-style", m), this.element.setAttribute("data-choice", "active");
                  }, p.prototype.reveal = function() {
                    this.element.classList.remove(this.classNames.input), this.element.hidden = !1, this.element.removeAttribute("tabindex");
                    var m = this.element.getAttribute("data-choice-orig-style");
                    m ? (this.element.removeAttribute("data-choice-orig-style"), this.element.setAttribute("style", m)) : this.element.removeAttribute("style"), this.element.removeAttribute("data-choice"), this.element.value = this.element.value;
                  }, p.prototype.enable = function() {
                    this.element.removeAttribute("disabled"), this.element.disabled = !1, this.isDisabled = !1;
                  }, p.prototype.disable = function() {
                    this.element.setAttribute("disabled", ""), this.element.disabled = !0, this.isDisabled = !0;
                  }, p.prototype.triggerEvent = function(m, v) {
                    (0, d.dispatchEvent)(this.element, m, v);
                  }, p;
                }()
              );
              l.default = f;
            }
          ),
          /***/
          541: (
            /***/
            function(o, l, c) {
              var d = this && this.__extends || function() {
                var v = function(r, h) {
                  return v = Object.setPrototypeOf || {
                    __proto__: []
                  } instanceof Array && function(u, g) {
                    u.__proto__ = g;
                  } || function(u, g) {
                    for (var b in g)
                      Object.prototype.hasOwnProperty.call(g, b) && (u[b] = g[b]);
                  }, v(r, h);
                };
                return function(r, h) {
                  if (typeof h != "function" && h !== null)
                    throw new TypeError("Class extends value " + String(h) + " is not a constructor or null");
                  v(r, h);
                  function u() {
                    this.constructor = r;
                  }
                  r.prototype = h === null ? Object.create(h) : (u.prototype = h.prototype, new u());
                };
              }(), f = this && this.__importDefault || function(v) {
                return v && v.__esModule ? v : {
                  default: v
                };
              };
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
              var p = f(c(730)), m = (
                /** @class */
                function(v) {
                  d(r, v);
                  function r(h) {
                    var u = h.element, g = h.classNames, b = h.delimiter, O = v.call(this, {
                      element: u,
                      classNames: g
                    }) || this;
                    return O.delimiter = b, O;
                  }
                  return Object.defineProperty(r.prototype, "value", {
                    get: function() {
                      return this.element.value;
                    },
                    set: function(h) {
                      this.element.setAttribute("value", h), this.element.value = h;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), r;
                }(p.default)
              );
              l.default = m;
            }
          ),
          /***/
          982: (
            /***/
            function(o, l, c) {
              var d = this && this.__extends || function() {
                var v = function(r, h) {
                  return v = Object.setPrototypeOf || {
                    __proto__: []
                  } instanceof Array && function(u, g) {
                    u.__proto__ = g;
                  } || function(u, g) {
                    for (var b in g)
                      Object.prototype.hasOwnProperty.call(g, b) && (u[b] = g[b]);
                  }, v(r, h);
                };
                return function(r, h) {
                  if (typeof h != "function" && h !== null)
                    throw new TypeError("Class extends value " + String(h) + " is not a constructor or null");
                  v(r, h);
                  function u() {
                    this.constructor = r;
                  }
                  r.prototype = h === null ? Object.create(h) : (u.prototype = h.prototype, new u());
                };
              }(), f = this && this.__importDefault || function(v) {
                return v && v.__esModule ? v : {
                  default: v
                };
              };
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
              var p = f(c(730)), m = (
                /** @class */
                function(v) {
                  d(r, v);
                  function r(h) {
                    var u = h.element, g = h.classNames, b = h.template, O = v.call(this, {
                      element: u,
                      classNames: g
                    }) || this;
                    return O.template = b, O;
                  }
                  return Object.defineProperty(r.prototype, "placeholderOption", {
                    get: function() {
                      return this.element.querySelector('option[value=""]') || // Backward compatibility layer for the non-standard placeholder attribute supported in older versions.
                      this.element.querySelector("option[placeholder]");
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(r.prototype, "optionGroups", {
                    get: function() {
                      return Array.from(this.element.getElementsByTagName("OPTGROUP"));
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(r.prototype, "options", {
                    get: function() {
                      return Array.from(this.element.options);
                    },
                    set: function(h) {
                      var u = this, g = document.createDocumentFragment(), b = function(O) {
                        var x = u.template(O);
                        g.appendChild(x);
                      };
                      h.forEach(function(O) {
                        return b(O);
                      }), this.appendDocFragment(g);
                    },
                    enumerable: !1,
                    configurable: !0
                  }), r.prototype.appendDocFragment = function(h) {
                    this.element.innerHTML = "", this.element.appendChild(h);
                  }, r;
                }(p.default)
              );
              l.default = m;
            }
          ),
          /***/
          883: (
            /***/
            function(o, l) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              }), l.SCROLLING_SPEED = l.SELECT_MULTIPLE_TYPE = l.SELECT_ONE_TYPE = l.TEXT_TYPE = l.KEY_CODES = l.ACTION_TYPES = l.EVENTS = void 0, l.EVENTS = {
                showDropdown: "showDropdown",
                hideDropdown: "hideDropdown",
                change: "change",
                choice: "choice",
                search: "search",
                addItem: "addItem",
                removeItem: "removeItem",
                highlightItem: "highlightItem",
                highlightChoice: "highlightChoice",
                unhighlightItem: "unhighlightItem"
              }, l.ACTION_TYPES = {
                ADD_CHOICE: "ADD_CHOICE",
                FILTER_CHOICES: "FILTER_CHOICES",
                ACTIVATE_CHOICES: "ACTIVATE_CHOICES",
                CLEAR_CHOICES: "CLEAR_CHOICES",
                ADD_GROUP: "ADD_GROUP",
                ADD_ITEM: "ADD_ITEM",
                REMOVE_ITEM: "REMOVE_ITEM",
                HIGHLIGHT_ITEM: "HIGHLIGHT_ITEM",
                CLEAR_ALL: "CLEAR_ALL",
                RESET_TO: "RESET_TO",
                SET_IS_LOADING: "SET_IS_LOADING"
              }, l.KEY_CODES = {
                BACK_KEY: 46,
                DELETE_KEY: 8,
                ENTER_KEY: 13,
                A_KEY: 65,
                ESC_KEY: 27,
                UP_KEY: 38,
                DOWN_KEY: 40,
                PAGE_UP_KEY: 33,
                PAGE_DOWN_KEY: 34
              }, l.TEXT_TYPE = "text", l.SELECT_ONE_TYPE = "select-one", l.SELECT_MULTIPLE_TYPE = "select-multiple", l.SCROLLING_SPEED = 4;
            }
          ),
          /***/
          789: (
            /***/
            function(o, l, c) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              }), l.DEFAULT_CONFIG = l.DEFAULT_CLASSNAMES = void 0;
              var d = c(799);
              l.DEFAULT_CLASSNAMES = {
                containerOuter: "choices",
                containerInner: "choices__inner",
                input: "choices__input",
                inputCloned: "choices__input--cloned",
                list: "choices__list",
                listItems: "choices__list--multiple",
                listSingle: "choices__list--single",
                listDropdown: "choices__list--dropdown",
                item: "choices__item",
                itemSelectable: "choices__item--selectable",
                itemDisabled: "choices__item--disabled",
                itemChoice: "choices__item--choice",
                placeholder: "choices__placeholder",
                group: "choices__group",
                groupHeading: "choices__heading",
                button: "choices__button",
                activeState: "is-active",
                focusState: "is-focused",
                openState: "is-open",
                disabledState: "is-disabled",
                highlightedState: "is-highlighted",
                selectedState: "is-selected",
                flippedState: "is-flipped",
                loadingState: "is-loading",
                noResults: "has-no-results",
                noChoices: "has-no-choices"
              }, l.DEFAULT_CONFIG = {
                items: [],
                choices: [],
                silent: !1,
                renderChoiceLimit: -1,
                maxItemCount: -1,
                addItems: !0,
                addItemFilter: null,
                removeItems: !0,
                removeItemButton: !1,
                editItems: !1,
                allowHTML: !0,
                duplicateItemsAllowed: !0,
                delimiter: ",",
                paste: !0,
                searchEnabled: !0,
                searchChoices: !0,
                searchFloor: 1,
                searchResultLimit: 4,
                searchFields: ["label", "value"],
                position: "auto",
                resetScrollPosition: !0,
                shouldSort: !0,
                shouldSortItems: !1,
                sorter: d.sortByAlpha,
                placeholder: !0,
                placeholderValue: null,
                searchPlaceholderValue: null,
                prependValue: null,
                appendValue: null,
                renderSelectedChoices: "auto",
                loadingText: "Loading...",
                noResultsText: "No results found",
                noChoicesText: "No choices to choose from",
                itemSelectText: "Press to select",
                uniqueItemText: "Only unique values can be added",
                customAddItemText: "Only values matching specific conditions can be added",
                addItemText: function(f) {
                  return 'Press Enter to add <b>"'.concat((0, d.sanitise)(f), '"</b>');
                },
                maxItemText: function(f) {
                  return "Only ".concat(f, " values can be added");
                },
                valueComparer: function(f, p) {
                  return f === p;
                },
                fuseOptions: {
                  includeScore: !0
                },
                labelId: "",
                callbackOnInit: null,
                callbackOnCreateTemplates: null,
                classNames: l.DEFAULT_CLASSNAMES
              };
            }
          ),
          /***/
          18: (
            /***/
            function(o, l) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
            }
          ),
          /***/
          978: (
            /***/
            function(o, l) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
            }
          ),
          /***/
          948: (
            /***/
            function(o, l) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
            }
          ),
          /***/
          359: (
            /***/
            function(o, l) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
            }
          ),
          /***/
          285: (
            /***/
            function(o, l) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
            }
          ),
          /***/
          533: (
            /***/
            function(o, l) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
            }
          ),
          /***/
          187: (
            /***/
            function(o, l, c) {
              var d = this && this.__createBinding || (Object.create ? function(p, m, v, r) {
                r === void 0 && (r = v);
                var h = Object.getOwnPropertyDescriptor(m, v);
                (!h || ("get" in h ? !m.__esModule : h.writable || h.configurable)) && (h = {
                  enumerable: !0,
                  get: function() {
                    return m[v];
                  }
                }), Object.defineProperty(p, r, h);
              } : function(p, m, v, r) {
                r === void 0 && (r = v), p[r] = m[v];
              }), f = this && this.__exportStar || function(p, m) {
                for (var v in p)
                  v !== "default" && !Object.prototype.hasOwnProperty.call(m, v) && d(m, p, v);
              };
              Object.defineProperty(l, "__esModule", {
                value: !0
              }), f(c(18), l), f(c(978), l), f(c(948), l), f(c(359), l), f(c(285), l), f(c(533), l), f(c(287), l), f(c(132), l), f(c(837), l), f(c(598), l), f(c(369), l), f(c(37), l), f(c(47), l), f(c(923), l), f(c(876), l);
            }
          ),
          /***/
          287: (
            /***/
            function(o, l) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
            }
          ),
          /***/
          132: (
            /***/
            function(o, l) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
            }
          ),
          /***/
          837: (
            /***/
            function(o, l) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
            }
          ),
          /***/
          598: (
            /***/
            function(o, l) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
            }
          ),
          /***/
          37: (
            /***/
            function(o, l) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
            }
          ),
          /***/
          369: (
            /***/
            function(o, l) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
            }
          ),
          /***/
          47: (
            /***/
            function(o, l) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
            }
          ),
          /***/
          923: (
            /***/
            function(o, l) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
            }
          ),
          /***/
          876: (
            /***/
            function(o, l) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
            }
          ),
          /***/
          799: (
            /***/
            function(o, l) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              }), l.parseCustomProperties = l.diff = l.cloneObject = l.existsInArray = l.dispatchEvent = l.sortByScore = l.sortByAlpha = l.strToEl = l.sanitise = l.isScrolledIntoView = l.getAdjacentEl = l.wrap = l.isType = l.getType = l.generateId = l.generateChars = l.getRandomNumber = void 0;
              var c = function(_, $) {
                return Math.floor(Math.random() * ($ - _) + _);
              };
              l.getRandomNumber = c;
              var d = function(_) {
                return Array.from({
                  length: _
                }, function() {
                  return (0, l.getRandomNumber)(0, 36).toString(36);
                }).join("");
              };
              l.generateChars = d;
              var f = function(_, $) {
                var L = _.id || _.name && "".concat(_.name, "-").concat((0, l.generateChars)(2)) || (0, l.generateChars)(4);
                return L = L.replace(/(:|\.|\[|\]|,)/g, ""), L = "".concat($, "-").concat(L), L;
              };
              l.generateId = f;
              var p = function(_) {
                return Object.prototype.toString.call(_).slice(8, -1);
              };
              l.getType = p;
              var m = function(_, $) {
                return $ != null && (0, l.getType)($) === _;
              };
              l.isType = m;
              var v = function(_, $) {
                return $ === void 0 && ($ = document.createElement("div")), _.parentNode && (_.nextSibling ? _.parentNode.insertBefore($, _.nextSibling) : _.parentNode.appendChild($)), $.appendChild(_);
              };
              l.wrap = v;
              var r = function(_, $, L) {
                L === void 0 && (L = 1);
                for (var E = "".concat(L > 0 ? "next" : "previous", "ElementSibling"), A = _[E]; A; ) {
                  if (A.matches($))
                    return A;
                  A = A[E];
                }
                return A;
              };
              l.getAdjacentEl = r;
              var h = function(_, $, L) {
                if (L === void 0 && (L = 1), !_)
                  return !1;
                var E;
                return L > 0 ? E = $.scrollTop + $.offsetHeight >= _.offsetTop + _.offsetHeight : E = _.offsetTop >= $.scrollTop, E;
              };
              l.isScrolledIntoView = h;
              var u = function(_) {
                return typeof _ != "string" ? _ : _.replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;").replace(/"/g, "&quot;");
              };
              l.sanitise = u, l.strToEl = function() {
                var _ = document.createElement("div");
                return function($) {
                  var L = $.trim();
                  _.innerHTML = L;
                  for (var E = _.children[0]; _.firstChild; )
                    _.removeChild(_.firstChild);
                  return E;
                };
              }();
              var g = function(_, $) {
                var L = _.value, E = _.label, A = E === void 0 ? L : E, y = $.value, w = $.label, T = w === void 0 ? y : w;
                return A.localeCompare(T, [], {
                  sensitivity: "base",
                  ignorePunctuation: !0,
                  numeric: !0
                });
              };
              l.sortByAlpha = g;
              var b = function(_, $) {
                var L = _.score, E = L === void 0 ? 0 : L, A = $.score, y = A === void 0 ? 0 : A;
                return E - y;
              };
              l.sortByScore = b;
              var O = function(_, $, L) {
                L === void 0 && (L = null);
                var E = new CustomEvent($, {
                  detail: L,
                  bubbles: !0,
                  cancelable: !0
                });
                return _.dispatchEvent(E);
              };
              l.dispatchEvent = O;
              var x = function(_, $, L) {
                return L === void 0 && (L = "value"), _.some(function(E) {
                  return typeof $ == "string" ? E[L] === $.trim() : E[L] === $;
                });
              };
              l.existsInArray = x;
              var S = function(_) {
                return JSON.parse(JSON.stringify(_));
              };
              l.cloneObject = S;
              var k = function(_, $) {
                var L = Object.keys(_).sort(), E = Object.keys($).sort();
                return L.filter(function(A) {
                  return E.indexOf(A) < 0;
                });
              };
              l.diff = k;
              var C = function(_) {
                if (typeof _ < "u")
                  try {
                    return JSON.parse(_);
                  } catch {
                    return _;
                  }
                return {};
              };
              l.parseCustomProperties = C;
            }
          ),
          /***/
          273: (
            /***/
            function(o, l) {
              var c = this && this.__spreadArray || function(f, p, m) {
                if (m || arguments.length === 2)
                  for (var v = 0, r = p.length, h; v < r; v++)
                    (h || !(v in p)) && (h || (h = Array.prototype.slice.call(p, 0, v)), h[v] = p[v]);
                return f.concat(h || Array.prototype.slice.call(p));
              };
              Object.defineProperty(l, "__esModule", {
                value: !0
              }), l.defaultState = void 0, l.defaultState = [];
              function d(f, p) {
                switch (f === void 0 && (f = l.defaultState), p === void 0 && (p = {}), p.type) {
                  case "ADD_CHOICE": {
                    var m = p, v = {
                      id: m.id,
                      elementId: m.elementId,
                      groupId: m.groupId,
                      value: m.value,
                      label: m.label || m.value,
                      disabled: m.disabled || !1,
                      selected: !1,
                      active: !0,
                      score: 9999,
                      customProperties: m.customProperties,
                      placeholder: m.placeholder || !1
                    };
                    return c(c([], f, !0), [v], !1);
                  }
                  case "ADD_ITEM": {
                    var r = p;
                    return r.choiceId > -1 ? f.map(function(b) {
                      var O = b;
                      return O.id === parseInt("".concat(r.choiceId), 10) && (O.selected = !0), O;
                    }) : f;
                  }
                  case "REMOVE_ITEM": {
                    var h = p;
                    return h.choiceId && h.choiceId > -1 ? f.map(function(b) {
                      var O = b;
                      return O.id === parseInt("".concat(h.choiceId), 10) && (O.selected = !1), O;
                    }) : f;
                  }
                  case "FILTER_CHOICES": {
                    var u = p;
                    return f.map(function(b) {
                      var O = b;
                      return O.active = u.results.some(function(x) {
                        var S = x.item, k = x.score;
                        return S.id === O.id ? (O.score = k, !0) : !1;
                      }), O;
                    });
                  }
                  case "ACTIVATE_CHOICES": {
                    var g = p;
                    return f.map(function(b) {
                      var O = b;
                      return O.active = g.active, O;
                    });
                  }
                  case "CLEAR_CHOICES":
                    return l.defaultState;
                  default:
                    return f;
                }
              }
              l.default = d;
            }
          ),
          /***/
          871: (
            /***/
            function(o, l) {
              var c = this && this.__spreadArray || function(f, p, m) {
                if (m || arguments.length === 2)
                  for (var v = 0, r = p.length, h; v < r; v++)
                    (h || !(v in p)) && (h || (h = Array.prototype.slice.call(p, 0, v)), h[v] = p[v]);
                return f.concat(h || Array.prototype.slice.call(p));
              };
              Object.defineProperty(l, "__esModule", {
                value: !0
              }), l.defaultState = void 0, l.defaultState = [];
              function d(f, p) {
                switch (f === void 0 && (f = l.defaultState), p === void 0 && (p = {}), p.type) {
                  case "ADD_GROUP": {
                    var m = p;
                    return c(c([], f, !0), [{
                      id: m.id,
                      value: m.value,
                      active: m.active,
                      disabled: m.disabled
                    }], !1);
                  }
                  case "CLEAR_CHOICES":
                    return [];
                  default:
                    return f;
                }
              }
              l.default = d;
            }
          ),
          /***/
          655: (
            /***/
            function(o, l, c) {
              var d = this && this.__importDefault || function(b) {
                return b && b.__esModule ? b : {
                  default: b
                };
              };
              Object.defineProperty(l, "__esModule", {
                value: !0
              }), l.defaultState = void 0;
              var f = c(791), p = d(c(52)), m = d(c(871)), v = d(c(273)), r = d(c(502)), h = c(799);
              l.defaultState = {
                groups: [],
                items: [],
                choices: [],
                loading: !1
              };
              var u = (0, f.combineReducers)({
                items: p.default,
                groups: m.default,
                choices: v.default,
                loading: r.default
              }), g = function(b, O) {
                var x = b;
                if (O.type === "CLEAR_ALL")
                  x = l.defaultState;
                else if (O.type === "RESET_TO")
                  return (0, h.cloneObject)(O.state);
                return u(x, O);
              };
              l.default = g;
            }
          ),
          /***/
          52: (
            /***/
            function(o, l) {
              var c = this && this.__spreadArray || function(f, p, m) {
                if (m || arguments.length === 2)
                  for (var v = 0, r = p.length, h; v < r; v++)
                    (h || !(v in p)) && (h || (h = Array.prototype.slice.call(p, 0, v)), h[v] = p[v]);
                return f.concat(h || Array.prototype.slice.call(p));
              };
              Object.defineProperty(l, "__esModule", {
                value: !0
              }), l.defaultState = void 0, l.defaultState = [];
              function d(f, p) {
                switch (f === void 0 && (f = l.defaultState), p === void 0 && (p = {}), p.type) {
                  case "ADD_ITEM": {
                    var m = p, v = c(c([], f, !0), [{
                      id: m.id,
                      choiceId: m.choiceId,
                      groupId: m.groupId,
                      value: m.value,
                      label: m.label,
                      active: !0,
                      highlighted: !1,
                      customProperties: m.customProperties,
                      placeholder: m.placeholder || !1,
                      keyCode: null
                    }], !1);
                    return v.map(function(h) {
                      var u = h;
                      return u.highlighted = !1, u;
                    });
                  }
                  case "REMOVE_ITEM":
                    return f.map(function(h) {
                      var u = h;
                      return u.id === p.id && (u.active = !1), u;
                    });
                  case "HIGHLIGHT_ITEM": {
                    var r = p;
                    return f.map(function(h) {
                      var u = h;
                      return u.id === r.id && (u.highlighted = r.highlighted), u;
                    });
                  }
                  default:
                    return f;
                }
              }
              l.default = d;
            }
          ),
          /***/
          502: (
            /***/
            function(o, l) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              }), l.defaultState = void 0, l.defaultState = !1;
              var c = function(d, f) {
                switch (d === void 0 && (d = l.defaultState), f === void 0 && (f = {}), f.type) {
                  case "SET_IS_LOADING":
                    return f.isLoading;
                  default:
                    return d;
                }
              };
              l.default = c;
            }
          ),
          /***/
          744: (
            /***/
            function(o, l, c) {
              var d = this && this.__spreadArray || function(r, h, u) {
                if (u || arguments.length === 2)
                  for (var g = 0, b = h.length, O; g < b; g++)
                    (O || !(g in h)) && (O || (O = Array.prototype.slice.call(h, 0, g)), O[g] = h[g]);
                return r.concat(O || Array.prototype.slice.call(h));
              }, f = this && this.__importDefault || function(r) {
                return r && r.__esModule ? r : {
                  default: r
                };
              };
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
              var p = c(791), m = f(c(655)), v = (
                /** @class */
                function() {
                  function r() {
                    this._store = (0, p.createStore)(m.default, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
                  }
                  return r.prototype.subscribe = function(h) {
                    this._store.subscribe(h);
                  }, r.prototype.dispatch = function(h) {
                    this._store.dispatch(h);
                  }, Object.defineProperty(r.prototype, "state", {
                    /**
                     * Get store object (wrapping Redux method)
                     */
                    get: function() {
                      return this._store.getState();
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(r.prototype, "items", {
                    /**
                     * Get items from store
                     */
                    get: function() {
                      return this.state.items;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(r.prototype, "activeItems", {
                    /**
                     * Get active items from store
                     */
                    get: function() {
                      return this.items.filter(function(h) {
                        return h.active === !0;
                      });
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(r.prototype, "highlightedActiveItems", {
                    /**
                     * Get highlighted items from store
                     */
                    get: function() {
                      return this.items.filter(function(h) {
                        return h.active && h.highlighted;
                      });
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(r.prototype, "choices", {
                    /**
                     * Get choices from store
                     */
                    get: function() {
                      return this.state.choices;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(r.prototype, "activeChoices", {
                    /**
                     * Get active choices from store
                     */
                    get: function() {
                      return this.choices.filter(function(h) {
                        return h.active === !0;
                      });
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(r.prototype, "selectableChoices", {
                    /**
                     * Get selectable choices from store
                     */
                    get: function() {
                      return this.choices.filter(function(h) {
                        return h.disabled !== !0;
                      });
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(r.prototype, "searchableChoices", {
                    /**
                     * Get choices that can be searched (excluding placeholders)
                     */
                    get: function() {
                      return this.selectableChoices.filter(function(h) {
                        return h.placeholder !== !0;
                      });
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(r.prototype, "placeholderChoice", {
                    /**
                     * Get placeholder choice from store
                     */
                    get: function() {
                      return d([], this.choices, !0).reverse().find(function(h) {
                        return h.placeholder === !0;
                      });
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(r.prototype, "groups", {
                    /**
                     * Get groups from store
                     */
                    get: function() {
                      return this.state.groups;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), Object.defineProperty(r.prototype, "activeGroups", {
                    /**
                     * Get active groups from store
                     */
                    get: function() {
                      var h = this, u = h.groups, g = h.choices;
                      return u.filter(function(b) {
                        var O = b.active === !0 && b.disabled === !1, x = g.some(function(S) {
                          return S.active === !0 && S.disabled === !1;
                        });
                        return O && x;
                      }, []);
                    },
                    enumerable: !1,
                    configurable: !0
                  }), r.prototype.isLoading = function() {
                    return this.state.loading;
                  }, r.prototype.getChoiceById = function(h) {
                    return this.activeChoices.find(function(u) {
                      return u.id === parseInt(h, 10);
                    });
                  }, r.prototype.getGroupById = function(h) {
                    return this.groups.find(function(u) {
                      return u.id === h;
                    });
                  }, r;
                }()
              );
              l.default = v;
            }
          ),
          /***/
          686: (
            /***/
            function(o, l) {
              Object.defineProperty(l, "__esModule", {
                value: !0
              });
              var c = {
                containerOuter: function(d, f, p, m, v, r, h) {
                  var u = d.classNames.containerOuter, g = Object.assign(document.createElement("div"), {
                    className: u
                  });
                  return g.dataset.type = r, f && (g.dir = f), m && (g.tabIndex = 0), p && (g.setAttribute("role", v ? "combobox" : "listbox"), v && g.setAttribute("aria-autocomplete", "list")), g.setAttribute("aria-haspopup", "true"), g.setAttribute("aria-expanded", "false"), h && g.setAttribute("aria-labelledby", h), g;
                },
                containerInner: function(d) {
                  var f = d.classNames.containerInner;
                  return Object.assign(document.createElement("div"), {
                    className: f
                  });
                },
                itemList: function(d, f) {
                  var p = d.classNames, m = p.list, v = p.listSingle, r = p.listItems;
                  return Object.assign(document.createElement("div"), {
                    className: "".concat(m, " ").concat(f ? v : r)
                  });
                },
                placeholder: function(d, f) {
                  var p, m = d.allowHTML, v = d.classNames.placeholder;
                  return Object.assign(document.createElement("div"), (p = {
                    className: v
                  }, p[m ? "innerHTML" : "innerText"] = f, p));
                },
                item: function(d, f, p) {
                  var m, v, r = d.allowHTML, h = d.classNames, u = h.item, g = h.button, b = h.highlightedState, O = h.itemSelectable, x = h.placeholder, S = f.id, k = f.value, C = f.label, _ = f.customProperties, $ = f.active, L = f.disabled, E = f.highlighted, A = f.placeholder, y = Object.assign(document.createElement("div"), (m = {
                    className: u
                  }, m[r ? "innerHTML" : "innerText"] = C, m));
                  if (Object.assign(y.dataset, {
                    item: "",
                    id: S,
                    value: k,
                    customProperties: _
                  }), $ && y.setAttribute("aria-selected", "true"), L && y.setAttribute("aria-disabled", "true"), A && y.classList.add(x), y.classList.add(E ? b : O), p) {
                    L && y.classList.remove(O), y.dataset.deletable = "";
                    var w = "Remove item", T = Object.assign(document.createElement("button"), (v = {
                      type: "button",
                      className: g
                    }, v[r ? "innerHTML" : "innerText"] = w, v));
                    T.setAttribute("aria-label", "".concat(w, ": '").concat(k, "'")), T.dataset.button = "", y.appendChild(T);
                  }
                  return y;
                },
                choiceList: function(d, f) {
                  var p = d.classNames.list, m = Object.assign(document.createElement("div"), {
                    className: p
                  });
                  return f || m.setAttribute("aria-multiselectable", "true"), m.setAttribute("role", "listbox"), m;
                },
                choiceGroup: function(d, f) {
                  var p, m = d.allowHTML, v = d.classNames, r = v.group, h = v.groupHeading, u = v.itemDisabled, g = f.id, b = f.value, O = f.disabled, x = Object.assign(document.createElement("div"), {
                    className: "".concat(r, " ").concat(O ? u : "")
                  });
                  return x.setAttribute("role", "group"), Object.assign(x.dataset, {
                    group: "",
                    id: g,
                    value: b
                  }), O && x.setAttribute("aria-disabled", "true"), x.appendChild(Object.assign(document.createElement("div"), (p = {
                    className: h
                  }, p[m ? "innerHTML" : "innerText"] = b, p))), x;
                },
                choice: function(d, f, p) {
                  var m, v = d.allowHTML, r = d.classNames, h = r.item, u = r.itemChoice, g = r.itemSelectable, b = r.selectedState, O = r.itemDisabled, x = r.placeholder, S = f.id, k = f.value, C = f.label, _ = f.groupId, $ = f.elementId, L = f.disabled, E = f.selected, A = f.placeholder, y = Object.assign(document.createElement("div"), (m = {
                    id: $
                  }, m[v ? "innerHTML" : "innerText"] = C, m.className = "".concat(h, " ").concat(u), m));
                  return E && y.classList.add(b), A && y.classList.add(x), y.setAttribute("role", _ && _ > 0 ? "treeitem" : "option"), Object.assign(y.dataset, {
                    choice: "",
                    id: S,
                    value: k,
                    selectText: p
                  }), L ? (y.classList.add(O), y.dataset.choiceDisabled = "", y.setAttribute("aria-disabled", "true")) : (y.classList.add(g), y.dataset.choiceSelectable = ""), y;
                },
                input: function(d, f) {
                  var p = d.classNames, m = p.input, v = p.inputCloned, r = Object.assign(document.createElement("input"), {
                    type: "search",
                    name: "search_terms",
                    className: "".concat(m, " ").concat(v),
                    autocomplete: "off",
                    autocapitalize: "off",
                    spellcheck: !1
                  });
                  return r.setAttribute("role", "textbox"), r.setAttribute("aria-autocomplete", "list"), r.setAttribute("aria-label", f), r;
                },
                dropdown: function(d) {
                  var f = d.classNames, p = f.list, m = f.listDropdown, v = document.createElement("div");
                  return v.classList.add(p, m), v.setAttribute("aria-expanded", "false"), v;
                },
                notice: function(d, f, p) {
                  var m, v = d.allowHTML, r = d.classNames, h = r.item, u = r.itemChoice, g = r.noResults, b = r.noChoices;
                  p === void 0 && (p = "");
                  var O = [h, u];
                  return p === "no-choices" ? O.push(b) : p === "no-results" && O.push(g), Object.assign(document.createElement("div"), (m = {}, m[v ? "innerHTML" : "innerText"] = f, m.className = O.join(" "), m));
                },
                option: function(d) {
                  var f = d.label, p = d.value, m = d.customProperties, v = d.active, r = d.disabled, h = new Option(f, p, !1, v);
                  return m && (h.dataset.customProperties = "".concat(m)), h.disabled = !!r, h;
                }
              };
              l.default = c;
            }
          ),
          /***/
          996: (
            /***/
            function(o) {
              var l = function($) {
                return c($) && !d($);
              };
              function c(_) {
                return !!_ && typeof _ == "object";
              }
              function d(_) {
                var $ = Object.prototype.toString.call(_);
                return $ === "[object RegExp]" || $ === "[object Date]" || m(_);
              }
              var f = typeof Symbol == "function" && Symbol.for, p = f ? Symbol.for("react.element") : 60103;
              function m(_) {
                return _.$$typeof === p;
              }
              function v(_) {
                return Array.isArray(_) ? [] : {};
              }
              function r(_, $) {
                return $.clone !== !1 && $.isMergeableObject(_) ? k(v(_), _, $) : _;
              }
              function h(_, $, L) {
                return _.concat($).map(function(E) {
                  return r(E, L);
                });
              }
              function u(_, $) {
                if (!$.customMerge)
                  return k;
                var L = $.customMerge(_);
                return typeof L == "function" ? L : k;
              }
              function g(_) {
                return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(_).filter(function($) {
                  return _.propertyIsEnumerable($);
                }) : [];
              }
              function b(_) {
                return Object.keys(_).concat(g(_));
              }
              function O(_, $) {
                try {
                  return $ in _;
                } catch {
                  return !1;
                }
              }
              function x(_, $) {
                return O(_, $) && !(Object.hasOwnProperty.call(_, $) && Object.propertyIsEnumerable.call(_, $));
              }
              function S(_, $, L) {
                var E = {};
                return L.isMergeableObject(_) && b(_).forEach(function(A) {
                  E[A] = r(_[A], L);
                }), b($).forEach(function(A) {
                  x(_, A) || (O(_, A) && L.isMergeableObject($[A]) ? E[A] = u(A, L)(_[A], $[A], L) : E[A] = r($[A], L));
                }), E;
              }
              function k(_, $, L) {
                L = L || {}, L.arrayMerge = L.arrayMerge || h, L.isMergeableObject = L.isMergeableObject || l, L.cloneUnlessOtherwiseSpecified = r;
                var E = Array.isArray($), A = Array.isArray(_), y = E === A;
                return y ? E ? L.arrayMerge(_, $, L) : S(_, $, L) : r($, L);
              }
              k.all = function($, L) {
                if (!Array.isArray($))
                  throw new Error("first argument should be an array");
                return $.reduce(function(E, A) {
                  return k(E, A, L);
                }, {});
              };
              var C = k;
              o.exports = C;
            }
          ),
          /***/
          221: (
            /***/
            function(o, l, c) {
              c.r(l), c.d(l, {
                /* harmony export */
                default: function() {
                  return (
                    /* binding */
                    mn
                  );
                }
                /* harmony export */
              });
              function d(V) {
                return Array.isArray ? Array.isArray(V) : x(V) === "[object Array]";
              }
              const f = 1 / 0;
              function p(V) {
                if (typeof V == "string")
                  return V;
                let F = V + "";
                return F == "0" && 1 / V == -f ? "-0" : F;
              }
              function m(V) {
                return V == null ? "" : p(V);
              }
              function v(V) {
                return typeof V == "string";
              }
              function r(V) {
                return typeof V == "number";
              }
              function h(V) {
                return V === !0 || V === !1 || g(V) && x(V) == "[object Boolean]";
              }
              function u(V) {
                return typeof V == "object";
              }
              function g(V) {
                return u(V) && V !== null;
              }
              function b(V) {
                return V != null;
              }
              function O(V) {
                return !V.trim().length;
              }
              function x(V) {
                return V == null ? V === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(V);
              }
              const S = "Incorrect 'index' type", k = (V) => `Invalid value for key ${V}`, C = (V) => `Pattern length exceeds max of ${V}.`, _ = (V) => `Missing ${V} property in key`, $ = (V) => `Property 'weight' in key '${V}' must be a positive integer`, L = Object.prototype.hasOwnProperty;
              class E {
                constructor(F) {
                  this._keys = [], this._keyMap = {};
                  let H = 0;
                  F.forEach((J) => {
                    let se = A(J);
                    H += se.weight, this._keys.push(se), this._keyMap[se.id] = se, H += se.weight;
                  }), this._keys.forEach((J) => {
                    J.weight /= H;
                  });
                }
                get(F) {
                  return this._keyMap[F];
                }
                keys() {
                  return this._keys;
                }
                toJSON() {
                  return JSON.stringify(this._keys);
                }
              }
              function A(V) {
                let F = null, H = null, J = null, se = 1, re = null;
                if (v(V) || d(V))
                  J = V, F = y(V), H = w(V);
                else {
                  if (!L.call(V, "name"))
                    throw new Error(_("name"));
                  const ae = V.name;
                  if (J = ae, L.call(V, "weight") && (se = V.weight, se <= 0))
                    throw new Error($(ae));
                  F = y(ae), H = w(ae), re = V.getFn;
                }
                return { path: F, id: H, weight: se, src: J, getFn: re };
              }
              function y(V) {
                return d(V) ? V : V.split(".");
              }
              function w(V) {
                return d(V) ? V.join(".") : V;
              }
              function T(V, F) {
                let H = [], J = !1;
                const se = (re, ae, ue) => {
                  if (b(re))
                    if (!ae[ue])
                      H.push(re);
                    else {
                      let pe = ae[ue];
                      const ve = re[pe];
                      if (!b(ve))
                        return;
                      if (ue === ae.length - 1 && (v(ve) || r(ve) || h(ve)))
                        H.push(m(ve));
                      else if (d(ve)) {
                        J = !0;
                        for (let Se = 0, Ee = ve.length; Se < Ee; Se += 1)
                          se(ve[Se], ae, ue + 1);
                      } else
                        ae.length && se(ve, ae, ue + 1);
                    }
                };
                return se(V, v(F) ? F.split(".") : F, 0), J ? H : H[0];
              }
              var W = {
                ...{
                  // When `true`, the algorithm continues searching to the end of the input even if a perfect
                  // match is found before the end of the same input.
                  isCaseSensitive: !1,
                  // When true, the matching function will continue to the end of a search pattern even if
                  includeScore: !1,
                  // List of properties that will be searched. This also supports nested properties.
                  keys: [],
                  // Whether to sort the result list, by score
                  shouldSort: !0,
                  // Default sort function: sort by ascending score, ascending index
                  sortFn: (V, F) => V.score === F.score ? V.idx < F.idx ? -1 : 1 : V.score < F.score ? -1 : 1
                },
                ...{
                  // Whether the matches should be included in the result set. When `true`, each record in the result
                  // set will include the indices of the matched characters.
                  // These can consequently be used for highlighting purposes.
                  includeMatches: !1,
                  // When `true`, the matching function will continue to the end of a search pattern even if
                  // a perfect match has already been located in the string.
                  findAllMatches: !1,
                  // Minimum number of characters that must be matched before a result is considered a match
                  minMatchCharLength: 1
                },
                ...{
                  // Approximately where in the text is the pattern expected to be found?
                  location: 0,
                  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
                  // (of both letters and location), a threshold of '1.0' would match anything.
                  threshold: 0.6,
                  // Determines how close the match must be to the fuzzy location (specified above).
                  // An exact letter match which is 'distance' characters away from the fuzzy location
                  // would score as a complete mismatch. A distance of '0' requires the match be at
                  // the exact location specified, a threshold of '1000' would require a perfect match
                  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
                  distance: 100
                },
                ...{
                  // When `true`, it enables the use of unix-like search commands
                  useExtendedSearch: !1,
                  // The get function to use when fetching an object's properties.
                  // The default will search nested paths *ie foo.bar.baz*
                  getFn: T,
                  // When `true`, search will ignore `location` and `distance`, so it won't matter
                  // where in the string the pattern appears.
                  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
                  ignoreLocation: !1,
                  // When `true`, the calculation for the relevance score (used for sorting) will
                  // ignore the field-length norm.
                  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
                  ignoreFieldNorm: !1,
                  // The weight to determine how much field length norm effects scoring.
                  fieldNormWeight: 1
                }
              };
              const G = /[^ ]+/g;
              function de(V = 1, F = 3) {
                const H = /* @__PURE__ */ new Map(), J = Math.pow(10, F);
                return {
                  get(se) {
                    const re = se.match(G).length;
                    if (H.has(re))
                      return H.get(re);
                    const ae = 1 / Math.pow(re, 0.5 * V), ue = parseFloat(Math.round(ae * J) / J);
                    return H.set(re, ue), ue;
                  },
                  clear() {
                    H.clear();
                  }
                };
              }
              class xe {
                constructor({
                  getFn: F = W.getFn,
                  fieldNormWeight: H = W.fieldNormWeight
                } = {}) {
                  this.norm = de(H, 3), this.getFn = F, this.isCreated = !1, this.setIndexRecords();
                }
                setSources(F = []) {
                  this.docs = F;
                }
                setIndexRecords(F = []) {
                  this.records = F;
                }
                setKeys(F = []) {
                  this.keys = F, this._keysMap = {}, F.forEach((H, J) => {
                    this._keysMap[H.id] = J;
                  });
                }
                create() {
                  this.isCreated || !this.docs.length || (this.isCreated = !0, v(this.docs[0]) ? this.docs.forEach((F, H) => {
                    this._addString(F, H);
                  }) : this.docs.forEach((F, H) => {
                    this._addObject(F, H);
                  }), this.norm.clear());
                }
                // Adds a doc to the end of the index
                add(F) {
                  const H = this.size();
                  v(F) ? this._addString(F, H) : this._addObject(F, H);
                }
                // Removes the doc at the specified index of the index
                removeAt(F) {
                  this.records.splice(F, 1);
                  for (let H = F, J = this.size(); H < J; H += 1)
                    this.records[H].i -= 1;
                }
                getValueForItemAtKeyId(F, H) {
                  return F[this._keysMap[H]];
                }
                size() {
                  return this.records.length;
                }
                _addString(F, H) {
                  if (!b(F) || O(F))
                    return;
                  let J = {
                    v: F,
                    i: H,
                    n: this.norm.get(F)
                  };
                  this.records.push(J);
                }
                _addObject(F, H) {
                  let J = { i: H, $: {} };
                  this.keys.forEach((se, re) => {
                    let ae = se.getFn ? se.getFn(F) : this.getFn(F, se.path);
                    if (b(ae)) {
                      if (d(ae)) {
                        let ue = [];
                        const pe = [{ nestedArrIndex: -1, value: ae }];
                        for (; pe.length; ) {
                          const { nestedArrIndex: ve, value: Se } = pe.pop();
                          if (b(Se))
                            if (v(Se) && !O(Se)) {
                              let Ee = {
                                v: Se,
                                i: ve,
                                n: this.norm.get(Se)
                              };
                              ue.push(Ee);
                            } else
                              d(Se) && Se.forEach((Ee, Qe) => {
                                pe.push({
                                  nestedArrIndex: Qe,
                                  value: Ee
                                });
                              });
                        }
                        J.$[re] = ue;
                      } else if (v(ae) && !O(ae)) {
                        let ue = {
                          v: ae,
                          n: this.norm.get(ae)
                        };
                        J.$[re] = ue;
                      }
                    }
                  }), this.records.push(J);
                }
                toJSON() {
                  return {
                    keys: this.keys,
                    records: this.records
                  };
                }
              }
              function ie(V, F, { getFn: H = W.getFn, fieldNormWeight: J = W.fieldNormWeight } = {}) {
                const se = new xe({ getFn: H, fieldNormWeight: J });
                return se.setKeys(V.map(A)), se.setSources(F), se.create(), se;
              }
              function fe(V, { getFn: F = W.getFn, fieldNormWeight: H = W.fieldNormWeight } = {}) {
                const { keys: J, records: se } = V, re = new xe({ getFn: F, fieldNormWeight: H });
                return re.setKeys(J), re.setIndexRecords(se), re;
              }
              function $e(V, {
                errors: F = 0,
                currentLocation: H = 0,
                expectedLocation: J = 0,
                distance: se = W.distance,
                ignoreLocation: re = W.ignoreLocation
              } = {}) {
                const ae = F / V.length;
                if (re)
                  return ae;
                const ue = Math.abs(J - H);
                return se ? ae + ue / se : ue ? 1 : ae;
              }
              function Me(V = [], F = W.minMatchCharLength) {
                let H = [], J = -1, se = -1, re = 0;
                for (let ae = V.length; re < ae; re += 1) {
                  let ue = V[re];
                  ue && J === -1 ? J = re : !ue && J !== -1 && (se = re - 1, se - J + 1 >= F && H.push([J, se]), J = -1);
                }
                return V[re - 1] && re - J >= F && H.push([J, re - 1]), H;
              }
              const Ie = 32;
              function ot(V, F, H, {
                location: J = W.location,
                distance: se = W.distance,
                threshold: re = W.threshold,
                findAllMatches: ae = W.findAllMatches,
                minMatchCharLength: ue = W.minMatchCharLength,
                includeMatches: pe = W.includeMatches,
                ignoreLocation: ve = W.ignoreLocation
              } = {}) {
                if (F.length > Ie)
                  throw new Error(C(Ie));
                const Se = F.length, Ee = V.length, Qe = Math.max(0, Math.min(J, Ee));
                let qe = re, mt = Qe;
                const ri = ue > 1 || pe, Fs = ri ? Array(Ee) : [];
                let Ui;
                for (; (Ui = V.indexOf(F, mt)) > -1; ) {
                  let ai = $e(F, {
                    currentLocation: Ui,
                    expectedLocation: Qe,
                    distance: se,
                    ignoreLocation: ve
                  });
                  if (qe = Math.min(ai, qe), mt = Ui + Se, ri) {
                    let us = 0;
                    for (; us < Se; )
                      Fs[Ui + us] = 1, us += 1;
                  }
                }
                mt = -1;
                let bn = [], Ws = 1, La = Se + Ee;
                const O0 = 1 << Se - 1;
                for (let ai = 0; ai < Se; ai += 1) {
                  let us = 0, fs = La;
                  for (; us < fs; )
                    $e(F, {
                      errors: ai,
                      currentLocation: Qe + fs,
                      expectedLocation: Qe,
                      distance: se,
                      ignoreLocation: ve
                    }) <= qe ? us = fs : La = fs, fs = Math.floor((La - us) / 2 + us);
                  La = fs;
                  let Lu = Math.max(1, Qe - fs + 1), Kl = ae ? Ee : Math.min(Qe + fs, Ee) + Se, vn = Array(Kl + 2);
                  vn[Kl + 1] = (1 << ai) - 1;
                  for (let yi = Kl; yi >= Lu; yi -= 1) {
                    let Ma = yi - 1, Mu = H[V.charAt(Ma)];
                    if (ri && (Fs[Ma] = +!!Mu), vn[yi] = (vn[yi + 1] << 1 | 1) & Mu, ai && (vn[yi] |= (bn[yi + 1] | bn[yi]) << 1 | 1 | bn[yi + 1]), vn[yi] & O0 && (Ws = $e(F, {
                      errors: ai,
                      currentLocation: Ma,
                      expectedLocation: Qe,
                      distance: se,
                      ignoreLocation: ve
                    }), Ws <= qe)) {
                      if (qe = Ws, mt = Ma, mt <= Qe)
                        break;
                      Lu = Math.max(1, 2 * Qe - mt);
                    }
                  }
                  if ($e(F, {
                    errors: ai + 1,
                    currentLocation: Qe,
                    expectedLocation: Qe,
                    distance: se,
                    ignoreLocation: ve
                  }) > qe)
                    break;
                  bn = vn;
                }
                const ql = {
                  isMatch: mt >= 0,
                  // Count exact matches (those with a score of 0) to be "almost" exact
                  score: Math.max(1e-3, Ws)
                };
                if (ri) {
                  const ai = Me(Fs, ue);
                  ai.length ? pe && (ql.indices = ai) : ql.isMatch = !1;
                }
                return ql;
              }
              function Ge(V) {
                let F = {};
                for (let H = 0, J = V.length; H < J; H += 1) {
                  const se = V.charAt(H);
                  F[se] = (F[se] || 0) | 1 << J - H - 1;
                }
                return F;
              }
              class qt {
                constructor(F, {
                  location: H = W.location,
                  threshold: J = W.threshold,
                  distance: se = W.distance,
                  includeMatches: re = W.includeMatches,
                  findAllMatches: ae = W.findAllMatches,
                  minMatchCharLength: ue = W.minMatchCharLength,
                  isCaseSensitive: pe = W.isCaseSensitive,
                  ignoreLocation: ve = W.ignoreLocation
                } = {}) {
                  if (this.options = {
                    location: H,
                    threshold: J,
                    distance: se,
                    includeMatches: re,
                    findAllMatches: ae,
                    minMatchCharLength: ue,
                    isCaseSensitive: pe,
                    ignoreLocation: ve
                  }, this.pattern = pe ? F : F.toLowerCase(), this.chunks = [], !this.pattern.length)
                    return;
                  const Se = (Qe, qe) => {
                    this.chunks.push({
                      pattern: Qe,
                      alphabet: Ge(Qe),
                      startIndex: qe
                    });
                  }, Ee = this.pattern.length;
                  if (Ee > Ie) {
                    let Qe = 0;
                    const qe = Ee % Ie, mt = Ee - qe;
                    for (; Qe < mt; )
                      Se(this.pattern.substr(Qe, Ie), Qe), Qe += Ie;
                    if (qe) {
                      const ri = Ee - Ie;
                      Se(this.pattern.substr(ri), ri);
                    }
                  } else
                    Se(this.pattern, 0);
                }
                searchIn(F) {
                  const { isCaseSensitive: H, includeMatches: J } = this.options;
                  if (H || (F = F.toLowerCase()), this.pattern === F) {
                    let mt = {
                      isMatch: !0,
                      score: 0
                    };
                    return J && (mt.indices = [[0, F.length - 1]]), mt;
                  }
                  const {
                    location: se,
                    distance: re,
                    threshold: ae,
                    findAllMatches: ue,
                    minMatchCharLength: pe,
                    ignoreLocation: ve
                  } = this.options;
                  let Se = [], Ee = 0, Qe = !1;
                  this.chunks.forEach(({ pattern: mt, alphabet: ri, startIndex: Fs }) => {
                    const { isMatch: Ui, score: bn, indices: Ws } = ot(F, mt, ri, {
                      location: se + Fs,
                      distance: re,
                      threshold: ae,
                      findAllMatches: ue,
                      minMatchCharLength: pe,
                      includeMatches: J,
                      ignoreLocation: ve
                    });
                    Ui && (Qe = !0), Ee += bn, Ui && Ws && (Se = [...Se, ...Ws]);
                  });
                  let qe = {
                    isMatch: Qe,
                    score: Qe ? Ee / this.chunks.length : 1
                  };
                  return Qe && J && (qe.indices = Se), qe;
                }
              }
              class Pi {
                constructor(F) {
                  this.pattern = F;
                }
                static isMultiMatch(F) {
                  return Cu(F, this.multiRegex);
                }
                static isSingleMatch(F) {
                  return Cu(F, this.singleRegex);
                }
                search() {
                }
              }
              function Cu(V, F) {
                const H = V.match(F);
                return H ? H[1] : null;
              }
              class i0 extends Pi {
                constructor(F) {
                  super(F);
                }
                static get type() {
                  return "exact";
                }
                static get multiRegex() {
                  return /^="(.*)"$/;
                }
                static get singleRegex() {
                  return /^=(.*)$/;
                }
                search(F) {
                  const H = F === this.pattern;
                  return {
                    isMatch: H,
                    score: H ? 0 : 1,
                    indices: [0, this.pattern.length - 1]
                  };
                }
              }
              class s0 extends Pi {
                constructor(F) {
                  super(F);
                }
                static get type() {
                  return "inverse-exact";
                }
                static get multiRegex() {
                  return /^!"(.*)"$/;
                }
                static get singleRegex() {
                  return /^!(.*)$/;
                }
                search(F) {
                  const J = F.indexOf(this.pattern) === -1;
                  return {
                    isMatch: J,
                    score: J ? 0 : 1,
                    indices: [0, F.length - 1]
                  };
                }
              }
              class n0 extends Pi {
                constructor(F) {
                  super(F);
                }
                static get type() {
                  return "prefix-exact";
                }
                static get multiRegex() {
                  return /^\^"(.*)"$/;
                }
                static get singleRegex() {
                  return /^\^(.*)$/;
                }
                search(F) {
                  const H = F.startsWith(this.pattern);
                  return {
                    isMatch: H,
                    score: H ? 0 : 1,
                    indices: [0, this.pattern.length - 1]
                  };
                }
              }
              class r0 extends Pi {
                constructor(F) {
                  super(F);
                }
                static get type() {
                  return "inverse-prefix-exact";
                }
                static get multiRegex() {
                  return /^!\^"(.*)"$/;
                }
                static get singleRegex() {
                  return /^!\^(.*)$/;
                }
                search(F) {
                  const H = !F.startsWith(this.pattern);
                  return {
                    isMatch: H,
                    score: H ? 0 : 1,
                    indices: [0, F.length - 1]
                  };
                }
              }
              class a0 extends Pi {
                constructor(F) {
                  super(F);
                }
                static get type() {
                  return "suffix-exact";
                }
                static get multiRegex() {
                  return /^"(.*)"\$$/;
                }
                static get singleRegex() {
                  return /^(.*)\$$/;
                }
                search(F) {
                  const H = F.endsWith(this.pattern);
                  return {
                    isMatch: H,
                    score: H ? 0 : 1,
                    indices: [F.length - this.pattern.length, F.length - 1]
                  };
                }
              }
              class o0 extends Pi {
                constructor(F) {
                  super(F);
                }
                static get type() {
                  return "inverse-suffix-exact";
                }
                static get multiRegex() {
                  return /^!"(.*)"\$$/;
                }
                static get singleRegex() {
                  return /^!(.*)\$$/;
                }
                search(F) {
                  const H = !F.endsWith(this.pattern);
                  return {
                    isMatch: H,
                    score: H ? 0 : 1,
                    indices: [0, F.length - 1]
                  };
                }
              }
              class Tu extends Pi {
                constructor(F, {
                  location: H = W.location,
                  threshold: J = W.threshold,
                  distance: se = W.distance,
                  includeMatches: re = W.includeMatches,
                  findAllMatches: ae = W.findAllMatches,
                  minMatchCharLength: ue = W.minMatchCharLength,
                  isCaseSensitive: pe = W.isCaseSensitive,
                  ignoreLocation: ve = W.ignoreLocation
                } = {}) {
                  super(F), this._bitapSearch = new qt(F, {
                    location: H,
                    threshold: J,
                    distance: se,
                    includeMatches: re,
                    findAllMatches: ae,
                    minMatchCharLength: ue,
                    isCaseSensitive: pe,
                    ignoreLocation: ve
                  });
                }
                static get type() {
                  return "fuzzy";
                }
                static get multiRegex() {
                  return /^"(.*)"$/;
                }
                static get singleRegex() {
                  return /^(.*)$/;
                }
                search(F) {
                  return this._bitapSearch.searchIn(F);
                }
              }
              class Au extends Pi {
                constructor(F) {
                  super(F);
                }
                static get type() {
                  return "include";
                }
                static get multiRegex() {
                  return /^'"(.*)"$/;
                }
                static get singleRegex() {
                  return /^'(.*)$/;
                }
                search(F) {
                  let H = 0, J;
                  const se = [], re = this.pattern.length;
                  for (; (J = F.indexOf(this.pattern, H)) > -1; )
                    H = J + re, se.push([J, H - 1]);
                  const ae = !!se.length;
                  return {
                    isMatch: ae,
                    score: ae ? 0 : 1,
                    indices: se
                  };
                }
              }
              const Hl = [
                i0,
                Au,
                n0,
                r0,
                o0,
                a0,
                s0,
                Tu
              ], $u = Hl.length, l0 = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/, c0 = "|";
              function h0(V, F = {}) {
                return V.split(c0).map((H) => {
                  let J = H.trim().split(l0).filter((re) => re && !!re.trim()), se = [];
                  for (let re = 0, ae = J.length; re < ae; re += 1) {
                    const ue = J[re];
                    let pe = !1, ve = -1;
                    for (; !pe && ++ve < $u; ) {
                      const Se = Hl[ve];
                      let Ee = Se.isMultiMatch(ue);
                      Ee && (se.push(new Se(Ee, F)), pe = !0);
                    }
                    if (!pe)
                      for (ve = -1; ++ve < $u; ) {
                        const Se = Hl[ve];
                        let Ee = Se.isSingleMatch(ue);
                        if (Ee) {
                          se.push(new Se(Ee, F));
                          break;
                        }
                      }
                  }
                  return se;
                });
              }
              const d0 = /* @__PURE__ */ new Set([Tu.type, Au.type]);
              class u0 {
                constructor(F, {
                  isCaseSensitive: H = W.isCaseSensitive,
                  includeMatches: J = W.includeMatches,
                  minMatchCharLength: se = W.minMatchCharLength,
                  ignoreLocation: re = W.ignoreLocation,
                  findAllMatches: ae = W.findAllMatches,
                  location: ue = W.location,
                  threshold: pe = W.threshold,
                  distance: ve = W.distance
                } = {}) {
                  this.query = null, this.options = {
                    isCaseSensitive: H,
                    includeMatches: J,
                    minMatchCharLength: se,
                    findAllMatches: ae,
                    ignoreLocation: re,
                    location: ue,
                    threshold: pe,
                    distance: ve
                  }, this.pattern = H ? F : F.toLowerCase(), this.query = h0(this.pattern, this.options);
                }
                static condition(F, H) {
                  return H.useExtendedSearch;
                }
                searchIn(F) {
                  const H = this.query;
                  if (!H)
                    return {
                      isMatch: !1,
                      score: 1
                    };
                  const { includeMatches: J, isCaseSensitive: se } = this.options;
                  F = se ? F : F.toLowerCase();
                  let re = 0, ae = [], ue = 0;
                  for (let pe = 0, ve = H.length; pe < ve; pe += 1) {
                    const Se = H[pe];
                    ae.length = 0, re = 0;
                    for (let Ee = 0, Qe = Se.length; Ee < Qe; Ee += 1) {
                      const qe = Se[Ee], { isMatch: mt, indices: ri, score: Fs } = qe.search(F);
                      if (mt) {
                        if (re += 1, ue += Fs, J) {
                          const Ui = qe.constructor.type;
                          d0.has(Ui) ? ae = [...ae, ...ri] : ae.push(ri);
                        }
                      } else {
                        ue = 0, re = 0, ae.length = 0;
                        break;
                      }
                    }
                    if (re) {
                      let Ee = {
                        isMatch: !0,
                        score: ue / re
                      };
                      return J && (Ee.indices = ae), Ee;
                    }
                  }
                  return {
                    isMatch: !1,
                    score: 1
                  };
                }
              }
              const Gl = [];
              function f0(...V) {
                Gl.push(...V);
              }
              function jl(V, F) {
                for (let H = 0, J = Gl.length; H < J; H += 1) {
                  let se = Gl[H];
                  if (se.condition(V, F))
                    return new se(V, F);
                }
                return new qt(V, F);
              }
              const Pa = {
                AND: "$and",
                OR: "$or"
              }, Ul = {
                PATH: "$path",
                PATTERN: "$val"
              }, Zl = (V) => !!(V[Pa.AND] || V[Pa.OR]), p0 = (V) => !!V[Ul.PATH], g0 = (V) => !d(V) && u(V) && !Zl(V), Eu = (V) => ({
                [Pa.AND]: Object.keys(V).map((F) => ({
                  [F]: V[F]
                }))
              });
              function Pu(V, F, { auto: H = !0 } = {}) {
                const J = (se) => {
                  let re = Object.keys(se);
                  const ae = p0(se);
                  if (!ae && re.length > 1 && !Zl(se))
                    return J(Eu(se));
                  if (g0(se)) {
                    const pe = ae ? se[Ul.PATH] : re[0], ve = ae ? se[Ul.PATTERN] : se[pe];
                    if (!v(ve))
                      throw new Error(k(pe));
                    const Se = {
                      keyId: w(pe),
                      pattern: ve
                    };
                    return H && (Se.searcher = jl(ve, F)), Se;
                  }
                  let ue = {
                    children: [],
                    operator: re[0]
                  };
                  return re.forEach((pe) => {
                    const ve = se[pe];
                    d(ve) && ve.forEach((Se) => {
                      ue.children.push(J(Se));
                    });
                  }), ue;
                };
                return Zl(V) || (V = Eu(V)), J(V);
              }
              function m0(V, { ignoreFieldNorm: F = W.ignoreFieldNorm }) {
                V.forEach((H) => {
                  let J = 1;
                  H.matches.forEach(({ key: se, norm: re, score: ae }) => {
                    const ue = se ? se.weight : null;
                    J *= Math.pow(
                      ae === 0 && ue ? Number.EPSILON : ae,
                      (ue || 1) * (F ? 1 : re)
                    );
                  }), H.score = J;
                });
              }
              function b0(V, F) {
                const H = V.matches;
                F.matches = [], b(H) && H.forEach((J) => {
                  if (!b(J.indices) || !J.indices.length)
                    return;
                  const { indices: se, value: re } = J;
                  let ae = {
                    indices: se,
                    value: re
                  };
                  J.key && (ae.key = J.key.src), J.idx > -1 && (ae.refIndex = J.idx), F.matches.push(ae);
                });
              }
              function v0(V, F) {
                F.score = V.score;
              }
              function y0(V, F, {
                includeMatches: H = W.includeMatches,
                includeScore: J = W.includeScore
              } = {}) {
                const se = [];
                return H && se.push(b0), J && se.push(v0), V.map((re) => {
                  const { idx: ae } = re, ue = {
                    item: F[ae],
                    refIndex: ae
                  };
                  return se.length && se.forEach((pe) => {
                    pe(re, ue);
                  }), ue;
                });
              }
              class mn {
                constructor(F, H = {}, J) {
                  this.options = { ...W, ...H }, this.options.useExtendedSearch, this._keyStore = new E(this.options.keys), this.setCollection(F, J);
                }
                setCollection(F, H) {
                  if (this._docs = F, H && !(H instanceof xe))
                    throw new Error(S);
                  this._myIndex = H || ie(this.options.keys, this._docs, {
                    getFn: this.options.getFn,
                    fieldNormWeight: this.options.fieldNormWeight
                  });
                }
                add(F) {
                  b(F) && (this._docs.push(F), this._myIndex.add(F));
                }
                remove(F = () => !1) {
                  const H = [];
                  for (let J = 0, se = this._docs.length; J < se; J += 1) {
                    const re = this._docs[J];
                    F(re, J) && (this.removeAt(J), J -= 1, se -= 1, H.push(re));
                  }
                  return H;
                }
                removeAt(F) {
                  this._docs.splice(F, 1), this._myIndex.removeAt(F);
                }
                getIndex() {
                  return this._myIndex;
                }
                search(F, { limit: H = -1 } = {}) {
                  const {
                    includeMatches: J,
                    includeScore: se,
                    shouldSort: re,
                    sortFn: ae,
                    ignoreFieldNorm: ue
                  } = this.options;
                  let pe = v(F) ? v(this._docs[0]) ? this._searchStringList(F) : this._searchObjectList(F) : this._searchLogical(F);
                  return m0(pe, { ignoreFieldNorm: ue }), re && pe.sort(ae), r(H) && H > -1 && (pe = pe.slice(0, H)), y0(pe, this._docs, {
                    includeMatches: J,
                    includeScore: se
                  });
                }
                _searchStringList(F) {
                  const H = jl(F, this.options), { records: J } = this._myIndex, se = [];
                  return J.forEach(({ v: re, i: ae, n: ue }) => {
                    if (!b(re))
                      return;
                    const { isMatch: pe, score: ve, indices: Se } = H.searchIn(re);
                    pe && se.push({
                      item: re,
                      idx: ae,
                      matches: [{ score: ve, value: re, norm: ue, indices: Se }]
                    });
                  }), se;
                }
                _searchLogical(F) {
                  const H = Pu(F, this.options), J = (ue, pe, ve) => {
                    if (!ue.children) {
                      const { keyId: Ee, searcher: Qe } = ue, qe = this._findMatches({
                        key: this._keyStore.get(Ee),
                        value: this._myIndex.getValueForItemAtKeyId(pe, Ee),
                        searcher: Qe
                      });
                      return qe && qe.length ? [
                        {
                          idx: ve,
                          item: pe,
                          matches: qe
                        }
                      ] : [];
                    }
                    const Se = [];
                    for (let Ee = 0, Qe = ue.children.length; Ee < Qe; Ee += 1) {
                      const qe = ue.children[Ee], mt = J(qe, pe, ve);
                      if (mt.length)
                        Se.push(...mt);
                      else if (ue.operator === Pa.AND)
                        return [];
                    }
                    return Se;
                  }, se = this._myIndex.records, re = {}, ae = [];
                  return se.forEach(({ $: ue, i: pe }) => {
                    if (b(ue)) {
                      let ve = J(H, ue, pe);
                      ve.length && (re[pe] || (re[pe] = { idx: pe, item: ue, matches: [] }, ae.push(re[pe])), ve.forEach(({ matches: Se }) => {
                        re[pe].matches.push(...Se);
                      }));
                    }
                  }), ae;
                }
                _searchObjectList(F) {
                  const H = jl(F, this.options), { keys: J, records: se } = this._myIndex, re = [];
                  return se.forEach(({ $: ae, i: ue }) => {
                    if (!b(ae))
                      return;
                    let pe = [];
                    J.forEach((ve, Se) => {
                      pe.push(
                        ...this._findMatches({
                          key: ve,
                          value: ae[Se],
                          searcher: H
                        })
                      );
                    }), pe.length && re.push({
                      idx: ue,
                      item: ae,
                      matches: pe
                    });
                  }), re;
                }
                _findMatches({ key: F, value: H, searcher: J }) {
                  if (!b(H))
                    return [];
                  let se = [];
                  if (d(H))
                    H.forEach(({ v: re, i: ae, n: ue }) => {
                      if (!b(re))
                        return;
                      const { isMatch: pe, score: ve, indices: Se } = J.searchIn(re);
                      pe && se.push({
                        score: ve,
                        key: F,
                        value: re,
                        idx: ae,
                        norm: ue,
                        indices: Se
                      });
                    });
                  else {
                    const { v: re, n: ae } = H, { isMatch: ue, score: pe, indices: ve } = J.searchIn(re);
                    ue && se.push({ score: pe, key: F, value: re, norm: ae, indices: ve });
                  }
                  return se;
                }
              }
              mn.version = "6.6.2", mn.createIndex = ie, mn.parseIndex = fe, mn.config = W, mn.parseQuery = Pu, f0(u0);
            }
          ),
          /***/
          791: (
            /***/
            function(o, l, c) {
              c.r(l), c.d(l, {
                __DO_NOT_USE__ActionTypes: function() {
                  return (
                    /* binding */
                    b
                  );
                },
                applyMiddleware: function() {
                  return (
                    /* binding */
                    E
                  );
                },
                bindActionCreators: function() {
                  return (
                    /* binding */
                    $
                  );
                },
                combineReducers: function() {
                  return (
                    /* binding */
                    C
                  );
                },
                compose: function() {
                  return (
                    /* binding */
                    L
                  );
                },
                createStore: function() {
                  return (
                    /* binding */
                    x
                  );
                },
                legacy_createStore: function() {
                  return (
                    /* binding */
                    S
                  );
                }
              });
              function d(A) {
                "@babel/helpers - typeof";
                return d = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(y) {
                  return typeof y;
                } : function(y) {
                  return y && typeof Symbol == "function" && y.constructor === Symbol && y !== Symbol.prototype ? "symbol" : typeof y;
                }, d(A);
              }
              function f(A, y) {
                if (d(A) !== "object" || A === null)
                  return A;
                var w = A[Symbol.toPrimitive];
                if (w !== void 0) {
                  var T = w.call(A, y || "default");
                  if (d(T) !== "object")
                    return T;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return (y === "string" ? String : Number)(A);
              }
              function p(A) {
                var y = f(A, "string");
                return d(y) === "symbol" ? y : String(y);
              }
              function m(A, y, w) {
                return y = p(y), y in A ? Object.defineProperty(A, y, {
                  value: w,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0
                }) : A[y] = w, A;
              }
              function v(A, y) {
                var w = Object.keys(A);
                if (Object.getOwnPropertySymbols) {
                  var T = Object.getOwnPropertySymbols(A);
                  y && (T = T.filter(function(P) {
                    return Object.getOwnPropertyDescriptor(A, P).enumerable;
                  })), w.push.apply(w, T);
                }
                return w;
              }
              function r(A) {
                for (var y = 1; y < arguments.length; y++) {
                  var w = arguments[y] != null ? arguments[y] : {};
                  y % 2 ? v(Object(w), !0).forEach(function(T) {
                    m(A, T, w[T]);
                  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(A, Object.getOwnPropertyDescriptors(w)) : v(Object(w)).forEach(function(T) {
                    Object.defineProperty(A, T, Object.getOwnPropertyDescriptor(w, T));
                  });
                }
                return A;
              }
              function h(A) {
                return "Minified Redux error #" + A + "; visit https://redux.js.org/Errors?code=" + A + " for the full message or use the non-minified dev environment for full errors. ";
              }
              var u = function() {
                return typeof Symbol == "function" && Symbol.observable || "@@observable";
              }(), g = function() {
                return Math.random().toString(36).substring(7).split("").join(".");
              }, b = {
                INIT: "@@redux/INIT" + g(),
                REPLACE: "@@redux/REPLACE" + g(),
                PROBE_UNKNOWN_ACTION: function() {
                  return "@@redux/PROBE_UNKNOWN_ACTION" + g();
                }
              };
              function O(A) {
                if (typeof A != "object" || A === null)
                  return !1;
                for (var y = A; Object.getPrototypeOf(y) !== null; )
                  y = Object.getPrototypeOf(y);
                return Object.getPrototypeOf(A) === y;
              }
              function x(A, y, w) {
                var T;
                if (typeof y == "function" && typeof w == "function" || typeof w == "function" && typeof arguments[3] == "function")
                  throw new Error(h(0));
                if (typeof y == "function" && typeof w > "u" && (w = y, y = void 0), typeof w < "u") {
                  if (typeof w != "function")
                    throw new Error(h(1));
                  return w(x)(A, y);
                }
                if (typeof A != "function")
                  throw new Error(h(2));
                var P = A, R = y, Q = [], z = Q, W = !1;
                function G() {
                  z === Q && (z = Q.slice());
                }
                function de() {
                  if (W)
                    throw new Error(h(3));
                  return R;
                }
                function xe(Me) {
                  if (typeof Me != "function")
                    throw new Error(h(4));
                  if (W)
                    throw new Error(h(5));
                  var Ie = !0;
                  return G(), z.push(Me), function() {
                    if (Ie) {
                      if (W)
                        throw new Error(h(6));
                      Ie = !1, G();
                      var Ge = z.indexOf(Me);
                      z.splice(Ge, 1), Q = null;
                    }
                  };
                }
                function ie(Me) {
                  if (!O(Me))
                    throw new Error(h(7));
                  if (typeof Me.type > "u")
                    throw new Error(h(8));
                  if (W)
                    throw new Error(h(9));
                  try {
                    W = !0, R = P(R, Me);
                  } finally {
                    W = !1;
                  }
                  for (var Ie = Q = z, ot = 0; ot < Ie.length; ot++) {
                    var Ge = Ie[ot];
                    Ge();
                  }
                  return Me;
                }
                function fe(Me) {
                  if (typeof Me != "function")
                    throw new Error(h(10));
                  P = Me, ie({
                    type: b.REPLACE
                  });
                }
                function $e() {
                  var Me, Ie = xe;
                  return Me = {
                    /**
                     * The minimal observable subscription method.
                     * @param {Object} observer Any object that can be used as an observer.
                     * The observer object should have a `next` method.
                     * @returns {subscription} An object with an `unsubscribe` method that can
                     * be used to unsubscribe the observable from the store, and prevent further
                     * emission of values from the observable.
                     */
                    subscribe: function(Ge) {
                      if (typeof Ge != "object" || Ge === null)
                        throw new Error(h(11));
                      function qt() {
                        Ge.next && Ge.next(de());
                      }
                      qt();
                      var Pi = Ie(qt);
                      return {
                        unsubscribe: Pi
                      };
                    }
                  }, Me[u] = function() {
                    return this;
                  }, Me;
                }
                return ie({
                  type: b.INIT
                }), T = {
                  dispatch: ie,
                  subscribe: xe,
                  getState: de,
                  replaceReducer: fe
                }, T[u] = $e, T;
              }
              var S = x;
              function k(A) {
                Object.keys(A).forEach(function(y) {
                  var w = A[y], T = w(void 0, {
                    type: b.INIT
                  });
                  if (typeof T > "u")
                    throw new Error(h(12));
                  if (typeof w(void 0, {
                    type: b.PROBE_UNKNOWN_ACTION()
                  }) > "u")
                    throw new Error(h(13));
                });
              }
              function C(A) {
                for (var y = Object.keys(A), w = {}, T = 0; T < y.length; T++) {
                  var P = y[T];
                  typeof A[P] == "function" && (w[P] = A[P]);
                }
                var R = Object.keys(w), Q;
                try {
                  k(w);
                } catch (z) {
                  Q = z;
                }
                return function(W, G) {
                  if (W === void 0 && (W = {}), Q)
                    throw Q;
                  for (var de = !1, xe = {}, ie = 0; ie < R.length; ie++) {
                    var fe = R[ie], $e = w[fe], Me = W[fe], Ie = $e(Me, G);
                    if (typeof Ie > "u")
                      throw G && G.type, new Error(h(14));
                    xe[fe] = Ie, de = de || Ie !== Me;
                  }
                  return de = de || R.length !== Object.keys(W).length, de ? xe : W;
                };
              }
              function _(A, y) {
                return function() {
                  return y(A.apply(this, arguments));
                };
              }
              function $(A, y) {
                if (typeof A == "function")
                  return _(A, y);
                if (typeof A != "object" || A === null)
                  throw new Error(h(16));
                var w = {};
                for (var T in A) {
                  var P = A[T];
                  typeof P == "function" && (w[T] = _(P, y));
                }
                return w;
              }
              function L() {
                for (var A = arguments.length, y = new Array(A), w = 0; w < A; w++)
                  y[w] = arguments[w];
                return y.length === 0 ? function(T) {
                  return T;
                } : y.length === 1 ? y[0] : y.reduce(function(T, P) {
                  return function() {
                    return T(P.apply(void 0, arguments));
                  };
                });
              }
              function E() {
                for (var A = arguments.length, y = new Array(A), w = 0; w < A; w++)
                  y[w] = arguments[w];
                return function(T) {
                  return function() {
                    var P = T.apply(void 0, arguments), R = function() {
                      throw new Error(h(15));
                    }, Q = {
                      getState: P.getState,
                      dispatch: function() {
                        return R.apply(void 0, arguments);
                      }
                    }, z = y.map(function(W) {
                      return W(Q);
                    });
                    return R = L.apply(void 0, z)(P.dispatch), r(r({}, P), {}, {
                      dispatch: R
                    });
                  };
                };
              }
            }
          )
          /******/
        }, i = {};
        function s(o) {
          var l = i[o];
          if (l !== void 0)
            return l.exports;
          var c = i[o] = {
            /******/
            // no module.id needed
            /******/
            // no module.loaded needed
            /******/
            exports: {}
            /******/
          };
          return t[o].call(c.exports, c, c.exports, s), c.exports;
        }
        (function() {
          s.n = function(o) {
            var l = o && o.__esModule ? (
              /******/
              function() {
                return o.default;
              }
            ) : (
              /******/
              function() {
                return o;
              }
            );
            return s.d(l, { a: l }), l;
          };
        })(), function() {
          s.d = function(o, l) {
            for (var c in l)
              s.o(l, c) && !s.o(o, c) && Object.defineProperty(o, c, { enumerable: !0, get: l[c] });
          };
        }(), function() {
          s.o = function(o, l) {
            return Object.prototype.hasOwnProperty.call(o, l);
          };
        }(), function() {
          s.r = function(o) {
            typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(o, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(o, "__esModule", { value: !0 });
          };
        }();
        var n = {};
        return function() {
          var o = s(373), l = /* @__PURE__ */ s.n(o);
          s(187), s(883), s(789), s(686), n.default = l();
        }(), n = n.default, n;
      }()
    );
  });
})(bb);
var vb = bb.exports;
const $d = /* @__PURE__ */ _A(vb), yb = /* @__PURE__ */ P0({
  __proto__: null,
  default: $d
}, [vb]);
const CA = ["required"], TA = {
  value: "",
  disabled: "",
  selected: ""
}, uH = j({
  __name: "FormAutocomplete",
  props: {
    modelValue: {},
    placeholder: { default: "Selecione" },
    options: { default: () => [] },
    label: {},
    size: { default: "md" },
    last: { type: Boolean },
    template: {},
    position: { default: "bottom" },
    config: { default: () => ({}) },
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "open", "close", "update"],
  setup(a, { expose: e, emit: t }) {
    var u;
    const i = t, s = $d || yb, n = a, o = `ui-form-select-${(u = yt()) == null ? void 0 : u.uid}`, l = Ci(), c = Z(!1);
    let d;
    const f = (g) => n.template.choice(g), p = ge(() => {
      var O;
      const g = zn(n.options);
      g.options = g.options ?? [];
      const b = {
        searchEnabled: !0,
        searchChoices: !0,
        removeItems: !0,
        position: n.position,
        removeItemButton: !0,
        addItems: !0,
        placeholder: !0,
        noResultsText: "Nenhum resultado encontrado",
        noChoicesText: "Sem opções para escolher",
        items: [],
        choices: g,
        allowHTML: !1,
        searchResultLimit: 20,
        options: [],
        ...n.config
      };
      return (O = n.template) != null && O.choice && (b.callbackOnCreateTemplates = function(x) {
        return {
          choice: ({ classNames: S }, k) => x(`
						<div class="${S.item} ${S.itemChoice} ${k.disabled ? S.itemDisabled : S.itemSelectable}"
						data-select-text="${this.config.itemSelectText}"
						data-choice ${k.disabled ? 'data-choice-disabled aria-disabled="true"' : "data-choice-selectable"}
						data-id="${k.id}"
						data-value="${k.value}" ${k.groupId > 0 ? 'role="treeitem"' : 'role="option"'}
						>
							${f(k)}
						</div>
					`)
        };
      }), b;
    }), m = () => {
      $s(() => {
        l.value && l.value.destroy(), d && (l.value = new s(d, p.value), r());
      });
    }, v = (g, b) => {
      i("update:modelValue", g), i("update", g, b);
    }, r = () => {
      $s(() => {
        l.value && (n.modelValue == null ? l.value.setChoiceByValue("") : l.value.setChoiceByValue(n.modelValue));
      });
    };
    function h() {
      l.value && l.value.showDropdown();
    }
    return at(() => {
      d = document.getElementById(`${o}`), d && (d.addEventListener("showDropdown", () => i("open"), !1), d.addEventListener(
        "change",
        function(g) {
          v(l.value.getValue(!0), l.value.getValue());
        },
        !1
      )), zt(
        () => n.modelValue,
        () => r()
      ), zt(
        () => [n.options],
        () => m(),
        { immediate: !0, deep: !0 }
      );
    }), e({
      setChoices(g, b) {
        l.value && l.value.setChoices(g, void 0, void 0, b);
      }
    }), (g, b) => (M(), D("div", {
      class: he(["ui-form-autocomplete", [{ "-focus": c.value, "mb-0": g.last }, `-${g.size}`]])
    }, [
      g.label ? (M(), q(pd, {
        key: 0,
        label: g.label,
        onClick: h
      }, null, 8, ["label"])) : X("", !0),
      I("select", {
        class: "ui-form-select",
        id: o,
        required: g.required
      }, [
        I("option", TA, ne(g.placeholder), 1)
      ], 8, CA)
    ], 2));
  }
});
const AA = {
  key: 0,
  class: "ui-form-spinbutton-loader"
}, $A = /* @__PURE__ */ I("svg", {
  viewBox: "0 0 16 16",
  width: "1em",
  height: "1em",
  focusable: "false",
  role: "img",
  "aria-label": "dash",
  "aria-hidden": "true",
  xmlns: "http://www.w3.org/2000/svg",
  fill: "currentColor",
  class: "icon"
}, [
  /* @__PURE__ */ I("g", { transform: "translate(8 8) scale(1.25 1.25) translate(-8 -8)" }, [
    /* @__PURE__ */ I("path", { d: "M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z" })
  ])
], -1), EA = ["disabled"], PA = ["value", "readonly", "placeholder"], LA = /* @__PURE__ */ I("svg", {
  viewBox: "0 0 16 16",
  width: "1em",
  height: "1em",
  focusable: "false",
  role: "img",
  "aria-label": "plus",
  "aria-hidden": "true",
  xmlns: "http://www.w3.org/2000/svg",
  fill: "currentColor",
  class: "icon"
}, [
  /* @__PURE__ */ I("g", { transform: "translate(8 8) scale(1.25 1.25) translate(-8 -8)" }, [
    /* @__PURE__ */ I("path", { d: "M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z" })
  ])
], -1), fH = j({
  __name: "FormSpinbutton",
  props: {
    modelValue: { default: 1 },
    min: {},
    max: {},
    placeholder: {},
    size: {},
    step: { default: 1 },
    loading: { type: Boolean },
    disabled: { type: Boolean },
    inputable: { type: Boolean }
  },
  emits: ["update:modelValue", "change"],
  setup(a, { emit: e }) {
    const t = e, i = a, s = Z(!1), n = Z(!1), o = (p) => {
      t("update:modelValue", p), t("change", p);
    }, l = () => {
      (i.max === void 0 || i.modelValue < Number(i.max)) && o(Number(i.modelValue) + Number(i.step));
    }, c = () => {
      (i.min === void 0 || i.modelValue > Number(i.min)) && o(Number(i.modelValue) - Number(i.step));
    }, d = ge(() => {
      const p = [];
      return i.size && p.push(`-${i.size}`), i.disabled && p.push("-disabled"), p;
    }), f = (p) => {
      let m = p.target.value;
      i.max && m > i.max && (m = i.max), i.min && m < i.min && (m = i.min), p.target.value = m, m != i.modelValue && o(Number(m));
    };
    return Lt(() => {
      n.value = !1, s.value = !1, i.max && i.modelValue >= Number(i.max) && (n.value = !0), i.max && i.modelValue <= Number(i.min) && (s.value = !0);
    }), (p, m) => (M(), D("div", {
      role: "group",
      tabindex: "-1",
      class: he(["ui-form-spinbutton", d.value])
    }, [
      p.loading ? (M(), D("div", AA, [
        B(dn, {
          class: "ui-form-spinbutton-loader-spin",
          size: "18"
        })
      ])) : X("", !0),
      B(Le, {
        disabled: p.disabled || s.value,
        tabindex: "-1",
        type: "button",
        "aria-controls": "demo-sb",
        "aria-label": "Decrement",
        "aria-keyshortcuts": "ArrowDown",
        class: he([d.value, "ui-form-spinbutton-action"]),
        onClick: c
      }, {
        default: U(() => [
          $A
        ]),
        _: 1
      }, 8, ["disabled", "class"]),
      I("div", {
        disabled: p.disabled,
        class: "output",
        dir: "ltr",
        role: "spinbutton",
        tabindex: "0",
        "aria-live": "off",
        "aria-valuemin": "1",
        "aria-valuemax": "100",
        "aria-valuenow": "50",
        "aria-valuetext": "50"
      }, [
        I("input", {
          type: "tel",
          value: p.modelValue,
          readonly: !p.inputable,
          onBlur: f,
          onFocus: m[0] || (m[0] = (v) => v.target.select()),
          placeholder: p.placeholder
        }, null, 40, PA)
      ], 8, EA),
      B(Le, {
        tabindex: "-1",
        disabled: p.disabled || n.value,
        type: "button",
        "aria-controls": "demo-sb",
        "aria-label": "Increment",
        "aria-keyshortcuts": "ArrowUp",
        class: he([d.value, "ui-form-spinbutton-action"]),
        onClick: l
      }, {
        default: U(() => [
          LA
        ]),
        _: 1
      }, 8, ["disabled", "class"])
    ], 2));
  }
});
const MA = {}, DA = { class: "ui-form-helper" };
function RA(a, e) {
  return M(), D("div", DA, [
    te(a.$slots, "default")
  ]);
}
const pH = /* @__PURE__ */ gt(MA, [["render", RA]]);
const IA = {
  key: 0,
  class: "ui-form-validation"
}, QA = {
  key: 0,
  class: "ui-form-validation-key"
}, NA = j({
  __name: "FormValidation",
  props: {
    modelValue: {},
    translate: {},
    scrollToTop: { type: Boolean },
    title: { default: "Erros encontrados" },
    hideKey: { type: Boolean },
    noDismissible: { type: Boolean }
  },
  emits: ["update:modelValue"],
  setup(a, { emit: e }) {
    const t = e, i = a, s = (o) => {
      if (!i.translate)
        return o;
      const l = o.split(".");
      if (l.length >= 3) {
        const c = l[0], d = Number(l[1]) + 1, f = l[2], p = i.translate[c];
        return p[f] ? `${p[c]}: ${p[f]} #${d}` : o;
      }
      return i.translate[o] || o;
    }, n = () => {
      t("update:modelValue", null);
    };
    return Lt(() => {
      const o = i.modelValue, l = document.querySelectorAll("[class*='form-error-']");
      gi(l, (c) => {
        c.classList.remove("-invalid");
      }), o && i.scrollToTop && (window.scrollTo(0, 0), gi(o, (c, d) => {
        const f = document.getElementsByClassName(`error.${d}`);
        f[0] && f[0].classList.add("-invalid");
      }));
    }), (o, l) => o.modelValue != null ? (M(), D("div", IA, [
      B(ih, {
        variant: "danger",
        show: !!o.modelValue,
        title: o.title,
        dismissible: !o.noDismissible,
        onDismissed: n
      }, {
        default: U(() => [
          (M(!0), D(ke, null, Ae(o.modelValue, (c, d) => (M(), D("ul", { key: d }, [
            (M(!0), D(ke, null, Ae(c, (f) => (M(), D("li", { key: f }, [
              o.hideKey ? X("", !0) : (M(), D("b", QA, ne(s(String(d))) + ":", 1)),
              ye(" " + ne(f), 1)
            ]))), 128))
          ]))), 128))
        ]),
        _: 1
      }, 8, ["show", "title", "dismissible"])
    ])) : X("", !0);
  }
}), Ob = /* @__PURE__ */ gt(NA, [["__scopeId", "data-v-7a5dd414"]]);
const FA = { class: "ui-avatar-content" }, WA = ["src"], gH = j({
  __name: "Avatar",
  props: {
    title: {},
    variant: {},
    size: {},
    label: {},
    src: {}
  },
  setup(a) {
    const e = a, t = Z([]), i = Z({});
    return e.size && (i.value.width = `${e.size}px`, i.value.height = `${e.size}px`, i.value.fontSize = `${Number(e.size) * 0.33}px`), e.variant && t.value.push(`-${e.variant}`), (s, n) => (M(), D("div", {
      class: he(["ui-avatar", t.value]),
      style: wt(i.value)
    }, [
      I("div", FA, [
        s.src ? (M(), D("img", {
          key: 0,
          src: s.src
        }, null, 8, WA)) : te(s.$slots, "default", { key: 1 }, () => [
          ye(ne(s.label), 1)
        ])
      ])
    ], 6));
  }
});
const BA = ["value", "max"], mH = j({
  __name: "ProgressBar",
  props: {
    height: { default: "3px" },
    max: { default: 100 },
    value: {}
  },
  setup(a) {
    return ol((e) => ({
      "13bdfeaa": e.height
    })), (e, t) => (M(), D("progress", {
      class: "ui-progress-bar",
      value: e.value,
      max: e.max
    }, null, 8, BA));
  }
});
const wn = j({
  __name: "Skeleton",
  props: {
    width: {},
    height: {}
  },
  setup(a) {
    const e = a, t = ge(() => {
      const i = {};
      return e.width && (i.width = e.width), e.height && (i.height = e.height), i;
    });
    return (i, s) => (M(), D("div", {
      class: "ui-skeleton",
      style: wt(t.value)
    }, null, 4));
  }
});
const zA = { key: 0 }, XA = { key: 0 }, YA = {
  key: 0,
  width: "1"
}, VA = j({
  __name: "SkeletonTable",
  props: {
    cols: { default: 5 },
    hideHeader: { type: Boolean },
    lines: {},
    noBorder: { type: Boolean },
    padding: { default: "16px" },
    rows: { default: 3 },
    width: {},
    withAction: { type: [Boolean, String, Number] },
    withAvatar: { type: Boolean }
  },
  setup(a) {
    ol((i) => ({
      "797e0b5c": i.padding
    }));
    const e = a, t = ge(() => {
      const i = {};
      return e.width && (i.width = e.width), i;
    });
    return (i, s) => (M(), D("table", {
      class: he(["ui-table ui-skeleton-table", { "-no-border": i.noBorder }]),
      style: wt(t.value)
    }, [
      i.hideHeader ? X("", !0) : (M(), D("thead", zA, [
        I("tr", null, [
          i.withAvatar ? (M(), D("th", XA)) : X("", !0),
          (M(!0), D(ke, null, Ae(Number(i.cols), (n) => (M(), D("th", { key: n }, [
            B(wn)
          ]))), 128)),
          (M(!0), D(ke, null, Ae(Number(i.withAction), (n) => (M(), D("th", {
            width: "1",
            key: n
          }))), 128))
        ])
      ])),
      I("tbody", null, [
        (M(!0), D(ke, null, Ae(Number(i.rows), (n) => (M(), D("tr", { key: n }, [
          i.withAvatar ? (M(), D("td", YA, [
            B(wn, {
              width: "30px",
              height: "30px",
              style: { "border-radius": "100%" }
            })
          ])) : X("", !0),
          (M(!0), D(ke, null, Ae(Number(i.cols), (o) => (M(), D("td", { key: o }, [
            B(wn, { width: "85%" }),
            Number(i.lines) > 1 ? (M(), q(wn, {
              key: 0,
              width: "40%",
              height: "14px"
            })) : X("", !0)
          ]))), 128)),
          (M(!0), D(ke, null, Ae(Number(i.withAction), (o) => (M(), D("td", {
            width: "1",
            key: o
          }, [
            B(wn, { width: "32px" })
          ]))), 128))
        ]))), 128))
      ])
    ], 6));
  }
});
const HA = { class: "ui-skeleton-list" }, bH = j({
  __name: "SkeletonList",
  props: {
    cols: { default: 5 },
    rows: { default: 3 }
  },
  setup(a) {
    return (e, t) => (M(), D("div", HA, [
      (M(!0), D(ke, null, Ae(Number(e.rows), (i) => (M(), D("div", {
        class: "ui-skeleton-list-item",
        key: i
      }, [
        B(wn, {
          width: "50%",
          height: "10px"
        })
      ]))), 128))
    ]));
  }
});
const GA = ["src"], vH = j({
  __name: "Image",
  props: {
    src: {},
    size: { default: 50 },
    rounded: { type: Boolean }
  },
  setup(a) {
    ol((n) => ({
      "564d42a6": i.value.width,
      "25cde73c": s.value.fontSize,
      e04a70d8: s.value.width,
      "0a88a0e7": s.value.minHeight
    }));
    const e = a, t = ge(() => {
      let n = [];
      return e.src || n.push("-no-image"), e.rounded && n.push("-is-rounded"), n;
    }), i = ge(() => {
      const n = {};
      return e.size && (n.width = `${e.size}px`), n;
    }), s = ge(() => {
      const n = {};
      return e.size && (n.fontSize = `${Number(e.size) / 2.5}px`, n.width = `${Number(e.size) / 2.5}px`, n.minHeight = `${Number(e.size) / 2.5}px`), n;
    });
    return (n, o) => (M(), D("div", {
      class: he(["ui-image", t.value])
    }, [
      n.src ? (M(), D("img", {
        key: 0,
        src: n.src,
        class: "ui-image-content"
      }, null, 8, GA)) : (M(), q(Pe, {
        key: 1,
        name: "wallpaper",
        class: "ui-image-icon",
        size: "22"
      }))
    ], 2));
  }
});
const jA = { class: "ui-form-tags-content" }, UA = ["placeholder", "disabled"], ZA = {
  key: 2,
  class: "ui-form-tags-actions"
}, yH = j({
  __name: "FormTags",
  props: {
    modelValue: {},
    placeholder: { default: "Criar tags" },
    label: {},
    closeOnSelect: { type: Boolean },
    last: { type: Boolean },
    actions: {},
    options: { default: [] },
    create: { type: Boolean, default: !0 },
    variant: {},
    disabled: { type: Boolean }
  },
  emits: ["update:modelValue", "update", "open", "close", "add", "remove"],
  setup(a, { emit: e }) {
    var v;
    const t = $d || yb, i = e, s = a, n = `ui-form-select-${(v = yt()) == null ? void 0 : v.uid}`, o = Ci();
    let l;
    const c = (r) => {
      i("update:modelValue", r), i("update", r);
    }, d = () => {
      $s(() => {
        if (o.value && o.value.destroy(), l) {
          const r = {
            searchEnabled: !0,
            searchChoices: !0,
            removeItems: !0,
            removeItemButton: !0,
            addItems: !0,
            position: "bottom",
            create: !1,
            placeholder: !0,
            placeholderValue: s.placeholder || "Selecione",
            noResultsText: "Nenhum resultado encontrado",
            noChoicesText: "Sem opções para escolher",
            items: [],
            choices: zn(s.options),
            allowHTML: !0
          };
          o.value = new t(l, r), p(), s.options.length && m().length && f();
        }
      });
    }, f = () => {
      m().map((r) => {
        o.value.setChoiceByValue(Number(r));
      });
    }, p = () => {
      $s(() => {
        if (o.value) {
          const r = m();
          r == null && o.value.clearStore(), s.create && Pt(r) && (o.value.clearStore(), o.value.setValue(r));
        }
      });
    }, m = () => s.modelValue && !Pt(s.modelValue) ? s.modelValue.split(",") : s.modelValue ?? [];
    return at(() => {
      l = document.querySelector(`#${n}`), l && (l.addEventListener(
        "change",
        function(r) {
          const h = o.value.getValue(!0);
          c(h.join(",")), s.closeOnSelect && o.value.hideDropdown();
        },
        !1
      ), l.addEventListener(
        "addItem",
        function(r) {
          i("add", r.detail);
        },
        !1
      ), l.addEventListener(
        "removeItem",
        function(r) {
          i("remove", r.detail);
        },
        !1
      )), zt(
        () => s.modelValue,
        () => p(),
        { immediate: !0 }
      ), zt(
        () => [s.options],
        () => d(),
        { immediate: !0, deep: !0 }
      );
    }), (r, h) => {
      var u;
      return M(), D("div", {
        class: he(["ui-form-tags", { "-has-value": (u = r.modelValue) == null ? void 0 : u.length, "mb-0": r.last, variant: `-${r.variant}` }])
      }, [
        r.label ? (M(), q(pd, {
          key: 0,
          label: r.label,
          action: {
            label: "Remover"
          }
        }, null, 8, ["label"])) : X("", !0),
        I("div", jA, [
          s.create ? (M(), D("input", {
            key: 0,
            ref: "selectRef",
            id: n,
            type: "text",
            autocomplete: "off",
            placeholder: r.placeholder,
            disabled: r.disabled
          }, null, 8, UA)) : (M(), D("select", {
            key: 1,
            multiple: "",
            ref: "selectRef",
            id: n,
            autocomplete: "off"
          }, null, 512)),
          r.actions ? (M(), D("div", ZA, [
            (M(!0), D(ke, null, Ae(r.actions, (g) => (M(), q(Le, {
              label: g.label,
              onClick: g.onAction
            }, null, 8, ["label", "onClick"]))), 256))
          ])) : X("", !0)
        ])
      ], 2);
    };
  }
});
const qA = j({
  __name: "Tag",
  props: {
    label: {},
    variant: { default: "default" }
  },
  emits: ["remove"],
  setup(a, { emit: e }) {
    const t = a, i = e, s = () => {
      i("remove");
    }, n = ge(() => {
      let o = [];
      return t.variant && o.push(`-variant-${t.variant}`), o;
    });
    return (o, l) => (M(), D("span", {
      class: he(["ui-tag", n.value])
    }, [
      te(o.$slots, "default", {}, () => [
        ye(ne(o.label), 1)
      ]),
      B(Pe, {
        name: "close",
        class: "ui-tag-close",
        onClick: s
      })
    ], 2));
  }
});
const KA = {}, JA = { class: "ui-tag-list" };
function e$(a, e) {
  return M(), D("div", JA, [
    te(a.$slots, "default")
  ]);
}
const t$ = /* @__PURE__ */ gt(KA, [["render", e$]]);
const Hr = j({
  __name: "TextStyle",
  props: {
    block: { type: Boolean },
    label: {},
    tag: { default: "span" },
    variant: {}
  },
  setup(a) {
    const e = a, t = ge(() => [e.variant ? `-variant-${e.variant}` : "", e.block ? "-block" : ""]);
    return (i, s) => (M(), q(Ut(i.tag), {
      class: he(["ui-text-style", t.value])
    }, {
      default: U(() => [
        te(i.$slots, "default", {}, () => [
          ye(ne(i.label), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
const i$ = { class: "ui-page-actions" }, s$ = {
  key: 0,
  class: "ui-page-actions-secondary"
}, n$ = {
  key: 1,
  class: "ui-page-actions-primary"
}, OH = j({
  __name: "PageActions",
  props: {
    primaryAction: {},
    secondaryActions: {}
  },
  setup(a) {
    return (e, t) => {
      var i;
      return M(), D("div", i$, [
        e.secondaryActions ? (M(), D("div", s$, [
          (M(!0), D(ke, null, Ae(e.secondaryActions, (s) => (M(), q(Le, {
            variant: s.variant,
            onClick: s.onAction,
            outline: ""
          }, {
            default: U(() => [
              ye(ne(s.label), 1)
            ]),
            _: 2
          }, 1032, ["variant", "onClick"]))), 256))
        ])) : X("", !0),
        e.primaryAction ? (M(), D("div", n$, [
          e.primaryAction ? (M(), q(Le, {
            key: 0,
            variant: "success",
            type: "submit",
            onClick: (i = e.primaryAction) == null ? void 0 : i.onAction,
            to: e.primaryAction.to,
            leadingIcon: e.primaryAction.leadingIcon
          }, {
            default: U(() => [
              ye(ne(e.primaryAction.label), 1)
            ]),
            _: 1
          }, 8, ["onClick", "to", "leadingIcon"])) : X("", !0)
        ])) : X("", !0)
      ]);
    };
  }
});
function xb(a, e, t, i, s = {}) {
  e instanceof HTMLCollection || e instanceof NodeList ? e = Array.from(e) : Array.isArray(e) || (e = [e]), Array.isArray(t) || (t = [t]);
  for (const n of e)
    for (const o of t)
      n[a](o, i, { capture: !1, ...s });
  return Array.prototype.slice.call(arguments, 1);
}
const lt = xb.bind(null, "addEventListener"), Ki = xb.bind(null, "removeEventListener");
function Ed(a) {
  const e = document.createElement("div");
  return e.innerHTML = a.trim(), e.firstElementChild;
}
function wb(a) {
  const e = (i, s) => {
    const n = i.getAttribute(s);
    return i.removeAttribute(s), n;
  }, t = (i, s = {}) => {
    const n = e(i, ":obj"), o = e(i, ":ref"), l = n ? s[n] = {} : s;
    o && (s[o] = i);
    for (const c of Array.from(i.children)) {
      const d = e(c, ":arr"), f = t(c, d ? {} : l);
      d && (l[d] || (l[d] = [])).push(Object.keys(f).length ? f : c);
    }
    return s;
  };
  return t(Ed(a));
}
function Sb(a) {
  let e = a.path || a.composedPath && a.composedPath();
  if (e)
    return e;
  let t = a.target.parentElement;
  for (e = [a.target, t]; t = t.parentElement; )
    e.push(t);
  return e.push(document, window), e;
}
function kb(a) {
  return a instanceof Element ? a : typeof a == "string" ? a.split(/>>/g).reduce((e, t, i, s) => (e = e.querySelector(t), i < s.length - 1 ? e.shadowRoot : e), document) : null;
}
function _b(a, e = (t) => t) {
  function t(i) {
    const s = [1e-3, 0.01, 0.1][Number(i.shiftKey || i.ctrlKey * 2)] * (i.deltaY < 0 ? 1 : -1);
    let n = 0, o = a.selectionStart;
    a.value = a.value.replace(/[\d.]+/g, (l, c) => c <= o && c + l.length >= o ? (o = c, e(Number(l), s, n)) : (n++, l)), a.focus(), a.setSelectionRange(o, o), i.preventDefault(), a.dispatchEvent(new Event("input"));
  }
  lt(a, "focus", () => lt(window, "wheel", t, { passive: !1 })), lt(a, "blur", () => Ki(window, "wheel", t));
}
const r$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  adjustableInputNumbers: _b,
  createElementFromString: Ed,
  createFromTemplate: wb,
  eventPath: Sb,
  off: Ki,
  on: lt,
  resolveElement: kb
}, Symbol.toStringTag, { value: "Module" })), { min: Dr, max: a$, floor: o$, round: l$ } = Math;
function c$(a) {
  if (a.toLowerCase() === "black")
    return "#000";
  const e = document.createElement("canvas").getContext("2d");
  return e.fillStyle = a, e.fillStyle === "#000" ? null : e.fillStyle;
}
function Pd(a, e, t) {
  a = a / 360 * 6, e /= 100, t /= 100;
  const i = o$(a), s = a - i, n = t * (1 - e), o = t * (1 - s * e), l = t * (1 - (1 - s) * e), c = i % 6, d = [t, o, n, n, l, t][c], f = [l, t, t, o, n, n][c], p = [n, n, l, t, t, o][c];
  return [
    d * 255,
    f * 255,
    p * 255
  ];
}
function h$(a, e, t) {
  return Pd(a, e, t).map(
    (i) => l$(i).toString(16).padStart(2, "0")
  );
}
function d$(a, e, t) {
  const i = Pd(a, e, t), s = i[0] / 255, n = i[1] / 255, o = i[2] / 255, l = Dr(1 - s, 1 - n, 1 - o), c = l === 1 ? 0 : (1 - s - l) / (1 - l), d = l === 1 ? 0 : (1 - n - l) / (1 - l), f = l === 1 ? 0 : (1 - o - l) / (1 - l);
  return [
    c * 100,
    d * 100,
    f * 100,
    l * 100
  ];
}
function u$(a, e, t) {
  e /= 100, t /= 100;
  const i = (2 - e) * t / 2;
  return i !== 0 && (i === 1 ? e = 0 : i < 0.5 ? e = e * t / (i * 2) : e = e * t / (2 - i * 2)), [
    a,
    e * 100,
    i * 100
  ];
}
function Ld(a, e, t) {
  a /= 255, e /= 255, t /= 255;
  const i = Dr(a, e, t), s = a$(a, e, t), n = s - i;
  let o, l;
  const c = s;
  if (n === 0)
    o = l = 0;
  else {
    l = n / s;
    const d = ((s - a) / 6 + n / 2) / n, f = ((s - e) / 6 + n / 2) / n, p = ((s - t) / 6 + n / 2) / n;
    a === s ? o = p - f : e === s ? o = 1 / 3 + d - p : t === s && (o = 2 / 3 + f - d), o < 0 ? o += 1 : o > 1 && (o -= 1);
  }
  return [
    o * 360,
    l * 100,
    c * 100
  ];
}
function f$(a, e, t, i) {
  a /= 100, e /= 100, t /= 100, i /= 100;
  const s = (1 - Dr(1, a * (1 - i) + i)) * 255, n = (1 - Dr(1, e * (1 - i) + i)) * 255, o = (1 - Dr(1, t * (1 - i) + i)) * 255;
  return [...Ld(s, n, o)];
}
function p$(a, e, t) {
  e /= 100, t /= 100, e *= t < 0.5 ? t : 1 - t;
  const i = 2 * e / (t + e) * 100, s = (t + e) * 100;
  return [a, isNaN(i) ? 0 : i, s];
}
function g$(a) {
  return Ld(...a.match(/.{2}/g).map((e) => parseInt(e, 16)));
}
function m$(a) {
  a = a.match(/^[a-zA-Z]+$/) ? c$(a) : a;
  const e = {
    cmyk: /^cmyk[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)/i,
    rgba: /^((rgba)|rgb)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i,
    hsla: /^((hsla)|hsl)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i,
    hsva: /^((hsva)|hsv)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i,
    hexa: /^#?(([\dA-Fa-f]{3,4})|([\dA-Fa-f]{6})|([\dA-Fa-f]{8}))$/i
  }, t = (s) => s.map((n) => /^(|\d+)\.\d+|\d+$/.test(n) ? Number(n) : void 0);
  let i;
  e:
    for (const s in e) {
      if (!(i = e[s].exec(a)))
        continue;
      const n = (o) => !!i[2] == (typeof o == "number");
      switch (s) {
        case "cmyk": {
          const [, o, l, c, d] = t(i);
          if (o > 100 || l > 100 || c > 100 || d > 100)
            break e;
          return { values: f$(o, l, c, d), type: s };
        }
        case "rgba": {
          const [, , , o, l, c, d] = t(i);
          if (o > 255 || l > 255 || c > 255 || d < 0 || d > 1 || !n(d))
            break e;
          return { values: [...Ld(o, l, c), d], a: d, type: s };
        }
        case "hexa": {
          let [, o] = i;
          (o.length === 4 || o.length === 3) && (o = o.split("").map((d) => d + d).join(""));
          const l = o.substring(0, 6);
          let c = o.substring(6);
          return c = c ? parseInt(c, 16) / 255 : void 0, { values: [...g$(l), c], a: c, type: s };
        }
        case "hsla": {
          const [, , , o, l, c, d] = t(i);
          if (o > 360 || l > 100 || c > 100 || d < 0 || d > 1 || !n(d))
            break e;
          return { values: [...p$(o, l, c), d], a: d, type: s };
        }
        case "hsva": {
          const [, , , o, l, c, d] = t(i);
          if (o > 360 || l > 100 || c > 100 || d < 0 || d > 1 || !n(d))
            break e;
          return { values: [o, l, c, d], a: d, type: s };
        }
      }
    }
  return { values: null, type: null };
}
function wr(a = 0, e = 0, t = 0, i = 1) {
  const s = (o, l) => (c = -1) => l(~c ? o.map((d) => Number(d.toFixed(c))) : o), n = {
    h: a,
    s: e,
    v: t,
    a: i,
    toHSVA() {
      const o = [n.h, n.s, n.v, n.a];
      return o.toString = s(o, (l) => `hsva(${l[0]}, ${l[1]}%, ${l[2]}%, ${n.a})`), o;
    },
    toHSLA() {
      const o = [...u$(n.h, n.s, n.v), n.a];
      return o.toString = s(o, (l) => `hsla(${l[0]}, ${l[1]}%, ${l[2]}%, ${n.a})`), o;
    },
    toRGBA() {
      const o = [...Pd(n.h, n.s, n.v), n.a];
      return o.toString = s(o, (l) => `rgba(${l[0]}, ${l[1]}, ${l[2]}, ${n.a})`), o;
    },
    toCMYK() {
      const o = d$(n.h, n.s, n.v);
      return o.toString = s(o, (l) => `cmyk(${l[0]}%, ${l[1]}%, ${l[2]}%, ${l[3]}%)`), o;
    },
    toHEXA() {
      const o = h$(n.h, n.s, n.v), l = n.a >= 1 ? "" : Number((n.a * 255).toFixed(0)).toString(16).toUpperCase().padStart(2, "0");
      return l && o.push(l), o.toString = () => `#${o.join("").toUpperCase()}`, o;
    },
    clone: () => wr(n.h, n.s, n.v, n.a)
  };
  return n;
}
const Ia = (a) => Math.max(Math.min(a, 1), 0);
function ac(a) {
  const e = {
    // Assign default values
    options: Object.assign({
      lock: null,
      onchange: () => 0,
      onstop: () => 0
    }, a),
    _keyboard(n) {
      const { options: o } = e, { type: l, key: c } = n;
      if (document.activeElement === o.wrapper) {
        const { lock: d } = e.options, f = c === "ArrowUp", p = c === "ArrowRight", m = c === "ArrowDown", v = c === "ArrowLeft";
        if (l === "keydown" && (f || p || m || v)) {
          let r = 0, h = 0;
          d === "v" ? r = f || p ? 1 : -1 : d === "h" ? r = f || p ? -1 : 1 : (h = f ? -1 : m ? 1 : 0, r = v ? -1 : p ? 1 : 0), e.update(
            Ia(e.cache.x + 0.01 * r),
            Ia(e.cache.y + 0.01 * h)
          ), n.preventDefault();
        } else
          c.startsWith("Arrow") && (e.options.onstop(), n.preventDefault());
      }
    },
    _tapstart(n) {
      lt(document, ["mouseup", "touchend", "touchcancel"], e._tapstop), lt(document, ["mousemove", "touchmove"], e._tapmove), n.cancelable && n.preventDefault(), e._tapmove(n);
    },
    _tapmove(n) {
      const { options: o, cache: l } = e, { lock: c, element: d, wrapper: f } = o, p = f.getBoundingClientRect();
      let m = 0, v = 0;
      if (n) {
        const u = n && n.touches && n.touches[0];
        m = n ? (u || n).clientX : 0, v = n ? (u || n).clientY : 0, m < p.left ? m = p.left : m > p.left + p.width && (m = p.left + p.width), v < p.top ? v = p.top : v > p.top + p.height && (v = p.top + p.height), m -= p.left, v -= p.top;
      } else
        l && (m = l.x * p.width, v = l.y * p.height);
      c !== "h" && (d.style.left = `calc(${m / p.width * 100}% - ${d.offsetWidth / 2}px)`), c !== "v" && (d.style.top = `calc(${v / p.height * 100}% - ${d.offsetHeight / 2}px)`), e.cache = { x: m / p.width, y: v / p.height };
      const r = Ia(m / p.width), h = Ia(v / p.height);
      switch (c) {
        case "v":
          return o.onchange(r);
        case "h":
          return o.onchange(h);
        default:
          return o.onchange(r, h);
      }
    },
    _tapstop() {
      e.options.onstop(), Ki(document, ["mouseup", "touchend", "touchcancel"], e._tapstop), Ki(document, ["mousemove", "touchmove"], e._tapmove);
    },
    trigger() {
      e._tapmove();
    },
    update(n = 0, o = 0) {
      const { left: l, top: c, width: d, height: f } = e.options.wrapper.getBoundingClientRect();
      e.options.lock === "h" && (o = n), e._tapmove({
        clientX: l + d * n,
        clientY: c + f * o
      });
    },
    destroy() {
      const { options: n, _tapstart: o, _keyboard: l } = e;
      Ki(document, ["keydown", "keyup"], l), Ki([n.wrapper, n.element], "mousedown", o), Ki([n.wrapper, n.element], "touchstart", o, {
        passive: !1
      });
    }
  }, { options: t, _tapstart: i, _keyboard: s } = e;
  return lt([t.wrapper, t.element], "mousedown", i), lt([t.wrapper, t.element], "touchstart", i, {
    passive: !1
  }), lt(document, ["keydown", "keyup"], s), e;
}
function b$(a = {}) {
  a = Object.assign({
    onchange: () => 0,
    className: "",
    elements: []
  }, a);
  const e = lt(a.elements, "click", (t) => {
    a.elements.forEach(
      (i) => i.classList[t.target === i ? "add" : "remove"](a.className)
    ), a.onchange(t), t.stopPropagation();
  });
  return {
    destroy: () => Ki(...e)
  };
}
const v$ = (a) => {
  const {
    components: e,
    useAsButton: t,
    inline: i,
    appClass: s,
    theme: n,
    lockOpacity: o
  } = a.options, l = (p) => p ? "" : 'style="display:none" hidden', c = (p) => a._t(p), d = wb(`
      <div :ref="root" class="pickr">

        ${t ? "" : '<button type="button" :ref="button" class="pcr-button"></button>'}

        <div :ref="app" class="pcr-app ${s || ""}" data-theme="${n}" ${i ? 'style="position: unset"' : ""} aria-label="${c("ui:dialog")}" role="window">
          <div class="pcr-selection" ${l(e.palette)}>
            <div :obj="preview" class="pcr-color-preview" ${l(e.preview)}>
              <button type="button" :ref="lastColor" class="pcr-last-color" aria-label="${c("btn:last-color")}"></button>
              <div :ref="currentColor" class="pcr-current-color"></div>
            </div>

            <div :obj="palette" class="pcr-color-palette">
              <div :ref="picker" class="pcr-picker"></div>
              <div :ref="palette" class="pcr-palette" tabindex="0" aria-label="${c("aria:palette")}" role="listbox"></div>
            </div>

            <div :obj="hue" class="pcr-color-chooser" ${l(e.hue)}>
              <div :ref="picker" class="pcr-picker"></div>
              <div :ref="slider" class="pcr-hue pcr-slider" tabindex="0" aria-label="${c("aria:hue")}" role="slider"></div>
            </div>

            <div :obj="opacity" class="pcr-color-opacity" ${l(e.opacity)}>
              <div :ref="picker" class="pcr-picker"></div>
              <div :ref="slider" class="pcr-opacity pcr-slider" tabindex="0" aria-label="${c("aria:opacity")}" role="slider"></div>
            </div>
          </div>

          <div class="pcr-swatches ${e.palette ? "" : "pcr-last"}" :ref="swatches"></div>

          <div :obj="interaction" class="pcr-interaction" ${l(Object.keys(e.interaction).length)}>
            <input :ref="result" class="pcr-result" type="text" spellcheck="false" ${l(e.interaction.input)} aria-label="${c("aria:input")}">

            <input :arr="options" class="pcr-type" data-type="HEXA" value="${o ? "HEX" : "HEXA"}" type="button" ${l(e.interaction.hex)}>
            <input :arr="options" class="pcr-type" data-type="RGBA" value="${o ? "RGB" : "RGBA"}" type="button" ${l(e.interaction.rgba)}>
            <input :arr="options" class="pcr-type" data-type="HSLA" value="${o ? "HSL" : "HSLA"}" type="button" ${l(e.interaction.hsla)}>
            <input :arr="options" class="pcr-type" data-type="HSVA" value="${o ? "HSV" : "HSVA"}" type="button" ${l(e.interaction.hsva)}>
            <input :arr="options" class="pcr-type" data-type="CMYK" value="CMYK" type="button" ${l(e.interaction.cmyk)}>

            <input :ref="save" class="pcr-save" value="${c("btn:save")}" type="button" ${l(e.interaction.save)} aria-label="${c("aria:btn:save")}">
            <input :ref="cancel" class="pcr-cancel" value="${c("btn:cancel")}" type="button" ${l(e.interaction.cancel)} aria-label="${c("aria:btn:cancel")}">
            <input :ref="clear" class="pcr-clear" value="${c("btn:clear")}" type="button" ${l(e.interaction.clear)} aria-label="${c("aria:btn:clear")}">
          </div>
        </div>
      </div>
    `), f = d.interaction;
  return f.options.find((p) => !p.hidden && !p.classList.add("active")), f.type = () => f.options.find((p) => p.classList.contains("active")), d;
};
/*! NanoPop 2.3.0 MIT | https://github.com/Simonwep/nanopop */
const y$ = {
  variantFlipOrder: { start: "sme", middle: "mse", end: "ems" },
  positionFlipOrder: { top: "tbrl", right: "rltb", bottom: "btrl", left: "lrbt" },
  position: "bottom",
  margin: 8,
  padding: 0
}, O$ = (a, e, t) => {
  const {
    container: i,
    arrow: s,
    margin: n,
    padding: o,
    position: l,
    variantFlipOrder: c,
    positionFlipOrder: d
  } = {
    container: document.documentElement.getBoundingClientRect(),
    ...y$,
    ...t
  }, { left: f, top: p } = e.style;
  e.style.left = "0", e.style.top = "0";
  const m = a.getBoundingClientRect(), v = e.getBoundingClientRect(), r = {
    t: m.top - v.height - n,
    b: m.bottom + n,
    r: m.right + n,
    l: m.left - v.width - n
  }, h = {
    vs: m.left,
    vm: m.left + m.width / 2 - v.width / 2,
    ve: m.left + m.width - v.width,
    hs: m.top,
    hm: m.bottom - m.height / 2 - v.height / 2,
    he: m.bottom - v.height
  }, [u, g = "middle"] = l.split("-"), b = d[u], O = c[g], { top: x, left: S, bottom: k, right: C } = i;
  for (const _ of b) {
    const $ = _ === "t" || _ === "b";
    let L = r[_];
    const [E, A] = $ ? ["top", "left"] : ["left", "top"], [y, w] = $ ? [v.height, v.width] : [v.width, v.height], [T, P] = $ ? [k, C] : [C, k], [R, Q] = $ ? [x, S] : [S, x];
    if (!(L < R || L + y + o > T))
      for (const z of O) {
        let W = h[($ ? "v" : "h") + z];
        if (!(W < Q || W + w + o > P)) {
          if (W -= v[A], L -= v[E], e.style[A] = `${W}px`, e.style[E] = `${L}px`, s) {
            const G = $ ? m.width / 2 : m.height / 2, de = G * 2 < w ? m[A] + G : W + w / 2;
            L < m[E] && (L += y), s.style[A] = `${de}px`, s.style[E] = `${L}px`;
          }
          return _ + z;
        }
      }
  }
  return e.style.left = f, e.style.top = p, null;
}, x$ = (a, e, t) => {
  const i = typeof a == "object" && !(a instanceof HTMLElement) ? a : { reference: a, popper: e, ...t };
  return {
    /**
     * Repositions the current popper.
     * @param options Optional options which get merged with the current ones.
     */
    update(s = i) {
      const { reference: n, popper: o } = Object.assign(i, s);
      if (!o || !n)
        throw new Error("Popper- or reference-element missing.");
      return O$(n, o, i);
    }
  };
}, nn = class oh {
  constructor(e) {
    this._initializingActive = !0, this._recalc = !0, this._nanopop = null, this._root = null, this._color = wr(), this._lastColor = wr(), this._swatchColors = [], this._setupAnimationFrame = null, this._eventListener = {
      init: [],
      save: [],
      hide: [],
      show: [],
      clear: [],
      change: [],
      changestop: [],
      cancel: [],
      swatchselect: []
    }, this.options = e = Object.assign({ ...oh.DEFAULT_OPTIONS }, e);
    const { swatches: t, components: i, theme: s, sliders: n, lockOpacity: o, padding: l } = e;
    ["nano", "monolith"].includes(s) && !n && (e.sliders = "h"), i.interaction || (i.interaction = {});
    const { preview: c, opacity: d, hue: f, palette: p } = i;
    i.opacity = !o && d, i.palette = p || c || d || f, this._preBuild(), this._buildComponents(), this._bindEvents(), this._finalBuild(), t && t.length && t.forEach((h) => this.addSwatch(h));
    const { button: m, app: v } = this._root;
    this._nanopop = x$(m, v, {
      margin: l
    }), m.setAttribute("role", "button"), m.setAttribute("aria-label", this._t("btn:toggle"));
    const r = this;
    this._setupAnimationFrame = requestAnimationFrame(function h() {
      if (!v.offsetWidth)
        return requestAnimationFrame(h);
      r.setColor(e.default), r._rePositioningPicker(), e.defaultRepresentation && (r._representation = e.defaultRepresentation, r.setColorRepresentation(r._representation)), e.showAlways && r.show(), r._initializingActive = !1, r._emit("init");
    });
  }
  // Does only the absolutly basic thing to initialize the components
  _preBuild() {
    const { options: e } = this;
    for (const t of ["el", "container"])
      e[t] = kb(e[t]);
    this._root = v$(this), e.useAsButton && (this._root.button = e.el), e.container.appendChild(this._root.root);
  }
  _finalBuild() {
    const e = this.options, t = this._root;
    if (e.container.removeChild(t.root), e.inline) {
      const i = e.el.parentElement;
      e.el.nextSibling ? i.insertBefore(t.app, e.el.nextSibling) : i.appendChild(t.app);
    } else
      e.container.appendChild(t.app);
    e.useAsButton ? e.inline && e.el.remove() : e.el.parentNode.replaceChild(t.root, e.el), e.disabled && this.disable(), e.comparison || (t.button.style.transition = "none", e.useAsButton || (t.preview.lastColor.style.transition = "none")), this.hide();
  }
  _buildComponents() {
    const e = this, t = this.options.components, i = (e.options.sliders || "v").repeat(2), [s, n] = i.match(/^[vh]+$/g) ? i : [], o = () => this._color || (this._color = this._lastColor.clone()), l = {
      palette: ac({
        element: e._root.palette.picker,
        wrapper: e._root.palette.palette,
        onstop: () => e._emit("changestop", "slider", e),
        onchange(c, d) {
          if (!t.palette)
            return;
          const f = o(), { _root: p, options: m } = e, { lastColor: v, currentColor: r } = p.preview;
          e._recalc && (f.s = c * 100, f.v = 100 - d * 100, f.v < 0 && (f.v = 0), e._updateOutput("slider"));
          const h = f.toRGBA().toString(0);
          this.element.style.background = h, this.wrapper.style.background = `
                        linear-gradient(to top, rgba(0, 0, 0, ${f.a}), transparent),
                        linear-gradient(to left, hsla(${f.h}, 100%, 50%, ${f.a}), rgba(255, 255, 255, ${f.a}))
                    `, m.comparison ? !m.useAsButton && !e._lastColor && v.style.setProperty("--pcr-color", h) : (p.button.style.setProperty("--pcr-color", h), p.button.classList.remove("clear"));
          const u = f.toHEXA().toString();
          for (const { el: g, color: b } of e._swatchColors)
            g.classList[u === b.toHEXA().toString() ? "add" : "remove"]("pcr-active");
          r.style.setProperty("--pcr-color", h);
        }
      }),
      hue: ac({
        lock: n === "v" ? "h" : "v",
        element: e._root.hue.picker,
        wrapper: e._root.hue.slider,
        onstop: () => e._emit("changestop", "slider", e),
        onchange(c) {
          if (!t.hue || !t.palette)
            return;
          const d = o();
          e._recalc && (d.h = c * 360), this.element.style.backgroundColor = `hsl(${d.h}, 100%, 50%)`, l.palette.trigger();
        }
      }),
      opacity: ac({
        lock: s === "v" ? "h" : "v",
        element: e._root.opacity.picker,
        wrapper: e._root.opacity.slider,
        onstop: () => e._emit("changestop", "slider", e),
        onchange(c) {
          if (!t.opacity || !t.palette)
            return;
          const d = o();
          e._recalc && (d.a = Math.round(c * 100) / 100), this.element.style.background = `rgba(0, 0, 0, ${d.a})`, l.palette.trigger();
        }
      }),
      selectable: b$({
        elements: e._root.interaction.options,
        className: "active",
        onchange(c) {
          e._representation = c.target.getAttribute("data-type").toUpperCase(), e._recalc && e._updateOutput("swatch");
        }
      })
    };
    this._components = l;
  }
  _bindEvents() {
    const { _root: e, options: t } = this, i = [
      // Clear color
      lt(e.interaction.clear, "click", () => this._clearColor()),
      // Select last color on click
      lt([
        e.interaction.cancel,
        e.preview.lastColor
      ], "click", () => {
        this.setHSVA(...(this._lastColor || this._color).toHSVA(), !0), this._emit("cancel");
      }),
      // Save color
      lt(e.interaction.save, "click", () => {
        !this.applyColor() && !t.showAlways && this.hide();
      }),
      // User input
      lt(e.interaction.result, ["keyup", "input"], (s) => {
        this.setColor(s.target.value, !0) && !this._initializingActive && (this._emit("change", this._color, "input", this), this._emit("changestop", "input", this)), s.stopImmediatePropagation();
      }),
      // Detect user input and disable auto-recalculation
      lt(e.interaction.result, ["focus", "blur"], (s) => {
        this._recalc = s.type === "blur", this._recalc && this._updateOutput(null);
      }),
      // Cancel input detection on color change
      lt([
        e.palette.palette,
        e.palette.picker,
        e.hue.slider,
        e.hue.picker,
        e.opacity.slider,
        e.opacity.picker
      ], ["mousedown", "touchstart"], () => this._recalc = !0, { passive: !0 })
    ];
    if (!t.showAlways) {
      const s = t.closeWithKey;
      i.push(
        // Save and hide / show picker
        lt(e.button, "click", () => this.isOpen() ? this.hide() : this.show()),
        // Close with escape key
        lt(document, "keyup", (n) => this.isOpen() && (n.key === s || n.code === s) && this.hide()),
        // Cancel selecting if the user taps behind the color picker
        lt(document, ["touchstart", "mousedown"], (n) => {
          this.isOpen() && !Sb(n).some((o) => o === e.app || o === e.button) && this.hide();
        }, { capture: !0 })
      );
    }
    if (t.adjustableNumbers) {
      const s = {
        rgba: [255, 255, 255, 1],
        hsva: [360, 100, 100, 1],
        hsla: [360, 100, 100, 1],
        cmyk: [100, 100, 100, 100]
      };
      _b(e.interaction.result, (n, o, l) => {
        const c = s[this.getColorRepresentation().toLowerCase()];
        if (c) {
          const d = c[l], f = n + (d >= 100 ? o * 1e3 : o);
          return f <= 0 ? 0 : Number((f < d ? f : d).toPrecision(3));
        }
        return n;
      });
    }
    if (t.autoReposition && !t.inline) {
      let s = null;
      const n = this;
      i.push(
        lt(window, ["scroll", "resize"], () => {
          n.isOpen() && (t.closeOnScroll && n.hide(), s === null ? (s = setTimeout(() => s = null, 100), requestAnimationFrame(function o() {
            n._rePositioningPicker(), s !== null && requestAnimationFrame(o);
          })) : (clearTimeout(s), s = setTimeout(() => s = null, 100)));
        }, { capture: !0 })
      );
    }
    this._eventBindings = i;
  }
  _rePositioningPicker() {
    const { options: e } = this;
    if (!e.inline && !this._nanopop.update({
      container: document.body.getBoundingClientRect(),
      position: e.position
    })) {
      const i = this._root.app, s = i.getBoundingClientRect();
      i.style.top = `${(window.innerHeight - s.height) / 2}px`, i.style.left = `${(window.innerWidth - s.width) / 2}px`;
    }
  }
  _updateOutput(e) {
    const { _root: t, _color: i, options: s } = this;
    if (t.interaction.type()) {
      const n = `to${t.interaction.type().getAttribute("data-type")}`;
      t.interaction.result.value = typeof i[n] == "function" ? i[n]().toString(s.outputPrecision) : "";
    }
    !this._initializingActive && this._recalc && this._emit("change", i, e, this);
  }
  _clearColor(e = !1) {
    const { _root: t, options: i } = this;
    i.useAsButton || t.button.style.setProperty("--pcr-color", "rgba(0, 0, 0, 0.15)"), t.button.classList.add("clear"), i.showAlways || this.hide(), this._lastColor = null, !this._initializingActive && !e && (this._emit("save", null), this._emit("clear"));
  }
  _parseLocalColor(e) {
    const { values: t, type: i, a: s } = m$(e), { lockOpacity: n } = this.options, o = s !== void 0 && s !== 1;
    return t && t.length === 3 && (t[3] = void 0), {
      values: !t || n && o ? null : t,
      type: i
    };
  }
  _t(e) {
    return this.options.i18n[e] || oh.I18N_DEFAULTS[e];
  }
  _emit(e, ...t) {
    this._eventListener[e].forEach((i) => i(...t, this));
  }
  on(e, t) {
    return this._eventListener[e].push(t), this;
  }
  off(e, t) {
    const i = this._eventListener[e] || [], s = i.indexOf(t);
    return ~s && i.splice(s, 1), this;
  }
  /**
   * Appends a color to the swatch palette
   * @param color
   * @returns {boolean}
   */
  addSwatch(e) {
    const { values: t } = this._parseLocalColor(e);
    if (t) {
      const { _swatchColors: i, _root: s } = this, n = wr(...t), o = Ed(
        `<button type="button" style="--pcr-color: ${n.toRGBA().toString(0)}" aria-label="${this._t("btn:swatch")}"/>`
      );
      return s.swatches.appendChild(o), i.push({ el: o, color: n }), this._eventBindings.push(
        lt(o, "click", () => {
          this.setHSVA(...n.toHSVA(), !0), this._emit("swatchselect", n), this._emit("change", n, "swatch", this);
        })
      ), !0;
    }
    return !1;
  }
  /**
   * Removes a swatch color by it's index
   * @param index
   * @returns {boolean}
   */
  removeSwatch(e) {
    const t = this._swatchColors[e];
    if (t) {
      const { el: i } = t;
      return this._root.swatches.removeChild(i), this._swatchColors.splice(e, 1), !0;
    }
    return !1;
  }
  applyColor(e = !1) {
    const { preview: t, button: i } = this._root, s = this._color.toRGBA().toString(0);
    return t.lastColor.style.setProperty("--pcr-color", s), this.options.useAsButton || i.style.setProperty("--pcr-color", s), i.classList.remove("clear"), this._lastColor = this._color.clone(), !this._initializingActive && !e && this._emit("save", this._color), this;
  }
  /**
   * Destroy's all functionalitys
   */
  destroy() {
    cancelAnimationFrame(this._setupAnimationFrame), this._eventBindings.forEach((e) => Ki(...e)), Object.keys(this._components).forEach((e) => this._components[e].destroy());
  }
  /**
   * Destroy's all functionalitys and removes
   * the pickr element.
   */
  destroyAndRemove() {
    this.destroy();
    const { root: e, app: t } = this._root;
    e.parentElement && e.parentElement.removeChild(e), t.parentElement.removeChild(t), Object.keys(this).forEach((i) => this[i] = null);
  }
  /**
   * Hides the color-picker ui.
   */
  hide() {
    return this.isOpen() ? (this._root.app.classList.remove("visible"), this._emit("hide"), !0) : !1;
  }
  /**
   * Shows the color-picker ui.
   */
  show() {
    return !this.options.disabled && !this.isOpen() ? (this._root.app.classList.add("visible"), this._rePositioningPicker(), this._emit("show", this._color), this) : !1;
  }
  /**
   * @return {boolean} If the color picker is currently open
   */
  isOpen() {
    return this._root.app.classList.contains("visible");
  }
  /**
   * Set a specific color.
   * @param h Hue
   * @param s Saturation
   * @param v Value
   * @param a Alpha channel (0 - 1)
   * @param silent If the button should not change the color
   * @return boolean if the color has been accepted
   */
  setHSVA(e = 360, t = 0, i = 0, s = 1, n = !1) {
    const o = this._recalc;
    if (this._recalc = !1, e < 0 || e > 360 || t < 0 || t > 100 || i < 0 || i > 100 || s < 0 || s > 1)
      return !1;
    this._color = wr(e, t, i, s);
    const { hue: l, opacity: c, palette: d } = this._components;
    return l.update(e / 360), c.update(s), d.update(t / 100, 1 - i / 100), n || this.applyColor(), o && this._updateOutput(), this._recalc = o, !0;
  }
  /**
   * Tries to parse a string which represents a color.
   * Examples: #fff
   *           rgb 10 10 200
   *           hsva 10 20 5 0.5
   * @param string
   * @param silent
   */
  setColor(e, t = !1) {
    if (e === null)
      return this._clearColor(t), !0;
    const { values: i, type: s } = this._parseLocalColor(e);
    if (i) {
      const n = s.toUpperCase(), { options: o } = this._root.interaction, l = o.find((c) => c.getAttribute("data-type") === n);
      if (l && !l.hidden)
        for (const c of o)
          c.classList[c === l ? "add" : "remove"]("active");
      return this.setHSVA(...i, t) ? this.setColorRepresentation(n) : !1;
    }
    return !1;
  }
  /**
   * Changes the color _representation.
   * Allowed values are HEX, RGB, HSV, HSL and CMYK
   * @param type
   * @returns {boolean} if the selected type was valid.
   */
  setColorRepresentation(e) {
    return e = e.toUpperCase(), !!this._root.interaction.options.find((t) => t.getAttribute("data-type").startsWith(e) && !t.click());
  }
  /**
   * Returns the current color representaion. See setColorRepresentation
   * @returns {*}
   */
  getColorRepresentation() {
    return this._representation;
  }
  /**
   * @returns HSVaColor Current HSVaColor object.
   */
  getColor() {
    return this._color;
  }
  /**
   * Returns the currently selected color.
   * @returns {{a, toHSVA, toHEXA, s, v, h, clone, toCMYK, toHSLA, toRGBA}}
   */
  getSelectedColor() {
    return this._lastColor;
  }
  /**
   * @returns The root HTMLElement with all his components.
   */
  getRoot() {
    return this._root;
  }
  /**
   * Disable pickr
   */
  disable() {
    return this.hide(), this.options.disabled = !0, this._root.button.classList.add("disabled"), this;
  }
  /**
   * Enable pickr
   */
  enable() {
    return this.options.disabled = !1, this._root.button.classList.remove("disabled"), this;
  }
};
nn.utils = r$;
nn.version = "dooca";
nn.I18N_DEFAULTS = {
  // Strings visible in the UI
  "ui:dialog": "color picker dialog",
  "btn:toggle": "toggle color picker dialog",
  "btn:swatch": "color swatch",
  "btn:last-color": "use previous color",
  "btn:save": "Save",
  "btn:cancel": "Cancel",
  "btn:clear": "Clear",
  // Strings used for aria-labels
  "aria:btn:save": "save and close",
  "aria:btn:cancel": "cancel and close",
  "aria:btn:clear": "clear and close",
  "aria:input": "color input field",
  "aria:palette": "color selection area",
  "aria:hue": "hue selection slider",
  "aria:opacity": "selection slider"
};
nn.DEFAULT_OPTIONS = {
  appClass: null,
  theme: "classic",
  useAsButton: !1,
  padding: 8,
  disabled: !1,
  comparison: !0,
  closeOnScroll: !1,
  outputPrecision: 0,
  lockOpacity: !1,
  autoReposition: !0,
  container: "body",
  components: {
    interaction: {}
  },
  i18n: {},
  swatches: null,
  inline: !1,
  sliders: null,
  default: "#42445a",
  defaultRepresentation: null,
  position: "bottom-middle",
  adjustableNumbers: !0,
  showAlways: !1,
  closeWithKey: "Escape"
};
nn.create = (a) => new nn(a);
let w$ = nn;
const S$ = { class: "ui-colorpicker-content" }, k$ = ["placeholder", "value"], xH = j({
  __name: "FormColorpicker",
  props: {
    modelValue: {},
    label: {},
    placeholder: {},
    width: {},
    withInput: { type: Boolean }
  },
  emits: ["update", "update:modelValue"],
  setup(a, { expose: e, emit: t }) {
    var p;
    const i = a, s = t, n = `colopicker-${(p = yt()) == null ? void 0 : p.uid}`, o = Ci(), l = Z(!1), c = Z({});
    i.width && (c.value.width = i.width);
    const d = (m) => {
      s("update:modelValue", m), s("update", m);
    }, f = (m) => {
      const v = !m.default, r = w$.create({
        ...m,
        ...v && { default: "#000000" }
      });
      if (r.init = !0, v) {
        r.init = !1;
        const h = () => {
          r.off("init", h), r.setColor(null), r.init = !0;
        };
        r.on("init", h);
      }
      return r;
    };
    return at(() => {
      o.value = f({
        el: `#${n}`,
        theme: "monolith",
        default: i.modelValue || void 0,
        defaultRepresentation: "HEXA",
        // container: 'body',
        // lockOpacity: true,
        components: {
          preview: !0,
          opacity: !0,
          hue: !0,
          interaction: {
            // hex: true,
            // rgba: true,
            // hsla: true,
            // hsva: true,
            // cmyk: true,
            input: !0,
            save: !0,
            clear: !0
          }
        },
        i18n: {
          // Strings visible in the UI
          "ui:dialog": "color picker dialog",
          "btn:toggle": "toggle color picker dialog",
          "btn:swatch": "color swatch",
          "btn:last-color": "use previous color",
          "btn:save": "Aplicar",
          "btn:cancel": "Cancelar",
          "btn:clear": "Limpar",
          // Strings used for aria-labels
          "aria:btn:save": "save and close",
          "aria:btn:cancel": "cancel and close",
          "aria:btn:clear": "clear and close",
          "aria:input": "color input field",
          "aria:palette": "color selection area",
          "aria:hue": "hue selection slider",
          "aria:opacity": "selection slider"
        }
      }), o.value.on("save", (m, v) => {
        if (v.init) {
          let r = null;
          m && (r = m.toHEXA().toString()), v.hide(), l.value || d(r);
        }
      }), Du(() => {
        o.value && i.modelValue != null && o.value.getColor().toHEXA().toString() != i.modelValue && o.value.setColor(i.modelValue);
      });
    }), Du(() => {
      o.value && i.modelValue && !l.value && o.value.setColor(i.modelValue);
    }), e({
      show: () => {
        o.value.show();
      },
      hide: () => {
        o.value.hide();
      }
    }), (m, v) => (M(), D("label", {
      class: "ui-colorpicker",
      style: wt(c.value)
    }, [
      B(pd, {
        class: "ui-colorpicker",
        label: m.label,
        onClick: v[0] || (v[0] = (r) => o.value.show())
      }, null, 8, ["label"]),
      I("div", S$, [
        I("div", {
          class: "pickr",
          id: n
        }),
        m.withInput ? (M(), D("input", al({
          key: 0,
          class: "form-control",
          maxlength: "9"
        }, m.$attrs, {
          placeholder: m.placeholder,
          value: m.modelValue,
          onFocus: v[1] || (v[1] = (r) => l.value = !0),
          onBlur: v[2] || (v[2] = (r) => l.value = !1),
          onInput: v[3] || (v[3] = (r) => m.$emit("update:modelValue", r.target.value))
        }), null, 16, k$)) : X("", !0)
      ])
    ], 4));
  }
});
if (typeof Cb > "u")
  var Cb = void 0;
if (typeof lh > "u")
  var lh = void 0;
(function() {
  var a = {};
  a.settings = {}, a.post = function(r) {
    return new e("post", r);
  }, a.get = function(r) {
    return new e("get", r);
  }, a.request = function(r, h) {
    return new e(r, h);
  };
  var e = function(r, h) {
    var u = {
      method: r,
      url: "",
      before: function() {
      },
      success: function() {
      },
      error: function() {
      },
      data: !1,
      async: !0,
      headers: {}
    };
    this.p = this.extend(u, h), this.p = this.extend(this.p, a.settings), this.p.method = this.p.method.toUpperCase(), this.prepareData(), this.xhr = new XMLHttpRequest(), this.xhr.open(this.p.method, this.p.url, this.p.async), this.setHeaders();
    var g = typeof this.p.before == "function" ? this.p.before(this.xhr) : !0;
    g !== !1 && this.send();
  };
  e.prototype = {
    extend: function(r, h) {
      if (h)
        for (var u in h)
          r[u] = h[u];
      return r;
    },
    prepareData: function() {
      ["POST", "PUT"].indexOf(this.p.method) !== -1 && !this.isFormData() && (this.p.headers["Content-Type"] = "application/x-www-form-urlencoded"), typeof this.p.data == "object" && !this.isFormData() && (this.p.data = this.toParams(this.p.data)), this.p.method === "GET" && (this.p.url = this.p.data ? this.p.url + "?" + this.p.data : this.p.url);
    },
    setHeaders: function() {
      this.xhr.setRequestHeader("X-Requested-With", this.p.headers["X-Requested-With"] || "XMLHttpRequest");
      for (var r in this.p.headers)
        this.xhr.setRequestHeader(r, this.p.headers[r]);
    },
    isFormData: function() {
      return typeof window.FormData < "u" && this.p.data instanceof window.FormData;
    },
    isComplete: function() {
      return !(this.xhr.status < 200 || this.xhr.status >= 300 && this.xhr.status !== 304);
    },
    send: function() {
      this.p.async ? (this.xhr.onload = this.loaded.bind(this), this.xhr.send(this.p.data)) : (this.xhr.send(this.p.data), this.loaded.call(this));
    },
    loaded: function() {
      if (this.isComplete()) {
        var r = this.parseResponse();
        typeof this.p.success == "function" && this.p.success(r, this.xhr);
      } else {
        var r = this.parseResponse();
        typeof this.p.error == "function" && this.p.error(r, this.xhr, this.xhr.status);
      }
    },
    parseResponse: function() {
      var r = this.xhr.response, h = this.parseJson(r);
      return h || r;
    },
    parseJson: function(r) {
      try {
        var h = JSON.parse(r);
        if (h && typeof h == "object")
          return h;
      } catch {
      }
      return !1;
    },
    toParams: function(r) {
      return Object.keys(r).map(function(h) {
        return encodeURIComponent(h) + "=" + encodeURIComponent(r[h]);
      }).join("&");
    }
  };
  var t = [0], i = "data" + (/* @__PURE__ */ new Date()).getTime(), s = "is-hidden", n = "is-hidden-mobile", o = function(r, h) {
    return this.parse(r, h);
  };
  o.ready = function(r) {
    document.readyState !== "loading" ? r() : document.addEventListener("DOMContentLoaded", r);
  }, o.prototype = {
    get sdom() {
      return !0;
    },
    get length() {
      return this.nodes.length;
    },
    parse: function(r, h) {
      var u, g = /^\s*<(\w+|!)[^>]*>/;
      if (!r)
        u = [];
      else {
        if (r.sdom)
          return this.nodes = r.nodes, r;
        typeof r != "string" ? r.nodeType && r.nodeType === 11 ? u = r.childNodes : u = r.nodeType || r === window ? [r] : r : g.test(r) ? u = this.create(r) : u = this._query(r, h);
      }
      this.nodes = this._slice(u);
    },
    create: function(r) {
      if (/^<(\w+)\s*\/?>(?:<\/\1>|)$/.test(r))
        return [document.createElement(RegExp.$1)];
      var h = [], u = document.createElement("div"), g = u.childNodes;
      u.innerHTML = r;
      for (var b = 0, O = g.length; b < O; b++)
        h.push(g[b]);
      return h;
    },
    // add
    add: function(r) {
      this.nodes = this.nodes.concat(this._toArray(r));
    },
    // get
    get: function(r) {
      return this.nodes[r || 0] || !1;
    },
    getAll: function() {
      return this.nodes;
    },
    eq: function(r) {
      return new o(this.nodes[r]);
    },
    first: function() {
      return new o(this.nodes[0]);
    },
    last: function() {
      return new o(this.nodes[this.nodes.length - 1]);
    },
    contents: function() {
      return this.get().childNodes;
    },
    // loop
    each: function(r) {
      for (var h = this.nodes.length, u = 0; u < h; u++)
        r.call(this, this.nodes[u].sdom ? this.nodes[u].get() : this.nodes[u], u);
      return this;
    },
    // traversing
    is: function(r) {
      return this.filter(r).length > 0;
    },
    filter: function(r) {
      var h;
      return r === void 0 ? this : (typeof r == "function" ? h = r : h = function(u) {
        return r instanceof Node ? r === u : r && r.sdom ? r.nodes.indexOf(u) !== -1 : (u.matches = u.matches || u.msMatchesSelector || u.webkitMatchesSelector, u.nodeType === 1 ? u.matches(r || "*") : !1);
      }, new o(this.nodes.filter(h)));
    },
    not: function(r) {
      return this.filter(function(h) {
        return !new o(h).is(r || !0);
      });
    },
    find: function(r) {
      var h = [];
      return this.each(function(u) {
        for (var g = this._query(r || "*", u), b = 0; b < g.length; b++)
          h.push(g[b]);
      }), new o(h);
    },
    children: function(r) {
      var h = [];
      return this.each(function(u) {
        if (u.children)
          for (var g = u.children, b = 0; b < g.length; b++)
            h.push(g[b]);
      }), new o(h).filter(r);
    },
    parent: function(r) {
      var h = [];
      return this.each(function(u) {
        u.parentNode && h.push(u.parentNode);
      }), new o(h).filter(r);
    },
    parents: function(r, h) {
      h = this._getContext(h);
      var u = [];
      return this.each(function(g) {
        for (var b = g.parentNode; b && b !== h; )
          r ? new o(b).is(r) && u.push(b) : u.push(b), b = b.parentNode;
      }), new o(u);
    },
    closest: function(r, h) {
      h = this._getContext(h), r = r.sdom ? r.get() : r;
      var u = [], g = r && r.nodeType;
      return this.each(function(b) {
        do
          if (g && b === r || new o(b).is(r))
            return u.push(b);
        while ((b = b.parentNode) && b !== h);
      }), new o(u);
    },
    next: function(r) {
      return this._getSibling(r, "nextSibling");
    },
    nextElement: function(r) {
      return this._getSibling(r, "nextElementSibling");
    },
    prev: function(r) {
      return this._getSibling(r, "previousSibling");
    },
    prevElement: function(r) {
      return this._getSibling(r, "previousElementSibling");
    },
    // css
    css: function(r, h) {
      if (h === void 0 && typeof r != "object") {
        var u = this.get();
        return r === "width" || r === "height" ? u.style ? this._getHeightOrWidth(r, u, !1) + "px" : void 0 : u.style ? getComputedStyle(u, null)[r] : void 0;
      }
      return this.each(function(g) {
        var b = {};
        typeof r == "object" ? b = r : b[r] = h;
        for (var O in b)
          g.style && (g.style[O] = b[O]);
      });
    },
    // attr
    attr: function(r, h, u) {
      if (u = u ? "data-" : "", h === void 0 && typeof r != "object") {
        var g = this.get();
        return g && g.nodeType !== 3 ? r === "checked" ? g.checked : this._getBooleanFromStr(g.getAttribute(u + r)) : void 0;
      }
      return this.each(function(b) {
        var O = {};
        typeof r == "object" ? O = r : O[r] = h;
        for (var x in O)
          b.nodeType !== 3 && (x === "checked" ? b.checked = O[x] : b.setAttribute(u + x, O[x]));
      });
    },
    data: function(r, h) {
      if (r === void 0) {
        var u = /^data-(.+)$/, g = this.get().attributes, b = {}, O = function(C) {
          return C[1].toUpperCase();
        };
        for (var x in g)
          if (g[x] && u.test(g[x].nodeName)) {
            var S = g[x].nodeName.match(u)[1], k = g[x].value;
            S = S.replace(/-([a-z])/g, O), this._isObjectString(k) ? k = this._toObject(k) : k = this._isNumber(k) ? parseFloat(k) : this._getBooleanFromStr(k), b[S] = k;
          }
        return b;
      }
      return this.attr(r, h, !0);
    },
    val: function(r) {
      if (r === void 0) {
        var h = this.get();
        return h.type && h.type === "checkbox" ? h.checked : h.value;
      }
      return this.each(function(u) {
        u.value = r;
      });
    },
    removeAttr: function(r) {
      return this.each(function(h) {
        var u = function(g) {
          h.nodeType !== 3 && h.removeAttribute(g);
        };
        r.split(" ").forEach(u);
      });
    },
    removeData: function(r) {
      return this.each(function(h) {
        var u = function(g) {
          h.nodeType !== 3 && h.removeAttribute("data-" + g);
        };
        r.split(" ").forEach(u);
      });
    },
    // dataset/dataget
    dataset: function(r, h) {
      return this.each(function(u) {
        t[this.dataindex(u)][r] = h;
      });
    },
    dataget: function(r) {
      return t[this.dataindex(this.get())][r];
    },
    dataindex: function(r) {
      var h = r[i], u = t.length;
      return h || (h = r[i] = u, t[h] = {}), h;
    },
    // class
    addClass: function(r) {
      return this._eachClass(r, "add");
    },
    removeClass: function(r) {
      return this._eachClass(r, "remove");
    },
    toggleClass: function(r) {
      return this._eachClass(r, "toggle");
    },
    hasClass: function(r) {
      return this.nodes.some(function(h) {
        return h.classList ? h.classList.contains(r) : !1;
      });
    },
    // html & text
    empty: function() {
      return this.each(function(r) {
        r.innerHTML = "";
      });
    },
    html: function(r) {
      return r === void 0 ? this.get().innerHTML || "" : this.empty().append(r);
    },
    text: function(r) {
      return r === void 0 ? this.get().textContent || "" : this.each(function(h) {
        h.textContent = r;
      });
    },
    // manipulation
    after: function(r) {
      return this._inject(r, function(h, u) {
        if (typeof h == "string")
          u.insertAdjacentHTML("afterend", h);
        else if (u.parentNode !== null)
          for (var g = h instanceof Node ? [h] : this._toArray(h).reverse(), b = 0; b < g.length; b++)
            u.parentNode.insertBefore(g[b], u.nextSibling);
        return u;
      });
    },
    before: function(r) {
      return this._inject(r, function(h, u) {
        if (typeof h == "string")
          u.insertAdjacentHTML("beforebegin", h);
        else
          for (var g = h instanceof Node ? [h] : this._toArray(h), b = 0; b < g.length; b++)
            u.parentNode.insertBefore(g[b], u);
        return u;
      });
    },
    append: function(r) {
      return this._inject(r, function(h, u) {
        if (typeof h == "string" || typeof h == "number")
          u.insertAdjacentHTML("beforeend", h);
        else
          for (var g = h instanceof Node ? [h] : this._toArray(h), b = 0; b < g.length; b++)
            u.appendChild(g[b]);
        return u;
      });
    },
    prepend: function(r) {
      return this._inject(r, function(h, u) {
        if (typeof h == "string" || typeof h == "number")
          u.insertAdjacentHTML("afterbegin", h);
        else
          for (var g = h instanceof Node ? [h] : this._toArray(h).reverse(), b = 0; b < g.length; b++)
            u.insertBefore(g[b], u.firstChild);
        return u;
      });
    },
    wrap: function(r) {
      return this._inject(r, function(h, u) {
        var g = typeof h == "string" || typeof h == "number" ? this.create(h)[0] : h instanceof Node ? h : this._toArray(h)[0];
        return u.parentNode && u.parentNode.insertBefore(g, u), g.appendChild(u), new o(g);
      });
    },
    unwrap: function() {
      return this.each(function(r) {
        var h = new o(r);
        return h.replaceWith(h.contents());
      });
    },
    replaceWith: function(r) {
      return this._inject(r, function(h, u) {
        for (var g = document.createDocumentFragment(), b = typeof h == "string" || typeof h == "number" ? this.create(h) : h instanceof Node ? [h] : this._toArray(h), O = 0; O < b.length; O++)
          g.appendChild(b[O]);
        var x = g.childNodes[0];
        return u.parentNode && u.parentNode.replaceChild(g, u), x;
      });
    },
    remove: function() {
      return this.each(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      });
    },
    clone: function(r) {
      var h = [];
      return this.each(function(u) {
        var g = this._clone(u);
        r && (g = this._cloneEvents(u, g)), h.push(g);
      }), new o(h);
    },
    // show/hide
    show: function() {
      return this.each(
        (function(r) {
          if (!(!r.style || !this._hasDisplayNone(r))) {
            var h = r.getAttribute("domTargetShow"), u = r.classList ? r.classList.contains(s) : !1, g = r.classList ? r.classList.contains(n) : !1, b;
            u ? (b = s, r.classList.remove(s)) : g ? (b = n, r.classList.remove(n)) : r.style.display = h || "block", b && r.setAttribute("domTargetHide", b), r.removeAttribute("domTargetShow");
          }
        }).bind(this)
      );
    },
    hide: function() {
      return this.each(function(r) {
        if (!(!r.style || this._hasDisplayNone(r))) {
          var h = r.style.display, u = r.getAttribute("domTargetHide");
          u === s ? r.classList.add(s) : u === n ? r.classList.add(n) : (h !== "block" && r.setAttribute("domTargetShow", h), r.style.display = "none"), r.removeAttribute("domTargetHide");
        }
      });
    },
    // dimensions
    scrollTop: function(r) {
      var h = this.get(), u = h === window, g = h.nodeType === 9, b = g ? document.scrollingElement || document.body.parentNode || document.body || document.documentElement : h;
      if (r !== void 0) {
        u ? window.scrollTo(0, r) : b.scrollTop = r;
        return;
      }
      return g ? typeof window.pageYOffset < "u" ? window.pageYOffset : document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop ? document.body.scrollTop : 0 : u ? window.pageYOffset : b.scrollTop;
    },
    offset: function() {
      return this._getDim("Offset");
    },
    position: function() {
      return this._getDim("Position");
    },
    width: function(r, h) {
      return this._getSize("width", "Width", r, h);
    },
    height: function(r, h) {
      return this._getSize("height", "Height", r, h);
    },
    outerWidth: function() {
      return this._getInnerOrOuter("width", "outer");
    },
    outerHeight: function() {
      return this._getInnerOrOuter("height", "outer");
    },
    innerWidth: function() {
      return this._getInnerOrOuter("width", "inner");
    },
    innerHeight: function() {
      return this._getInnerOrOuter("height", "inner");
    },
    // events
    click: function() {
      return this._triggerEvent("click");
    },
    focus: function() {
      return this._triggerEvent("focus");
    },
    trigger: function(r) {
      return this.each(function(h) {
        for (var u = r.split(" "), g = 0; g < u.length; g++) {
          var b, O = { bubbles: !0, cancelable: !0 };
          try {
            b = new window.CustomEvent(u[g], O);
          } catch {
            b = document.createEvent("CustomEvent"), b.initCustomEvent(u[g], !0, !0);
          }
          h.dispatchEvent(b);
        }
      });
    },
    on: function(r, h, u) {
      return this.each(function(g) {
        for (var b = r.split(" "), O = 0; O < b.length; O++) {
          var x = this._getEventName(b[O]), S = this._getEventNamespace(b[O]);
          h = u ? this._getOneHandler(h, r) : h, g.addEventListener(x, h), g._e = g._e || {}, g._e[S] = g._e[S] || {}, g._e[S][x] = g._e[S][x] || [], g._e[S][x].push(h);
        }
      });
    },
    one: function(r, h) {
      return this.on(r, h, !0);
    },
    off: function(r, h) {
      var u = function(x, S, k) {
        return x === k;
      }, g = function(x, S, k, C) {
        return S === C;
      }, b = function(x, S, k, C) {
        return x === k && S === C;
      }, O = function() {
        return !0;
      };
      return r === void 0 ? this.each(function(x) {
        this._offEvent(x, !1, !1, h, O);
      }) : this.each(function(x) {
        for (var S = r.split(" "), k = 0; k < S.length; k++) {
          var C = this._getEventName(S[k]), _ = this._getEventNamespace(S[k]);
          _ === "_events" ? this._offEvent(x, C, _, h, u) : !C && _ !== "_events" ? this._offEvent(x, C, _, h, g) : this._offEvent(x, C, _, h, b);
        }
      });
    },
    // form
    serialize: function(r) {
      for (var h = {}, u = this.get().elements, g = 0; g < u.length; g++) {
        var b = u[g];
        if (!(/(checkbox|radio)/.test(b.type) && !b.checked) && !(!b.name || b.disabled || b.type === "file")) {
          if (b.type === "select-multiple")
            for (var O = 0; O < b.options.length; O++) {
              var x = b.options[O];
              x.selected && (h[b.name] = x.value);
            }
          h[b.name] = this._isNumber(b.value) ? parseFloat(b.value) : this._getBooleanFromStr(b.value);
        }
      }
      return r ? h : this._toParams(h);
    },
    ajax: function(r, h) {
      if (typeof e < "u") {
        var u = this.attr("method") || "post", g = {
          url: this.attr("action"),
          data: this.serialize(),
          success: r,
          error: h
        };
        return new e(u, g);
      }
    },
    // private
    _queryContext: function(r, h) {
      return h = this._getContext(h), h.nodeType !== 3 && typeof h.querySelectorAll == "function" ? h.querySelectorAll(r) : [];
    },
    _query: function(r, h) {
      if (h)
        return this._queryContext(r, h);
      if (/^[.#]?[\w-]*$/.test(r)) {
        if (r[0] === "#") {
          var u = document.getElementById(r.slice(1));
          return u ? [u] : [];
        }
        return r[0] === "." ? document.getElementsByClassName(r.slice(1)) : document.getElementsByTagName(r);
      }
      return document.querySelectorAll(r);
    },
    _getContext: function(r) {
      return r = typeof r == "string" ? document.querySelector(r) : r, r && r.sdom ? r.get() : r || document;
    },
    _inject: function(r, h) {
      for (var u = this.nodes.length, g = []; u--; ) {
        var b = typeof r == "function" ? r.call(this, this.nodes[u]) : r, O = u === 0 ? b : this._clone(b), x = h.call(this, O, this.nodes[u]);
        x && (x.sdom ? g.push(x.get()) : g.push(x));
      }
      return new o(g);
    },
    _cloneEvents: function(r, h) {
      var u = r._e;
      if (u) {
        h._e = u;
        for (var g in u._events)
          for (var b = 0; b < u._events[g].length; b++)
            h.addEventListener(g, u._events[g][b]);
      }
      return h;
    },
    _clone: function(r) {
      if (!(typeof r > "u")) {
        if (typeof r == "string")
          return r;
        if (r instanceof Node || r.nodeType)
          return r.cloneNode(!0);
        if ("length" in r)
          return [].map.call(this._toArray(r), function(h) {
            return h.cloneNode(!0);
          });
      }
    },
    _slice: function(r) {
      return !r || r.length === 0 ? [] : r.length ? [].slice.call(r.nodes || r) : [r];
    },
    _eachClass: function(r, h) {
      return this.each(function(u) {
        if (r) {
          var g = function(b) {
            u.classList && u.classList[h](b);
          };
          r.split(" ").forEach(g);
        }
      });
    },
    _triggerEvent: function(r) {
      var h = this.get();
      return h && h.nodeType !== 3 && h[r](), this;
    },
    _getOneHandler: function(r, h) {
      var u = this;
      return function() {
        r.apply(this, arguments), u.off(h);
      };
    },
    _getEventNamespace: function(r) {
      var h = r.split("."), u = h[1] ? h[1] : "_events";
      return h[2] ? u + h[2] : u;
    },
    _getEventName: function(r) {
      return r.split(".")[0];
    },
    _offEvent: function(r, h, u, g, b) {
      for (var O in r._e)
        for (var x in r._e[O])
          if (b(x, O, h, u))
            for (var S = r._e[O][x], k = 0; k < S.length; k++)
              typeof g < "u" && S[k].toString() !== g.toString() || (r.removeEventListener(x, S[k]), r._e[O][x].splice(k, 1), r._e[O][x].length === 0 && delete r._e[O][x], Object.keys(r._e[O]).length === 0 && delete r._e[O]);
    },
    _getInnerOrOuter: function(r, h) {
      return this[r](void 0, h);
    },
    _getDocSize: function(r, h) {
      var u = r.body, g = r.documentElement;
      return Math.max(
        u["scroll" + h],
        u["offset" + h],
        g["client" + h],
        g["scroll" + h],
        g["offset" + h]
      );
    },
    _getSize: function(r, h, u, g) {
      if (u === void 0) {
        var b = this.get();
        return b.nodeType === 3 ? u = 0 : b.nodeType === 9 ? u = this._getDocSize(b, h) : b === window ? u = window["inner" + h] : u = this._getHeightOrWidth(r, b, g || "normal"), Math.round(u);
      }
      return this.each(
        (function(O) {
          u = parseFloat(u), u = u + this._adjustResultHeightOrWidth(r, O, g || "normal"), new o(O).css(r, u + "px");
        }).bind(this)
      );
    },
    _getHeightOrWidth: function(r, h, u) {
      if (!h)
        return 0;
      var g = r.charAt(0).toUpperCase() + r.slice(1), b = 0, O = getComputedStyle(h, null), x = new o(h), S = x.parents().filter(function(_) {
        return _.nodeType === 1 && getComputedStyle(_, null).display === "none" ? _ : !1;
      });
      if (O.display === "none" && S.add(h), S.length !== 0) {
        var k = "visibility: hidden !important; display: block !important;", C = [];
        S.each(function(_) {
          var $ = new o(_), L = $.attr("style");
          L !== null && C.push(L), $.attr("style", L !== null ? L + ";" + k : k);
        }), b = x.get()["offset" + g] - this._adjustResultHeightOrWidth(r, h, u), S.each(function(_, $) {
          var L = new o(_);
          C[$] === void 0 ? L.removeAttr("style") : L.attr("style", C[$]);
        });
      } else
        b = h["offset" + g] - this._adjustResultHeightOrWidth(r, h, u);
      return b;
    },
    _adjustResultHeightOrWidth: function(r, h, u) {
      if (!h || u === !1)
        return 0;
      var g = 0, b = getComputedStyle(h, null), O = b.boxSizing === "border-box";
      return r === "height" ? ((u === "inner" || u === "normal" && O) && (g += (parseFloat(b.borderTopWidth) || 0) + (parseFloat(b.borderBottomWidth) || 0)), u === "outer" && (g -= (parseFloat(b.marginTop) || 0) + (parseFloat(b.marginBottom) || 0))) : ((u === "inner" || u === "normal" && O) && (g += (parseFloat(b.borderLeftWidth) || 0) + (parseFloat(b.borderRightWidth) || 0)), u === "outer" && (g -= (parseFloat(b.marginLeft) || 0) + (parseFloat(b.marginRight) || 0))), g;
    },
    _getDim: function(r) {
      var h = this.get();
      return h.nodeType === 3 ? { top: 0, left: 0 } : this["_get" + r](h);
    },
    _getPosition: function(r) {
      return { top: r.offsetTop, left: r.offsetLeft };
    },
    _getOffset: function(r) {
      var h = r.getBoundingClientRect(), u = r.ownerDocument, g = u.documentElement, b = u.defaultView;
      return {
        top: h.top + b.pageYOffset - g.clientTop,
        left: h.left + b.pageXOffset - g.clientLeft
      };
    },
    _getSibling: function(r, h) {
      r = r && r.sdom ? r.get() : r;
      var u = r && r.nodeType, g;
      return this.each(function(b) {
        for (; b = b[h]; )
          if (u && b === r || new o(b).is(r)) {
            g = b;
            return;
          }
      }), new o(g);
    },
    _toArray: function(r) {
      if (r instanceof NodeList) {
        for (var h = [], u = 0; u < r.length; u++)
          h[u] = r[u];
        return h;
      } else
        return r === void 0 ? [] : r.sdom ? r.nodes : r;
    },
    _toParams: function(r) {
      var h = "";
      for (var u in r)
        h += "&" + this._encodeUri(u) + "=" + this._encodeUri(r[u]);
      return h.replace(/^&/, "");
    },
    _toObject: function(r) {
      return new Function("return " + r)();
    },
    _encodeUri: function(r) {
      return encodeURIComponent(r).replace(/!/g, "%21").replace(/'/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/\*/g, "%2A").replace(/%20/g, "+");
    },
    _isNumber: function(r) {
      return !isNaN(r) && !isNaN(parseFloat(r));
    },
    _isObjectString: function(r) {
      return r.search(/^{/) !== -1;
    },
    _getBooleanFromStr: function(r) {
      return r === "true" ? !0 : r === "false" ? !1 : r;
    },
    _hasDisplayNone: function(r) {
      return r.style.display === "none" || (r.currentStyle ? r.currentStyle.display : getComputedStyle(r, null).display) === "none";
    }
  };
  var l = 0, c = function(r, h) {
    return d(r, h, [].slice.call(arguments, 2));
  };
  c.app = [], c.version = "3.5.2", c.options = {}, c.modules = {}, c.services = {}, c.classes = {}, c.plugins = {}, c.mixins = {}, c.modals = {}, c.lang = {}, c.dom = function(r, h) {
    return new o(r, h);
  }, c.ajax = a, c.Dom = o, c.keycodes = {
    BACKSPACE: 8,
    DELETE: 46,
    UP: 38,
    DOWN: 40,
    ENTER: 13,
    SPACE: 32,
    ESC: 27,
    TAB: 9,
    CTRL: 17,
    META: 91,
    SHIFT: 16,
    ALT: 18,
    RIGHT: 39,
    LEFT: 37
  }, c.env = {
    plugin: "plugins",
    module: "modules",
    service: "services",
    class: "classes",
    mixin: "mixins"
  }, typeof lh < "u" && function(r) {
    r.fn.redactor = function(h) {
      return d(this.toArray(), h, [].slice.call(arguments, 1));
    };
  }(lh);
  var d = function(r, h, u) {
    for (var g = "redactor", b = Array.isArray(r) ? r : r && r.nodeType ? [r] : document.querySelectorAll(r), O = typeof h == "string" || typeof h == "function", x = [], S, k = 0; k < b.length; k++) {
      var C = b[k], _ = c.dom(C);
      if (S = _.dataget(g), !S && !O && (S = new f(C, h, l), _.dataset(g, S), c.app[l] = S, l++), S && O) {
        var $ = h === "destroy";
        h = $ ? "stop" : h;
        var L;
        typeof h == "function" ? L = h.apply(S, u) : (u.unshift(h), L = S.api.apply(S, u)), L !== void 0 && x.push(L), $ && _.dataset(g, !1);
      }
    }
    return x.length === 0 || x.length === 1 ? x.length === 0 ? S : x[0] : x;
  };
  c.add = function(r, h, u) {
    if (!(typeof c.env[r] > "u"))
      if (u.translations && (c.lang = c.extend(!0, {}, c.lang, u.translations)), u.modals && (c.modals = c.extend(!0, {}, c.modals, u.modals)), r === "mixin")
        c[c.env[r]][h] = u;
      else {
        var g = function() {
        };
        if (g.prototype = u, u.mixins)
          for (var b = 0; b < u.mixins.length; b++)
            c.inherit(g, c.mixins[u.mixins[b]]);
        c[c.env[r]][h] = g;
      }
  }, c.addLang = function(r, h) {
    typeof c.lang[r] > "u" && (c.lang[r] = {}), c.lang[r] = c.extend(c.lang[r], h);
  }, c.create = function(r) {
    var h = r.split("."), u = [].slice.call(arguments, 1), g = "classes";
    typeof c.env[h[0]] < "u" && (g = c.env[h[0]], r = h.slice(1).join("."));
    var b = new c[g][r]();
    if (b.init) {
      var O = b.init.apply(b, u);
      return O || b;
    }
    return b;
  }, c.inherit = function(r, h) {
    var u = function() {
    };
    u.prototype = h;
    var g = new u();
    for (var b in r.prototype)
      r.prototype.__lookupGetter__(b) ? g.__defineGetter__(b, r.prototype.__lookupGetter__(b)) : g[b] = r.prototype[b];
    return r.prototype = g, r.prototype.super = h, r;
  }, c.error = function(r) {
    throw r;
  }, c.extend = function() {
    var r = {}, h = !1, u = 0, g = arguments.length;
    Object.prototype.toString.call(arguments[0]) === "[object Boolean]" && (h = arguments[0], u++);
    for (var b = function(x) {
      for (var S in x)
        Object.prototype.hasOwnProperty.call(x, S) && (h && Object.prototype.toString.call(x[S]) === "[object Object]" ? r[S] = c.extend(!0, r[S], x[S]) : r[S] = x[S]);
    }; u < g; u++) {
      var O = arguments[u];
      b(O);
    }
    return r;
  }, c.opts = {
    animation: !0,
    lang: "en",
    direction: "ltr",
    spellcheck: !0,
    structure: !1,
    scrollTarget: !1,
    styles: !0,
    stylesClass: "redactor-styles",
    placeholder: !1,
    source: !0,
    showSource: !1,
    inline: !1,
    breakline: !1,
    markup: "p",
    enterKey: !0,
    clickToEdit: !1,
    clickToSave: !1,
    clickToCancel: !1,
    focus: !1,
    focusEnd: !1,
    minHeight: !1,
    // string, '100px'
    maxHeight: !1,
    // string, '100px'
    maxWidth: !1,
    // string, '700px'
    plugins: [],
    // array
    callbacks: {},
    // pre & tab
    preClass: !1,
    // string
    preSpaces: 4,
    // or false
    tabindex: !1,
    // int
    tabAsSpaces: !1,
    // true or number of spaces
    tabKey: !0,
    // autosave
    autosave: !1,
    // false or url
    autosaveName: !1,
    autosaveData: !1,
    autosaveMethod: "post",
    // toolbar
    toolbar: !0,
    toolbarFixed: !0,
    toolbarFixedTarget: document,
    toolbarFixedTopOffset: 0,
    // pixels
    toolbarExternal: !1,
    // ID selector
    toolbarContext: !0,
    // air
    air: !1,
    // formatting
    formatting: ["p", "blockquote", "pre", "h1", "h2", "h3", "h4", "h5", "h6"],
    formattingAdd: !1,
    formattingHide: !1,
    // buttons
    buttons: ["html", "format", "bold", "italic", "deleted", "lists", "image", "file", "link"],
    // + 'line', 'redo', 'undo', 'underline', 'ol', 'ul', 'indent', 'outdent'
    buttonsTextLabeled: !1,
    buttonsAdd: [],
    buttonsAddFirst: [],
    buttonsAddAfter: !1,
    buttonsAddBefore: !1,
    buttonsHide: [],
    buttonsHideOnMobile: [],
    // image
    imageUpload: !1,
    imageUploadParam: "file",
    imageData: !1,
    imageEditable: !0,
    imageCaption: !0,
    imageLink: !0,
    imagePosition: !1,
    imageResizable: !1,
    imageFloatMargin: "10px",
    imageFigure: !0,
    imageObserve: !0,
    imageSrcData: !1,
    // file
    fileUpload: !1,
    fileUploadParam: "file",
    fileData: !1,
    fileAttachment: !1,
    // upload opts
    uploadData: !1,
    dragUpload: !0,
    multipleUpload: !0,
    clipboardUpload: !0,
    uploadBase64: !1,
    // link
    linkTarget: !1,
    linkTitle: !1,
    linkNewTab: !0,
    linkNofollow: !1,
    linkSize: 30,
    linkValidation: !0,
    // clean
    cleanOnEnter: !0,
    cleanInlineOnEnter: !1,
    paragraphize: !0,
    removeScript: !0,
    removeNewLines: !1,
    removeComments: !0,
    replaceTags: {
      b: "strong",
      i: "em",
      strike: "del"
    },
    // paste
    pastePlainText: !1,
    pasteLinkTarget: !1,
    pasteImages: !0,
    pasteLinks: !0,
    pasteClean: !0,
    pasteKeepStyle: [],
    pasteKeepClass: [],
    pasteKeepAttrs: ["td", "th"],
    pasteBlockTags: [
      "pre",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "table",
      "tbody",
      "thead",
      "tfoot",
      "th",
      "tr",
      "td",
      "ul",
      "ol",
      "li",
      "blockquote",
      "p",
      "figure",
      "figcaption"
    ],
    pasteInlineTags: [
      "a",
      "img",
      "br",
      "strong",
      "ins",
      "code",
      "del",
      "span",
      "samp",
      "kbd",
      "sup",
      "sub",
      "mark",
      "var",
      "cite",
      "small",
      "b",
      "u",
      "em",
      "i",
      "abbr"
    ],
    // active buttons
    activeButtons: {
      b: "bold",
      strong: "bold",
      i: "italic",
      em: "italic",
      del: "deleted",
      strike: "deleted",
      u: "underline"
    },
    activeButtonsAdd: {},
    activeButtonsObservers: {},
    // autoparser
    autoparse: !0,
    autoparseStart: !0,
    autoparsePaste: !0,
    autoparseLinks: !0,
    autoparseImages: !0,
    autoparseVideo: !0,
    autoparseHttps: !1,
    // shortcodes
    shortcodes: {
      "p.": { format: "p" },
      "quote.": { format: "blockquote" },
      "pre.": { format: "pre" },
      "h1.": { format: "h1" },
      "h2.": { format: "h2" },
      "h3.": { format: "h3" },
      "h4.": { format: "h4" },
      "h5.": { format: "h5" },
      "h6.": { format: "h6" },
      //'1.': { format: 'ol' },
      "*.": { format: "ul" }
    },
    shortcodesAdd: !1,
    // object
    // shortcuts
    shortcuts: {
      "ctrl+shift+m, meta+shift+m": { api: "module.inline.clearformat" },
      "ctrl+b, meta+b": { api: "module.inline.format", args: "b" },
      "ctrl+i, meta+i": { api: "module.inline.format", args: "i" },
      "ctrl+u, meta+u": { api: "module.inline.format", args: "u" },
      "ctrl+h, meta+h": { api: "module.inline.format", args: "sup" },
      "ctrl+l, meta+l": { api: "module.inline.format", args: "sub" },
      "ctrl+k, meta+k": { api: "module.link.open" },
      "ctrl+alt+0, meta+alt+0": { api: "module.block.format", args: "p" },
      "ctrl+alt+1, meta+alt+1": { api: "module.block.format", args: "h1" },
      "ctrl+alt+2, meta+alt+2": { api: "module.block.format", args: "h2" },
      "ctrl+alt+3, meta+alt+3": { api: "module.block.format", args: "h3" },
      "ctrl+alt+4, meta+alt+4": { api: "module.block.format", args: "h4" },
      "ctrl+alt+5, meta+alt+5": { api: "module.block.format", args: "h5" },
      "ctrl+alt+6, meta+alt+6": { api: "module.block.format", args: "h6" },
      "ctrl+shift+7, meta+shift+7": { api: "module.list.toggle", args: "ol" },
      "ctrl+shift+8, meta+shift+8": { api: "module.list.toggle", args: "ul" }
    },
    shortcutsAdd: !1,
    // object
    // misc
    grammarly: !0,
    notranslate: !1,
    // private
    bufferLimit: 100,
    emptyHtml: "<p></p>",
    markerChar: "\uFEFF",
    imageTypes: ["image/png", "image/jpeg", "image/gif"],
    imageAttrs: ["alt", "title", "src", "class", "width", "height", "srcset"],
    inlineTags: [
      "a",
      "span",
      "strong",
      "strike",
      "b",
      "u",
      "em",
      "i",
      "code",
      "del",
      "ins",
      "samp",
      "kbd",
      "sup",
      "sub",
      "mark",
      "var",
      "cite",
      "small",
      "abbr"
    ],
    blockTags: [
      "pre",
      "ul",
      "ol",
      "li",
      "p",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "dl",
      "dt",
      "dd",
      "div",
      "table",
      "tbody",
      "thead",
      "tfoot",
      "tr",
      "th",
      "td",
      "blockquote",
      "output",
      "figcaption",
      "figure",
      "address",
      "section",
      "header",
      "footer",
      "aside",
      "article",
      "iframe"
    ],
    regex: {
      youtube: /^https?\:\/\/(?:www\.youtube(?:\-nocookie)?\.com\/|m\.youtube\.com\/|youtube\.com\/)?(?:ytscreeningroom\?vi?=|youtu\.be\/|vi?\/|user\/.+\/u\/\w{1,2}\/|embed\/|watch\?(?:.*\&)?vi?=|\&vi?=|\?(?:.*\&)?vi?=)([^#\&\?\n\/<>"']*)/gi,
      vimeo: /(http|https)?:\/\/(?:www.|player.)?vimeo.com\/(?:channels\/(?:\w+\/)?|groups\/(?:[^/]*)\/videos\/|album\/(?:\d+)\/video\/|video\/|)(\d+)(?:\/[a-zA-Z0-9_-]+)?/gi,
      imageurl: /((https?|www)[^\s]+\.)(jpe?g|png|gif)(\?[^\s-]+)?/gi,
      url: /https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z\u00F0-\u02AF0-9()!@:%_+.~#?&//=]*)/gi,
      aurl1: /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/gim,
      aurl2: /(^|[^\/])(www\.[\S]+(\b|$))/gim
    },
    input: !0,
    zindex: !1,
    modes: {
      inline: {
        pastePlainText: !0,
        pasteImages: !1,
        enterKey: !1,
        toolbar: !1,
        autoparse: !1,
        source: !1,
        showSource: !1,
        styles: !1,
        air: !1
      },
      original: {
        styles: !1
      }
    }
  }, c.lang.en = {
    format: "Format",
    image: "Image",
    file: "File",
    link: "Link",
    bold: "Bold",
    italic: "Italic",
    deleted: "Strikethrough",
    underline: "Underline",
    superscript: "Superscript",
    subscript: "Subscript",
    "bold-abbr": "B",
    "italic-abbr": "I",
    "deleted-abbr": "S",
    "underline-abbr": "U",
    "superscript-abbr": "Sup",
    "subscript-abbr": "Sub",
    lists: "Lists",
    "link-insert": "Insert Link",
    "link-edit": "Edit Link",
    "link-in-new-tab": "Open link in new tab",
    unlink: "Unlink",
    cancel: "Cancel",
    close: "Close",
    insert: "Insert",
    save: "Save",
    delete: "Delete",
    text: "Text",
    edit: "Edit",
    title: "Alt",
    paragraph: "Normal text",
    quote: "Quote",
    code: "Code",
    heading1: "Heading 1",
    heading2: "Heading 2",
    heading3: "Heading 3",
    heading4: "Heading 4",
    heading5: "Heading 5",
    heading6: "Heading 6",
    filename: "Name",
    optional: "optional",
    unorderedlist: "Unordered List",
    orderedlist: "Ordered List",
    outdent: "Outdent",
    indent: "Indent",
    horizontalrule: "Line",
    upload: "Upload",
    "upload-label": "Drop files here or click to upload",
    "accessibility-help-label": "Rich text editor",
    caption: "Caption",
    bulletslist: "Bullets",
    numberslist: "Numbers",
    "image-position": "Position",
    none: "None",
    left: "Left",
    right: "Right",
    center: "Center",
    undo: "Undo",
    redo: "Redo"
  }, c.buttons = {
    html: {
      title: "HTML",
      icon: !0,
      api: "module.source.toggle"
    },
    undo: {
      title: "## undo ##",
      icon: !0,
      api: "module.buffer.undo"
    },
    redo: {
      title: "## redo ##",
      icon: !0,
      api: "module.buffer.redo"
    },
    format: {
      title: "## format ##",
      icon: !0,
      dropdown: {
        p: {
          title: "## paragraph ##",
          api: "module.block.format",
          args: {
            tag: "p"
          }
        },
        blockquote: {
          title: "## quote ##",
          api: "module.block.format",
          args: {
            tag: "blockquote"
          }
        },
        pre: {
          title: "## code ##",
          api: "module.block.format",
          args: {
            tag: "pre"
          }
        },
        h1: {
          title: "## heading1 ##",
          api: "module.block.format",
          args: {
            tag: "h1"
          }
        },
        h2: {
          title: "## heading2 ##",
          api: "module.block.format",
          args: {
            tag: "h2"
          }
        },
        h3: {
          title: "## heading3 ##",
          api: "module.block.format",
          args: {
            tag: "h3"
          }
        },
        h4: {
          title: "## heading4 ##",
          api: "module.block.format",
          args: {
            tag: "h4"
          }
        },
        h5: {
          title: "## heading5 ##",
          api: "module.block.format",
          args: {
            tag: "h5"
          }
        },
        h6: {
          title: "## heading6 ##",
          api: "module.block.format",
          args: {
            tag: "h6"
          }
        }
      }
    },
    bold: {
      title: "## bold-abbr ##",
      icon: !0,
      tooltip: "## bold ##",
      api: "module.inline.format",
      args: {
        tag: "b"
      }
    },
    italic: {
      title: "## italic-abbr ##",
      icon: !0,
      tooltip: "## italic ##",
      api: "module.inline.format",
      args: {
        tag: "i"
      }
    },
    deleted: {
      title: "## deleted-abbr ##",
      icon: !0,
      tooltip: "## deleted ##",
      api: "module.inline.format",
      args: {
        tag: "del"
      }
    },
    underline: {
      title: "## underline-abbr ##",
      icon: !0,
      tooltip: "## underline ##",
      api: "module.inline.format",
      args: {
        tag: "u"
      }
    },
    sup: {
      title: "## superscript-abbr ##",
      icon: !0,
      tooltip: "## superscript ##",
      api: "module.inline.format",
      args: {
        tag: "sup"
      }
    },
    sub: {
      title: "## subscript-abbr ##",
      icon: !0,
      tooltip: "## subscript ##",
      api: "module.inline.format",
      args: {
        tag: "sub"
      }
    },
    lists: {
      title: "## lists ##",
      icon: !0,
      observe: "list",
      dropdown: {
        observe: "list",
        unorderedlist: {
          title: "&bull; ## unorderedlist ##",
          api: "module.list.toggle",
          args: "ul"
        },
        orderedlist: {
          title: "1. ## orderedlist ##",
          api: "module.list.toggle",
          args: "ol"
        },
        outdent: {
          title: "< ## outdent ##",
          api: "module.list.outdent"
        },
        indent: {
          title: "> ## indent ##",
          api: "module.list.indent"
        }
      }
    },
    ul: {
      title: "&bull; ## bulletslist ##",
      icon: !0,
      api: "module.list.toggle",
      observe: "list",
      args: "ul"
    },
    ol: {
      title: "1. ## numberslist ##",
      icon: !0,
      api: "module.list.toggle",
      observe: "list",
      args: "ol"
    },
    outdent: {
      title: "## outdent ##",
      icon: !0,
      api: "module.list.outdent",
      observe: "list"
    },
    indent: {
      title: "## indent ##",
      icon: !0,
      api: "module.list.indent",
      observe: "list"
    },
    image: {
      title: "## image ##",
      icon: !0,
      api: "module.image.open"
    },
    file: {
      title: "## file ##",
      icon: !0,
      api: "module.file.open"
    },
    link: {
      title: "## link ##",
      icon: !0,
      observe: "link",
      dropdown: {
        observe: "link",
        link: {
          title: "## link-insert ##",
          api: "module.link.open"
        },
        unlink: {
          title: "## unlink ##",
          api: "module.link.unlink"
        }
      }
    },
    line: {
      title: "## horizontalrule ##",
      icon: !0,
      api: "module.line.insert"
    }
  };
  var f = function(r, h, u) {
    this.module = {}, this.plugin = {}, this.instances = {}, this.started = !1, this.stopped = !1, this.uuid = u, this.rootElement = r, this.rootOpts = h, this.dragInside = !1, this.dragComponentInside = !1, this.keycodes = c.keycodes, this.namespace = "redactor", this.$win = c.dom(window), this.$doc = c.dom(document), this.$body = c.dom("body"), this.editorReadOnly = !1, this.opts = c.create("service.options", h, r), this.lang = c.create("service.lang", this), this.buildServices(), this.buildModules(), this.buildPlugins(), this.start();
  };
  f.prototype = {
    start: function() {
      this.stopped = !1, this.broadcast("start"), this.broadcast("startcode"), this.opts.clickToEdit ? this.broadcast("startclicktoedit") : (this.broadcast("enable"), this.opts.showSource && this.broadcast("startcodeshow"), this.broadcast("enablefocus")), this.broadcast("started"), this.started = !0;
    },
    stop: function() {
      this.started = !1, this.stopped = !0, this.broadcast("stop"), this.broadcast("disable"), this.broadcast("stopped");
    },
    // started & stopped
    isStarted: function() {
      return this.started;
    },
    isStopped: function() {
      return this.stopped;
    },
    // build
    buildServices: function() {
      var r = ["options", "lang"], h = ["uuid", "keycodes", "opts", "lang", "$win", "$doc", "$body"], u = [];
      for (var g in c.services)
        r.indexOf(g) === -1 && (this[g] = c.create("service." + g, this), u.push(g), h.push(g));
      for (var b = 0; b < u.length; b++)
        for (var O = u[b], x = 0; x < h.length; x++) {
          var S = h[x];
          O !== S && (this[O][S] = this[S]);
        }
    },
    buildModules: function() {
      for (var r in c.modules)
        this.module[r] = c.create("module." + r, this), this.instances[r] = this.module[r];
    },
    buildPlugins: function() {
      for (var r = this.opts.plugins, h = 0; h < r.length; h++) {
        var u = r[h];
        typeof c.plugins[u] < "u" && (this.plugin[u] = c.create("plugin." + u, this), this.instances[u] = this.plugin[u]);
      }
    },
    // draginside
    isDragInside: function() {
      return this.dragInside;
    },
    setDragInside: function(r) {
      this.dragInside = r;
    },
    isDragComponentInside: function() {
      return this.dragComponentInside;
    },
    setDragComponentInside: function(r) {
      this.dragComponentInside = r;
    },
    getDragComponentInside: function() {
      return this.dragComponentInside;
    },
    // readonly
    isReadOnly: function() {
      return this.editorReadOnly;
    },
    enableReadOnly: function() {
      this.editorReadOnly = !0, this.broadcast("enablereadonly"), this.component.clearActive(), this.toolbar.disableButtons();
    },
    disableReadOnly: function() {
      this.editorReadOnly = !1, this.broadcast("disablereadonly"), this.toolbar.enableButtons();
    },
    // messaging
    callMessageHandler: function(r, h, u) {
      var g = h.split("."), b;
      if (g.length === 1)
        typeof r["on" + h] == "function" && (b = r["on" + h].apply(r, u));
      else {
        g[0] = "on" + g[0];
        var O = this.utils.checkProperty(r, g);
        typeof O == "function" && (b = O.apply(r, u));
      }
      return b;
    },
    broadcast: function(r) {
      var h = [].slice.call(arguments, 1), u;
      for (var g in this.instances) {
        var b = this.callMessageHandler(this.instances[g], r, h);
        typeof b < "u" && (u = b);
      }
      var O = this.callback.trigger(r, h);
      return typeof u < "u" ? u : O;
    },
    // callback
    on: function(r, h) {
      this.callback.add(r, h);
    },
    off: function(r, h) {
      this.callback.remove(r, h);
    },
    // api
    api: function(r) {
      if (!(!this.isStarted() && r !== "start") && !(this.isReadOnly() && r !== "disableReadOnly")) {
        this.broadcast("state");
        var h = [].slice.call(arguments, 1), u = r.split("."), g = u.length === 1, b = u[0] === "on" || u[0] === "off", O = !b && u.length === 2, x = u[0] === "plugin", S = u[0] === "module";
        if (g) {
          if (typeof this[u[0]] == "function")
            return this.callInstanceMethod(this, u[0], h);
        } else {
          if (b)
            return u[0] === "on" ? this.on(u[1], h[0]) : this.off(u[1], h[0] || void 0);
          if (O) {
            if (this.isInstanceExists(this, u[0]))
              return this.callInstanceMethod(this[u[0]], u[1], h);
            c.error(new Error('Service "' + u[0] + '" not found'));
          } else if (x) {
            if (this.isInstanceExists(this.plugin, u[1]))
              return this.callInstanceMethod(this.plugin[u[1]], u[2], h);
            c.error(new Error('Plugin "' + u[1] + '" not found'));
          } else if (S) {
            if (this.isInstanceExists(this.module, u[1]))
              return this.callInstanceMethod(this.module[u[1]], u[2], h);
            c.error(new Error('Module "' + u[1] + '" not found'));
          }
        }
      }
    },
    isInstanceExists: function(r, h) {
      return typeof r[h] < "u";
    },
    callInstanceMethod: function(r, h, u) {
      if (typeof r[h] == "function")
        return r[h].apply(r, u);
    }
  }, c.add("mixin", "formatter", {
    // public
    buildArgs: function(r) {
      this.args = {
        class: r.class || !1,
        style: r.style || !1,
        attr: r.attr || !1
      }, !this.args.class && !this.args.style && !this.args.attr && (this.args = !1);
    },
    applyArgs: function(r, h) {
      return this.args ? r = this[this.type](this.args, !1, r, h) : r = this._clearAll(r, h), r;
    },
    clearClass: function(r, h) {
      this.selection.save();
      var u = h ? c.dom(h) : this.getElements(r, !0);
      return u.removeAttr("class"), h = this._unwrapSpanWithoutAttr(u.getAll()), this.selection.restore(), h;
    },
    clearStyle: function(r, h) {
      this.selection.save();
      var u = h ? c.dom(h) : this.getElements(r, !0);
      return u.removeAttr("style"), h = this._unwrapSpanWithoutAttr(u.getAll()), this.selection.restore(), h;
    },
    clearAttr: function(r, h) {
      this.selection.save();
      var u = h ? c.dom(h) : this.getElements(r, !0);
      return this._removeAllAttr(u), h = this._unwrapSpanWithoutAttr(u.getAll()), this.selection.restore(), h;
    },
    set: function(r, h, u, g) {
      g !== !1 && this.selection.save();
      var b = u ? c.dom(u) : this.getElements(h);
      return r.class && (b.removeAttr("class"), b.addClass(r.class)), r.style && (b.removeAttr("style"), b.css(r.style), b.each(function(O) {
        var x = c.dom(O);
        x.attr("data-redactor-style-cache", x.attr("style"));
      })), r.attr && (this._removeAllAttr(b), b.attr(r.attr)), g !== !1 && this.selection.restore(), b.getAll();
    },
    toggle: function(r, h, u, g) {
      g !== !1 && this.selection.save();
      var b = u ? c.dom(u) : this.getElements(h);
      r.class && (b.toggleClass(r.class), b.each(function(x) {
        x.className === "" && x.removeAttribute("class");
      }));
      var O;
      return r.style && (O = r.style, b.each(
        (function(x) {
          var S = c.dom(x);
          for (var k in O) {
            var C = O[k], _ = S.css(k);
            _ = this.utils.isRgb(_) ? this.utils.rgb2hex(_) : _.replace(/"/g, ""), C = this.utils.isRgb(C) ? this.utils.rgb2hex(C) : C.replace(/"/g, ""), _ = this.utils.hex2long(_), C = this.utils.hex2long(C);
            var $ = typeof C == "string" ? C.toLowerCase() : C, L = typeof _ == "string" ? _.toLowerCase() : _;
            $ === L ? S.css(k, "") : S.css(k, C);
          }
          this._convertStyleQuotes(S), this.utils.removeEmptyAttr(x, "style") ? S.removeAttr("data-redactor-style-cache") : S.attr("data-redactor-style-cache", S.attr("style"));
        }).bind(this)
      )), r.attr && (O = r.attr, b.each(function(x) {
        var S = c.dom(x);
        for (var k in O)
          S.attr(k) ? S.removeAttr(k) : S.attr(k, O[k]);
      })), g !== !1 && this.selection.restore(), b.getAll();
    },
    add: function(r, h, u, g) {
      g !== !1 && this.selection.save();
      var b = u ? c.dom(u) : this.getElements(h);
      if (r.class && b.addClass(r.class), r.style) {
        var O = r.style;
        b.each(
          (function(x) {
            var S = c.dom(x);
            S.css(O), S.attr("data-redactor-style-cache", S.attr("style")), this._convertStyleQuotes(S);
          }).bind(this)
        );
      }
      return r.attr && b.attr(r.attr), g !== !1 && this.selection.restore(), b.getAll();
    },
    remove: function(r, h, u, g) {
      g !== !1 && this.selection.save();
      var b = u ? c.dom(u) : this.getElements(h);
      if (r.class && (b.removeClass(r.class), b.each(function(x) {
        x.className === "" && x.removeAttribute("class");
      })), r.style) {
        var O = r.style;
        b.each(
          (function(x) {
            var S = c.dom(x);
            S.css(O, ""), this.utils.removeEmptyAttr(x, "style") ? S.removeAttr("data-redactor-style-cache") : S.attr("data-redactor-style-cache", S.attr("style"));
          }).bind(this)
        );
      }
      return r.attr && b.removeAttr(r.attr), u = this._unwrapSpanWithoutAttr(b.getAll()), g !== !1 && this.selection.restore(), u;
    },
    // private
    _removeAllAttr: function(r) {
      r.each(function(h) {
        for (var u = h.attributes.length; u-- > 0; ) {
          var g = h.attributes[u], b = g.name;
          b !== "style" && b !== "class" && h.removeAttributeNode(g);
        }
      });
    },
    _convertStyleQuotes: function(r) {
      var h = r.attr("style");
      h && r.attr("style", h.replace(/"/g, "'"));
    },
    _clearAll: function(r, h) {
      h !== !1 && this.selection.save();
      for (var u = 0; u < r.length; u++)
        for (var g = r[u]; g.attributes.length > 0; )
          g.removeAttribute(g.attributes[0].name);
      return r = this._unwrapSpanWithoutAttr(r), h !== !1 && this.selection.restore(), r;
    },
    _unwrapSpanWithoutAttr: function(r) {
      for (var h = [], u = 0; u < r.length; u++) {
        var g = r[u], b = g.attributes.length;
        b <= 0 && g.nodeType !== 3 && g.tagName === "SPAN" ? c.dom(g).unwrap() : h.push(g);
      }
      return h;
    }
  }), c.add("mixin", "dom", c.Dom.prototype), c.add("mixin", "component", {
    get cmnt() {
      return !0;
    }
  }), c.add("service", "options", {
    init: function(r, h) {
      var u = c.dom(h), g = c.extend({}, c.opts, h ? u.data() : {}, c.options);
      return g = c.extend(!0, g, r), g;
    }
  }), c.add("service", "lang", {
    init: function(r) {
      this.app = r, this.opts = r.opts, this.vars = this._build(this.opts.lang);
    },
    // public
    rebuild: function(r) {
      this.opts.lang = r, this.vars = this._build(r);
    },
    extend: function(r) {
      this.vars = c.extend(this.vars, r);
    },
    parse: function(r) {
      if (r === void 0)
        return "";
      var h = r.match(/## (.*?) ##/g);
      if (h)
        for (var u = 0; u < h.length; u++) {
          var g = h[u].replace(/^##\s/g, "").replace(/\s##$/g, "");
          r = r.replace(h[u], this.get(g));
        }
      return r;
    },
    get: function(r) {
      var h = "";
      return typeof this.vars[r] < "u" ? h = this.vars[r] : this.opts.lang !== "en" && typeof c.lang.en[r] < "u" && (h = c.lang.en[r]), h;
    },
    // private
    _build: function(r) {
      var h = c.lang.en;
      return r !== "en" && (h = c.lang[r] !== void 0 ? c.lang[r] : h), h;
    }
  }), c.add("service", "callback", {
    init: function(r) {
      this.app = r, this.opts = r.opts, this.callbacks = {}, this.opts.callbacks && this._set(this.opts.callbacks, "");
    },
    stop: function() {
      this.callbacks = {};
    },
    add: function(r, h) {
      this.callbacks[r] || (this.callbacks[r] = []), this.callbacks[r].push(h);
    },
    remove: function(r, h) {
      if (h === void 0)
        delete this.callbacks[r];
      else {
        for (var u = 0; u < this.callbacks[r].length; u++)
          this.callbacks[r].splice(u, 1);
        Object.keys(this.callbacks[r]).length === 0 && delete this.callbacks[r];
      }
    },
    trigger: function(r, h) {
      var u = this._loop(r, h, this.callbacks);
      return typeof u > "u" && h && h[0] !== !1 ? h[0] : u;
    },
    // private
    _set: function(r, h) {
      for (var u in r) {
        var g = h === "" ? u : h + "." + u;
        typeof r[u] == "object" ? this._set(r[u], g) : (this.callbacks[g] = [], this.callbacks[g].push(r[u]));
      }
    },
    _loop: function(r, h, u) {
      var g;
      for (var b in u)
        if (r === b)
          for (var O = 0; O < u[b].length; O++)
            g = u[b][O].apply(this.app, h);
      return g;
    }
  }), c.add("service", "animate", {
    init: function(r) {
      this.animationOpt = r.opts.animation;
    },
    start: function(r, h, u, g) {
      var b = {
        duration: !1,
        iterate: !1,
        delay: !1,
        timing: !1,
        prefix: "redactor-"
      };
      return b = typeof u == "function" ? b : c.extend(b, u), g = typeof u == "function" ? u : g, new c.AnimatePlay(r, h, b, g, this.animationOpt);
    },
    stop: function(r) {
      this.$el = c.dom(r), this.$el.removeClass("redactor-animated");
      var h = this.$el.attr("redactor-animate-effect");
      this.$el.removeClass(h), this.$el.removeAttr("redactor-animate-effect");
      var u = this.$el.attr("redactor-animate-hide");
      u && this.$el.addClass(u).removeAttr("redactor-animate-hide"), this.$el.off("animationend webkitAnimationEnd");
    }
  }), c.AnimatePlay = function(r, h, u, g, b) {
    return this.hidableEffects = ["fadeOut", "flipOut", "slideUp", "zoomOut", "slideOutUp", "slideOutRight", "slideOutLeft"], this.prefixes = ["", "-webkit-"], this.$el = c.dom(r), this.$body = c.dom("body"), this.callback = g, this.animation = b ? h : this.buildAnimationOff(h), this.defaults = u, this.animation === "slideUp" && this.$el.height(this.$el.height()), this.isInanimate() ? this.inanimate() : this.animate();
  }, c.AnimatePlay.prototype = {
    buildAnimationOff: function(r) {
      return this.isHidable(r) ? "hide" : "show";
    },
    buildHideClass: function() {
      return "redactor-animate-hide";
    },
    isInanimate: function() {
      return this.animation === "show" || this.animation === "hide";
    },
    isAnimated: function() {
      return this.$el.hasClass("redactor-animated");
    },
    isHidable: function(r) {
      return this.hidableEffects.indexOf(r) !== -1;
    },
    inanimate: function() {
      this.defaults.timing = "linear";
      var r;
      return this.animation === "show" ? (r = this.buildHideClass(), this.$el.attr("redactor-animate-hide", r), this.$el.removeClass(r)) : (r = this.$el.attr("redactor-animate-hide"), this.$el.addClass(r).removeAttr("redactor-animate-hide")), typeof this.callback == "function" && this.callback(this), this;
    },
    animate: function() {
      var r = this.defaults.delay ? this.defaults.delay : 0;
      return setTimeout(
        (function() {
          if (this.$body.addClass("no-scroll-x"), this.$el.addClass("redactor-animated"), !this.$el.attr("redactor-animate-hide")) {
            var h = this.buildHideClass();
            this.$el.attr("redactor-animate-hide", h), this.$el.removeClass(h);
          }
          this.$el.addClass(this.defaults.prefix + this.animation), this.$el.attr("redactor-animate-effect", this.defaults.prefix + this.animation), this.set(this.defaults.duration + "s", this.defaults.iterate, this.defaults.timing), this.complete();
        }).bind(this),
        r * 1e3
      ), this;
    },
    set: function(r, h, u) {
      for (var g = this.prefixes.length; g--; )
        (r !== !1 || r === "") && this.$el.css(this.prefixes[g] + "animation-duration", r), (h !== !1 || h === "") && this.$el.css(this.prefixes[g] + "animation-iteration-count", h), (u !== !1 || u === "") && this.$el.css(this.prefixes[g] + "animation-timing-function", u);
    },
    clean: function() {
      this.$body.removeClass("no-scroll-x"), this.$el.removeClass("redactor-animated"), this.$el.removeClass(this.defaults.prefix + this.animation), this.$el.removeAttr("redactor-animate-effect"), this.set("", "", "");
    },
    complete: function() {
      this.$el.one(
        "animationend webkitAnimationEnd",
        (function() {
          if (this.$el.hasClass(this.defaults.prefix + this.animation) && this.clean(), this.isHidable(this.animation)) {
            var r = this.$el.attr("redactor-animate-hide");
            this.$el.addClass(r).removeAttr("redactor-animate-hide");
          }
          this.animation === "slideUp" && this.$el.height(""), typeof this.callback == "function" && this.callback(this.$el);
        }).bind(this)
      );
    }
  }, c.add("service", "caret", {
    init: function(r) {
      this.app = r;
    },
    // set
    setStart: function(r) {
      this._setCaret("Start", r);
    },
    setEnd: function(r) {
      this._setCaret("End", r);
    },
    setBefore: function(r) {
      this._setCaret("Before", r);
    },
    setAfter: function(r) {
      this._setCaret("After", r);
    },
    // is
    isStart: function(r) {
      return this._isStartOrEnd(r, "First");
    },
    isEnd: function(r) {
      return this._isStartOrEnd(r, "Last");
    },
    // set side
    setAtEnd: function(r) {
      var h = this.inspector.parse(r), u = h.getTag(), g = document.createRange();
      if (this._isInPage(r)) {
        if (u === "a") {
          var b = this.utils.createInvisibleChar();
          c.dom(r).after(b), g.selectNodeContents(b), g.collapse(!0);
        } else
          g.selectNodeContents(r), g.collapse(!1);
        this.selection.setRange(g);
      }
    },
    setAtStart: function(r) {
      var h = document.createRange(), u = this.inspector.parse(r);
      if (this._isInPage(r)) {
        if (h.setStart(r, 0), h.collapse(!0), u.isInline()) {
          var g = this.utils.createInvisibleChar();
          h.insertNode(g), h.selectNodeContents(g), h.collapse(!1);
        }
        this.selection.setRange(h);
      }
    },
    setAtBefore: function(r) {
      var h = this.inspector.parse(r), u = document.createRange();
      if (this._isInPage(r)) {
        if (u.setStartBefore(r), u.collapse(!0), h.isInline()) {
          var g = this.utils.createInvisibleChar();
          r.parentNode.insertBefore(g, r), u.selectNodeContents(g), u.collapse(!1);
        }
        this.selection.setRange(u);
      }
    },
    setAtAfter: function(r) {
      var h = document.createRange();
      if (this._isInPage(r)) {
        h.setStartAfter(r), h.collapse(!0);
        var u = this.utils.createInvisibleChar();
        h.insertNode(u), h.selectNodeContents(u), h.collapse(!1), this.selection.setRange(h);
      }
    },
    setAtPrev: function(r) {
      var h = r.previousSibling;
      h && (h = h.nodeType === 3 && this._isEmptyTextNode(h) ? h.previousElementSibling : h, h && this.setEnd(h));
    },
    setAtNext: function(r) {
      var h = r.nextSibling;
      h && (h = h.nodeType === 3 && this._isEmptyTextNode(h) ? h.nextElementSibling : h, h && this.setStart(h));
    },
    // private
    _setCaret: function(r, h) {
      var u = this.inspector.parse(h), g = u.getNode();
      g && (this.component.clearActive(), this["_set" + r](g, u, u.getTag()));
    },
    _setStart: function(r, h, u) {
      if (h.isText())
        return this.editor.focus(), this.setAtStart(r);
      if (u === "ul" || u === "ol") {
        r = h.findFirstNode("li");
        var g = this.utils.getFirstElement(r), b = this.inspector.parse(g);
        if (g && b.isComponent())
          return this.setStart(b.getComponent());
      } else if (u === "dl")
        r = h.findFirstNode("dt");
      else {
        if (u === "br" || u === "hr")
          return this.setBefore(r);
        if (u === "td" || u === "th") {
          var O = h.getFirstElement(r);
          if (O)
            return this.setStart(O);
        } else {
          if (u === "table" || u === "tr")
            return this.setStart(h.findFirstNode("th, td"));
          if (h.isComponentType("code") && !h.isFigcaption()) {
            var x = h.findLastNode("pre, code");
            return this.editor.focus(), this.setAtStart(x);
          } else if (u === "figure" && h.isComponentType("table")) {
            var S = h.getTable(), k = this.inspector.parse(S);
            return this.setStart(k.findFirstNode("th, td"));
          } else if (!h.isComponentType("table") && h.isComponent() && !h.isFigcaption())
            return this.component.setActive(r);
        }
      }
      this.editor.focus(), this._setInline(r, "Start") || this.setAtStart(r);
    },
    _setEnd: function(r, h, u) {
      if (h.isText())
        return this.editor.focus(), this.setAtEnd(r);
      if (u === "ul" || u === "ol") {
        r = h.findLastNode("li");
        var g = this.utils.getLastElement(r), b = this.inspector.parse(g);
        if (g && b.isComponent())
          return this.setEnd(b.getComponent());
      } else if (u === "dl")
        r = h.findLastNode("dd");
      else {
        if (u === "br" || u === "hr")
          return this.setAfter(r);
        if (u === "td" || u === "th") {
          var O = h.getLastElement();
          if (O)
            return this.setEnd(O);
        } else {
          if (u === "table" || u === "tr")
            return this.setEnd(h.findLastNode("th, td"));
          if (h.isComponentType("code") && !h.isFigcaption()) {
            var x = h.findLastNode("pre, code");
            return this.editor.focus(), this.setAtEnd(x);
          } else if (u === "figure" && h.isComponentType("table")) {
            var S = h.getTable(), k = this.inspector.parse(S);
            return this.setEnd(k.findLastNode("th, td"));
          } else if (!h.isComponentType("table") && h.isComponent() && !h.isFigcaption())
            return this.component.setActive(r);
        }
      }
      if (this.editor.focus(), !this._setInline(r, "End")) {
        if (this.utils.isEmpty(r))
          return this.setStart(r);
        this.setAtEnd(r);
      }
    },
    _setBefore: function(r, h, u) {
      if (r.nodeType === 3)
        return this.setAtBefore(r);
      if (h.isInline())
        return this.setAtBefore(r);
      if (h.isFirstTableCell())
        return this.setAtPrev(h.getComponent());
      if (u === "td" || u === "th")
        return this.setAtPrev(r);
      if (h.isFirstListItem())
        return this.setAtPrev(h.getList());
      if (h.isFigcaption())
        return this.setStart(h.getComponent());
      if (!h.isComponentType("table") && h.isComponent())
        return this.setAtPrev(h.getComponent());
      if (h.isBlock())
        return this.setAtPrev(r);
      this.editor.focus(), this.setAtBefore(r);
    },
    _setAfter: function(r, h, u) {
      if (r.nodeType === 3)
        return this.setAtAfter(r);
      if (h.isInline())
        return this.setAtAfter(r);
      if (h.isLastTableCell())
        return this.setAtNext(h.getComponent());
      if (u === "td" || u === "th")
        return this.setAtNext(r);
      if (h.isFirstListItem())
        return this.setAtNext(h.getList());
      if (!h.isComponentType("table") && h.isComponent())
        return this.setAtNext(h.getComponent());
      if (h.isBlock())
        return this.setAtNext(r);
      this.editor.focus(), this.setAtAfter(r);
    },
    _setInline: function(r, h) {
      var u = this._hasInlineChild(r, h === "Start" ? "first" : "last");
      if (u)
        return h === "Start" ? this.setStart(u) : this.setEnd(u), !0;
    },
    _isStartOrEnd: function(r, h) {
      var u = this.utils.getNode(r);
      if (!u)
        return !1;
      var g = this.inspector.parse(u);
      if (u = this._getStartEndNode(u, g, h), u && u.nodeType !== 3 && u.tagName !== "LI") {
        var b = u.nodeType === 3 ? u.textContent : u.innerHTML;
        if (b = this.utils.trimSpaces(b), b === "")
          return !0;
      }
      if (!g.isFigcaption() && g.isComponent() && !g.isComponentEditable())
        return !0;
      var O = this.offset.get(u, !0);
      return O ? h === "First" ? O.start === 0 : O.end === this.offset.size(u, !0) : !1;
    },
    _isInPage: function(r) {
      return r && r.nodeType ? r === document.body ? !1 : document.body.contains(r) : !1;
    },
    _hasInlineChild: function(r, h) {
      var u = this.inspector.parse(r), g = h === "first" ? u.getFirstNode() : u.getLastNode(), b = c.dom(g);
      if (g && g.nodeType !== 3 && this.inspector.isInlineTag(g.tagName) && !b.hasClass("redactor-component") && !b.hasClass("non-editable"))
        return g;
    },
    _isEmptyTextNode: function(r) {
      var h = r.textContent.trim().replace(/\n/, "");
      return h = this.utils.removeInvisibleChars(h), h === "";
    },
    _getStartEndNode: function(r, h, u) {
      return h.isFigcaption() ? r = h.getFigcaption() : h.isTable() ? r = h["find" + u + "Node"]("th, td") : h.isList() ? r = h["find" + u + "Node"]("li") : h.isComponentType("code") && (r = h.findLastNode("pre, code")), r;
    }
  });
  var p = function(h) {
    return document.getSelection().containsNode(h, !0);
  }, m = function(h) {
    var u = document.getSelection(), g = u.anchorNode.parentNode, b = u.focusNode.parentNode, O = u.getRangeAt(0).getBoundingClientRect(), x = h.getBoundingClientRect();
    return !!(c.dom(g).closest(h).length || c.dom(b).closest(h).length || O.top < x.top && O.height > x.height);
  };
  "containsNode" in Selection.prototype || (p = m), c.add("service", "selection", {
    init: function(r) {
      this.app = r;
    },
    // is
    is: function() {
      var r = this.get();
      if (r) {
        var h = r.anchorNode;
        return c.dom(h).closest(".redactor-in-" + this.uuid).length !== 0 || h === this.editor.getElement().get();
      }
      return !1;
    },
    isCollapsed: function() {
      var r = this.get(), h = this.getRange();
      return r && r.isCollapsed ? !0 : !!(h && h.toString().length === 0);
    },
    isBackwards: function() {
      var r = !1, h = this.get();
      if (h && !h.isCollapsed) {
        var u = document.createRange();
        u.setStart(h.anchorNode, h.anchorOffset), u.setEnd(h.focusNode, h.focusOffset), r = u.collapsed, u.detach();
      }
      return r;
    },
    isIn: function(r) {
      var h = c.dom(r).get(), u = this.getCurrent();
      return u && h ? h.contains(u) : !1;
    },
    isText: function() {
      var r = this.get();
      if (r) {
        var h = r.anchorNode, u = this.getBlock(h), g = this.getBlocks();
        if (u && this.inspector.isTableCellTag(u.tagName) || u === !1 && g.length === 0)
          return !0;
      }
      return !1;
    },
    isAll: function(r) {
      var h = this.utils.getNode(r);
      if (!h)
        return !1;
      var u = this.editor.isEditor(h), g = this.inspector.parse(h);
      if (!g.isFigcaption() && this.component.isNonEditable(h) && this.component.isActive(h))
        return !0;
      if (u) {
        var b = this.editor.getElement(), O = b.html().replace(/<p><\/p>$/i, ""), x = this.getHtml(!1).length, S = O.length;
        if (x !== S)
          return !1;
      }
      if (u && this.editor.isEmpty() || this.isCollapsed())
        return !1;
      var k = this.offset.get(h, !0), C = this.offset.size(h, !0);
      return !u && g.isComponentType("code") && (C = this.getText().trim().length), !!(k && k.start === 0 && k.end === C);
    },
    // has
    hasNonEditable: function() {
      var r = this.getHtml(), h = c.dom("<div>").html(r);
      return !this.isCollapsed() && h.find(".non-editable").length !== 0;
    },
    // set
    setRange: function(r) {
      var h = window.getSelection();
      h.removeAllRanges(), h.addRange(r);
    },
    setAll: function(r) {
      var h = this.utils.getNode(r);
      if (h) {
        var u = this.inspector.parse(h);
        if (this.component.clearActive(), this.editor.focus(), this.editor.saveScroll(), this.editor.disableNonEditables(), h && h.tagName === "TABLE") {
          var g = u.findFirstNode("td, th"), b = u.findLastNode("td, th");
          c.dom(g).prepend(this.marker.build("start")), c.dom(b).append(this.marker.build("end")), this.restoreMarkers();
        } else if (!u.isFigcaption() && this.component.isNonEditable(h))
          this.component.setActive(h);
        else {
          u.isComponentType("code") && (h = u.getComponentCodeElement(), h.focus());
          var O = document.createRange();
          O.selectNodeContents(h), this.setRange(O);
        }
        this.editor.enableNonEditables(), this.editor.restoreScroll();
      }
    },
    // get
    get: function() {
      var r = window.getSelection();
      return r.rangeCount > 0 ? r : null;
    },
    getRange: function() {
      var r = this.get();
      return r && r.getRangeAt(0) ? r.getRangeAt(0) : null;
    },
    getTextBeforeCaret: function(r) {
      r = typeof r > "u" ? 1 : r;
      var h = this.editor.getElement().get(), u = this.getRange(), g = !1;
      return u && (u = u.cloneRange(), u.collapse(!0), u.setStart(h, 0), g = u.toString().slice(-r)), g;
    },
    getTextAfterCaret: function(r) {
      r = typeof r > "u" ? 1 : r;
      var h = this.editor.getElement().get(), u = this.getRange(), g = !1;
      if (u) {
        var b = u.cloneRange();
        b.selectNodeContents(h), b.setStart(u.endContainer, u.endOffset), g = b.toString().slice(0, r);
      }
      return g;
    },
    getPosition: function() {
      var r = this.getRange(), h = { top: 0, left: 0, width: 0, height: 0 };
      if (window.getSelection && r.getBoundingClientRect) {
        r = r.cloneRange();
        var u = r.startOffset - 1;
        r.setStart(r.startContainer, u < 0 ? 0 : u);
        var g = r.getBoundingClientRect();
        h = { top: g.top, left: g.left, width: g.right - g.left, height: g.bottom - g.top };
      }
      return h;
    },
    getCurrent: function() {
      var r = !1, h = this.get(), u = this.component.getActive();
      return u ? r = u : h && this.is() && (r = h.anchorNode !== this.editor.getElement().get() ? h.anchorNode : !1), r;
    },
    getParent: function() {
      var r = !1, h = this.getCurrent();
      if (h) {
        var u = h.parentNode;
        r = u !== this.editor.getElement().get() ? u : !1;
      }
      return r;
    },
    getElement: function(r) {
      for (var h = r || this.getCurrent(); h; ) {
        var u = this.inspector.parse(h);
        if (u.isElement() && u.isInEditor())
          return h;
        h = h.parentNode;
      }
      return !1;
    },
    getInline: function(r) {
      for (var h = r || this.getCurrent(), u = !1; h; )
        this._isInlineNode(h) && (u = h), h = h.parentNode;
      return u;
    },
    getInlineFirst: function(r) {
      for (var h = r || this.getCurrent(); h; ) {
        if (this._isInlineNode(h))
          return h;
        h = h.parentNode;
      }
      return !1;
    },
    getInlineAll: function(r) {
      for (var h = r || this.getCurrent(), u = []; h; )
        this._isInlineNode(h) && u.push(h), h = h.parentNode;
      return u;
    },
    getBlock: function(r) {
      for (var h = r || this.getCurrent(); h; ) {
        var u = this.inspector.parse(h), g = this.inspector.isBlockTag(h.tagName);
        if (g && u.isInEditor(h))
          return h;
        h = h.parentNode;
      }
      return !1;
    },
    getInlinesAllSelected: function(r) {
      if (this.isAll())
        return [];
      var h = this.getInlines({ all: !0, inside: !0 }), u = this.getText().replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&"), g = [];
      if (u === "")
        g = h;
      else if (h.length > 1)
        for (var b = 0; b < h.length; b++)
          this._isTextSelected(h[b], u) && g.push(h[b]);
      else
        h.length === 1 && this._isTextSelected(h[0], u) && (g = h);
      return g = r && r.tags ? this._filterNodesByTags(g, r.tags) : g, g;
    },
    getInlines: function(r) {
      for (var h = this.getNodes(), u = [], g = 0; g < h.length; g++) {
        var b;
        if (r && r.all)
          for (b = h[g]; b; )
            this._isInlineNode(b) && !this._isInNodesArray(u, b) && u.push(b), b = b.parentNode;
        else
          b = this.getInline(h[g]), b && !this._isInNodesArray(u, b) && u.push(b);
      }
      return u = r && r.tags ? this._filterNodesByTags(u, r.tags) : u, u = r && r.inside ? this._filterInlinesInside(u, r) : u, u;
    },
    getBlocks: function(r) {
      var h = this.getNodes(), u = this.getBlock();
      h = h.length === 0 && u ? [u] : h;
      for (var g = [], b = 0; b < h.length; b++) {
        var O = this.getBlock(h[b]), x = c.dom(O);
        x.hasClass("non-editable") || O && !this._isInNodesArray(g, O) && g.push(O);
      }
      return g = r && r.tags ? this._filterNodesByTags(g, r.tags) : g, g = r && r.first ? this._filterBlocksFirst(g, r) : g, g;
    },
    getElements: function(r) {
      var h = this.getNodes({ textnodes: !1 }), u = this.getBlock();
      h = h.length === 0 && u ? [u] : h;
      for (var g = [], b = 0; b < h.length; b++)
        this._isInNodesArray(g, h[b]) || g.push(h[b]);
      return g = r && r.tags ? this._filterNodesByTags(g, r.tags) : g, g;
    },
    getNodes: function(r) {
      var h = [], u = this.component.getActive();
      if (u)
        h = this._getNodesComponent(u);
      else if (this.isCollapsed()) {
        var g = this.getCurrent();
        h = g ? [g] : [];
      } else
        this.is() && !u && (h = this._getRangeSelectedNodes());
      return h = this._filterServicesNodes(h), h = this._filterEditor(h), h = r && r.tags ? this._filterNodesByTags(h, r.tags) : h, h = r && r.textnodes ? this._filterNodesTexts(h, r) : h, h = r && !r.textnodes ? this._filterNodesElements(h) : h, h;
    },
    // text & html
    getText: function() {
      var r = this.get();
      return r ? this.utils.removeInvisibleChars(r.toString()) : "";
    },
    getHtml: function(r) {
      var h = "", u = this.get();
      if (u) {
        for (var g = document.createElement("div"), b = u.rangeCount, O = 0; O < b; ++O)
          g.appendChild(u.getRangeAt(O).cloneContents());
        h = g.innerHTML, h = r !== !1 ? this.cleaner.output(h) : h, h = h.replace(/<p><\/p>$/i, "");
      }
      return h;
    },
    // clear
    clear: function() {
      this.component.clearActive(), this.get().removeAllRanges();
    },
    // collapse
    collapseToStart: function() {
      var r = this.get();
      r && !r.isCollapsed && r.collapseToStart();
    },
    collapseToEnd: function() {
      var r = this.get();
      r && !r.isCollapsed && r.collapseToEnd();
    },
    // save
    saveActiveComponent: function() {
      var r = this.component.getActive();
      return r ? (this.savedComponent = r, !0) : !1;
    },
    restoreActiveComponent: function() {
      return this.savedComponent ? (this.component.setActive(this.savedComponent), !0) : !1;
    },
    save: function() {
      this._clearSaved();
      var r = this.getElement(), h = ["TD", "TH", "P", "DIV", "PRE", "H1", "H2", "H3", "H4", "H5", "H6", "LI", "BLOCKQUOTE"];
      r && h.indexOf(r.tagName) !== -1 && (r.innerHTML === "" || r.innerHTML === "<br>") ? this.savedElement = r : this.saveActiveComponent() || (this.saved = this.offset.get());
    },
    restore: function() {
      !this.saved && !this.savedComponent && !this.savedElement || (this.editor.saveScroll(), this.savedElement ? this.caret.setStart(this.savedElement) : this.restoreActiveComponent() || this.offset.set(this.saved), this._clearSaved(), this.editor.restoreScroll());
    },
    saveMarkers: function() {
      this._clearSaved(), this.saveActiveComponent() || this.marker.insert();
    },
    restoreMarkers: function() {
      this.editor.saveScroll(), this.restoreActiveComponent() || this.marker.restore(), this._clearSaved(), this.editor.restoreScroll();
    },
    // private
    _getNextNode: function(r) {
      if (r.hasChildNodes())
        return r.firstChild;
      for (; r && !r.nextSibling; )
        r = r.parentNode;
      return r ? r.nextSibling : null;
    },
    _getNodesComponent: function(r) {
      var h = this.getCurrent(), u = this.inspector.parse(h);
      return u.isFigcaption() ? [u.getFigcaption()] : [r];
    },
    _getRangeSelectedNodes: function() {
      var r = [], h = this.getRange(), u = h.startContainer, g = h.startContainer, b = h.endContainer, O = this.editor.getElement();
      if (g === O.get() && this.isAll())
        r = this.utils.getChildNodes(O);
      else if (u === b)
        r = [u];
      else {
        for (; u && u !== b; )
          r.push(u = this._getNextNode(u));
        for (u = h.startContainer; u && u !== h.commonAncestorContainer; )
          r.unshift(u), u = u.parentNode;
      }
      return r;
    },
    _isInNodesArray: function(r, h) {
      return r.indexOf(h) !== -1;
    },
    _filterEditor: function(r) {
      for (var h = [], u = 0; u < r.length; u++) {
        var g = this.inspector.parse(r[u]);
        g.isInEditor() && h.push(r[u]);
      }
      return h;
    },
    _filterServicesNodes: function(r) {
      for (var h = [], u = 0; u < r.length; u++) {
        var g = c.dom(r[u]), b = !1;
        r[u] && r[u].nodeType === 3 && this.utils.isEmpty(r[u]) && (b = !0), (g.hasClass("redactor-script-tag") || g.hasClass("redactor-component-caret") || g.hasClass("redactor-selection-marker") || g.hasClass("non-editable")) && (b = !0), b || h.push(r[u]);
      }
      return h;
    },
    _filterNodesTexts: function(r, h) {
      for (var u = [], g = 0; g < r.length; g++)
        if (r[g].nodeType === 3 || h.keepbr && r[g].tagName === "BR") {
          var b = this.getInline(r[g]), O = b && h && h.inline === !1;
          O || u.push(r[g]);
        }
      return u;
    },
    _filterNodesElements: function(r) {
      for (var h = [], u = 0; u < r.length; u++)
        r[u].nodeType !== 3 && h.push(r[u]);
      return h;
    },
    _filterNodesByTags: function(r, h, u) {
      for (var g = [], b = 0; b < r.length; b++)
        if (u && r[b].nodeType === 3)
          g.push(r[b]);
        else if (r[b].nodeType !== 3) {
          var O = r[b].tagName.toLowerCase();
          h.indexOf(O.toLowerCase()) !== -1 && g.push(r[b]);
        }
      return g;
    },
    _filterBlocksFirst: function(r) {
      for (var h = [], u = 0; u < r.length; u++) {
        var g = c.dom(r[u]), b = g.parent().get(), O = g.parent().hasClass("redactor-in"), x = b && (b.tagName === "TD" || b.tagName === "TH");
        (O || x) && h.push(r[u]);
      }
      return h;
    },
    _filterInlinesInside: function(r) {
      for (var h = [], u = 0; u < r.length; u++)
        p(r[u], !0) && h.push(r[u]);
      return h;
    },
    _isTextSelected: function(r, h) {
      var u = r.nodeType !== 9 ? this.utils.removeInvisibleChars(r.textContent) : "";
      return h === u || u.search(h) !== -1 || h.search(new RegExp("^" + this.utils.escapeRegExp(u) + "$")) !== -1;
    },
    _isInlineNode: function(r) {
      var h = this.inspector.parse(r);
      return this.inspector.isInlineTag(r.tagName) && h.isInEditor();
    },
    _clearSaved: function() {
      this.saved = !1, this.savedComponent = !1, this.savedElement = !1;
    }
  }), c.add("service", "element", {
    init: function(r) {
      this.app = r, this.rootElement = r.rootElement, this.$element = {}, this.type = "inline";
    },
    start: function() {
      this._build(), this._buildType();
    },
    // public
    isType: function(r) {
      return r === this.type;
    },
    getType: function() {
      return this.type;
    },
    getElement: function() {
      return this.$element;
    },
    // private
    _build: function() {
      this.$element = c.dom(this.rootElement);
    },
    _buildType: function() {
      var r = this.$element.get().tagName;
      this.type = r === "TEXTAREA" ? "textarea" : this.type, this.type = r === "DIV" ? "div" : this.type, this.type = this.opts.inline ? "inline" : this.type;
    }
  }), c.add("service", "editor", {
    init: function(r) {
      this.app = r, this.scrolltop = !1, this.pasting = !1;
    },
    // start
    start: function() {
      this._build();
    },
    // focus
    focus: function() {
      !this.isFocus() && !this._isContenteditableFocus() && (this.saveScroll(), this.$editor.focus(), this.restoreScroll());
    },
    startFocus: function() {
      this.caret.setStart(this.getFirstNode());
    },
    endFocus: function() {
      this.caret.setEnd(this.getLastNode());
    },
    // pasting
    isPasting: function() {
      return this.pasting;
    },
    enablePasting: function() {
      this.pasting = !0;
    },
    disablePasting: function() {
      this.pasting = !1;
    },
    // scroll
    saveScroll: function() {
      this.scrolltop = this._getScrollTarget().scrollTop(), this.opts.maxHeight && (this.scrolltopin = this.$editor.scrollTop());
    },
    restoreScroll: function() {
      this.scrolltop !== !1 && (this._getScrollTarget().scrollTop(this.scrolltop), this.scrolltop = !1), this.scrolltopin && (this.$editor.scrollTop(this.scrolltopin), this.scrolltopin = !1);
    },
    // non editables
    disableNonEditables: function() {
      this.$noneditables = this.$editor.find("[contenteditable=false]"), this.$noneditables.attr("contenteditable", !0);
    },
    enableNonEditables: function() {
      this.$noneditables && setTimeout(
        (function() {
          this.$noneditables.attr("contenteditable", !1);
        }).bind(this),
        1
      );
    },
    // nodes
    getFirstNode: function() {
      return this.$editor.contents()[0];
    },
    getLastNode: function() {
      var r = this.$editor.contents();
      return r[r.length - 1];
    },
    // utils
    isSourceMode: function() {
      var r = this.source.getElement();
      return r.hasClass("redactor-source-open");
    },
    isEditor: function(r) {
      var h = c.dom(r).get();
      return h === this.$editor.get();
    },
    isEmpty: function(r) {
      return this.utils.isEmptyHtml(this.$editor.html(), !1, r);
    },
    isFocus: function() {
      var r = c.dom(document.activeElement), h = this.$editor.find(".redactor-component-active").length !== 0;
      return h || r.closest(".redactor-in-" + this.uuid).length !== 0;
    },
    setEmpty: function() {
      this.$editor.html(this.opts.emptyHtml);
    },
    // element
    getElement: function() {
      return this.$editor;
    },
    // private
    _build: function() {
      var r = this.element.getElement(), h = this.element.isType("textarea") ? "<div>" : r.get();
      this.$editor = c.dom(h);
    },
    _getScrollTarget: function() {
      var r = this.$doc;
      return this.opts.toolbarFixedTarget !== document ? r = c.dom(this.opts.toolbarFixedTarget) : r = this.opts.scrollTarget ? c.dom(this.opts.scrollTarget) : r, r;
    },
    _isContenteditableFocus: function() {
      var r = this.selection.getBlock(), h = r ? c.dom(r).closest("[contenteditable=true]").not(".redactor-in") : [];
      return h.length !== 0;
    }
  }), c.add("service", "container", {
    init: function(r) {
      this.app = r;
    },
    // public
    start: function() {
      this._build();
    },
    getElement: function() {
      return this.$container;
    },
    // private
    _build: function() {
      var r = this.element.isType("inline") ? "<span>" : "<div>";
      this.$container = c.dom(r);
    }
  }), c.add("service", "source", {
    init: function(r) {
      this.app = r, this.$source = {}, this.content = "";
    },
    // public
    start: function() {
      this._build(), this._buildName(), this._buildStartedContent();
    },
    getElement: function() {
      return this.$source;
    },
    getCode: function() {
      return this.$source.val();
    },
    getName: function() {
      return this.$source.attr("name");
    },
    getStartedContent: function() {
      return this.content;
    },
    setCode: function(r) {
      return this.insertion.set(r, !0, !1);
    },
    isNameGenerated: function() {
      return this.name;
    },
    rebuildStartedContent: function() {
      this._buildStartedContent();
    },
    // private
    _build: function() {
      var r = this.element.getElement(), h = this.element.isType("textarea"), u = h ? r.get() : "<textarea>";
      this.$source = c.dom(u);
    },
    _buildName: function() {
      var r = this.element.getElement();
      this.name = r.attr("name"), this.$source.attr("name", this.name ? this.name : "content-" + this.uuid);
    },
    _buildStartedContent: function() {
      var r = this.element.getElement(), h = this.element.isType("textarea") ? r.val() : r.html();
      this.content = h.trim();
    }
  }), c.add("service", "statusbar", {
    init: function(r) {
      this.app = r, this.$statusbar = {}, this.items = [];
    },
    // public
    start: function() {
      this.$statusbar = c.dom("<ul>"), this.$statusbar.attr("dir", this.opts.direction);
    },
    add: function(r, h) {
      return this.update(r, h);
    },
    update: function(r, h) {
      var u;
      return typeof this.items[r] < "u" ? u = this.items[r] : (u = c.dom("<li>"), this.$statusbar.append(u), this.items[r] = u), u.html(h);
    },
    get: function(r) {
      return this.items[r] ? this.items[r] : !1;
    },
    remove: function(r) {
      this.items[r] && (this.items[r].remove(), delete this.items[r]);
    },
    getItems: function() {
      return this.items;
    },
    removeItems: function() {
      this.items = {}, this.$statusbar.html("");
    },
    getElement: function() {
      return this.$statusbar;
    }
  }), c.add("service", "toolbar", {
    init: function(r) {
      this.app = r, this.buttons = [], this.dropdownOpened = !1, this.buttonsObservers = {};
    },
    // public
    start: function() {
      this.is() && (this.opts.activeButtons = this.opts.activeButtonsAdd ? this._extendActiveButtons() : this.opts.activeButtons, this.create());
    },
    stopObservers: function() {
      this.buttonsObservers = {};
    },
    create: function() {
      this.$wrapper = c.dom("<div>"), this.$toolbar = c.dom("<div>");
    },
    observe: function() {
      if (this.is()) {
        this.setButtonsInactive();
        var r, h;
        for (var u in this.buttonsObservers)
          h = this.buttonsObservers[u], r = this.getButton(u), this.app.broadcast("button." + h + ".observe", r);
        var g = this.opts.activeButtons, b = this.selection.getInlinesAllSelected(), O = this.selection.getInline(), x = this.selection.getInlineAll();
        this.selection.isCollapsed() && (O && b.push(O), x.length !== 0 && (b = b.concat(x)));
        var S = this._inlinesToTags(b);
        for (var k in g)
          S.indexOf(k) !== -1 && (r = this.getButton(g[k]), r && r.setActive());
      }
    },
    // is
    is: function() {
      return !(!this.opts.toolbar || this.detector.isMobile() && this.opts.air);
    },
    isAir: function() {
      return this.is() ? this.$toolbar.hasClass("redactor-air") : !1;
    },
    isFixed: function() {
      return this.is() ? this.$toolbar.hasClass("redactor-toolbar-fixed") : !1;
    },
    isContextBar: function() {
      var r = this.$body.find("#redactor-context-toolbar-" + this.uuid);
      return r.hasClass("open");
    },
    isTarget: function() {
      return this.opts.toolbarFixedTarget !== document;
    },
    // get
    getElement: function() {
      return this.$toolbar;
    },
    getWrapper: function() {
      return this.$wrapper;
    },
    getDropdown: function() {
      return this.dropdownOpened;
    },
    getTargetElement: function() {
      return c.dom(this.opts.toolbarFixedTarget);
    },
    getButton: function(r) {
      var h = this._findButton(".re-" + r);
      return h.length !== 0 ? h.dataget("data-button-instance") : !1;
    },
    getButtons: function() {
      var r = [];
      return this._findButtons().each(function(h) {
        var u = c.dom(h);
        r.push(u.dataget("data-button-instance"));
      }), r;
    },
    getButtonsKeys: function() {
      var r = [];
      return this._findButtons().each(function(h) {
        var u = c.dom(h);
        r.push(u.attr("data-re-name"));
      }), r;
    },
    // add
    addButton: function(r, h, u, g, b) {
      u = u || "end";
      var O = c.create("toolbar.button", this.app, r, h);
      if (h.observe && (this.opts.activeButtonsObservers[r] = { observe: h.observe, button: O }), this.is())
        if (u === "first")
          this.$toolbar.prepend(O);
        else if (u === "after")
          g.after(O);
        else if (u === "before")
          g.before(O);
        else {
          var x = this.opts.buttons.indexOf(r);
          if (b !== !0 && x !== -1)
            if (x === 0)
              this.$toolbar.prepend(O);
            else {
              var S = this._findButtons(), k = S.eq(x - 1);
              k.length > 0 ? k.after(O) : this.$toolbar.append(O);
            }
          else
            this.$toolbar.append(O);
        }
      return O;
    },
    addButtonFirst: function(r, h) {
      return this.addButton(r, h, "first");
    },
    addButtonAfter: function(r, h, u) {
      var g = this.getButton(r);
      return g ? this.addButton(h, u, "after", g) : this.addButton(h, u);
    },
    addButtonBefore: function(r, h, u) {
      var g = this.getButton(r);
      return g ? this.addButton(h, u, "before", g) : this.addButton(h, u);
    },
    addButtonObserver: function(r, h) {
      this.buttonsObservers[r] = h;
    },
    // set
    setButtons: function(r) {
      this.buttons = r;
    },
    setDropdown: function(r) {
      this.dropdownOpened = r;
    },
    setButtonsInactive: function() {
      for (var r = this.getButtons(), h = 0; h < r.length; h++)
        r[h].setInactive();
    },
    setButtonsActive: function() {
      for (var r = this.getButtons(), h = 0; h < r.length; h++)
        r[h].setActive();
    },
    // disable & enable
    disableButtons: function() {
      for (var r = this.getButtons(), h = 0; h < r.length; h++)
        r[h].disable();
    },
    enableButtons: function() {
      for (var r = this.getButtons(), h = 0; h < r.length; h++)
        r[h].enable();
    },
    // private
    _findButton: function(r) {
      return this.is() ? this.$toolbar.find(r) : c.dom();
    },
    _findButtons: function() {
      return this.is() ? this.$toolbar.find(".re-button") : c.dom();
    },
    _extendActiveButtons: function() {
      return c.extend({}, this.opts.activeButtons, this.opts.activeButtonsAdd);
    },
    _inlinesToTags: function(r) {
      for (var h = [], u = 0; u < r.length; u++)
        h.push(r[u].tagName.toLowerCase());
      return h;
    }
  }), c.add("class", "toolbar.button", {
    mixins: ["dom"],
    init: function(r, h, u) {
      this.app = r, this.opts = r.opts, this.lang = r.lang, this.$body = r.$body, this.toolbar = r.toolbar, this.detector = r.detector, this.obj = u, this.name = h, this.dropdown = !1, this.tooltip = !1, this._init();
    },
    // is
    isActive: function() {
      return this.hasClass("redactor-button-active");
    },
    isDisabled: function() {
      return this.hasClass("redactor-button-disabled");
    },
    // has
    hasIcon: function() {
      return this.obj.icon && !this.opts.buttonsTextLabeled;
    },
    // set
    setDropdown: function(r) {
      this.obj.dropdown = r, this.obj.message = !1, this.dropdown = c.create("toolbar.dropdown", this.app, this.name, this.obj.dropdown), this.attr("data-dropdown", !0);
    },
    setMessage: function(r, h) {
      this.obj.message = r, this.obj.args = h, this.obj.dropdown = !1;
    },
    setApi: function(r, h) {
      this.obj.api = r, this.obj.args = h, this.obj.dropdown = !1;
    },
    setTitle: function(r) {
      this.obj.title = this.lang.parse(r), this.obj.tooltip = this.obj.title, this.attr({ alt: this.obj.tooltip, "aria-label": this.obj.tooltip }), this.attr("data-re-icon") || this.html(this.obj.title);
    },
    setTooltip: function(r) {
      this.obj.tooltip = this.lang.parse(r), this.attr({ alt: this.obj.tooltip, "aria-label": this.obj.tooltip });
    },
    setIcon: function(r) {
      this.opts.buttonsTextLabeled || (this.obj.icon = !0, this.$icon = c.dom(r), this.html(""), this.append(this.$icon), this.attr("data-re-icon", !0), this.addClass("re-button-icon"), this.setTooltip(this.obj.title), this._buildTooltip());
    },
    setActive: function() {
      this.addClass("redactor-button-active");
    },
    setInactive: function() {
      this.removeClass("redactor-button-active");
    },
    // hide
    hideTooltip: function() {
      this.$body.find(".re-button-tooltip").remove();
    },
    // get
    getDropdown: function() {
      return this.dropdown;
    },
    // enable & disable
    disable: function() {
      this.addClass("redactor-button-disabled");
    },
    enable: function() {
      this.removeClass("redactor-button-disabled");
    },
    // toggle
    toggle: function(r) {
      r && r.preventDefault(), !this.isDisabled() && (this.obj.dropdown ? this.dropdown.toggle(r) : this.obj.api ? this.app.api(this.obj.api, this.obj.args, this.name) : this.obj.message && this.app.broadcast(this.obj.message, this.obj.args, this.name), this.hideTooltip());
    },
    // private
    _init: function() {
      this._parseTitle(), this._parseTooltip(), this._build(), this._buildCallback(), this._buildAttributes(), this._buildObserver(), this.hasIcon() ? (this._buildIcon(), this._buildTooltip()) : this.html(this.obj.title);
    },
    _parseTooltip: function() {
      this.obj.tooltip = this.obj.tooltip ? this.lang.parse(this.obj.tooltip) : this.obj.title;
    },
    _parseTitle: function() {
      this.obj.title = this.lang.parse(this.obj.title);
    },
    _build: function() {
      this.parse("<a>"), this.addClass("re-button re-" + this.name), this.attr("data-re-name", this.name), this.dataset("data-button-instance", this), this.obj.dropdown && this.setDropdown(this.obj.dropdown);
    },
    _buildCallback: function() {
      this.on("click", this.toggle.bind(this));
    },
    _buildAttributes: function() {
      var r = {
        href: "#",
        alt: this.obj.tooltip,
        rel: this.name,
        role: "button",
        "aria-label": this.obj.tooltip,
        tabindex: "-1"
      };
      this.attr(r);
    },
    _buildObserver: function() {
      typeof this.obj.observe < "u" && this.toolbar.addButtonObserver(this.name, this.obj.observe);
    },
    _buildIcon: function() {
      var r = this.obj.icon, h = /(<([^>]+)>)/gi.test(r);
      this.$icon = h ? c.dom(r) : c.dom("<i>"), h || this.$icon.addClass("re-icon-" + this.name), this.append(this.$icon), this.attr("data-re-icon", !0), this.addClass("re-button-icon");
    },
    _buildTooltip: function() {
      this.detector.isDesktop() && (this.tooltip = c.create("toolbar.button.tooltip", this.app, this));
    }
  }), c.add("class", "toolbar.button.tooltip", {
    mixins: ["dom"],
    init: function(r, h) {
      this.app = r, this.uuid = r.uuid, this.opts = r.opts, this.$body = r.$body, this.toolbar = r.toolbar, this.$button = h, this.created = !1, this._init();
    },
    open: function() {
      if (!(this.$button.hasClass("redactor-button-disabled") || this.$button.hasClass("redactor-button-active"))) {
        this.created = !0, this.parse("<span>"), this.addClass("re-button-tooltip re-button-tooltip-" + this.uuid), this.$body.append(this), this.html(this.$button.attr("alt"));
        var r = this.$button.offset(), h = "absolute", u = this.$button.height(), g = this.$button.width(), b = 4;
        this.css({
          top: r.top + u + b + "px",
          left: r.left + g / 2 - this.width() / 2 + "px",
          position: h
        }), this.show();
      }
    },
    close: function() {
      !this.created || this.$button.hasClass("redactor-button-disabled") || (this.remove(), this.created = !1);
    },
    // private
    _init: function() {
      this.$button.on("mouseover", this.open.bind(this)), this.$button.on("mouseout", this.close.bind(this));
    }
  }), c.add("class", "toolbar.dropdown", {
    mixins: ["dom"],
    init: function(r, h, u) {
      this.app = r, this.uuid = r.uuid, this.opts = r.opts, this.$win = r.$win, this.$doc = r.$doc, this.$body = r.$body, this.animate = r.animate, this.toolbar = r.toolbar, this.name = h, this.started = !1, this.items = h === "format" ? c.extend({}, !0, u) : u, this.$items = [];
    },
    // public
    toggle: function(r) {
      this.started || this._build(), this.isOpened() && this.isActive() ? this.close(!1) : this.open(r);
    },
    isOpened: function() {
      var r = this.$body.find(".redactor-dropdown-" + this.uuid + ".open");
      return r.length !== 0 && r.attr("data-re-name") === this.name;
    },
    isActive: function() {
      var r = this.$body.find("#redactor-dropdown-" + this.uuid + "-" + this.name + ".open");
      return r.length !== 0;
    },
    getName: function() {
      return this.attr("data-re-name");
    },
    getItem: function(r) {
      return this.$items[r];
    },
    getItemsByClass: function(r) {
      var h = [];
      for (var u in this.$items) {
        var g = this.$items[u];
        typeof g == "object" && g.attr("data-re-name") && g.hasClass(r) && h.push(g);
      }
      return h;
    },
    open: function(r) {
      this._closeAll(), this.$btn = this.toolbar.getButton(this.name), this.app.broadcast("dropdown.open", r, this, this.$btn), this.toolbar.setDropdown(this), this.show(), this.removeClass("redactor-animate-hide"), this.addClass("open"), this._observe(), this.$btn.hideTooltip(), this.$btn.setActive(), this.$doc.on("keyup.redactor.dropdown-" + this.uuid, this._handleKeyboard.bind(this)), this.$doc.on("click.redactor.dropdown-" + this.uuid, this.close.bind(this)), this.updatePosition(), this.app.broadcast("dropdown.opened", r, this, this.$btn);
    },
    close: function(r, h) {
      if (r) {
        var u = c.dom(r.target);
        if (this._isButton(r) || u.hasClass("redactor-dropdown-not-close") || u.hasClass("redactor-dropdown-item-disabled")) {
          r.preventDefault();
          return;
        }
      }
      this.app.broadcast("dropdown.close", this, this.$btn), this.toolbar.setDropdown(!1), this.$btn.setInactive(), h === !1 ? this._close() : this.animate.start(this, "fadeOut", this._close.bind(this));
    },
    updatePosition: function() {
      this.toolbar.isFixed(), this.toolbar.isTarget();
      var r = this.$btn.height(), h = this.$btn.width(), u = this.$btn.offset(), g = "absolute", b = 2, O = 0, x = u.left + O, S = parseFloat(this.css("width")), k = this.$win.width(), C = k < x + S ? S - h : 0, _ = x - C, $ = u.top + r + b;
      _ = _ < 0 ? 4 : _, this.css({
        maxHeight: "",
        position: g,
        top: $ + "px",
        left: _ + "px"
      });
      var L = 10, E = this.$win.height(), A = this.$doc.scrollTop(), y = E - ($ - A) - L;
      this.css("max-height", y + "px");
    },
    // private
    _build: function() {
      this.parse("<div>"), this.attr("dir", this.opts.direction), this.attr("id", "redactor-dropdown-" + this.uuid + "-" + this.name), this.attr("data-re-name", this.name), this.addClass("redactor-dropdown redactor-dropdown-" + this.uuid + " redactor-dropdown-" + this.name), this.dataset("data-dropdown-instance", this);
      var r = this.items.sdom || typeof this.items == "string";
      r ? this._buildDom() : this._buildItems(), this.$body.append(this), this.started = !0;
    },
    _buildDom: function() {
      this.html("").append(c.dom(this.items));
    },
    _buildItems: function() {
      this.items = this.name === "format" ? this._buildFormattingItems() : this.items;
      for (var r in this.items) {
        var h = this.items[r];
        if (r === "observe")
          this.attr("data-observe", this.items[r]);
        else {
          var u = c.create("toolbar.dropdown.item", this.app, r, h, this);
          this.$items[r] = u, this.append(u);
        }
      }
    },
    _buildFormattingItems: function() {
      for (var r in this.items)
        this.opts.formatting.indexOf(r) === -1 && delete this.items[r];
      if (this.opts.formattingHide)
        for (var r in this.items)
          this.opts.formattingHide.indexOf(r) !== -1 && delete this.items[r];
      if (this.opts.formattingAdd)
        for (var r in this.opts.formattingAdd)
          this.items[r] = this.opts.formattingAdd[r];
      return this.items;
    },
    _handleKeyboard: function(r) {
      r.which === 27 && this.close();
    },
    _isButton: function(r) {
      var h = c.dom(r.target), u = h.closest(".re-button");
      return u.get() === this.$btn.get();
    },
    _close: function() {
      this.$btn.setInactive(), this.$doc.off(".redactor.dropdown-" + this.uuid), this.removeClass("open"), this.addClass("redactor-animate-hide"), this.app.broadcast("dropdown.closed", this, this.$btn);
    },
    _closeAll: function() {
      this.$body.find(".redactor-dropdown-" + this.uuid + ".open").each(function(r) {
        var h = c.dom(r), u = h.dataget("data-dropdown-instance");
        u._close();
      });
    },
    _observe: function() {
      var r = this.attr("data-observe");
      r && this.app.broadcast("dropdown." + r + ".observe", this);
    }
  }), c.add("class", "toolbar.dropdown.item", {
    mixins: ["dom"],
    init: function(r, h, u, g) {
      this.app = r, this.lang = r.lang, this.dropdown = g, this.name = h, this.obj = u, this._init();
    },
    setTitle: function(r) {
      this.$span.html(r);
    },
    getTitle: function() {
      return this.$span.html();
    },
    enable: function() {
      this.removeClass("redactor-dropdown-item-disabled");
    },
    disable: function() {
      this.addClass("redactor-dropdown-item-disabled");
    },
    toggle: function(r) {
      r && r.preventDefault(), !this.hasClass("redactor-dropdown-item-disabled") && (this.obj.message ? this.app.broadcast(this.obj.message, this.obj.args, this.name) : this.obj.api && this.app.api(this.obj.api, this.obj.args, this.name));
    },
    // private
    _init: function() {
      this.parse("<a>"), this.attr("href", "#"), this.addClass("redactor-dropdown-item-" + this.name), this.obj.classname && this.addClass(this.obj.classname), this.attr("data-re-name", this.name), this.on("click", this.toggle.bind(this)), this.$span = c.dom("<span>"), this.append(this.$span), this.setTitle(this.lang.parse(this.obj.title));
    }
  }), c.add("service", "cleaner", {
    init: function(r) {
      this.app = r, this.opts = r.opts, this.storedComponents = [], this.storedComments = [], this.storedImages = [], this.storedLinks = [], this.deniedTags = ["font", "html", "head", "link", "title", "body", "meta", "applet"], this.convertRules = {}, this.unconvertRules = {}, this.reComments = /<!--[\s\S]*?-->\n?/g, this.reSpacedEmpty = /^(||\s||<br\s?\/?>||&nbsp;)$/i, this.reScriptTag = /<script(.*?[^>]?)>([\w\W]*?)<\/script>/gi;
    },
    // public
    addConvertRules: function(r, h) {
      this.convertRules[r] = h;
    },
    addUnconvertRules: function(r, h) {
      this.unconvertRules[r] = h;
    },
    input: function(r, h, u) {
      r = r.replace(/¤t/gi, "&current");
      var g = [];
      r = this.storeComments(r, g), r = this.encodeCode(r);
      var b = this.utils.buildWrapper(r);
      b.find("a, b, i, strong, em, img, svg, details, audio").removeAttr("onload onerror ontoggle onwheel onmouseover oncopy"), b.find("a, iframe, embed").each(function(S) {
        var k = c.dom(S), C = k.attr("href"), _ = k.attr("src");
        C && C.trim().search(/^data|javascript:/i) !== -1 && k.attr("href", ""), _ && _.trim().search(/^data|javascript:/i) !== -1 && k.attr("src", "");
      });
      var O = ["alt", "title", "src", "class", "width", "height", "srcset", "style", "usemap"];
      b.find("img").each(
        (function(S) {
          if (S.attributes.length > 0)
            for (var k = S.attributes, C = k.length - 1; C >= 0; C--) {
              var _ = k[C].name.search(/^data-/) === -1 && O.indexOf(k[C].name) === -1, $ = k[C].name === "src" && k[C].value.search(/^data|javascript:/i) !== -1;
              this.opts.imageSrcData && ($ = !1), (_ || $) && S.removeAttribute(k[C].name);
            }
        }).bind(this)
      ), r = this.utils.getWrapperHtml(b), r = r.replace(/\$/g, "&#36;"), r = r.replace(/&amp;/g, "&");
      var x = c.create("cleaner.figure", this.app);
      return r = x.convert(r, this.convertRules), r = this.storeComponents(r), r = this.replaceTags(r, this.opts.replaceTags), r = this._setSpanAttr(r), r = this._setStyleCache(r), r = this.removeTags(r, this.deniedTags), r = this.opts.removeScript ? this._removeScriptTag(r) : this._replaceScriptTag(r), r = this.opts.removeComments ? this.removeComments(r) : r, r = this._isSpacedEmpty(r) ? this.opts.emptyHtml : r, r = this.restoreComponents(r), r = this._cleanWrapped(r), r = this.restoreComments(r, g), r = h ? this.paragraphize(r) : r, r;
    },
    output: function(r, h) {
      if (r = this.removeInvisibleSpaces(r), this.opts.breakline && (r = r.replace(/<\/(span|strong|b|i|em)><br\s?\/?><\/div>/gi, "</$1></div>"), r = r.replace(/<br\s?\/?><\/(span|strong|b|i|em)><\/div>/gi, "</$1></div>")), r = r.replace(/&#36;/g, "$"), this._isSpacedEmpty(r) || this._isParagraphEmpty(r))
        return "";
      r = this.removeServiceTagsAndAttrs(r, h), r = this.storeComponents(r), r = this.removeSpanWithoutAttributes(r), r = this.removeFirstBlockBreaklineInHtml(r), r = this.opts.removeScript ? r : this._unreplaceScriptTag(r), r = this.opts.preClass ? this._setPreClass(r) : r, r = this.opts.linkNofollow ? this._setLinkNofollow(r) : r, r = this.opts.removeNewLines ? this.cleanNewLines(r) : r, r = this.restoreComponents(r);
      var u = c.create("cleaner.figure", this.app);
      return r = u.unconvert(r, this.unconvertRules), r = this.removeEmptyAttributes(r, ["style", "class", "rel", "alt", "title"]), r = this.cleanSpacesInPre(r), r = this.tidy(r), r = r.replace(/&amp;/g, "&"), this.opts.breakline && (r = r.replace(/<br\s?\/?>/gi, `<br>
`), r = r.replace(/<br\s?\/?>\n+/gi, `<br>
`)), r = r.replace(/\n/g, "") === "" ? "" : r, r;
    },
    paste: function(r) {
      r = this.storeComponents(r), r = r.replace(/<!--[\s\S]*?-->/g, "");
      var h = this.deniedTags.concat(["iframe"]);
      r = this.removeTags(r, h), r = r.replace(new RegExp("<!doctype([\\s\\S]+?)>", "gi"), ""), r = r.replace(new RegExp("<style([\\s\\S]+?)</style>", "gi"), ""), r = r.replace(new RegExp("</p><br /><p", "gi"), "</p><p");
      var u = this._isHtmlMsWord(r);
      if (r = u ? r : this._cleanGDocs(r), r = u ? this._cleanMsWord(r) : r, !this.opts.pasteClean)
        return r = this.restoreComponents(r), r;
      if (this.opts.pastePlainText)
        return r = this.restoreComponents(r), this.pastePlainText(r);
      var b = this.utils.buildWrapper(r);
      b.find("*").removeAttr("style"), b.find("[data-redactor-tag]").each(
        (function(_) {
          var $ = c.dom(_);
          $.removeAttr("data-redactor-tag"), this.utils.isEmptyHtml($.html()) ? $.html("<br>").unwrap() : _.lastChild && _.lastChild.tagName === "BR" ? $.unwrap() : $.append("<br>").unwrap();
        }).bind(this)
      ), r = this.utils.getWrapperHtml(b), r = r.replace(/<br\s?\/?>$/, ""), r = r.replace(/<br\s?\/?><\/(td|th)>/, "</$1>");
      var g = this.opts.pasteBlockTags.concat(this.opts.pasteInlineTags);
      r = this.removeTagsExcept(r, g), r = this.opts.pasteLinks ? r : this.removeTags(r, ["a"]), r = this.opts.pasteImages ? r : this.removeTags(r, ["img"]);
      var b = this.utils.buildWrapper(r), O = b.find("*"), x = this.opts.pasteKeepStyle.length !== 0 ? "," + this.opts.pasteKeepStyle.join(",") : "";
      O.not("[data-redactor-style-cache]" + x).removeAttr("style");
      var S = this.opts.pasteKeepClass.length !== 0 ? "," + this.opts.pasteKeepClass.join(",") : "";
      O.not("[data-redactor-style-cache], span.redactor-component" + S).removeAttr("class");
      var k = this.opts.pasteKeepAttrs.length !== 0 ? "," + this.opts.pasteKeepAttrs.join(",") : "";
      O.not("img, a, span.redactor-component, [data-redactor-style-cache]" + k).each(function(_) {
        for (var $ = _.attributes, L = $.length - 1; L >= 0; L--)
          _.attributes[L].name !== "class" && _.attributes[L].name !== "dir" && _.removeAttribute($[L].name);
      }), this.opts.pasteLinks && this.opts.pasteLinkTarget !== !1 && b.find("a").attr("target", this.opts.pasteLinkTarget), b.find("[data-redactor-style-cache]").each(function(_) {
        var $ = _.getAttribute("data-redactor-style-cache");
        _.setAttribute("style", $);
      });
      var C = this.opts.imageAttrs;
      return b.find("img").each(function(_) {
        if (_.attributes.length > 0)
          for (var $ = _.attributes, L = $.length - 1; L >= 0; L--)
            C.indexOf($[L].name) === -1 && _.removeAttribute($[L].name);
      }), b.find("span").each(function(_) {
        _.attributes.length === 0 && c.dom(_).unwrap();
      }), b.find(this.opts.inlineTags.join(",")).each(
        (function(_) {
          _.attributes.length === 0 && this.utils.isEmptyHtml(_.innerHTML) && c.dom(_).unwrap();
        }).bind(this)
      ), b.find("ul, ol").each(function(_) {
        var $ = _.previousSibling;
        if ($ && $.tagName === "LI") {
          var L = c.dom($);
          L.find("p").unwrap(), L.append(_);
        }
      }), r = this.utils.getWrapperHtml(b), r = r.replace(/<li><p>/gi, "<li>"), r = r.replace(/<\/p><\/li>/gi, "</li>"), r = r.replace(/^<li/gi, "<ul><li"), r = r.replace(/<\/li>$/gi, "</li></ul>"), this.opts.breakline && (r = r.replace(/\n/g, "<br>")), r = r.replace(/<p>&nbsp;<\/p>/gi, "<p></p>"), r = r.replace(/<p><br\s?\/?><\/p>/gi, "<p></p>"), u && (r = r.replace(/<p><\/p>/gi, ""), r = r.replace(/<p>\s<\/p>/gi, ""), r = r.replace(/<td\n/gi, "<td ")), r = this.restoreComponents(r), r;
    },
    pastePlainText: function(r) {
      return r = this.opts.pasteLinks ? this.storeLinks(r) : r, r = this.opts.pasteImages ? this.storeImages(r) : r, r = this.getPlainText(r), r = this._replaceNlToBr(r), r = this.opts.pasteLinks ? this.restoreLinks(r) : r, r = this.opts.pasteImages ? this.restoreImages(r) : r, r;
    },
    tidy: function(r) {
      return r;
    },
    paragraphize: function(r) {
      var h = c.create("cleaner.paragraphize", this.app);
      return r = h.convert(r), r;
    },
    storeComments: function(r, h) {
      var u = r.match(new RegExp("<!--([\\w\\W]*?)-->", "gi"));
      if (u !== null)
        for (var g = 0; g < u.length; g++)
          r = r.replace(u[g], "#####xstarthtmlcommentzz" + g + "xendhtmlcommentzz#####"), h.push(u[g]);
      return r;
    },
    restoreComments: function(r, h) {
      for (var u = 0; u < h.length; u++)
        r = r.replace("#####xstarthtmlcommentzz" + u + "xendhtmlcommentzz#####", h[u]);
      return r;
    },
    // get
    getFlatText: function(r) {
      var h = c.dom("<div>");
      return !r.nodeType && !r.dom ? (r = r.toString(), r = r.trim(), h.html(r)) : h.append(r), r = h.get().textContent || h.get().innerText || "", r === void 0 ? "" : r;
    },
    getPlainText: function(r) {
      r = r.replace(/<!--[\s\S]*?-->/gi, ""), r = r.replace(/<style[\s\S]*?style>/gi, ""), r = r.replace(/<p><\/p>/g, ""), r = r.replace(/<\/div>|<\/li>|<\/td>/gi, `
`), r = r.replace(/<\/p>/gi, `

`), r = r.replace(/<\/H[1-6]>/gi, `

`);
      var h = document.createElement("div");
      return h.innerHTML = r, r = h.textContent || h.innerText, r.trim();
    },
    // replace
    replaceTags: function(r, h) {
      if (h) {
        var u = this, g = Object.keys(h), b = this.utils.buildWrapper(r);
        b.find(g.join(",")).each(function(O) {
          u.utils.replaceToTag(O, h[O.tagName.toLowerCase()]);
        }), r = this.utils.getWrapperHtml(b);
      }
      return r;
    },
    replaceNbspToSpaces: function(r) {
      return r.replace("&nbsp;", " ");
    },
    replaceBlocksToBr: function(r) {
      return r = r.replace(/<div[^>]*><\/div>/gi, ""), r = r.replace(/<td[^>]*><\/td>/gi, ""), r = r.replace(/<\/div>|<\/li>|<\/td>|<\/p>|<\/H[1-6]>/gi, "<br>"), r;
    },
    // clean
    cleanNewLines: function(r) {
      return r.replace(/\r?\n/g, "");
    },
    cleanSpacesInPre: function(r) {
      return r.replace("&nbsp;&nbsp;&nbsp;&nbsp;", "    ");
    },
    // remove
    removeInvisibleSpaces: function(r) {
      return r = this.utils.removeInvisibleChars(r), r = r.replace(/&#65279;/gi, ""), r;
    },
    removeNl: function(r) {
      return r = r.replace(/\n/g, " "), r = r.replace(/\s+/g, "s"), r;
    },
    removeBrAtEnd: function(r) {
      return r = r.replace(/<br\s?\/?>$/gi, " "), r = r.replace(/<br\s?\/?><li/gi, "<li"), r;
    },
    removeTags: function(r, h) {
      var u = h ? /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi : /(<([^>]+)>)/gi, g = h ? function(b, O) {
        return h.indexOf(O.toLowerCase()) === -1 ? b : "";
      } : "";
      return r.replace(u, g);
    },
    removeTagsExcept: function(r, h) {
      if (h === void 0)
        return r.replace(/(<([^>]+)>)/gi, "");
      var u = /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi;
      return r.replace(u, function(g, b) {
        return h.indexOf(b.toLowerCase()) === -1 ? "" : g;
      });
    },
    removeComments: function(r) {
      return r.replace(this.reComments, "");
    },
    removeServiceTagsAndAttrs: function(r, h) {
      var u = this.utils.buildWrapper(r), g = this;
      return h !== !1 && u.find(".redactor-selection-marker").each(function(b) {
        var O = c.dom(b), x = g.utils.removeInvisibleChars(O.text());
        return x === "" ? O.remove() : O.unwrap();
      }), u.find("[data-redactor-style-cache]").removeAttr("data-redactor-style-cache"), this.utils.getWrapperHtml(u);
    },
    removeSpanWithoutAttributes: function(r) {
      var h = this.utils.buildWrapper(r);
      return h.find("span").removeAttr("data-redactor-span data-redactor-style-cache").each(function(u) {
        u.attributes.length === 0 && c.dom(u).unwrap();
      }), this.utils.getWrapperHtml(h);
    },
    removeFirstBlockBreaklineInHtml: function(r) {
      return r.replace(new RegExp("</li><br\\s?/?>", "gi"), "</li>");
    },
    removeEmptyAttributes: function(r, h) {
      for (var u = this.utils.buildWrapper(r), g = 0; g < h.length; g++)
        u.find("[" + h[g] + '=""]').removeAttr(h[g]);
      return this.utils.getWrapperHtml(u);
    },
    // encode / decode
    encodeHtml: function(r) {
      return r = r.replace(/<br\s?\/?>/g, `
`), r = r.replace(/&nbsp;/g, " "), r = r.replace(/”/g, '"'), r = r.replace(/“/g, '"'), r = r.replace(/‘/g, "'"), r = r.replace(/’/g, "'"), r = this.encodeEntities(r), r = r.replace(/\$/g, "&#36;"), this.opts.preSpaces && (r = r.replace(/\t/g, new Array(this.opts.preSpaces + 1).join(" "))), r;
    },
    encodeCode: function(r) {
      return r = this.encodeAttrSings(r), r = r.replace(/<\s/gi, "&lt; "), r = r.replace(/<([^>]+)</gi, "&lt;$1<"), r = r.replace(/<(.*?)>/gi, "xtagstartz$1xtagendz"), r = r.replace(/xtagstartzpre(.*?)xtagendz/g, "<pre$1>"), r = r.replace(/xtagstartzcode(.*?)xtagendz/g, "<code$1>"), r = r.replace(/xtagstartz\/codextagendz/g, "</code>"), r = r.replace(/xtagstartz\/prextagendz/g, "</pre>"), r = this._encodeCode(r), r = r.replace(/xtagstartz([\w\W]*?)xtagendz/g, "<$1>"), r = r.replace(/xtagstartz\/(.*?)xtagendz/g, "</$1>"), r = this.decodeAttrSings(r), r;
    },
    _encodeCode: function(r) {
      var h = this.utils.buildWrapper(r);
      return h.find("pre code, pre, code").each(this._encodeNode.bind(this)), this.utils.getWrapperHtml(h);
    },
    _encodeNode: function(r) {
      var h = r.firstChild, u = r.innerHTML;
      if (!(r.tagName === "PRE" && h && h.tagName === "CODE")) {
        u = u.replace(/xtagstartz/g, "<"), u = u.replace(/xtagendz/g, ">");
        var g = this.decodeEntities(u);
        r.textContent = this._encodeNodeHtml(g);
      }
    },
    _encodeNodeHtml: function(r) {
      return r = r.replace(/&nbsp;/g, " ").replace(/<br\s?\/?>/g, `
`), r = this.opts.preSpaces ? r.replace(/\t/g, new Array(this.opts.preSpaces + 1).join(" ")) : r, r;
    },
    encodeAttrSings: function(r) {
      var h = r.match(/="(.*?)"/g);
      if (h !== null) {
        for (var u = 0; u < h.length; u++)
          if (!(h[u].search(/^"</) !== -1 || h[u].search(/>"$/) !== -1)) {
            var g = h[u].replace(">", "xmoresignz");
            g = g.replace("<", "xlesssignz"), r = r.replace(h[u], g);
          }
      }
      return r;
    },
    encodeEntities: function(r) {
      return r = this.decodeEntities(r), r = r.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;"), r;
    },
    encodePhpCode: function(r) {
      return r = r.replace("<?php", "&lt;?php"), r = r.replace("<?", "&lt;?"), r = r.replace("?>", "?&gt;"), r;
    },
    decodeAttrSings: function(r) {
      return r = r.replace(/xmoresignz/gi, ">"), r = r.replace(/xlesssignz/gi, "<"), r;
    },
    decodeEntities: function(r) {
      return String(r).replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&amp;/g, "&");
    },
    // store / restore
    storeComponents: function(r) {
      var h = this.utils.getElementsFromHtml(r, "figure", "table");
      return this._storeMatched(r, h, "Components", "figure");
    },
    restoreComponents: function(r) {
      return this._restoreMatched(r, "Components", "figure");
    },
    storeLinks: function(r) {
      var h = this.utils.getElementsFromHtml(r, "a");
      return this._storeMatched(r, h, "Links", "a");
    },
    storeImages: function(r) {
      var h = this.utils.getElementsFromHtml(r, "img");
      return this._storeMatched(r, h, "Images", "img");
    },
    restoreLinks: function(r) {
      return this._restoreMatched(r, "Links", "a");
    },
    restoreImages: function(r) {
      return this._restoreMatched(r, "Images", "img");
    },
    // PRIVATE
    // clean
    _cleanWrapped: function(r) {
      return r = r.replace(new RegExp("<p><figure([\\w\\W]*?)</figure></p>", "gi"), "<figure$1</figure>"), r;
    },
    _cleanGDocs: function(r) {
      return r = r.replace(/<b\sid="internal-source-marker(.*?)">([\w\W]*?)<\/b>/gi, "$2"), r = r.replace(/<b(.*?)id="docs-internal-guid(.*?)">([\w\W]*?)<\/b>/gi, "$3"), r = r.replace(
        /<span[^>]*(font-style:\s?italic;\s?font-weight:\s?bold|font-weight:\s?bold;\s?font-style:\s?italic)[^>]*>([\w\W]*?)<\/span>/gi,
        "<b><i>$2</i></b>"
      ), r = r.replace(
        /<span[^>]*(font-style:\s?italic;\s?font-weight:\s?600|font-weight:\s?600;\s?font-style:\s?italic)[^>]*>([\w\W]*?)<\/span>/gi,
        "<b><i>$2</i></b>"
      ), r = r.replace(
        /<span[^>]*(font-style:\s?italic;\s?font-weight:\s?700|font-weight:\s?700;\s?font-style:\s?italic)[^>]*>([\w\W]*?)<\/span>/gi,
        "<b><i>$2</i></b>"
      ), r = r.replace(/<span[^>]*font-style:\s?italic[^>]*>([\w\W]*?)<\/span>/gi, "<i>$1</i>"), r = r.replace(/<span[^>]*font-weight:\s?bold[^>]*>([\w\W]*?)<\/span>/gi, "<b>$1</b>"), r = r.replace(/<span[^>]*font-weight:\s?700[^>]*>([\w\W]*?)<\/span>/gi, "<b>$1</b>"), r = r.replace(/<span[^>]*font-weight:\s?600[^>]*>([\w\W]*?)<\/span>/gi, "<b>$1</b>"), r;
    },
    _cleanMsWord: function(r) {
      r = r.replace(/<!--[\s\S]+?-->/gi, ""), r = r.replace(
        /<(!|script[^>]*>.*?<\/script(?=[>\s])|\/?(\?xml(:\w+)?|img|meta|link|style|\w:\w+)(?=[\s\/>]))[^>]*>/gi,
        ""
      ), r = r.replace(/<(\/?)s>/gi, "<$1strike>"), r = r.replace(/&nbsp;/gi, " "), r = r.replace(
        /<span\s+style\s*=\s*"\s*mso-spacerun\s*:\s*yes\s*;?\s*"\s*>([\s\u00a0]*)<\/span>/gi,
        function(x, S) {
          return S.length > 0 ? S.replace(/./, " ").slice(Math.floor(S.length / 2)).split("").join(" ") : "";
        }
      );
      var h = this.utils.buildWrapper(r);
      h.find(".MsoFootnoteText").each(function(x) {
        var S = c.dom(x), k = S.parent();
        k.length !== 0 && k.attr("style").search(/mso-element:footnote/) !== -1 && S.find("a").attr("id", "_" + k.attr("id"));
      }), h.find(".MsoFootnoteReference").each(function(x) {
        var S = c.dom(x), k = S.parent();
        k.length !== 0 && k.get().tagName === "A" && k.attr("id", k.attr("name"));
      }), h.find("p").each(function(x) {
        var S = c.dom(x), k = S.attr("style"), C = /mso-list:\w+ \w+([0-9]+)/.exec(k);
        C && S.attr("data-listLevel", parseInt(C[1], 10));
      }), this._parseWordLists(h), h.find("[align]").removeAttr("align"), h.find("[name]").removeAttr("name"), h.find("span").each(function(x) {
        var S = c.dom(x), k = S.attr("style"), C = /mso-list:Ignore/.exec(k);
        C ? S.remove() : S.unwrap();
      }), h.find("[style]").removeAttr("style"), h.find("[class^='Mso']").removeAttr("class"), h.find("a").filter(function(x) {
        return !x.hasAttribute("href");
      }).unwrap(), r = this.utils.getWrapperHtml(h), r = r.replace(/<p[^>]*><\/p>/gi, ""), r = r.replace(/<li>·/gi, "<li>"), r = r.trim(), r = r.replace(
        /\/(p|ul|ol|h1|h2|h3|h4|h5|h6|blockquote)>\s+<(p|ul|ol|h1|h2|h3|h4|h5|h6|blockquote)/gi,
        `/$1>
<$2`
      );
      for (var u = "", g = r.split(/\n/), b = 0; b < g.length; b++) {
        var O = g[b] !== "" && g[b].search(/>$/) === -1 ? " " : `
`;
        u += g[b] + O;
      }
      return u;
    },
    _parseWordLists: function(r) {
      var h = 0, u = null, g = null, b = null;
      r.find("p").each(function(O) {
        var x = c.dom(O), S = x.attr("data-listLevel");
        if (S === null && x.hasClass("MsoListParagraphCxSpMiddle") && (S = 1), S !== null) {
          var k = x.text(), C = /^\s*\w+\./.test(k) ? "<ol></ol>" : "<ul></ul>";
          if (x.hasClass("MsoListParagraphCxSpFirst") || x.hasClass("MsoNormal") ? (g = c.dom(C), x.before(g)) : S > h && h !== 0 && (b = c.dom(C), u.append(b), g = b), S < h)
            for (var _ = h - S + 1, $ = 0; $ < _; $++)
              g = g.parent();
          x.find("span").first().unwrap(), u = c.dom("<li>" + x.html().trim() + "</li>"), g === null && (x.before(C), g = x.prev()), g.append(u), x.remove(), h = S;
        } else
          g = null, h = 0;
      });
    },
    // is
    _isSpacedEmpty: function(r) {
      return r.search(this.reSpacedEmpty) !== -1;
    },
    _isParagraphEmpty: function(r) {
      return r.search(/^<p><\/p>$/i) !== -1;
    },
    _isHtmlMsWord: function(r) {
      return r.match(/class="?Mso|style="[^"]*\bmso-|style='[^'']*\bmso-|w:WordDocument/i);
    },
    // set
    _setSpanAttr: function(r) {
      var h = this.utils.buildWrapper(r);
      return h.find("span").attr("data-redactor-span", !0), this.utils.getWrapperHtml(h);
    },
    _setStyleCache: function(r) {
      var h = this.utils.buildWrapper(r);
      return h.find("[style]").each(function(u) {
        var g = c.dom(u);
        g.attr("data-redactor-style-cache", g.attr("style"));
      }), this.utils.getWrapperHtml(h);
    },
    _setPreClass: function(r) {
      var h = this.utils.buildWrapper(r);
      return h.find("pre").addClass(this.opts.preClass), this.utils.getWrapperHtml(h);
    },
    _setLinkNofollow: function(r) {
      var h = this.utils.buildWrapper(r);
      return h.find("a").attr("rel", "nofollow"), this.utils.getWrapperHtml(h);
    },
    // replace
    _replaceScriptTag: function(r) {
      return r.replace(this.reScriptTag, '<script class="redactor-script-tag" $1>$2<\/script>');
    },
    _unreplaceScriptTag: function(r) {
      return r.replace(
        /<script class="redactor-script-tag"(.*?[^>]?)>([\w\W]*?)<\/script>/gi,
        "<script$1>$2<\/script>"
      );
    },
    _replaceNlToBr: function(r) {
      return r.replace(/\n/g, "<br />");
    },
    // remove
    _removeScriptTag: function(r) {
      return r.replace(this.reScriptTag, "");
    },
    // private
    _storeMatched: function(r, h, u, g) {
      if (this["stored" + u] = [], h)
        for (var b = 0; b < h.length; b++)
          this["stored" + u][b] = h[b], r = r.replace(h[b], "####" + g + b + "####");
      return r;
    },
    _restoreMatched: function(r, h, u) {
      if (this["stored" + h])
        for (var g = 0; g < this["stored" + h].length; g++)
          r = r.replace("####" + u + g + "####", this["stored" + h][g]);
      return r;
    }
  }), c.add("class", "cleaner.figure", {
    init: function(r) {
      this.app = r, this.opts = r.opts, this.utils = r.utils, this.detector = r.detector;
    },
    // public
    convert: function(r, h) {
      var u = this.utils.buildWrapper(r);
      return u.find("img").each(this._convertImage.bind(this)), u.find("hr").each(this._convertLine.bind(this)), u.find("iframe").each(this._convertIframe.bind(this)), u.find("table").each(this._convertTable.bind(this)), u.find("form").each(this._convertForm.bind(this)), u.find("figure pre").each(this._convertCode.bind(this)), u.find("[data-redactor-type=variable]").addClass("redactor-component"), u.find("figure").not(".redactor-component, .redactor-figure-code").each(this._convertWidget.bind(this)), u.find("figure pre").each(this._setContenteditableCode.bind(this)), u.find(".redactor-component, .non-editable").attr("contenteditable", !1), this.detector.isIe() && u.find("[data-redactor-type=table]").removeAttr("contenteditable"), u.find("figcaption, td, th").attr("contenteditable", !0), u.find(".redactor-component, figcaption").attr("tabindex", "-1"), this._acceptExtraRules(u, h), this.utils.getWrapperHtml(u);
    },
    unconvert: function(r, h) {
      r = r.replace(/<\/([^>]+)><div data-redactor-tag/g, `</$1>
<div data-redactor-tag`), r = r.replace(/<\/([^>]+)><p/g, `</$1>
<p`);
      var u = this.utils.buildWrapper(r);
      return u.find("th, td, figcaption, figure, pre, code, .redactor-component").removeAttr("contenteditable tabindex"), u.find("figure").removeClass("redactor-component redactor-component-active redactor-uploaded-figure"), u.find("[data-redactor-type=variable]").removeClass("redactor-component redactor-component-active"), u.find("figure[data-redactor-type=line]").unwrap(), u.find("figure[data-redactor-type=widget]").each(this._unconvertWidget.bind(this)), u.find("figure[data-redactor-type=form]").each(this._unconvertForm.bind(this)), u.find("figure[data-redactor-type=table]").each(this._unconvertTable.bind(this)), u.find("figure[data-redactor-type=image]").removeAttr("rel").each(this._unconvertImages.bind(this)), u.find("img").removeAttr("data-redactor-type").removeClass("redactor-component"), u.find(".non-editable").removeAttr("contenteditable"), u.find("figure").each(this._removeTypes.bind(this)), u.find("span.redactor-component-caret").remove(), u = this._unconvertBreakTag(u), this._acceptExtraRules(u, h), r = this.utils.getWrapperHtml(u), r = r.replace(/<br\s?\/?>$/, ""), r = r.replace(/<br\s?\/?><\/(td|th)>/, "</$1>"), r;
    },
    // private
    _convertImage: function(r) {
      var h = c.dom(r);
      if (!this._isNonEditable(h)) {
        this.opts.imageObserve && !h.attr("data-image") && h.attr("data-image", this.utils.getRandomId());
        var u = h.closest("a"), g = h.closest("figure"), b = g.children().not("a, img, br, figcaption").length === 0;
        if (b) {
          if (g.length === 0) {
            var O = u.length !== 0 ? u.closest("p") : h.closest("p");
            if (this.opts.imageFigure === !1 && O.length !== 0) {
              var x = this.utils.replaceToTag(O, "figure");
              g = x, g.addClass("redactor-replace-figure");
            } else
              O.length !== 0 && O.unwrap(), g = u.length !== 0 ? u.wrap("<figure>") : h.wrap("<figure>");
          } else
            g.hasClass("redactor-uploaded-figure") ? g.removeClass("redactor-uploaded-figure") : g.addClass("redactor-keep-figure");
          this._setFigure(g, "image");
        }
      }
    },
    _convertTable: function(r) {
      if (!this._isNonEditable(r)) {
        var h = this._wrapFigure(r);
        this._setFigure(h, "table");
      }
    },
    _convertLine: function(r) {
      if (!this._isNonEditable(r)) {
        var h = this._wrapFigure(r);
        this._setFigure(h, "line");
      }
    },
    _convertForm: function(r) {
      if (!this._isNonEditable(r)) {
        var h = this.utils.replaceToTag(r, "figure");
        this._setFigure(h, "form");
      }
    },
    _convertIframe: function(r) {
      if (!this._isNonEditable(r)) {
        var h = c.dom(r);
        if (h.closest(".redactor-component").length === 0) {
          var u = r.getAttribute("src"), g = u && (u.match(this.opts.regex.youtube) || u.match(this.opts.regex.vimeo)), b = this._wrapFigure(r);
          g && this._setFigure(b, "video");
        }
      }
    },
    _convertCode: function(r) {
      if (!this._isNonEditable(r)) {
        var h = this._wrapFigure(r);
        this._setFigure(h, "code");
      }
    },
    _convertWidget: function(r) {
      if (!this._isNonEditable(r)) {
        var h = c.dom(r);
        h.addClass("redactor-component"), h.attr("data-redactor-type", "widget"), h.attr("data-widget-code", encodeURI(r.innerHTML.trim()));
      }
    },
    // unconvert
    _unconvertBreakTag: function(r) {
      return r.find("[data-redactor-tag]").each(
        (function(h) {
          var u = c.dom(h);
          if (u.removeAttr("data-redactor-tag"), h.attributes.length !== 0) {
            h.lastChild && h.lastChild.tagName === "BR" && c.dom(h.lastChild).remove();
            return;
          }
          if (h.lastChild && h.lastChild.tagName === "BR")
            u.unwrap();
          else {
            var g = u.nextElement();
            g.length !== 0 && g.attr("data-redactor-tag") && h.appendChild(document.createElement("br")), u.unwrap();
          }
        }).bind(this)
      ), r;
    },
    _unconvertForm: function(r) {
      this.utils.replaceToTag(r, "form");
    },
    _unconvertTable: function(r) {
      var h = c.dom(r);
      h.unwrap();
    },
    _unconvertWidget: function(r) {
      var h = c.dom(r);
      h.html(decodeURI(h.attr("data-widget-code"))), h.removeAttr("data-widget-code");
    },
    _unconvertImages: function(r) {
      var h = c.dom(r);
      h.removeClass("redactor-component");
      var u = h.closest("li").length !== 0, g = h.closest("table").length !== 0, b = h.find("figcaption").length !== 0, O = h.attr("style"), x = !(O === null || O === ""), S = h.attr("class") !== "";
      (u || g && !b && !x && !S) && h.unwrap();
    },
    _removeTypes: function(r) {
      var h = c.dom(r), u = h.attr("data-redactor-type"), g = ["image", "widget", "line", "video", "code", "form", "table"];
      if (u && g.indexOf(u) !== -1 && h.removeAttr("data-redactor-type"), h.hasClass("redactor-keep-figure"))
        h.removeClass("redactor-keep-figure");
      else if (u === "image" && this.opts.imageFigure === !1) {
        var b = h.find("figcaption").length !== 0;
        b || (h.hasClass("redactor-replace-figure") ? (h.removeClass("redactor-replace-figure"), this.utils.replaceToTag(h, "p")) : this.utils.replaceToTag(h, "p"));
      }
      h.removeClass("redactor-replace-figure");
    },
    // wrap
    _wrapFigure: function(r) {
      var h = c.dom(r), u = h.closest("figure");
      return u.length === 0 ? h.wrap("<figure>") : u;
    },
    // set
    _setFigure: function(r, h) {
      r.addClass("redactor-component"), r.attr("data-redactor-type", h);
    },
    _setContenteditableCode: function(r) {
      if (!this._isNonEditable(r)) {
        var h = c.dom(r), u = h.children("code").first(), g = u.length !== 0 ? u : h;
        g.attr("contenteditable", !0).attr("tabindex", "-1");
      }
    },
    // utils
    _acceptExtraRules: function(r, h) {
      for (var u in h)
        typeof h[u] == "function" && h[u](r);
    },
    _isNonEditable: function(r) {
      return c.dom(r).closest(".non-editable").length !== 0;
    }
  }), c.add("class", "cleaner.paragraphize", {
    init: function(r) {
      this.app = r, this.opts = r.opts, this.utils = r.utils, this.cleaner = r.cleaner, this.element = r.element, this.stored = [], this.remStart = "#####replace", this.remEnd = "#####", this.paragraphizeTags = [
        "table",
        "div",
        "pre",
        "form",
        "ul",
        "ol",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "dl",
        "blockquote",
        "figcaption",
        "address",
        "section",
        "header",
        "footer",
        "aside",
        "article",
        "object",
        "style",
        "script",
        "iframe",
        "select",
        "input",
        "textarea",
        "button",
        "option",
        "map",
        "area",
        "math",
        "hr",
        "fieldset",
        "legend",
        "hgroup",
        "nav",
        "figure",
        "details",
        "menu",
        "summary",
        "p"
      ];
    },
    // public
    convert: function(r) {
      var h = this._isConverted(r);
      return h = h === !0 ? this._convert(r) : h, h = this._convertTable(h), h;
    },
    // private
    _convert: function(r, h) {
      var u = this.opts.breakline || h ? "sdivtag" : this.opts.markup, g = h ? "tbr" : "br";
      r = this._storeTags(r);
      var b = [];
      r = this.cleaner.storeComments(r, b), r = r.trim(), r = this._trimLinks(r);
      var O = this.opts.inlineTags.join("|");
      r = r.replace(new RegExp("<(" + O + `)(.*?[^>]?)>
</(` + O + ")>", "gi"), "<$1$2></$3>"), r = r.replace(/xparagraphmarkerz(?:\r\n|\r|\n)$/g, ""), r = r.replace(/xparagraphmarkerz$/g, ""), r = r.replace(/xparagraphmarkerz(?:\r\n|\r|\n)/g, `
`), r = r.replace(/xparagraphmarkerz/g, `
`), this.opts.breakline ? (r = r.replace(/<br\s?\/?>(?:\r\n|\r|\n)/gi, `xbreakmarkerz
`), r = r.replace(/<br\s?\/?>/gi, `xbreakmarkerz
`), r = r.replace(/xbreakmarkerz\n<\//gi, "xbreakmarkerz</")) : r = r.replace(/[\n]+/g, `
`);
      for (var x = "", S = r.split(`
`), k = 0; k < S.length; k++)
        x += "<" + u + ">" + S[k] + "</" + u + `>
`;
      return r = x.replace(/\n$/, ""), r = r.replace(new RegExp("<" + u + ">\\s+#####", "gi"), "#####"), r = r.replace(new RegExp("<" + u + ">#####", "gi"), "#####"), r = r.replace(new RegExp("#####</" + u + ">", "gi"), "#####"), r = this.opts.breakline ? r.replace(/xbreakmarkerz/gi, "<br>") : r, r = this._restoreTags(r), r = this.cleaner.restoreComments(r, b), this.opts.breakline && (r = r.replace(new RegExp("<" + u + "></" + u + ">", "gi"), "<" + u + "><br></" + u + ">")), r = r.replace(new RegExp("<sdivtag>", "gi"), '<div data-redactor-tag="' + g + '">'), r = r.replace(new RegExp("sdivtag", "gi"), "div"), r = r.replace(/<\/([^>]+)><div data-redactor-tag/g, `</$1>
<div data-redactor-tag`), r;
    },
    _convertTable: function(r) {
      var h = this.utils.buildWrapper(r);
      return h.find("td, th").each(this._convertCell.bind(this)), r = this.utils.getWrapperHtml(h), r;
    },
    _convertCell: function(r) {
      var h = c.dom(r);
      this.stored = [];
      var u = this._convert(h.html(), !0);
      h.html(u);
    },
    _storeTags: function(r) {
      var h = this, u = this.utils.buildWrapper(r);
      return u.find(this.paragraphizeTags.join(", ")).each(function(g, b) {
        var O = document.createTextNode(h.remStart + b + h.remEnd + "xparagraphmarkerz");
        h.stored.push(g.outerHTML), g.parentNode.replaceChild(O, g);
      }), this.utils.getWrapperHtml(u);
    },
    _restoreTags: function(r) {
      for (var h = 0; h < this.stored.length; h++)
        this.stored[h] = this.stored[h].replace(/\$/g, "&#36;"), r = r.replace(this.remStart + h + this.remEnd, this.stored[h]);
      return r;
    },
    _trimLinks: function(r) {
      var h = this.utils.buildWrapper(r);
      return h.find("a").each(this._trimLink.bind(this)), r = this.utils.getWrapperHtml(h), r;
    },
    _trimLink: function(r) {
      var h = c.dom(r);
      h.html(h.html().trim());
    },
    _isConverted: function(r) {
      return this._isDisabled(r) ? r : this._isEmptyHtml(r) ? this.opts.emptyHtml : !0;
    },
    _isDisabled: function() {
      return this.opts.paragraphize === !1 || this.element.isType("inline");
    },
    _isEmptyHtml: function(r) {
      return r === "" || r === "<p></p>" || r === "<div></div>";
    }
  }), c.add("service", "detector", {
    init: function(r) {
      this.app = r, this.userAgent = navigator.userAgent.toLowerCase();
    },
    isWebkit: function() {
      return /webkit/.test(this.userAgent);
    },
    isFirefox: function() {
      return this.userAgent.indexOf("firefox") > -1;
    },
    isIe: function(r) {
      if (document.documentMode || /Edge/.test(navigator.userAgent))
        return "edge";
      var h;
      return h = RegExp("msie" + (isNaN(r) ? "" : "\\s" + r), "i").test(navigator.userAgent), h || (h = !!navigator.userAgent.match(/Trident.*rv[ :]*11\./)), h;
    },
    isMobile: function() {
      return /(iPhone|iPod|Android)/.test(navigator.userAgent);
    },
    isDesktop: function() {
      return !/(iPhone|iPod|iPad|Android)/.test(navigator.userAgent);
    },
    isIpad: function() {
      return /iPad/.test(navigator.userAgent);
    }
  }), c.add("service", "offset", {
    init: function(r) {
      this.app = r;
    },
    get: function(r, h) {
      var u = { start: 0, end: 0 }, g = this.utils.getNode(r);
      if (!g)
        return !1;
      var b = this.editor.isEditor(g), O = b ? !0 : this.selection.isIn(g), x = this.selection.getRange();
      if (!b && !O)
        u = !1;
      else if (this.selection.is() && O) {
        var S = c.dom(x.startContainer), k = S.hasClass("redactor-component") ? x.startOffset : 0, C = x.cloneRange();
        C.selectNodeContents(g), C.setEnd(x.startContainer, x.startOffset);
        var _ = this._getString(x, h);
        u.start = this._getString(C, h).length - k, u.end = u.start + _.length + k;
      }
      return u;
    },
    set: function(r, h) {
      if (!this._setComponentOffset(h)) {
        this.component.clearActive();
        var u = this.utils.getNode(h);
        if (u) {
          var g = this.size(u), b = 0, O = document.createRange();
          r.end = r.end > g ? g : r.end, O.setStart(u, 0), O.collapse(!0);
          for (var x = [u], S = !1, k = !1; !k && (u = x.pop()); )
            if (u.nodeType === 3) {
              var C = b + u.length;
              !S && !this._isFigcaptionNext(u) && r.start >= b && r.start <= C && (O.setStart(u, r.start - b), S = !0), S && r.end >= b && r.end <= C && (O.setEnd(u, r.end - b), k = !0), b = C;
            } else
              for (var _ = u.childNodes.length; _--; )
                x.push(u.childNodes[_]);
          this.selection.setRange(O);
        }
      }
    },
    size: function(r, h) {
      var u = this.utils.getNode(r);
      if (u) {
        var g = document.createRange(), b = g.cloneRange();
        return b.selectNodeContents(u), this._getString(b, h).length;
      }
      return 0;
    },
    // private
    _getString: function(r, h) {
      var u = r.toString();
      return u = this.editor.isEmpty() ? u.replace(/\uFEFF/g, "") : u, u = h ? u.trim() : u, u;
    },
    _setComponentOffset: function(r) {
      return this.component.isNonEditable(r) ? this.component.setActive(r) : !1;
    },
    _isFigcaptionNext: function(r) {
      var h = r.nextSibling;
      return r.nodeValue.trim() === "" && h && h.tagName === "FIGCAPTION";
    }
  }), c.add("service", "inspector", {
    init: function(r) {
      this.app = r;
    },
    // parse
    parse: function(r) {
      return c.create("inspector.parser", this.app, this, r);
    },
    // text detection
    isText: function(r) {
      if (typeof r == "string" && !/^\s*<(\w+|!)[^>]*>/.test(r))
        return !0;
      var h = c.dom(r).get();
      return h && h.nodeType === 3;
    },
    // tag detection
    isInlineTag: function(r, h) {
      var u = this._extendTags(this.opts.inlineTags, h);
      return this._isTag(r) && u.indexOf(r.toLowerCase()) !== -1;
    },
    isBlockTag: function(r, h) {
      var u = this._extendTags(this.opts.blockTags, h);
      return this._isTag(r) && u.indexOf(r.toLowerCase()) !== -1;
    },
    isTableCellTag: function(r) {
      return ["td", "th"].indexOf(r.toLowerCase()) !== -1;
    },
    isHeadingTag: function(r) {
      return ["h1", "h2", "h3", "h4", "h5", "h6"].indexOf(r.toLowerCase()) !== -1;
    },
    _isTag: function(r) {
      return r !== void 0 && r;
    },
    _extendTags: function(r, h) {
      if (r = r.concat(r), h)
        for (var u = 0; u < h.length; u++)
          r.push(h[u]);
      return r;
    }
  }), c.add("class", "inspector.parser", {
    init: function(r, h, u) {
      this.app = r, this.uuid = r.uuid, this.opts = r.opts, this.utils = r.utils, this.editor = r.editor, this.selection = r.selection, this.inspector = h;
      var g = this.editor.getElement();
      this.el = u, this.$el = c.dom(this.el, g), this.node = this.$el.get(), this.node && this.node.nodeType === 8 && (this.node = !1), this.$component = this.$el.closest(".redactor-component", g);
    },
    // is
    isEditor: function() {
      return this.node === this.editor.getElement().get();
    },
    isInEditor: function() {
      return this.$el.parents(".redactor-in-" + this.uuid).length !== 0;
    },
    isComponent: function() {
      return this.$component.length !== 0;
    },
    isComponentType: function(r) {
      return this.getComponentType() === r;
    },
    isComponentActive: function() {
      return this.isComponent() && this.$component.hasClass("redactor-component-active");
    },
    isComponentEditable: function() {
      var r = ["code", "table"], h = this.getComponentType();
      return this.isComponent() && r.indexOf(h) !== -1;
    },
    isFigcaption: function() {
      return this.getFigcaption();
    },
    isPre: function() {
      return this.getPre();
    },
    isCode: function() {
      var r = this.$el.closest("code"), h = r.parent("pre");
      return r.length !== 0 && h.length === 0;
    },
    isList: function() {
      return this.getList();
    },
    isFirstListItem: function() {
      return this._getLastOrFirstListItem("first");
    },
    isLastListItem: function() {
      return this._getLastOrFirstListItem("last");
    },
    isFirstTableCell: function() {
      return this._getLastOrFirstTableCell("first");
    },
    isLastTableCell: function() {
      return this._getLastOrFirstTableCell("last");
    },
    isTable: function() {
      return this.isComponentType("table") || this.getTable();
    },
    isHeading: function() {
      return this.getHeading();
    },
    isBlockquote: function() {
      return this.getBlockquote();
    },
    isDl: function() {
      return this.getDl();
    },
    isParagraph: function() {
      return this.getParagraph();
    },
    isLink: function() {
      return this.getLink();
    },
    isFile: function() {
      return this.getFile();
    },
    isText: function() {
      return this.inspector.isText(this.el);
    },
    isInline: function() {
      var r = this.opts.inlineTags;
      return this.isElement() ? r.indexOf(this.node.tagName.toLowerCase()) !== -1 : !1;
    },
    isBlock: function() {
      var r = this.opts.blockTags;
      return this.isElement() ? r.indexOf(this.node.tagName.toLowerCase()) !== -1 : !1;
    },
    isElement: function() {
      return this.node && this.node.nodeType && this.node.nodeType !== 3;
    },
    // has
    hasParent: function(r) {
      return this.$el.closest(r.join(",")).length !== 0;
    },
    // get
    getNode: function() {
      return this.node;
    },
    getTag: function() {
      return this.isElement() ? this.node.tagName.toLowerCase() : !1;
    },
    getComponent: function() {
      return this.isComponent() ? this.$component.get() : !1;
    },
    getComponentType: function() {
      return this.isComponent() ? this.$component.attr("data-redactor-type") : !1;
    },
    getFirstNode: function() {
      return this.utils.getFirstNode(this.node);
    },
    getLastNode: function() {
      return this.utils.getLastNode(this.node);
    },
    getFirstElement: function() {
      return this.utils.getFirstElement(this.node);
    },
    getLastElement: function() {
      return this.utils.getLastElement(this.node);
    },
    getFigcaption: function() {
      return this._getClosestNode("figcaption");
    },
    getPre: function() {
      return this._getClosestNode("pre");
    },
    getCode: function() {
      return this._getClosestNode("code");
    },
    getList: function() {
      return this._getClosestNode("ul, ol");
    },
    getParentList: function() {
      return this._getClosestUpNode("ul, ol");
    },
    getListItem: function() {
      return this._getClosestNode("li");
    },
    getTable: function() {
      return this.getComponentType("table") ? this.$component.find("table").get() : this._getClosestNode("table");
    },
    getTableCell: function() {
      var r = this.$el.closest("td, th");
      return r.length !== 0 ? r.get() : !1;
    },
    getComponentCodeElement: function() {
      return this.isComponentType("code") ? this.$component.find("pre code, pre").last().get() : !1;
    },
    getImageElement: function() {
      return this.isComponentType("image") ? this.$component.find("img").get() : !1;
    },
    getParagraph: function() {
      return this._getClosestNode("p");
    },
    getHeading: function() {
      return this._getClosestNode("h1, h2, h3, h4, h5, h6");
    },
    getDl: function() {
      return this._getClosestNode("dl");
    },
    getBlockquote: function() {
      return this._getClosestNode("blockquote");
    },
    getLink: function() {
      var r = this.isComponent() && !this.isFigcaption(), h = this.isComponentType("table");
      if (h || !r) {
        var u = this._getClosestElement("a");
        return u && !u.attr("data-file") ? u.get() : !1;
      }
      return !1;
    },
    getFile: function() {
      var r = this.isComponent(), h = this.isComponentType("table");
      if (h || !r) {
        var u = this._getClosestElement("a");
        return u && u.attr("data-file") ? u.get() : !1;
      }
      return !1;
    },
    // find
    findFirstNode: function(r) {
      return this.$el.find(r).first().get();
    },
    findLastNode: function(r) {
      return this.$el.find(r).last().get();
    },
    // private
    _getLastOrFirstListItem: function(r) {
      var h = this.getList(), u = this.getTag();
      if (h && u === "li") {
        var g = c.dom(h).find("li")[r]().get();
        if (g && this.node === g)
          return !0;
      }
      return !1;
    },
    _getLastOrFirstTableCell: function(r) {
      var h = this.getTable(), u = this.getTag();
      if (h && (u === "td" || u === "th")) {
        var g = c.dom(h).find("td, th")[r]().get();
        if (g && this.node === g)
          return !0;
      }
      return !1;
    },
    _getClosestUpNode: function(r) {
      var h = this.editor.getElement(), u = this.$el.parents(r, h).last();
      return u.length !== 0 ? u.get() : !1;
    },
    _getClosestNode: function(r) {
      var h = this.editor.getElement(), u = this.$el.closest(r, h);
      return u.length !== 0 ? u.get() : !1;
    },
    _getClosestElement: function(r) {
      var h = this.editor.getElement(), u = this.$el.closest(r, h);
      return u.length !== 0 ? u : !1;
    }
  }), c.add("service", "marker", {
    init: function(r) {
      this.app = r;
    },
    build: function(r, h) {
      var u = document.createElement("span");
      return u.id = "selection-marker-" + this._getPos(r), u.className = "redactor-selection-marker", u.innerHTML = this.opts.markerChar, h ? u.outerHTML : u;
    },
    buildHtml: function(r) {
      return this.build(r, !0);
    },
    insert: function(r) {
      this.remove();
      var h = r !== "both" && (r === "start" || this.selection.isCollapsed());
      this.selection.is() || this.editor.focus();
      var u = this.selection.getRange();
      if (u) {
        var g = this.build("start"), b = this.build("end"), O = u.cloneRange();
        return h || (O.collapse(!1), O.insertNode(b)), O.setStart(u.startContainer, u.startOffset), O.collapse(!0), O.insertNode(g), u.setStartAfter(g), h || u.setEndBefore(b), this.selection.setRange(u), g;
      }
    },
    find: function(r, h) {
      var u = this.editor.getElement(), g = (h || u).find("span#selection-marker-" + this._getPos(r));
      return g.length !== 0 ? g.get() : !1;
    },
    restore: function() {
      var r = this.find("start"), h = this.find("end"), u = this.selection.getRange();
      if ((!u || !this.selection.is()) && (this.editor.focus(), u = document.createRange()), r) {
        var g = h ? h.previousSibling : !1, b = r.nextSibling;
        b = b && b.nodeType === 3 && b.textContent.replace(/[\n\t]/g, "") === "" ? !1 : b, h ? b && b.id === "selection-marker-end" ? this._restoreInject(u, r) : g && b ? (u.selectNodeContents(g), u.collapse(!1), u.setStart(b, 0)) : g && !b ? (u.selectNodeContents(g), u.collapse(!1), u.setStartAfter(r)) : (u.setStartAfter(r), u.setEndBefore(h)) : b ? (u.selectNodeContents(b), u.collapse(!0)) : this._restoreInject(u, r), this.selection.setRange(u), r && r.parentNode.removeChild(r), h && h.parentNode.removeChild(h);
      }
    },
    remove: function() {
      var r = this.find("start"), h = this.find("end");
      r && r.parentNode.removeChild(r), h && h.parentNode.removeChild(h);
    },
    // private
    _getPos: function(r) {
      return r === void 0 ? "start" : r;
    },
    _restoreInject: function(r, h) {
      var u = this.utils.createInvisibleChar();
      c.dom(h).after(u), r.selectNodeContents(u), r.collapse(!1);
    }
  }), c.add("service", "component", {
    init: function(r) {
      this.app = r, this.activeClass = "redactor-component-active";
    },
    create: function(r, h) {
      return c.create(r + ".component", this.app, h);
    },
    build: function(r) {
      var h = c.dom(r), u, g = h.attr("data-redactor-type");
      return g && (u = this.create(g, r)), u || r;
    },
    remove: function(r, h) {
      var u = c.dom(r).closest(".redactor-component"), g = u.attr("data-redactor-type"), b = u.parent(), O = this.inspector.parse(b), x = this.utils.findSiblings(u, "prev"), S = this.utils.findSiblings(u, "next"), k = this.app.broadcast(g + ".delete", u);
      if (k !== !1) {
        if (u.remove(), this.app.broadcast(g + ".deleted", u), this.app.broadcast("contextbar.close"), this.app.broadcast("imageresizer.stop"), h !== !1) {
          var C = O.getTableCell();
          C && this.utils.isEmptyHtml(C.innerHTML) ? this.caret.setStart(C) : S ? this.caret.setStart(S) : x ? this.caret.setEnd(x) : this.editor.startFocus();
        }
        this.editor.isEmpty() && (this.editor.setEmpty(), this.editor.startFocus(), this.app.broadcast("empty"));
      }
    },
    isNonEditable: function(r) {
      var h = this.inspector.parse(r);
      return h.isComponent() && !h.isComponentEditable();
    },
    isActive: function(r) {
      var h;
      if (r) {
        var u = this.inspector.parse(r);
        return h = c.dom(u.getComponent()), h.hasClass(this.activeClass);
      } else
        return h = this._find(), h.length !== 0;
    },
    getActive: function(r) {
      var h = this._find();
      return h.length !== 0 ? r ? h : h.get() : !1;
    },
    setActive: function(r) {
      this.clearActive(), this.editor.focus();
      var h = this.inspector.parse(r), u = h.getComponent(), g = c.dom(u);
      if (!h.isFigcaption()) {
        var b = g.find(".redactor-component-caret");
        b.length === 0 && (b = this._buildCaret(), g.prepend(b)), this.caret.setAtStart(b.get());
      }
      g.addClass(this.activeClass);
    },
    clearActive: function() {
      var r = this._find();
      r.removeClass(this.activeClass), r.find(".redactor-component-caret").remove(), this.app.broadcast("imageresizer.stop");
    },
    setOnEvent: function(r, h) {
      this.clearActive();
      var u = this.inspector.parse(r.target);
      u.isFigcaption() || u.isComponentEditable() || u.isComponent() && (this.setActive(r.target), h !== !0 && r.preventDefault());
    },
    executeScripts: function(r) {
      if (r === void 0) {
        var h = this.editor.getElement(), r = h.find("[data-redactor-type]").find("script").getAll();
        this.executeScripts.call(this, r);
      } else
        for (var u = 0; u < r.length; u++)
          if (r[u].src !== "") {
            var g = r[u].src;
            this.$doc.find('head script[src="' + g + '"]').remove();
            var b = c.dom("<script>");
            b.attr("src", g), b.attr("async defer"), b.get().onload = (function() {
              g.search("instagram") !== -1 && window.instgrm.Embeds.process(), this.executeScripts(r.slice(u + 1));
            }).bind(this);
            var O = document.getElementsByTagName("head")[0];
            O && O.appendChild(b.get());
            break;
          }
    },
    // private
    _find: function() {
      return this.editor.getElement().find("." + this.activeClass);
    },
    _buildCaret: function() {
      var r = c.dom("<span>");
      return r.addClass("redactor-component-caret"), r.attr("contenteditable", !0), r;
    }
  }), c.add("service", "insertion", {
    init: function(r) {
      this.app = r;
    },
    set: function(r, h, u) {
      r === null && (r = ""), r = h !== !1 ? this.cleaner.input(r) : r, r = h !== !1 ? this.cleaner.paragraphize(r) : r;
      var g = this.editor.getElement();
      return g.html(r), u !== !1 && this.editor.endFocus(), r;
    },
    insertNode: function(r, h) {
      this.editor.focus();
      var u = this.utils.isFragment(r) ? r : this.utils.createFragment(r);
      return this._collapseSelection(), this._insertFragment(u), this._setCaret(h, u), this._sendNodes(u.nodes);
    },
    insertBreakLine: function() {
      return this.insertNode(document.createElement("br"), "after");
    },
    insertNewline: function() {
      return this.insertNode(document.createTextNode(`
`), "after");
    },
    insertText: function(r) {
      return this.insertHtml(this.cleaner.getFlatText(r));
    },
    insertChar: function(r) {
      return this.insertNode(r, "after");
    },
    insertRaw: function(r) {
      return this.insertHtml(r, !1);
    },
    insertToEnd: function(r, h) {
      if (r) {
        r.nodeType === 3 && r.nodeValue.search(/^\n/) !== -1 && (r = r.previousElementSibling);
        var u = c.dom(r);
        if (u.attr("data-redactor-type") === h) {
          var g = this.opts.breakline ? "<br>" : "<p>", b = c.dom(g);
          u.after(b), this.caret.setStart(b);
        }
      }
    },
    insertPoint: function(r) {
      var h, u, g = this.marker.build("start"), b = !1, O = r.clientX, x = r.clientY;
      if (document.caretPositionFromPoint) {
        var S = document.caretPositionFromPoint(O, x), k = document.getSelection();
        u = this.inspector.parse(S.offsetNode), u.isInEditor() && (h = k.getRangeAt(0), h.setStart(S.offsetNode, S.offset), h.collapse(!0), h.insertNode(g), b = !0);
      } else
        document.caretRangeFromPoint && (h = document.caretRangeFromPoint(O, x), u = this.inspector.parse(h.startContainer), u.isInEditor() && (h.insertNode(g), b = !0));
      return b;
    },
    insertToPoint: function(r, h, u, g) {
      var b = u === !0 ? !0 : this.insertPoint(r);
      if (!b) {
        var O = this.editor.getLastNode();
        c.dom(O).after(this.marker.build("start"));
      }
      return this.component.clearActive(), this.selection.restoreMarkers(), this.insertHtml(h, g);
    },
    insertToOffset: function(r, h) {
      return this.offset.set({ start: r, end: r }), this.insertHtml(h);
    },
    insertHtml: function(r, h) {
      if (this.opts.input) {
        var u = this.utils.parseHtml(r);
        if (this.selection.isAll())
          return this._insertToAllSelected(u);
        if (!this.selection.is()) {
          var g = c.dom("<p>"), b = this.editor.getElement();
          b.append(g), this.caret.setStart(g);
        }
        var O = this.selection.isCollapsed(), x = this.selection.isText(), S = this.selection.getCurrent(), k = this.selection.getBlock(), C = this.inspector.parse(S);
        this._collapseSelection(), u = this._getCleanedInput(u, C, h);
        var _ = this._isFigure(u.html), $ = this._isComponentSpan(u.html), L = this.inspector.isText(u.html), E, A;
        if (this.editor.isEmpty())
          return this._insertToEmptyEditor(u.html);
        if (C.isComponent() && !C.isComponentEditable())
          return this._insertToWidget(S, C, u.html);
        if ($)
          return this.insertNode(u.nodes, "end");
        if (_ && !x && !C.isList())
          return C.isInline() ? this._insertToInline(S, u) : (E = this.utils.createFragment(u.html), this.utils.splitNode(S, E), this.caret.setEnd(E.last), this._sendNodes(E.nodes));
        if (C.isCode())
          return this._insertToCode(u, S, h);
        if (C.isPre())
          return this._insertToPre(u, h);
        if (C.isHeading() || C.isFigcaption())
          return u.html = h !== !1 ? this.cleaner.removeTagsExcept(u.html, ["a"]) : u.html, u.html = h !== !1 ? this.cleaner.replaceNbspToSpaces(u.html) : u.html, E = this.utils.createFragment(u.html), this.insertNode(E, "end");
        if (this.opts.breakline && k && k.tagName === "DIV") {
          if (this._isPlainHtml(u.html))
            return this.insertNode(u.nodes, "end");
          u.html = h !== !1 ? this.cleaner.paragraphize(u.html) : u.html, E = this.utils.createFragment(u.html);
          var y = this.selection.getRange();
          return y && !this.selection.isCollapsed() && y.deleteContents(), this.utils.splitNode(S, E), this.caret.setEnd(E.last), this._sendNodes(E.nodes);
        } else {
          if (L)
            return !x && this.opts.markup !== "br" && this._hasBlocksAndImages(u.nodes) ? (u.html = h !== !1 ? this.cleaner.paragraphize(u.html) : u.html, E = this.utils.createFragment(u.html), this.utils.splitNode(S, E), this.caret.setEnd(E.last), this._sendNodes(E.nodes)) : (u.html = h !== !1 ? u.html.replace(/\n/g, "<br>") : u.html, E = this.utils.createFragment(u.html), this.insertNode(E.nodes, "end"));
          if (!O && !_)
            return this._isPlainHtml(u.html) ? this.insertNode(u.nodes, "end") : (u.html = h !== !1 ? this.cleaner.paragraphize(u.html) : u.html, E = this.utils.createFragment(u.html), this.insertNode(E, "end"));
          if (C.isInline() && !this._isPlainHtml(u.html))
            return this._insertToInline(S, u);
          if (C.isBlockquote() || C.isDl())
            return A = this.opts.inlineTags, A.concat(["br"]), u.html = h !== !1 ? this.cleaner.replaceBlocksToBr(u.html) : u.html, u.html = h !== !1 ? this.cleaner.removeTagsExcept(u.html, A) : u.html, E = this.utils.createFragment(u.html), this.insertNode(E, "end");
          if (C.isParagraph())
            return this._isPlainHtml(u.html) ? this.insertNode(u.nodes, "end") : (u.html = h !== !1 ? this.cleaner.paragraphize(u.html) : u.html, E = this.utils.createFragment(u.html), this.utils.splitNode(S, E), this.caret.setEnd(E.last), this._sendNodes(E.nodes));
          if (C.isList() && (A = this.opts.inlineTags, A = A.concat(["br", "li", "ul", "ol", "img"]), u.html = h !== !1 ? this.cleaner.replaceBlocksToBr(u.html) : u.html, u.html = h !== !1 ? this.cleaner.removeTagsExcept(u.html, A) : u.html, u.html = h !== !1 ? this.cleaner.removeBrAtEnd(u.html) : u.html, E = this.utils.createFragment(u.html), u.nodes = E.nodes, this._containsTags(u.html, ["ul", "ol", "li"]))) {
            var w = this.selection.getElement(S);
            if (w && w.tagName === "LI" && this.caret.isStart(w)) {
              u.nodes = c.dom(E.nodes).unwrap("ul, ol").getAll(), c.dom(w).before(u.nodes);
              var T = u.nodes[u.nodes.length - 1];
              return this.caret.setEnd(T), this._sendNodes(u.nodes);
            } else
              return this._isPlainHtml(u.html) ? this.insertNode(E, "end") : (E = this._buildList(u, w, E), this.utils.splitNode(S, E, !0), this.caret.setEnd(E.last), this._sendNodes(E.nodes));
          }
        }
        return this.insertNode(u.nodes, "end");
      }
    },
    // private
    _insertToAllSelected: function(r) {
      var h = this.set(r.html), u = this.utils.parseHtml(h);
      return this._sendNodes(u.nodes);
    },
    _insertToEmptyEditor: function(r) {
      r = this.cleaner.paragraphize(r);
      var h = this.utils.createFragment(r), u = this.editor.getElement();
      return u.html(""), u.append(h.frag), this.caret.setEnd(h.last), this._sendNodes(h.nodes);
    },
    _insertToInline: function(r, h) {
      var u = this.utils.createFragment(h.html);
      return this.utils.splitNode(r, u, !1, !0), this.caret.setEnd(u.last), this._sendNodes(u.nodes);
    },
    _insertToCode: function(r, h, u) {
      r.html = u !== !1 ? this.cleaner.encodeHtml(r.html) : r.html, r.html = u !== !1 ? this.cleaner.removeNl(r.html) : r.html;
      var g = this.utils.createFragment(r.html), b = this.insertNode(g, "end");
      return this.utils.normalizeTextNodes(h), b;
    },
    _insertToPre: function(r, h) {
      r.html = h !== !1 ? this.cleaner.encodeHtml(r.html) : r.html;
      var u = this.utils.createFragment(r.html);
      return this.insertNode(u, "end");
    },
    _insertToWidget: function(r, h, u) {
      u = this._isComponentSpan(u) ? u : this.cleaner.paragraphize(u);
      var g = this.utils.createFragment(u), b = h.getComponent(), O = c.dom(b);
      return O.after(g.frag), O.remove(), this.caret.setEnd(g.last), this._sendNodes(g.nodes);
    },
    _insertFragment: function(r) {
      var h = this.selection.getRange();
      if (h) {
        if (this.selection.isCollapsed()) {
          var u = h.startContainer;
          u.nodeType !== 3 && u.tagName === "BR" && (this.caret.setAfter(u), u.parentNode.removeChild(u));
        } else
          h.deleteContents();
        h.insertNode(r.frag);
      }
    },
    _sendNodes: function(r) {
      for (var h = 0; h < r.length; h++) {
        var u = r[h], g = u.nodeType !== 3 && typeof u.getAttribute == "function" ? u.getAttribute("data-redactor-type") : !1;
        g && this.app.broadcast(g + ".inserted", this.component.build(u));
      }
      return this.detector.isIe() && this.editor.getElement().find("[data-redactor-type=table]").attr("contenteditable", !0), this.app.broadcast("inserted", r), this.component.executeScripts(), r;
    },
    _setCaret: function(r, h) {
      var u = this._isLastInline(h);
      r ? (r = u && r === "end" ? "after" : r, this.caret["set" + this.utils.ucfirst(r)](h.last)) : r !== !1 && u && this.caret.setAfter(h.last);
    },
    _isLastInline: function(r) {
      if (r.last) {
        var h = this.inspector.parse(r.last);
        return h.isInline();
      }
      return !1;
    },
    _getCleanedInput: function(r, h, u) {
      var g = h.isCode() || h.isPre();
      return r.html = r.html.replace(/&nbsp;/g, " "), r.html = !g && u !== !1 ? this.cleaner.input(r.html) : r.html, r = !g && u !== !1 ? this.utils.parseHtml(r.html) : r, r;
    },
    _getContainer: function(r) {
      return c.dom(this.utils.createTmpContainer(r));
    },
    _buildList: function(r, h, u) {
      var g = r.nodes, b = g[0];
      if (b && b.nodeType !== 3 && b.tagName === "li") {
        var O = c.dom(h), x = O.get().tagName.toLowerCase(), S = c.dom("<" + x + " />");
        return S.append(u.nodes), this.utils.createFragment(S.get().outerHTML);
      }
      return u;
    },
    _containsTags: function(r, h) {
      return this._getContainer(r).find(h.join(",")).length !== 0;
    },
    _collapseSelection: function() {
    },
    _hasFigureOrTable: function(r) {
      return this._getContainer(r).find("figure, table").length !== 0;
    },
    _hasBlocks: function(r) {
      return this._getContainer(r).find(this.opts.blockTags.join(",")).length !== 0;
    },
    _hasBlocksAndImages: function(r) {
      return this._getContainer(r).find(this.opts.blockTags.join(",") + ",img").length !== 0;
    },
    _isPlainHtml: function(r) {
      return this._getContainer(r).find(this.opts.blockTags.join(",") + ", img").length === 0;
    },
    _isFigure: function(r) {
      if (this._isHtmlString(r))
        return c.dom(r).closest("figure").length !== 0;
    },
    _isComponentSpan: function(r) {
      if (this._isHtmlString(r))
        return c.dom(r).closest("span.redactor-component").length !== 0;
    },
    _isHtmlString: function(r) {
      return !(typeof r == "string" && !/^\s*<(\w+|!)[^>]*>/.test(r));
    }
  }), c.add("service", "block", {
    init: function(r) {
      this.app = r, this.tags = ["p", "div", "blockquote", "pre", "h1", "h2", "h3", "h4", "h5", "h6"];
    },
    // format
    format: function(r) {
      return this.params = {
        args: !1
      }, this.params.type = r.type ? r.type : "set", this.params.tag = typeof r == "string" ? r : r.tag || this.opts.markup, this.params.tag = this.params.tag.toLowerCase(), this.params.args = {
        class: r.class || !1,
        style: r.style || !1,
        attr: r.attr || !1
      }, !r.class && !r.style && !r.attr && (this.params.args = !1), this._format();
    },
    // funcs
    add: function(r, h, u) {
      return this._apply("add", r, h, !0, u);
    },
    set: function(r, h) {
      return this._apply("set", r, h);
    },
    toggle: function(r, h) {
      return this._apply("toggle", r, h);
    },
    remove: function(r, h) {
      return this._apply("remove", r, h);
    },
    // clear
    clearFormat: function(r) {
      return this._clear(r, "all");
    },
    clearStyle: function(r) {
      return this._clear(r, "style");
    },
    clearClass: function(r) {
      return this._clear(r, "class");
    },
    clearAttr: function(r) {
      return this._clear(r, "attr");
    },
    // format
    _format: function() {
      var r = [];
      this.collapsed = this.selection.isCollapsed(), this.selection.save(), this.selection.getBlock();
      var h = this._getBlocks(), u = this._isToggleFormatType(h) ? "toggle" : "set", g = this._getReplacedTag(u);
      return r = this._replaceBlocks(h, g), r = this._buildNodes(r), this._restoreSelection(r), r;
    },
    // clear
    _clear: function(r, h, u, g) {
      u !== !1 && this.selection.save();
      var b = this._getElements(r, g);
      return h === "all" ? this._removeAllAttr(b, !1) : h === "style" ? (b.removeAttr("style"), b.removeAttr("data-redactor-style-cache")) : h === "class" ? b.removeAttr("class") : h === "attr" && this._removeAllAttr(b), g = b.getAll(), u !== !1 && this._restoreSelection(g), g;
    },
    // get
    _getElements: function(r, h) {
      return h ? c.dom(h) : c.dom(this._getBlocks(r));
    },
    _getBlocks: function(r) {
      for (var h = this.selection.getBlocks({ tags: r || this.tags }), u = [], g = 0; g < h.length; g++)
        h[g].tagName === "DIV" && !h[g].getAttribute("data-redactor-tag") || u.push(h[g]);
      return u;
    },
    _getReplacedTag: function(r) {
      return this.opts.breakline ? r === "toggle" || this.params.tag === "p" ? "div" : this.params.tag : r === "toggle" ? this.opts.markup : this.params.tag;
    },
    // is
    _isStandardParagraph: function() {
      return !this.opts.breakline && this.opts.markup === "p";
    },
    _isStandardDiv: function() {
      return !this.opts.breakline && this.opts.markup === "div";
    },
    _isBreaklineBlock: function(r) {
      return r && r.tagName === "DIV" && r.getAttribute("data-redactor-tag") === "br";
    },
    _isToggleFormatType: function(r) {
      for (var h = 0, u = r.length, g = 0; g < u; g++)
        r[g] && this.params.tag === r[g].tagName.toLowerCase() && h++;
      return h === u;
    },
    _isCurrentBlockOneAndEmpty: function(r) {
      return this.collapsed && r.length === 1 && this.utils.isEmpty(r[0]);
    },
    // build
    _buildNodes: function(r) {
      return r.length > 0 && (r = this._applyArgs(r, !1), r = this._combinePre(r), r = this._cleanBlocks(r)), r;
    },
    // replace
    _replaceBlocks: function(r, h) {
      for (var u = [], g = 0; g < r.length; g++) {
        var b = this.utils.replaceToTag(r[g], h);
        u.push(b.get());
      }
      return u;
    },
    // combine
    _combinePre: function(r) {
      for (var h = [], u = 0; u < r.length; u++) {
        var g = r[u].nextElementSibling;
        if (g && r[u].tagName === "PRE" && g.tagName === "PRE") {
          var b = c.dom(r[u]), O = c.dom(g), x = document.createTextNode(`
`);
          b.append(x), b.append(O), O.unwrap("pre");
        }
        h.push(r[u]);
      }
      return h;
    },
    // clean
    _cleanBlocks: function(r) {
      for (var h = ["h1", "h2", "h3", "h4", "h5", "h6"], u = this.opts.inlineTags, g = 0; g < r.length; g++) {
        var b = r[g].tagName.toLowerCase(), O = c.dom(r[g]);
        h.indexOf(b) !== -1 ? O.find("span").not(".redactor-component, .non-editable, .redactor-selection-marker").unwrap() : b === "pre" && O.find(u.join(",")).not(".redactor-selection-marker").unwrap(), this.params.args === !1 && this.params.tag === "p" && O.removeAttr("class"), this.opts.breakline && b === "div" ? O.attr("data-redactor-tag", "br") : O.removeAttr("data-redactor-tag"), this.utils.normalizeTextNodes(r[g]);
      }
      return r;
    },
    _cleanEmptyClass: function(r) {
      r.each(function(h) {
        h.className === "" && h.removeAttribute("class");
      });
    },
    _cleanEmptyStyle: function(r) {
      this.utils.removeEmptyAttr(r.get(), "style") ? r.removeAttr("data-redactor-style-cache") : r.attr("data-redactor-style-cache", r.attr("style"));
    },
    // apply
    _apply: function(r, h, u, g, b) {
      g !== !1 && this.selection.save();
      var O = this._getElements(u, b);
      if (h.class && (r === "set" ? (O.removeAttr("class"), O.addClass(h.class)) : r === "add" ? O.addClass(h.class) : r === "toggle" ? O.toggleClass(h.class) : r === "remove" && O.removeClass(h.class), this._cleanEmptyClass(O)), h.attr && (r === "set" ? (this._removeAllAttr(O), O.attr(h.attr)) : r === "add" ? O.attr(h.attr) : r === "toggle" ? (x = h.attr, O.each(function(k) {
        var C = c.dom(k);
        for (var _ in x)
          C.attr(_) ? C.removeAttr(_) : C.attr(_, x[_]);
      })) : r === "remove" && O.removeAttr(h.attr)), h.style) {
        if (r === "set")
          O.removeAttr("style"), O.css(h.style), O.each(function(k) {
            var C = c.dom(k);
            C.attr("data-redactor-style-cache", C.attr("style"));
          });
        else if (r === "add") {
          var x = h.style;
          O.each(
            (function(k) {
              var C = c.dom(k);
              C.css(x), C.attr("data-redactor-style-cache", C.attr("style")), this._convertStyleQuotes(C);
            }).bind(this)
          );
        } else if (r === "toggle") {
          var x = h.style;
          O.each(
            (function(C) {
              var _ = c.dom(C);
              for (var $ in x) {
                var L = x[$], E = _.css($);
                E = this.utils.isRgb(E) ? this.utils.rgb2hex(E) : E.replace(/"/g, ""), L = this.utils.isRgb(L) ? this.utils.rgb2hex(L) : L.replace(/"/g, ""), E = this.utils.hex2long(E), L = this.utils.hex2long(L);
                var A = typeof L == "string" ? L.toLowerCase() : L, y = typeof E == "string" ? E.toLowerCase() : E;
                A === y ? _.css($, "") : _.css($, L);
              }
              this._convertStyleQuotes(_), this._cleanEmptyStyle(_);
            }).bind(this)
          );
        } else if (r === "remove") {
          var S = h.style;
          O.each(
            (function(k) {
              var C = c.dom(k);
              C.css(S, ""), this._cleanEmptyStyle(C);
            }).bind(this)
          );
        }
      }
      return b = O.getAll(), g !== !1 && this._restoreSelection(b), b;
    },
    _applyArgs: function(r) {
      return this.params.args ? r = this._apply(this.params.type, this.params.args, !1, !1, r) : r = this._clear(!1, "all", !1, r), r;
    },
    // remove
    _removeAllAttr: function(r, h) {
      r.each(function(u) {
        var g = ["data-redactor-tag", "data-redactor-style-cache"];
        h === !1 && (g.push("style"), g.push("class"));
        for (var b = u.attributes.length; b-- > 0; ) {
          var O = u.attributes[b], x = O.name;
          g.indexOf(x) === -1 && u.removeAttributeNode(O);
        }
      });
    },
    // selection
    _restoreSelection: function(r) {
      this._isCurrentBlockOneAndEmpty(r) ? this.caret.setStart(r[0]) : setTimeout(
        (function() {
          this.selection.restore();
        }).bind(this),
        1
      );
    },
    // convert
    _convertStyleQuotes: function(r) {
      var h = r.attr("style");
      h && r.attr("style", h.replace(/"/g, "'"));
    }
  }), c.add("service", "inline", {
    mixins: ["formatter"],
    init: function(r) {
      this.app = r, this.count = 0;
    },
    // public
    format: function(r) {
      if (!this._isFormat())
        return [];
      this.type = r.type ? r.type : "set", this.tag = typeof r == "string" ? r : r.tag, this.tag = this.tag.toLowerCase(), this.tag = this.arrangeTag(this.tag), typeof r == "string" ? this.args = !1 : this.buildArgs(r), this.detector.isIe() || this.editor.disableNonEditables();
      var h = this.selection.isCollapsed() ? this.formatCollapsed() : this.formatUncollapsed();
      return this.detector.isIe() || this.editor.enableNonEditables(), h;
    },
    // private
    _isFormat: function() {
      var r = this.selection.getCurrent(), h = this.inspector.parse(r), u = h.isComponent() && !h.isComponentType("table") && !h.isFigcaption();
      return r === !1 && this.selection.isAll() ? !0 : !(!r || h.isPre() || h.isCode() || u);
    },
    arrangeTag: function(r) {
      var h = this.opts.replaceTags;
      for (var u in h)
        r === u && (r = h[u]);
      return r;
    },
    formatCollapsed: function() {
      var r = [], h = this.selection.getInlineFirst(), u = this.selection.getInlines({ all: !0 }), g = c.dom(h), b, O, x, S;
      if (!h)
        r = this.insertInline(r);
      else {
        var k = this.inspector.parse(h), C = this.utils.isEmptyHtml(h.innerHTML);
        if (C)
          if (h.tagName.toLowerCase() === this.tag)
            if (this.hasSameArgs(h)) {
              this.caret.setAfter(h), g.remove();
              var _ = this.selection.getElement();
              this.utils.normalizeTextNodes(_);
            } else
              this.tag === "span" ? (r = this.applyArgs([h], !1), this.caret.setStart(h)) : r = this.insertInline(r);
          else
            k.hasParent([this.tag]) ? (b = g.closest(this.tag), O = b.get(), this.hasSameArgs(O) ? (b.unwrap(), this.caret.setStart(h)) : r = this.insertInline(r)) : r = this.insertInline(r);
        else if (h.tagName.toLowerCase() === this.tag)
          this.hasSameArgs(h) ? (S = this.utils.extractHtmlFromCaret(h), x = c.dom("<" + this.tag + " />"), x = this.utils.cloneAttributes(h, x), g.after(x.append(S)), x.html().trim() === "" && x.remove(), this.caret.setAfter(h)) : r = this.insertInline(r);
        else if (k.hasParent([this.tag]))
          if (b = g.closest(this.tag), O = b.get(), this.hasSameArgs(O)) {
            S = this.utils.extractHtmlFromCaret(O, O), x = c.dom("<" + this.tag + " />"), x = this.utils.cloneAttributes(O, x);
            var $, L, E = 0;
            u = u.reverse();
            for (var A = 0; A < u.length; A++)
              u[A] !== O && (L = c.dom("<" + u[A].tagName.toLowerCase() + ">"), E === 0 ? $ = L : $.append(L), E++);
            b.after(x.append(S)), b.after($), this.caret.setStart(L);
          } else
            r = this.insertInline(r);
        else
          r = this.insertInline(r);
      }
      return r;
    },
    insertInline: function(r) {
      var h = document.createElement(this.tag);
      return r = this.insertion.insertNode(h, "start"), this.applyArgs(r, !1);
    },
    hasSameArgs: function(r) {
      if (r.attributes.length === 0 && this.args === !1)
        return !0;
      var h = !0;
      if (this.args) {
        var u = 0;
        for (var g in this.args) {
          var b = c.dom(r), O = this.args[g], x = this.utils.toParams(O), S = b.attr(g);
          if (O)
            if (g === "style") {
              x = x.trim().replace(/;$/, "");
              for (var k = this.utils.styleToObj(b.attr("style")), C = x.split(";"), _ = 0, $ = 0; $ < C.length; $++) {
                var L = C[$].split(":"), E = L[0].trim(), A = L[1].trim();
                if (E.search(/color/) !== -1) {
                  var y = b.css(E);
                  y && (y === A || this.utils.rgb2hex(y) === A) && _++;
                } else
                  b.css(E) === A && _++;
              }
              _ === C.length && Object.keys(k).length === C.length && u++;
            } else
              S === x && u++;
          else
            (!S || S === "") && u++;
        }
        h = u === Object.keys(this.args).length;
      }
      return h;
    },
    formatUncollapsed: function() {
      var r = this.selection.getInlines({ all: !0, inside: !0 });
      this.detector.isIe() ? this.selection.saveMarkers() : this.selection.save(), this._convertTags("u"), this._convertTags("del"), this._convertToStrike(r), this.detector.isIe() ? this.selection.restoreMarkers() : this.selection.restore(), document.execCommand("strikethrough"), this._clearDecoration(), this.selection.save();
      var h = this._revertToInlines();
      h = this.applyArgs(h, !1);
      for (var u = 0; u < h.length; u++) {
        var g = h[u], b = g.tagName.toLowerCase(), O = g.attributes.length;
        b === this.tag && O === 0 && this.args && (c.dom(g).unwrap(), h.splice(u, 1));
      }
      return this.selection.restore(), this._clearEmptyStyle(), h = this._normalizeBlocks(h), h;
    },
    _convertTags: function(r) {
      if (this.tag !== r) {
        var h = this.editor.getElement();
        h.find(r).each(
          (function(u) {
            var g = this.utils.replaceToTag(u, "span");
            g.addClass("redactor-convertable-" + r);
          }).bind(this)
        );
      }
    },
    _revertTags: function(r) {
      var h = this.editor.getElement();
      h.find("span.redactor-convertable-" + r).each(
        (function(u) {
          var g = this.utils.replaceToTag(u, r);
          g.removeClass("redactor-convertable-" + r), this.utils.removeEmptyAttr(g, "class") && g.removeAttr("class");
        }).bind(this)
      );
    },
    _convertToStrike: function(r) {
      for (var h = this.selection.getText().replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&"), u = 0; u < r.length; u++) {
        var g = this.arrangeTag(r[u].tagName.toLowerCase()), b = r[u], O = c.dom(b), x = this.hasSameArgs(b);
        if (g === this.tag)
          if (this.tag === "span" && this._isTextSelected(b, h))
            O.addClass("redactor-convertable-apply");
          else if (x && this.tag !== "a")
            this._replaceToStrike(O);
          else if (this.tag === "span") {
            if (this.args && this.args.style)
              for (var S in this.args.style)
                O.css(S, "");
            this.utils.removeEmptyAttr(O.get(), "style") ? O.addClass("redactor-convertable-apply") : O.addClass("redactor-unconvertable-apply");
          } else
            x || O.addClass("redactor-convertable-apply");
      }
    },
    _replaceToStrike: function(r) {
      r.replaceWith(function() {
        return c.dom("<strike>").append(r.contents());
      });
    },
    _revertToInlines: function() {
      var r = [], h = this.editor.getElement();
      return this.tag !== "u" && h.find("u").unwrap(), h.find(".redactor-convertable-u").each(function(u) {
        r.push(u);
      }), h.find(".redactor-convertable-apply").each(
        (function(u) {
          var g = c.dom(u);
          g.find("strike").unwrap(), this._forceRemoveClass(g, "redactor-convertable-apply"), r.push(u);
        }).bind(this)
      ), h.find("span.redactor-unconvertable-apply").each(
        (function(u) {
          var g = c.dom(u);
          this._forceRemoveClass(g, "redactor-unconvertable-apply");
        }).bind(this)
      ), h.find("strike").each(
        (function(u) {
          var g = this.utils.replaceToTag(u, this.tag);
          r.push(g.get());
        }).bind(this)
      ), this._revertTags("u"), this._revertTags("del"), r;
    },
    _normalizeBlocks: function(r) {
      var h = this.opts.inlineTags, u = this.selection.getBlocks();
      if (u) {
        for (var g = 0; g < u.length; g++)
          if (u[g].tagName === "PRE") {
            var b = c.dom(u[g]);
            b.find(h.join(",")).not(".redactor-selection-marker").each(
              (function(O) {
                r.indexOf(O) !== -1 && (r = this.utils.removeFromArrayByValue(r, O)), c.dom(O).unwrap();
              }).bind(this)
            );
          }
      }
      return r;
    },
    _clearDecoration: function() {
      var r = this.editor.getElement();
      r.find(this.opts.inlineTags.join(",")).each(function(h) {
        if (h.style.textDecoration === "line-through" || h.style.textDecorationLine === "line-through") {
          var u = c.dom(h);
          u.css("textDecorationLine", ""), u.css("textDecoration", ""), u.wrap("<strike>");
        }
      });
    },
    _clearEmptyStyle: function() {
      for (var r = this.getInlines(), h = 0; h < r.length; h++) {
        this._clearEmptyStyleAttr(r[h]);
        var u = r[h].childNodes;
        if (u)
          for (var g = 0; g < u.length; g++)
            this._clearEmptyStyleAttr(u[g]);
      }
    },
    _clearEmptyStyleAttr: function(r) {
      r.nodeType !== 3 && this.utils.removeEmptyAttr(r, "style") && (r.removeAttribute("style"), r.removeAttribute("data-redactor-style-cache"));
    },
    _forceRemoveClass: function(r, h) {
      r.removeClass(h), this.utils.removeEmptyAttr(r, "class") && r.removeAttr("class");
    },
    _isTextSelected: function(r, h) {
      var u = this.utils.removeInvisibleChars(r.textContent);
      return h === u || h.search(new RegExp("^" + this.utils.escapeRegExp(u) + "$")) !== -1;
    },
    getInlines: function(r) {
      return r ? this.selection.getInlines({ tags: r, all: !0 }) : this.selection.getInlines({ all: !0 });
    },
    getElements: function(r) {
      return c.dom(this.getInlines(r));
    },
    clearFormat: function() {
      this.selection.save();
      for (var r = this.selection.getInlines({ all: !0 }), h = 0; h < r.length; h++) {
        var u = c.dom(r[h]), g = this.selection.getInline(r[h]);
        g && u.unwrap();
      }
      this.selection.restore();
    }
  }), c.add("service", "autoparser", {
    init: function(r) {
      this.app = r, this.cleaner = this.app.cleaner;
    },
    observe: function() {
      var r = this.editor.getElement(), h = r.find(".redactor-autoparser-object").each(function(u) {
        var g = c.dom(u);
        g.removeClass("redactor-autoparser-object"), g.attr("class") === "" && g.removeAttr("class");
      });
      h.length > 0 && h.each(
        (function(u) {
          var g, b = !1, O = u.tagName;
          O === "A" ? g = "link" : O === "IMG" ? g = "image" : O === "IFRAME" && (g = "video"), g && (b = c.create(g + ".component", this.app, u), this.app.broadcast(g + ".inserted", b), this.app.broadcast("autoparse", g, b));
        }).bind(this)
      );
    },
    format: function(r, h) {
      this._isKey(h) && this._format(h === this.keycodes.ENTER);
    },
    parse: function(r) {
      var h = ["figure", "html", "form", "pre", "object", "video", "iframe", "code", "a", "img"], u = [], g = 0, b = [];
      r = this.cleaner.storeComments(r, b), r = this.cleaner.encodeCode(r), r = r.replace(/\$/g, "&#36;"), r = r.replace(/&amp;/g, "&");
      for (var O = 0; O < h.length; O++) {
        var x = h[O] === "img" ? "<" + h[O] + "[^>]*>" : "<" + h[O] + "([\\w\\W]*?)</" + h[O] + ">", S = r.match(new RegExp(x, "gi"));
        if (S !== null)
          for (var k = 0; k < S.length; k++)
            r = r.replace(S[k], "#####replaceparse" + g + "#####"), u.push(S[k]), g++;
      }
      if (this.opts.autoparseImages && r.match(this.opts.regex.imageurl))
        for (var C = r.match(this.opts.regex.imageurl), O = 0; O < C.length; O++)
          r = r.replace(
            C[O],
            '<img class="redactor-autoparser-object" src="' + C[O] + '">'
          );
      if (this.opts.autoparseVideo && (r.match(this.opts.regex.youtube) || r.match(this.opts.regex.vimeo))) {
        var _ = '<iframe width="500" height="281" src="', $ = '" frameborder="0" allowfullscreen></iframe>', L, E, A = this.opts.autoparseHttps ? "https:" : "";
        r.match(this.opts.regex.youtube) ? (L = A + "//www.youtube.com/embed/$1", E = this.opts.regex.youtube) : r.match(this.opts.regex.vimeo) && (L = A + "//player.vimeo.com/video/$2", E = this.opts.regex.vimeo);
        var y = this.component.create("video", _ + L + $);
        r = r.replace(E, y.get().outerHTML);
      }
      for (var O = 0; O < h.length; O++) {
        var x = h[O] === "img" ? "<" + h[O] + "[^>]*>" : "<" + h[O] + "([\\w\\W]*?)</" + h[O] + ">", S = r.match(new RegExp(x, "gi"));
        if (S !== null)
          for (var k = 0; k < S.length; k++)
            r = r.replace(S[k], "#####replaceparse" + g + "#####"), u.push(S[k]), g++;
      }
      return this.opts.autoparseLinks && r.match(this.opts.regex.url) && (r = this._formatLinks(r)), r = this._restoreReplaced(u, r), r = this._restoreReplaced(u, r), r = this.cleaner.restoreComments(r, b), r;
    },
    // private
    _isKey: function(r) {
      return r === this.keycodes.ENTER || r === this.keycodes.SPACE;
    },
    _format: function(r) {
      var h = this.selection.getParent(), u = c.dom(h), g = h && u.closest("figure, pre, code, img, a, iframe").length !== 0;
      if (!(g || !this.selection.isCollapsed())) {
        var b = this.utils.createInvisibleChar(), O = this.selection.getRange();
        O.insertNode(b);
        var x = this.selection.getCurrent(), S = this.inspector.parse(x), k = c.dom(x);
        if (b.parentNode.removeChild(b), x && x.nodeType === 3) {
          var C = x.textContent, _;
          if (this.opts.autoparseImages && C.match(this._convertToRegExp(this.opts.regex.imageurl))) {
            var $ = S.isList(), L = C.match(this.opts.regex.imageurl), E = $ ? void 0 : "<figure><img></figure>", A = this.component.create("image", E);
            A.setSrc(L[0]), A.addClass("redactor-autoparser-object"), C = C.replace(L[0], A.get().outerHTML), _ = "image";
          } else if (this.opts.autoparseVideo && (C.match(this._convertToRegExp(this.opts.regex.youtube)) || C.match(this._convertToRegExp(this.opts.regex.vimeo)))) {
            var y = '<iframe width="500" height="281" src="', w = '" frameborder="0" allowfullscreen></iframe>', T, P;
            C.match(this.opts.regex.youtube) ? (T = "//www.youtube.com/embed/$1", P = this.opts.regex.youtube) : C.match(this.opts.regex.vimeo) && (T = "//player.vimeo.com/video/$2", P = this.opts.regex.vimeo);
            var R = this.component.create("video", y + T + w);
            R.addClass("redactor-autoparser-object"), C = C.replace(P, R.get().outerHTML), _ = "video";
          } else
            this.opts.autoparseLinks && C.match(this._convertToRegExp(this.opts.regex.url)) && (C = this._formatLinks(C, r), _ = "link");
          if (_) {
            r ? (this.selection.save(), k.replaceWith(C), this.selection.restore()) : k.replaceWith(C);
            var Q = this.editor.getElement(), z = Q.find(".redactor-autoparser-object").removeClass("redactor-autoparser-object");
            if (z = _ === "link" ? c.create("link.component", this.app, z) : z, _ === "link")
              r || this.caret.setAfter(z), this.app.broadcast("link.inserted", z);
            else {
              this.caret.setAfter(z);
              var W = z.clone();
              z.remove(), z = this.insertion.insertHtml(W), z = this.component.build(z);
            }
            this.app.broadcast("autoparse", _, z);
          }
        }
      }
    },
    _formatLinks: function(r) {
      var h = this.opts.pasteLinkTarget !== !1 ? ' target="' + this.opts.pasteLinkTarget + '"' : "", u = "http", g = ' class="redactor-autoparser-object"', b = this;
      return r = r.replace(this.opts.regex.aurl1, function(O) {
        return '<a href="' + O + '"' + h + g + ">" + b._subLinkText(O) + "</a>";
      }), r = r.replace(this.opts.regex.aurl2, function(O, x, S) {
        return x + '<a href="' + u + "://" + S + '"' + h + g + ">" + b._subLinkText(S) + "</a>";
      }), r;
    },
    _subLinkText: function(r) {
      return r = r.length > this.opts.linkSize ? r.substring(0, this.opts.linkSize) + "..." : r, r = r.search("%") === -1 ? decodeURIComponent(r) : r, r;
    },
    _restoreReplaced: function(r, h) {
      for (var u = 0; u < r.length; u++)
        h = h.replace("#####replaceparse" + u + "#####", r[u]);
      return h;
    },
    _convertToRegExp: function(r) {
      return new RegExp(String(r).replace(/^\//, "").replace(/\/ig$/, "").replace(/\/gi$/, "") + "$", "gi");
    }
  }), c.add("service", "storage", {
    init: function(r) {
      this.app = r, this.data = [];
    },
    // public
    observeImages: function() {
      if (this.opts.imageObserve) {
        var r = this.editor.getElement(), h = r.find("[data-image]");
        h.each(this._addImage.bind(this));
      }
    },
    observeFiles: function() {
      var r = this.editor.getElement(), h = r.find("[data-file]");
      h.each(this._addFile.bind(this));
    },
    setStatus: function(r, h) {
      this.data[r].status = h;
    },
    getChanges: function() {
      var r = this.editor.getElement();
      for (var h in this.data) {
        var u = this.data[h], g = r.find("[data-" + u.type + '="' + u.id + '"]');
        this.setStatus(u.id, g.length !== 0);
      }
      return this.data;
    },
    add: function(r, h) {
      var u = c.dom(h), g = u.attr("data-" + r);
      this.data[g] = { type: r, status: !0, node: u.get(), id: u.attr("data-" + r) };
    },
    // private
    _addImage: function(r) {
      this.add("image", r);
    },
    _addFile: function(r) {
      this.add("file", r);
    }
  }), c.add("service", "utils", {
    init: function(r) {
      this.app = r;
    },
    // empty
    isEmpty: function(r) {
      var h = !1;
      return r = c.dom(r).get(), r && (h = r.nodeType === 3 ? r.textContent.trim().replace(/\n/, "") === "" : r.innerHTML === ""), h;
    },
    isEmptyHtml: function(r, h, u) {
      return r = this.removeInvisibleChars(r), r = r.replace(/&nbsp;/gi, ""), r = r.replace(/<\/?br\s?\/?>/g, h ? "br" : ""), r = r.replace(/\s/g, ""), r = r.replace(/^<p>[^\W\w\D\d]*?<\/p>$/i, ""), r = r.replace(/^<div>[^\W\w\D\d]*?<\/div>$/i, ""), u && (r = r.replace(/<ul(.*?[^>])>$/i, "ul"), r = r.replace(/<ol(.*?[^>])>$/i, "ol")), r = r.replace(/<hr(.*?[^>])>$/i, "hr"), r = r.replace(/<iframe(.*?[^>])>$/i, "iframe"), r = r.replace(/<source(.*?[^>])>$/i, "source"), r = r.replace(/<[^\/>][^>]*><\/[^>]+>/gi, ""), r = r.replace(/<[^\/>][^>]*><\/[^>]+>/gi, ""), r = r.trim(), r === "";
    },
    trimSpaces: function(r) {
      return r = this.removeInvisibleChars(r.trim());
    },
    // invisible chars
    createInvisibleChar: function() {
      return document.createTextNode(this.opts.markerChar);
    },
    searchInvisibleChars: function(r) {
      return r.search(/^\uFEFF$/g);
    },
    removeInvisibleChars: function(r) {
      return r.replace(/\uFEFF/g, "");
    },
    trimInvisibleChars: function(r) {
      if (this.selection.isCollapsed()) {
        var h = this.selection.getCurrent(), u = r === "left" ? this.selection.getTextBeforeCaret() : this.selection.getTextAfterCaret(), g = h && h.nodeType === 3 && this.searchInvisibleChars(u) === 0;
        if (g)
          if (r === "left")
            c.dom(h).replaceWith(h.textContent.trim());
          else {
            var b = this.offset.get();
            this.offset.set({ start: b.start + 1, end: b.end + 1 });
          }
      }
    },
    // wrapper
    buildWrapper: function(r) {
      return c.dom("<div>").html(r);
    },
    getWrapperHtml: function(r) {
      var h = r.html();
      return r.remove(), h;
    },
    // fragment
    createTmpContainer: function(r) {
      var h = c.dom("<div>");
      return typeof r == "string" ? h.html(r) : h.append(c.dom(r).clone(!0)), h.get();
    },
    createFragment: function(r) {
      for (var h = this.createTmpContainer(r), u = document.createDocumentFragment(), g, b, O, x = [], S = 0; g = h.firstChild; ) {
        S++;
        var k = u.appendChild(g);
        S === 1 && (b = k), x.push(k), O = k;
      }
      return { frag: u, first: b, last: O, nodes: x };
    },
    isFragment: function(r) {
      return typeof r == "object" && r.frag;
    },
    parseHtml: function(r) {
      var h = this.createTmpContainer(r);
      return { html: h.innerHTML, nodes: h.childNodes };
    },
    splitNode: function(r, h, u, g) {
      h = this.isFragment(h) ? h.frag : h;
      var b;
      g ? b = this.inspector.isInlineTag(r.tagName) ? r : this.selection.getInline(r) : b = this.inspector.isBlockTag(r.tagName) ? r : this.selection.getBlock(r);
      var O = c.dom(b);
      if (!g && this.isEmptyHtml(b.innerHTML, !0))
        return O.after(h), O.remove(), h;
      var x = O.get().tagName.toLowerCase(), S = this.caret.isEnd(b), k = this.caret.isStart(b);
      if (!S && !k) {
        var C = this.extractHtmlFromCaret(g), _ = c.dom("<" + x + " />");
        _ = this.cloneAttributes(b, _), O.after(_.append(C));
      }
      if (k)
        return O.before(h);
      if (u)
        return O.append(h);
      h = O.after(h);
      var $ = O.html();
      return $ = this.removeInvisibleChars($), $ = $.replace(/&nbsp;/gi, ""), $ === "" && O.remove(), h;
    },
    extractHtmlFromCaret: function(r, h) {
      var u = this.selection.getRange();
      if (u && (h = h || (r ? this.selection.getInline() : this.selection.getBlock()), h)) {
        var g = u.cloneRange();
        return g.selectNodeContents(h), g.setStart(u.endContainer, u.endOffset), g.extractContents();
      }
    },
    createMarkup: function(r) {
      var h = document.createElement(this.opts.markup);
      this.opts.breakline && h.setAttribute("data-redactor-tag", "br");
      var u = c.dom(r);
      u.after(h), this.caret.setStart(h);
    },
    createMarkupBefore: function(r) {
      var h = document.createElement(this.opts.markup);
      this.opts.breakline && h.setAttribute("data-redactor-tag", "br");
      var u = c.dom(r);
      u.before(h), this.caret.setEnd(h);
    },
    getNode: function(r) {
      var h = c.dom(r).get(), u = this.editor.getElement().get();
      return typeof r > "u" ? u : h || !1;
    },
    findSiblings: function(r, h) {
      for (r = c.dom(r).get(), h = h === "next" ? "nextSibling" : "previousSibling"; r = r[h]; )
        if (!(r.nodeType === 3 && r.textContent.trim() === "" || r.tagName === "BR"))
          return r;
      return !1;
    },
    getElementsFromHtml: function(r, h, u) {
      var g = document.createElement("div");
      g.innerHTML = r;
      var b = g.querySelectorAll(h), O = function(x, S) {
        if (typeof this.length == "number" && typeof x == "function") {
          var k = [];
          if (typeof this == "object")
            for (var C = 0; C < this.length; C++)
              if (C in this)
                k[C] = x.call(S || this, this[C], C, this);
              else
                return;
          return k;
        }
      };
      return O.call(b, function(x) {
        var S = x.getAttribute("data-redactor-type");
        if (!(u && S && S === u))
          return x.outerHTML;
      });
    },
    // childnodes
    getChildNodes: function(r, h, u) {
      r = r && r.nodeType && r.nodeType === 11 ? r : c.dom(r).get();
      var g = r.childNodes, b = [];
      if (g) {
        for (var O = 0; O < g.length; O++)
          if (!(u === !0 && g[O].nodeType === 3) && !(g[O].nodeType === 3 && this.isEmpty(g[O])) && (b.push(g[O]), h !== !1)) {
            var x = this.getChildNodes(g[O], u);
            x.length > 0 && (b = b.concat(x));
          }
      }
      return b;
    },
    getChildElements: function(r) {
      return this.getChildNodes(r, !0, !0);
    },
    getFirstNode: function(r) {
      return this._getFirst(this.getChildNodes(r, !1));
    },
    getLastNode: function(r) {
      return this._getLast(this.getChildNodes(r, !1));
    },
    getFirstElement: function(r) {
      return this._getFirst(this.getChildNodes(r, !1, !0));
    },
    getLastElement: function(r) {
      return this._getLast(this.getChildNodes(r, !1, !0));
    },
    // replace
    replaceToTag: function(r, h) {
      var u = c.dom(r);
      return u.replaceWith(function(g) {
        var b = c.dom("<" + h + ">").append(c.dom(g).contents());
        if (g.attributes)
          for (var O = g.attributes, x = 0; x < O.length; x++)
            b.attr(O[x].nodeName, O[x].value);
        return b;
      });
    },
    // string
    ucfirst: function(r) {
      return r.charAt(0).toUpperCase() + r.slice(1);
    },
    // array
    removeFromArrayByValue: function(r, h) {
      for (var u = arguments, g = u.length, b; g > 1 && r.length; )
        for (h = u[--g]; (b = r.indexOf(h)) !== -1; )
          r.splice(b, 1);
      return r;
    },
    // attributes
    removeEmptyAttr: function(r, h) {
      var u = c.dom(r);
      return typeof u.attr(h) > "u" || u.attr(h) === null ? !0 : u.attr(h) === "" ? (u.removeAttr(h), !0) : !1;
    },
    cloneAttributes: function(r, h) {
      r = c.dom(r).get(), h = c.dom(h);
      for (var u = r.attributes, g = u.length; g--; ) {
        var b = u[g];
        h.attr(b.name, b.value);
      }
      return h;
    },
    // object
    toParams: function(r) {
      if (typeof r != "object")
        return r;
      var h = Object.keys(r);
      if (!h.length)
        return "";
      for (var u = "", g = 0; g < h.length; g++) {
        var b = h[g];
        u += b + ":" + r[b] + ";";
      }
      return u;
    },
    styleToObj: function(r) {
      var h = {};
      if (r)
        for (var u = r.replace(/;$/, "").split(";"), g = 0; g < u.length; g++) {
          var b = u[g].split(":");
          h[b[0].trim()] = b[1].trim();
        }
      return h;
    },
    checkProperty: function(r) {
      for (var h = arguments[1] && Array.isArray(arguments[1]) ? arguments[1] : [].slice.call(arguments, 1), u = 0; u < h.length; u++) {
        if (!r || typeof r[h[u]] > "u")
          return !1;
        r = r[h[u]];
      }
      return r;
    },
    // data
    extendData: function(r, h) {
      for (var u in h)
        if (u === "elements") {
          var g = c.dom(h[u]);
          g.each(
            (function(b) {
              var O = c.dom(b);
              if (b.tagName === "FORM") {
                var x = O.serialize(!0);
                for (var S in x)
                  r = this._setData(r, S, x[S]);
              } else {
                var k = O.attr("name") ? O.attr("name") : O.attr("id");
                r = this._setData(r, k, O.val());
              }
            }).bind(this)
          );
        } else
          r = this._setData(r, u, h[u]);
      return r;
    },
    _setData: function(r, h, u) {
      return r instanceof FormData ? r.append(h, u) : r[h] = u, r;
    },
    // normalize
    normalizeTextNodes: function(r) {
      r = c.dom(r).get(), r && r.normalize();
    },
    // color
    isRgb: function(r) {
      return r.search(/^rgb/i) === 0;
    },
    rgb2hex: function(r) {
      return r = r.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i), r && r.length === 4 ? "#" + ("0" + parseInt(r[1], 10).toString(16)).slice(-2) + ("0" + parseInt(r[2], 10).toString(16)).slice(-2) + ("0" + parseInt(r[3], 10).toString(16)).slice(-2) : "";
    },
    hex2long: function(r) {
      return r.search(/^#/) !== -1 && r.length === 4 && (r = "#" + r[1] + r[1] + r[2] + r[2] + r[3] + r[3]), r;
    },
    // escape
    escapeRegExp: function(r) {
      return r.replace(/[-\/\\^$*~+?.()|[\]{}]/g, "\\$&");
    },
    // random
    getRandomId: function() {
      for (var r = "", h = "abcdefghijklmnopqrstuvwxyz0123456789", u = 0; u < 12; u++)
        r += h.charAt(Math.floor(Math.random() * h.length));
      return r;
    },
    // private
    _getFirst: function(r) {
      return r.length !== 0 ? r[0] : !1;
    },
    _getLast: function(r) {
      return r.length !== 0 ? r[r.length - 1] : !1;
    }
  }), c.add("service", "progress", {
    init: function(r) {
      this.app = r, this.$box = null, this.$bar = null;
    },
    // public
    show: function() {
      this._is() || this._build(), this.$box.show();
    },
    hide: function() {
      this._is() && this.animate.start(this.$box, "fadeOut", this._destroy.bind(this));
    },
    update: function(r) {
      this.show(), this.$bar.css("width", r + "%");
    },
    // private
    _is: function() {
      return this.$box !== null;
    },
    _build: function() {
      this.$bar = c.dom("<span />"), this.$box = c.dom('<div id="redactor-progress" />'), this.$box.append(this.$bar), this.$body.append(this.$box);
    },
    _destroy: function() {
      this._is() && this.$box.remove(), this.$box = null, this.$bar = null;
    }
  }), c.add("module", "starter", {
    init: function(r) {
      this.app = r, this.opts = r.opts, this.plugin = r.plugin, this.module = r.module;
    },
    // messages
    onstart: function() {
      var r = ["element", "container", "source", "editor", "statusbar", "toolbar"], h = ["element", "container", "source", "editor", "statusbar", "contextbar", "input"];
      this._startStop("start", this.app, r), this._startStop("start", this.module, h);
    },
    onstop: function() {
      var r = ["observer", "element", "container", "source", "editor", "contextbar"];
      this._startStop("stop", this.module, r);
    },
    onenable: function() {
      var r = ["observer", "toolbar"], h = this.opts.plugins;
      this._startStop("start", this.module, r), this._startStop("start", this.plugin, h);
    },
    ondisable: function() {
      var r = ["observer", "toolbar"], h = this.opts.plugins;
      this._startStop("stop", this.module, r), this._startStop("stop", this.plugin, h);
    },
    // private
    _startStop: function(r, h, u) {
      for (var g = 0; g < u.length; g++)
        typeof h[u[g]] < "u" && this.app.callInstanceMethod(h[u[g]], r);
    }
  }), c.add("module", "element", {
    init: function(r) {
      this.app = r, this.uuid = r.uuid, this.opts = r.opts, this.namespace = r.namespace, this.element = r.element, this.rootOpts = c.extend({}, !0, c.options, r.rootOpts);
    },
    // public
    start: function() {
      this._build(), this._buildModes(), this._buildMarkup();
    },
    stop: function() {
      var r = this.element.getElement();
      r.removeData(this.namespace + "-uuid");
    },
    // private
    _build: function() {
      var r = this.element.getElement();
      r.data(this.namespace + "-uuid", this.uuid);
    },
    _buildModes: function() {
      var r = this.element.getType();
      r === "inline" && this._redefineOptions(this.opts.modes.inline), r === "div" && this._redefineOptions(this.opts.modes.original), r !== "inline" && (this._isRootOption("styles") && this.rootOpts.styles && (this.opts.styles = !0), this._isRootOption("source") && !this.rootOpts.source && (this.opts.showSource = !1));
    },
    _buildMarkup: function() {
      var r = this.element.getType();
      r === "inline" ? this.opts.emptyHtml = "" : this.opts.breakline ? (this.opts.markup = "div", this.opts.emptyHtml = '<div data-redactor-tag="br">' + this.opts.markerChar + "</div>") : this.opts.emptyHtml = "<" + this.opts.markup + "></" + this.opts.markup + ">";
    },
    _redefineOptions: function(r) {
      for (var h in r)
        this.opts[h] = r[h];
    },
    _isRootOption: function() {
      return typeof this.rootOpts.styles < "u";
    }
  }), c.add("module", "editor", {
    init: function(r) {
      this.app = r, this.uuid = r.uuid, this.opts = r.opts, this.editor = r.editor, this.source = r.source, this.element = r.element, this.component = r.component, this.container = r.container, this.inspector = r.inspector, this.autoparser = r.autoparser, this.placeholder = !1, this.events = !1;
    },
    // messages
    onenable: function() {
      this.enable();
    },
    ondisable: function() {
      this.disable();
    },
    onenablefocus: function() {
      this._enableFocus();
    },
    oncontextmenu: function(r) {
      this.component.setOnEvent(r, !0);
    },
    onclick: function(r) {
      this.component.setOnEvent(r);
    },
    onkeyup: function(r) {
      var h = this.inspector.parse(r.target);
      h.isComponent() || this.component.clearActive();
    },
    onenablereadonly: function() {
      this._enableReadOnly();
    },
    ondisablereadonly: function() {
      this._disableReadOnly();
    },
    onautoparseobserve: function() {
      this.autoparser.observe();
    },
    onplaceholder: {
      build: function() {
        this._buildPlaceholder();
      },
      toggle: function() {
        this._togglePlacehodler();
      }
    },
    // public
    start: function() {
      this._build(), this._buildEvents(), this._buildOptions(), this._buildAccesibility();
    },
    stop: function() {
      var r = this.editor.getElement(), h = this.container.getElement(), u = [
        "redactor-in",
        "redactor-in-" + this.uuid,
        "redactor-structure",
        "redactor-placeholder",
        "notranslate"
      ];
      this.opts.stylesClass !== "" && u.push(this.opts.stylesClass);
      var g = [
        "redactor-focus",
        "redactor-blur",
        "redactor-over",
        "redactor-styles-on",
        "redactor-styles-off",
        "redactor-toolbar-on",
        "redactor-text-labeled-on",
        "redactor-source-view"
      ];
      r.removeAttr("spellcheck"), r.removeAttr("dir"), r.removeAttr("contenteditable"), r.removeAttr("placeholder"), r.removeAttr("data-gramm_editor"), r.removeClass(u.join(" ")), h.removeClass(g.join(" ")), this._destroyEvents(), r.get().classList.length === 0 && r.removeAttr("class");
    },
    enable: function() {
      var r = this.editor.getElement(), h = this.container.getElement();
      r.addClass("redactor-in redactor-in-" + this.uuid), r.attr({ contenteditable: !0 }), this.opts.structure && r.addClass("redactor-structure"), this.opts.toolbar && !this.opts.air && !this.opts.toolbarExternal && h.addClass("redactor-toolbar-on"), this._disableBrowsersEditing();
    },
    disable: function() {
      var r = this.editor.getElement(), h = this.container.getElement();
      r.removeClass("redactor-in redactor-in-" + this.uuid), r.removeClass("redactor-structure"), r.removeAttr("contenteditable"), h.addClass("redactor-toolbar-on");
    },
    // private
    _build: function() {
      var r = this.editor.getElement(), h = this.element.getElement(), u = this.container.getElement();
      u.addClass("redactor-blur"), this.opts.grammarly || r.attr("data-gramm_editor", !1), this.opts.notranslate && r.addClass("notranslate"), this.opts.styles ? (r.addClass(this.opts.stylesClass), u.addClass("redactor-styles-on")) : u.addClass("redactor-styles-off"), this.opts.buttonsTextLabeled && u.addClass("redactor-text-labeled-on"), this.element.isType("textarea") && h.before(r);
    },
    _buildEvents: function() {
      this.events = c.create("editor.events", this.app);
    },
    _buildOptions: function() {
      var r = this.editor.getElement();
      r.attr("dir", this.opts.direction), this.opts.spellcheck || r.attr("spellcheck", !1), this.opts.tabindex && r.attr("tabindex", this.opts.tabindex), this.opts.minHeight && r.css("min-height", this.opts.minHeight), this.opts.maxHeight && r.css("max-height", this.opts.maxHeight), this.opts.maxWidth && r.css({ "max-width": this.opts.maxWidth, margin: "auto" });
    },
    _buildAccesibility: function() {
      var r = this.editor.getElement();
      r.attr({ "aria-labelledby": "redactor-voice-" + this.uuid, role: "presentation" });
    },
    _buildPlaceholder: function() {
      this.placeholder = c.create("editor.placeholder", this.app);
    },
    _enableFocus: function() {
      this.opts.showSource ? this._enableFocusSource() : this._enableFocusEditor();
    },
    _enableFocusSource: function() {
      var r = this.source.getElement();
      this.opts.focus ? (r.focus(), r.get().setSelectionRange(0, 0)) : this.opts.focusEnd && r.focus();
    },
    _enableFocusEditor: function() {
      this.opts.focus ? setTimeout(this.editor.startFocus.bind(this.editor), 100) : this.opts.focusEnd && setTimeout(this.editor.endFocus.bind(this.editor), 100);
    },
    _togglePlacehodler: function() {
      this.placeholder && this.placeholder.toggle();
    },
    _disableBrowsersEditing: function() {
      try {
        document.execCommand("enableObjectResizing", !1, !1), document.execCommand("enableInlineTableEditing", !1, !1), document.execCommand("AutoUrlDetect", !1, !1);
        var r = this.editor.getElement(), h = r.get();
        h.addEventListener ? h.addEventListener("mscontrolselect", function(u) {
          u.preventDefault();
        }) : h.attachEvent("oncontrolselect", function(u) {
          u.returnValue = !1;
        });
      } catch {
      }
    },
    _destroyEvents: function() {
      this.events && this.events.destroy();
    },
    _enableReadOnly: function() {
      var r = this.editor.getElement();
      this._getEditables(r).removeAttr("contenteditable"), r.removeAttr("contenteditable"), r.addClass("redactor-read-only"), this.events && this.events.destroy();
    },
    _disableReadOnly: function() {
      var r = this.editor.getElement();
      this._getEditables(r).attr({ contenteditable: !0 }), r.removeClass("redactor-read-only"), r.attr({ contenteditable: !0 }), this._buildEvents();
    },
    _getEditables: function(r) {
      return r.find("figcaption, td, th");
    }
  }), c.add("class", "editor.placeholder", {
    init: function(r) {
      this.app = r, this.opts = r.opts, this.editor = r.editor, this.element = r.element, this.build();
    },
    build: function() {
      var r = this.element.getElement(), h = this.editor.getElement();
      if (this.opts.placeholder !== !1 || r.attr("placeholder")) {
        var u = this.opts.placeholder !== !1 ? this.opts.placeholder : r.attr("placeholder");
        h.attr("placeholder", u), this.toggle();
      }
    },
    toggle: function() {
      return this.editor.isEmpty(!0) ? this.show() : this.hide();
    },
    show: function() {
      var r = this.editor.getElement();
      r.addClass("redactor-placeholder");
    },
    hide: function() {
      var r = this.editor.getElement();
      r.removeClass("redactor-placeholder");
    }
  }), c.add("class", "editor.events", {
    init: function(r) {
      this.app = r, this.opts = r.opts, this.$doc = r.$doc, this.uuid = r.uuid, this.source = r.source, this.editor = r.editor, this.cleaner = r.cleaner, this.container = r.container, this.insertion = r.insertion, this.inspector = r.inspector, this.selection = r.selection, this.component = r.component, this.blurNamespace = ".redactor-blur." + this.uuid, this.eventsList = [
        "paste",
        "click",
        "contextmenu",
        "keydown",
        "keyup",
        "mouseup",
        "touchstart",
        "cut",
        "copy",
        "dragenter",
        "dragstart",
        "drop",
        "dragover",
        "dragleave"
      ], this._init();
    },
    destroy: function() {
      var r = this.editor.getElement();
      r.off(".redactor-focus"), this.$doc.off("keyup" + this.blurNamespace + " mousedown" + this.blurNamespace), this._loop("off");
    },
    focus: function(r) {
      var h = this.container.getElement();
      this.editor.isPasting() || h.hasClass("redactor-focus") || (h.addClass("redactor-focus"), h.removeClass("redactor-blur"), this.app.broadcast("observe", r), this.app.broadcast("focus", r), this.isFocused = !0, this.isBlured = !1);
    },
    blur: function(r) {
      var h = this.container.getElement(), u = c.dom(r.target), g = [
        ".redactor-in-" + this.uuid,
        ".redactor-toolbar",
        ".redactor-dropdown",
        ".redactor-context-toolbar",
        ".redactor-modal-box",
        "#redactor-image-resizer"
      ];
      this.app.broadcast("originalblur", r), !this.app.stopBlur && (!this.app.isStarted() || this.editor.isPasting() || u.closest(g.join(",")).length === 0 && !this.isBlured && !h.hasClass("redactor-blur") && (h.removeClass("redactor-focus"), h.addClass("redactor-blur"), this.app.broadcast("blur", r), this.isFocused = !1, this.isBlured = !0));
    },
    cut: function(r) {
      var h = this.selection.getCurrent(), u = this.inspector.parse(h);
      this.app.broadcast("state", r), this.component.isNonEditable(h) && (this._passSelectionToClipboard(r, u, !0), r.preventDefault());
    },
    copy: function(r) {
      var h = this.selection.getCurrent(), u = this.inspector.parse(h);
      this.app.broadcast("state", r), this.component.isNonEditable(h) && (this._passSelectionToClipboard(r, u, !1), r.preventDefault());
    },
    drop: function(r) {
      if (r = r.originalEvent || r, r.stopPropagation(), this._removeOverClass(), this.opts.dragUpload === !1) {
        r.preventDefault();
        return;
      }
      if (this.app.isDragComponentInside()) {
        var h = c.dom(this.app.getDragComponentInside()), u = h.clone(!0);
        this.insertion.insertToPoint(r, u), h.remove(), this.app.setDragComponentInside(!1), this.app.broadcast("state", r), this.app.broadcast("drop", r), this.app.broadcast("image.observe", r), r.preventDefault();
        return;
      } else if (this.app.isDragInside() && this.opts.input) {
        this.insertion.insertPoint(r);
        var g = r.dataTransfer, b = g.getData("text/html"), O = this.selection.getRange();
        if (O) {
          var x = this.selection.getBlocks();
          O.deleteContents();
          for (var S = 0; S < x.length; S++)
            x[S].innerHTML === "" && c.dom(x[S]).remove();
        }
        c.create("input.paste", this.app, r, !0, b, !0), this.app.broadcast("state", r), this.app.broadcast("drop", r), this.app.setDragInside(!1), r.preventDefault();
        return;
      }
      this.app.broadcast("state", r), this.app.broadcast("paste", r, r.dataTransfer), this.app.broadcast("drop", r);
    },
    dragenter: function(r) {
      r.preventDefault();
    },
    dragstart: function(r) {
      this.app.setDragComponentInside(!1), this.app.setDragInside(!1);
      var h = this.inspector.parse(r.target);
      h.isComponent() && !h.isComponentEditable() && !h.isFigcaption() ? this.app.setDragComponentInside(h.getComponent()) : this.selection.is() && !this.selection.isCollapsed() && (this.app.setDragInside(!0), this._setDragData(r)), this.app.broadcast("dragstart", r);
    },
    dragover: function(r) {
      this.app.broadcast("dragover", r);
    },
    dragleave: function(r) {
      this.app.broadcast("dragleave", r);
    },
    paste: function(r) {
      this.app.broadcast("paste", r);
    },
    contextmenu: function(r) {
    },
    click: function(r) {
      if (r.detail === 3) {
        r.preventDefault();
        var h = this.selection.getBlock();
        if (h) {
          var u = document.createRange();
          u.selectNodeContents(h), this.selection.setRange(u);
        }
      }
      var g = c.dom(r.target);
      if (g.hasClass("redactor-in")) {
        var b = g.offset().top, O = parseFloat(g.css("padding-bottom")), x = g.height(), S = b + x - O * 2;
        S < r.pageY ? this.app.broadcast("bottomclick", r) : g.hasClass("redactor-placeholder") && this.editor.startFocus(this.editor);
      }
      this.app.broadcast("state", r), this.app.broadcast("click", r);
    },
    keydown: function(r) {
      this.app.broadcast("state", r);
      var h = this.app.broadcast("keydown", r);
      if (h === !1)
        return r.preventDefault();
    },
    keyup: function(r) {
      this.app.broadcast("keyup", r);
    },
    mouseup: function(r) {
      this.app.broadcast("observe", r), this.app.broadcast("state", r);
    },
    touchstart: function(r) {
      this.app.broadcast("observe", r), this.app.broadcast("state", r);
    },
    // private
    _init: function() {
      var r = this.editor.getElement();
      r.on("focus.redactor-focus click.redactor-focus", this.focus.bind(this)), this.$doc.on("keyup" + this.blurNamespace + " mousedown" + this.blurNamespace, this.blur.bind(this)), this._loop("on");
    },
    _removeOverClass: function() {
      var r = this.editor.getElement();
      r.removeClass("over");
    },
    _loop: function(r) {
      for (var h = this.editor.getElement(), u = 0; u < this.eventsList.length; u++) {
        var g = this.eventsList[u] + ".redactor-events", b = this.eventsList[u];
        h[r](g, this[b].bind(this));
      }
    },
    _passAllToClipboard: function(r) {
      var h = r.clipboardData, u = this.source.getCode();
      h.setData("text/html", u), h.setData("text/plain", u.toString().replace(/\n$/, ""));
    },
    _passSelectionToClipboard: function(r, h, u) {
      var g = r.clipboardData, b = h.getComponent(), O = c.dom(b), x = O.clone();
      x.find(".redactor-component-caret").remove(), x.removeClass("redactor-component-active"), x.removeAttr("contenteditable"), x.removeAttr("tabindex");
      var S = x.get().outerHTML;
      u && this.component.remove(b), g.setData("text/html", S), g.setData("text/plain", S.toString().replace(/\n$/, ""));
    },
    _setDragData: function(r) {
      r = r.originalEvent || r;
      var h = r.dataTransfer;
      h.effectAllowed = "move", h.setData("text/Html", this.selection.getHtml());
    }
  }), c.add("module", "container", {
    init: function(r) {
      this.app = r, this.uuid = r.uuid, this.opts = r.opts, this.lang = r.lang, this.element = r.element, this.container = r.container;
    },
    // public
    start: function() {
      this._build(), this._buildAccesibility();
    },
    stop: function() {
      var r = this.element.getElement(), h = this.container.getElement();
      h.after(r), h.remove(), r.show();
    },
    // private
    _build: function() {
      var r = this.element.getElement(), h = this.container.getElement();
      h.addClass("redactor-box"), h.attr("dir", this.opts.direction), this.element.isType("inline") && h.addClass("redactor-inline"), r.after(h), h.append(r);
    },
    _buildAccesibility: function() {
      var r = this.container.getElement(), h = c.dom("<span />");
      h.addClass("redactor-voice-label"), h.attr({ id: "redactor-voice-" + this.uuid, "aria-hidden": !1 }), h.html(this.lang.get("accessibility-help-label")), r.prepend(h);
    }
  }), c.add("module", "source", {
    init: function(r) {
      this.app = r, this.uuid = r.uuid, this.opts = r.opts, this.utils = r.utils, this.element = r.element, this.source = r.source, this.editor = r.editor, this.toolbar = r.toolbar, this.cleaner = r.cleaner, this.component = r.component, this.container = r.container, this.autoparser = r.autoparser, this.selection = r.selection, this.syncedHtml = "";
    },
    // messages
    onstartcode: function() {
      var r = this.source.getStartedContent(), h = this.editor.getElement(), u = this.source.getElement();
      this.opts.autoparse && this.opts.autoparseStart && (r = this.autoparser.parse(r));
      var g = this.cleaner.input(r, !0, !0), b = this.cleaner.output(g);
      h.html(g), u.val(b), this.syncedHtml = b, this.app.broadcast("placeholder.build"), this.app.broadcast("autoparseobserve"), this.component.executeScripts();
    },
    onstartcodeshow: function() {
      this.show();
    },
    ontrytosync: function() {
      this.sync();
    },
    onhardsync: function() {
      var r = this.editor.getElement(), h = r.html();
      h = this.app.broadcast("syncBefore", h), h = this.cleaner.output(h), this._syncing(h);
    },
    // public
    start: function() {
      this._build(), this._buildClasses();
    },
    stop: function() {
      var r = this.element.getElement(), h = this.source.getElement();
      r.removeClass("redactor-source redactor-source-open"), h.off("input.redactor-source"), h.removeAttr("data-gramm_editor"), h.get().classList.length === 0 && h.removeAttr("class"), this.source.isNameGenerated() || r.removeAttr("name"), this.element.isType("textarea") || h.remove();
    },
    getCode: function() {
      return this.source.getCode();
    },
    // public
    toggle: function() {
      if (this.opts.source) {
        var r = this.source.getElement();
        return r.hasClass("redactor-source-open") ? this.hide() : this.show();
      }
    },
    show: function() {
      if (this.opts.source) {
        var r = this.editor.getElement(), h = this.source.getElement(), u = this.container.getElement(), g = h.val();
        this.app.isStarted() && (g = this.app.broadcast("source.open", g));
        var b = r.height();
        if (r.hide(), h.height(b), h.val(g.trim()), h.show(), h.addClass("redactor-source-open"), h.on("input.redactor-source-events", this._onChangedSource.bind(this)), h.on("keydown.redactor-source-events", this._onTabKey.bind(this)), h.on("focus.redactor-source-events", this._onFocus.bind(this)), this.opts.source.hasOwnProperty("codemirror")) {
          var O = typeof this.opts.source.codemirror == "object" ? this.opts.source.codemirror : {}, x = typeof this.opts.source.codemirrorSrc < "u" ? this.opts.source.codemirrorSrc : Cb;
          this.codemirror = x.fromTextArea(h.get(), O), this.codemirror.setSize(null, b), this.codemirror.on("change", function(S, k) {
            S.save();
          }), this.codemirror.on("change", this._onChangedSource.bind(this));
        } else
          u.addClass("redactor-source-view");
        setTimeout(
          (function() {
            this._disableButtons(), this._setActiveSourceButton();
          }).bind(this),
          100
        ), this.app.isStarted() && this.app.broadcast("source.opened");
      }
    },
    hide: function() {
      if (this.opts.source) {
        var r = this.editor.getElement(), h = this.source.getElement(), u = this.container.getElement(), g = h.val();
        this.opts.source.hasOwnProperty("codemirror") && (g = this.codemirror.getValue(), this.codemirror.toTextArea()), g = this.cleaner.input(g, !0), g = this.utils.isEmptyHtml(g) ? this.opts.emptyHtml : g, g = this.app.broadcast("source.close", g), this._enableButtons(), this._setInactiveSourceButton(), h.hide(), h.removeClass("redactor-source-open"), h.off(".redactor-source-events"), r.show(), r.html(g), u.removeClass("redactor-source-view"), setTimeout(
          (function() {
            this.editor.startFocus(), this.component.executeScripts();
          }).bind(this),
          0
        ), this.app.broadcast("source.closed");
      }
    },
    sync: function() {
      var r = this, h = this.editor.getElement(), u = h.html();
      u = this.app.broadcast("syncBefore", u), u = this.cleaner.output(u), this._isSync(u) && (this.timeout && clearTimeout(this.timeout), this.timeout = setTimeout(function() {
        r._syncing(u);
      }, 200));
    },
    // private
    _build: function() {
      var r = this.source.getElement(), h = this.element.getElement();
      r.hide(), this.opts.grammarly || r.attr("data-gramm_editor", !1), this.element.isType("textarea") || h.after(r);
    },
    _buildClasses: function() {
      var r = this.source.getElement();
      r.addClass("redactor-source");
    },
    _syncing: function(r) {
      r = this.app.broadcast("syncing", r);
      var h = this.source.getElement();
      h.val(r), this.app.broadcast("synced", r), this.app.broadcast("changed", r);
    },
    _isSync: function(r) {
      return this.syncedHtml !== r ? (this.syncedHtml = r, !0) : !1;
    },
    _onChangedSource: function() {
      var r = this.source.getElement(), h = r.val();
      this.app.broadcast("changed", h), this.app.broadcast("source.changed", h);
    },
    _onTabKey: function(r) {
      if (r.keyCode !== 9)
        return !0;
      r.preventDefault();
      var h = this.source.getElement(), u = h.get(), g = u.selectionStart;
      h.val(h.val().substring(0, g) + "    " + h.val().substring(u.selectionEnd)), u.selectionStart = u.selectionEnd = g + 4;
    },
    _onFocus: function() {
      this.app.broadcast("sourcefocus");
    },
    _disableButtons: function() {
      this.toolbar.disableButtons();
    },
    _enableButtons: function() {
      this.toolbar.enableButtons();
    },
    _setActiveSourceButton: function() {
      var r = this.toolbar.getButton("html");
      r.enable(), r.setActive();
    },
    _setInactiveSourceButton: function() {
      var r = this.toolbar.getButton("html");
      r.setInactive();
    }
  }), c.add("module", "observer", {
    init: function(r) {
      this.app = r, this.editor = r.editor, this.observerUnit = !1;
    },
    // public
    start: function() {
      if (window.MutationObserver) {
        var r = this.editor.getElement(), h = r.get();
        this.observerUnit = this._build(h), this.observerUnit.observe(h, {
          attributes: !0,
          subtree: !0,
          childList: !0,
          characterData: !0,
          characterDataOldValue: !0
        });
      }
    },
    stop: function() {
      this.observerUnit && this.observerUnit.disconnect();
    },
    // private
    _build: function(r) {
      var h = this;
      return new MutationObserver(function(u) {
        h._observe(u[u.length - 1], r);
      });
    },
    _observe: function(r, h) {
      this.app.isReadOnly() || r.type === "attributes" && r.target === h || (this.app.broadcast("observe"), this.app.broadcast("trytosync"), this.app.broadcast("placeholder.toggle"));
    }
  }), c.add("module", "clicktoedit", {
    init: function(r) {
      this.app = r, this.opts = r.opts, this.source = r.source, this.editor = r.editor, this.container = r.container, this.selection = r.selection;
    },
    // messages
    onstartclicktoedit: function() {
      this.start();
    },
    onenablereadonly: function() {
      this.opts.clickToEdit && (this._isEnabled() || this.stop());
    },
    ondisablereadonly: function() {
      this.opts.clickToEdit && (this._isEnabled() || this.start());
    },
    onstop: function() {
      this.stop();
    },
    // public
    start: function() {
      this._build();
    },
    stop: function() {
      this.buttonSave && this.buttonSave.stop(), this.buttonCancel && this.buttonCancel.stop(), this._destroy(), this.app.broadcast("disable");
    },
    enable: function() {
      this.app.broadcast("clickStart");
      var r = this.editor.isEmpty();
      r || this.selection.saveMarkers(), this._setFocus(), this._destroy(), this.app.broadcast("enable"), this.buttonSave.enable(), this.buttonCancel.enable(), r || this.selection.restoreMarkers(), r && this.editor.focus();
      var h = this.container.getElement();
      h.addClass("redactor-clicktoedit-enabled"), this.source.rebuildStartedContent(), this.app.broadcast("startcode"), this.app.broadcast("image.observe");
    },
    save: function(r) {
      r && r.preventDefault();
      var h = this.source.getCode();
      this.app.broadcast("disable"), this.app.broadcast("clickSave", h), this.app.broadcast("clickStop"), this.app.broadcast("toolbar.removeexternal"), this._build();
    },
    cancel: function(r) {
      r && r.preventDefault();
      var h = this.saved, u = this.editor.getElement();
      u.html(h), this.saved = "", this.app.broadcast("disable"), this.app.broadcast("clickCancel", h), this.app.broadcast("clickStop"), this.app.broadcast("toolbar.removeexternal"), this._build();
    },
    // private
    _build: function() {
      this.buttonSave = c.create("clicktoedit.button", "save", this.app, this), this.buttonCancel = c.create("clicktoedit.button", "cancel", this.app, this), this.buttonSave.stop(), this.buttonCancel.stop();
      var r = this.editor.getElement(), h = this.container.getElement();
      r.on("click.redactor-click-to-edit mouseup.redactor-click-to-edit", this.enable.bind(this)), h.addClass("redactor-over"), h.removeClass("redactor-clicktoedit-enabled");
    },
    _isEnabled: function() {
      return this.container.getElement().hasClass("redactor-clicktoedit-enabled");
    },
    _destroy: function() {
      var r = this.editor.getElement(), h = this.container.getElement();
      r.off(".redactor-click-to-edit"), h.removeClass("redactor-over redactor-clicktoedit-enabled");
    },
    _setFocus: function() {
      this.saved = this.source.getCode(), this.buttonSave.start(), this.buttonCancel.start();
    }
  }), c.add("class", "clicktoedit.button", {
    init: function(r, h, u) {
      this.app = h, this.opts = h.opts, this.toolbar = h.toolbar, this.context = u, this.type = r, this.name = r === "save" ? "clickToSave" : "clickToCancel", this.objected = !1, this.enabled = !1, this.namespace = ".redactor-click-to-edit", this._build();
    },
    enable: function() {
      if (this.objected) {
        var r = this.opts[this.name];
        r.api = "module.clicktoedit." + this.type, this.toolbar.addButton(this.type, r), this.enabled = !0;
      }
    },
    start: function() {
      this.objected || (this.$button.off(this.namespace), this.$button.show(), this.$button.on("click" + this.namespace, this.context[this.type].bind(this.context)));
    },
    stop: function() {
      this.objected || !this.enabled || this.$button.hide();
    },
    // private
    _build: function() {
      this.objected = typeof this.opts[this.name] == "object", this.objected || (this.$button = c.dom(this.opts[this.name]), this.enabled = !0);
    }
  }), c.add("module", "statusbar", {
    init: function(r) {
      this.app = r, this.opts = r.opts, this.element = r.element, this.statusbar = r.statusbar, this.container = r.container;
    },
    // public
    start: function() {
      if (!this.element.isType("inline")) {
        var r = this.statusbar.getElement(), h = this.container.getElement();
        r.addClass("redactor-statusbar"), h.append(r);
      }
    }
  }), c.add("module", "contextbar", {
    init: function(r) {
      this.app = r, this.opts = r.opts, this.uuid = r.uuid, this.$win = r.$win, this.$doc = r.$doc, this.$body = r.$body, this.editor = r.editor, this.toolbar = r.toolbar, this.detector = r.detector, this.$target = this.toolbar.isTarget() ? this.toolbar.getTargetElement() : this.$body;
    },
    // messages
    onstop: function() {
      this.stop();
    },
    onenablereadonly: function() {
      this.stop();
    },
    ondisablereadonly: function() {
      this.start();
    },
    oncontextbar: {
      close: function() {
        this.close();
      }
    },
    // public
    start: function() {
      if (this.opts.toolbarContext) {
        var r = this.editor.getElement();
        this._build(), r.on("click.redactor-context mouseup.redactor-context", this.open.bind(this)), this.opts.scrollTarget ? c.dom(this.opts.scrollTarget).on("scroll.redactor-context", this.close.bind(this)) : this.opts.maxHeight !== !1 && r.on("scroll.redactor-context", this.close.bind(this));
      }
    },
    stop: function() {
      var r = this.editor.getElement();
      r.off(".redactor-context"), this.$doc.off(".redactor-context"), this.$win.off(".redactor-context"), this.$contextbar && this.$contextbar.remove(), this.opts.scrollTarget && c.dom(this.opts.scrollTarget).off(".redactor-context");
    },
    is: function() {
      return this.$contextbar && this.$contextbar.hasClass("open");
    },
    set: function(r, h, u, g) {
      this.$contextbar.html(""), this.$el = c.dom(h);
      for (var b in u) {
        var O = c.create("contextbar.button", this.app, u[b]);
        O.html() !== "" && this.$contextbar.append(O);
      }
      var x = this._buildPosition(r, this.$el, g);
      this.$contextbar.css(x), this.$contextbar.show(), this.$contextbar.addClass("open"), this.$doc.on("click.redactor-context mouseup.redactor-context", this.close.bind(this)), this.$win.on("resize.redactor-context", this.close.bind(this));
    },
    open: function(r) {
      setTimeout(
        (function() {
          this.app.broadcast("contextbar", r, this);
        }).bind(this),
        0
      );
    },
    close: function(r) {
      if (this.$contextbar) {
        if (r) {
          var h = c.dom(r.target);
          if (this.$el && h.closest(this.$el).length !== 0)
            return;
        }
        this.$contextbar.hide(), this.$contextbar.removeClass("open"), this.$doc.off(".redactor.context");
      }
    },
    // private
    _build: function() {
      this.$contextbar = c.dom("<div>"), this.$contextbar.attr("id", "redactor-context-toolbar-" + this.uuid), this.$contextbar.attr("dir", this.opts.direction), this.$contextbar.addClass("redactor-context-toolbar"), this.$contextbar.hide(), this.$target.append(this.$contextbar);
    },
    _buildPosition: function(r, h, u) {
      var g, b, O = this.toolbar.isTarget(), x = O ? h.position() : h.offset(), S = h.width(), k = h.height(), C = this.$contextbar.width(), _ = this.$contextbar.height(), $ = O ? this.$target.scrollTop() + this.$doc.scrollTop() : this.$doc.scrollTop(), L = this.$target.offset(), E = O ? L.left : 0, A = O ? L.top : 0;
      return u ? u === "top" ? (g = x.top - _, b = x.left + S / 2 - C / 2) : u === "bottom" && (g = x.top + k, b = x.left + S / 2 - C / 2) : (g = r.clientY + $ - _, b = r.clientX - C / 2), b < 0 && (b = 0), { top: g - A + "px", left: b - E + "px" };
    }
  }), c.add("class", "contextbar.button", {
    mixins: ["dom"],
    init: function(r, h) {
      this.app = r, this.obj = h, this._init();
    },
    // private
    _init: function() {
      if (this.parse("<a>"), typeof this.obj.title != "string") {
        var r = this.obj.title.attr("href");
        this.attr("href", r), r.search(/^#/) === -1 && this.attr("target", "_blank"), this.text(this.obj.html || r);
      } else
        this.attr("href", "#"), this._buildTitle(), this._buildMessage();
    },
    _buildTitle: function() {
      this.html(this.obj.title);
    },
    _buildMessage: function() {
      (typeof this.obj.message < "u" || typeof this.obj.api < "u") && this.on("click", this._toggle.bind(this));
    },
    _toggle: function(r) {
      r.preventDefault(), this.obj.message ? this.app.broadcast(this.obj.message, this.obj.args) : this.obj.api && this.app.api(this.obj.api, this.obj.args);
    }
  }), c.add("module", "toolbar", {
    init: function(r) {
      this.app = r, this.uuid = r.uuid, this.opts = r.opts, this.utils = r.utils, this.toolbar = r.toolbar, this.detector = r.detector, this.buttons = [], this.toolbarModule = !1;
    },
    // messages
    onsource: {
      open: function() {
        !this.toolbar.isAir() && this.toolbar.isFixed() && this.toolbarModule.resetPosition();
      },
      opened: function() {
        this.toolbar.isAir() && this.toolbarModule && this.toolbarModule.createSourceHelper(), setTimeout(
          (function() {
            c.dom(".re-button-tooltip-" + this.uuid).remove();
          }).bind(this),
          100
        );
      },
      close: function() {
        this.toolbar.isAir() && this.toolbarModule && this.toolbarModule.destroySourceHelper();
      },
      closed: function() {
        this.toolbar.is() && this.opts.air && this.toolbarModule.openSelected();
      }
    },
    ontoolbar: {
      removeexternal: function() {
        !this.opts.air && this.opts.toolbarExternal && this.opts.clickToEdit && c.dom(this.opts.toolbarExternal).html("");
      }
    },
    onobserve: function() {
      this.toolbar.is() && this.toolbar.observe();
    },
    onfocus: function() {
      this._setExternalOnFocus();
    },
    onsourcefocus: function() {
      this._setExternalOnFocus();
    },
    onempty: function() {
      this.toolbar.isFixed() && this.toolbarModule.resetPosition();
    },
    onenablereadonly: function() {
      this.toolbar.isAir() && this.toolbarModule.close();
    },
    // public
    start: function() {
      this.toolbar.is() && (this._buildButtons(), this._initToolbar(), this._initButtons());
    },
    stop: function() {
      this.toolbarModule && this.toolbarModule.stop(), c.dom(".re-button-tooltip-" + this.uuid).remove(), c.dom(".redactor-dropdown-" + this.uuid).remove();
    },
    // private
    _buildButtons: function() {
      this.buttons = this.opts.buttons.concat(), this._buildImageButton(), this._buildFileButton(), this._buildSourceButton(), this._buildAdditionalButtons(), this._buildHiddenButtons();
    },
    _buildImageButton: function() {
      !this.opts.imageUpload && !this.opts.imageManagerJson && this.utils.removeFromArrayByValue(this.buttons, "image");
    },
    _buildFileButton: function() {
      this.opts.fileUpload || this.utils.removeFromArrayByValue(this.buttons, "file");
    },
    _buildSourceButton: function() {
      this.opts.source || this.utils.removeFromArrayByValue(this.buttons, "html");
    },
    _buildAdditionalButtons: function() {
      this.opts.buttonsAdd.length !== 0 && (this.opts.buttonsAdd = this._removeExistButtons(this.opts.buttonsAdd), this.buttons = this.buttons.concat(this.opts.buttonsAdd)), this.opts.buttonsAddFirst.length !== 0 && (this.opts.buttonsAddFirst = this._removeExistButtons(this.opts.buttonsAddFirst), this.buttons.unshift(this.opts.buttonsAddFirst));
      var r, h;
      if (this.opts.buttonsAddAfter !== !1) {
        r = this.buttons.indexOf(this.opts.buttonsAddAfter.after) + 1, h = this.opts.buttonsAddAfter.buttons;
        for (var u = 0; u < h.length; u++)
          this.buttons.splice(r + u, 0, h[u]);
      }
      if (this.opts.buttonsAddBefore !== !1) {
        r = this.buttons.indexOf(this.opts.buttonsAddBefore.before) + 1, h = this.opts.buttonsAddBefore.buttons;
        for (var u = 0; u < h.length; u++)
          this.buttons.splice(r - (1 - u), 0, h[u]);
      }
    },
    _buildHiddenButtons: function() {
      if (this.opts.buttonsHide.length !== 0)
        for (var r = this.opts.buttonsHide, h = 0; h < r.length; h++)
          this.utils.removeFromArrayByValue(this.buttons, r[h]);
      if (this.detector.isMobile() && this.opts.buttonsHideOnMobile.length !== 0)
        for (var r = this.opts.buttonsHideOnMobile, h = 0; h < r.length; h++)
          this.utils.removeFromArrayByValue(this.buttons, r[h]);
    },
    _removeExistButtons: function(r) {
      for (var h = 0; h < r.length; h++)
        this.opts.buttons.indexOf(r[h]) !== -1 && this.utils.removeFromArrayByValue(r, r[h]);
      return r;
    },
    _setExternalOnFocus: function() {
      !this.opts.air && this.opts.toolbarExternal && this.toolbarModule.setExternal();
    },
    _initToolbar: function() {
      this.toolbarModule = this.opts.air ? c.create("toolbar.air", this.app) : c.create("toolbar.standard", this.app);
    },
    _initButtons: function() {
      this.toolbar.setButtons(this.buttons);
      for (var r = 0; r < this.buttons.length; r++) {
        var h = this.buttons[r];
        c.buttons[h] && this.toolbar.addButton(h, c.extend(!0, {}, c.buttons[h]), !1, !1, !0);
      }
    }
  }), c.add("class", "toolbar.air", {
    init: function(r) {
      this.app = r, this.uuid = r.uuid, this.$doc = r.$doc, this.$win = r.$win, this.utils = r.utils, this.editor = r.editor, this.animate = r.animate, this.toolbar = r.toolbar, this.container = r.container, this.inspector = r.inspector, this.selection = r.selection, this.clicks = 0, this._init();
    },
    // public
    stop: function() {
      var r = this.toolbar.getWrapper();
      r.remove();
      var h = this.editor.getElement();
      h.off(".redactor-air-trigger-" + this.uuid), this.$doc.off(".redactor-air-" + this.uuid), this.$doc.off(".redactor-air-trigger-" + this.uuid), this.toolbar.stopObservers();
    },
    createSourceHelper: function() {
      this.$airHelper = c.dom("<span>"), this.$airHelper.addClass("redactor-air-helper"), this.$airHelper.html('<i class="re-icon-html"></i>'), this.$airHelper.on(
        "click",
        (function(h) {
          h.preventDefault(), this.app.api("module.source.hide");
        }).bind(this)
      );
      var r = this.container.getElement();
      r.append(this.$airHelper);
    },
    destroySourceHelper: function() {
      this.$airHelper && this.$airHelper.remove();
    },
    openSelected: function() {
      setTimeout(
        (function() {
          this._isSelection() && this._open(!1);
        }).bind(this),
        0
      );
    },
    close: function() {
      this.$doc.off(".redactor-air-" + this.uuid);
      var r = this.toolbar.getElement();
      r.removeClass("open"), r.hide();
    },
    // private
    _init: function() {
      this.toolbar.create();
      var r = this.toolbar.getWrapper(), h = this.toolbar.getElement(), u = this.editor.getElement(), g = this.container.getElement();
      r.addClass("redactor-toolbar-wrapper-air"), h.addClass("redactor-air"), h.hide(), r.append(h), g.prepend(r), this.openSelected(), this.$doc.on("mouseup.redactor-air-trigger-" + this.uuid, this._open.bind(this)), u.on("keyup.redactor-air-trigger-" + this.uuid, this._openCmd.bind(this));
    },
    _isSelection: function() {
      return this.selection.is() && !this.selection.isCollapsed();
    },
    _isOpened: function() {
      var r = this.toolbar.getElement();
      return r.hasClass("open");
    },
    _open: function(r) {
      var h = r ? r.target : !1, u = r ? c.dom(r.target) : !1, g = this.inspector.parse(h), b = g.isComponent() && !g.isComponentType("table"), O = g.isFigcaption(), x = u && u.closest(".redactor-modal").length !== 0, S = r && u.closest(".re-button").length !== 0, k = r && u.closest(".redactor-dropdown").length !== 0;
      if (!(k || S || x || O || b || this.toolbar.isContextBar() || !this._isSelection())) {
        var C = this.selection.getPosition();
        setTimeout(
          (function() {
            this.app.isReadOnly() || this._isSelection() && this._doOpen(C);
          }).bind(this),
          1
        );
      }
    },
    _openCmd: function() {
      if (this.selection.isAll()) {
        var r = this.toolbar.getElement(), h = this.selection.getPosition();
        h.top = h.top < 20 ? 0 : h.top - r.height(), h.height = 0, this._doOpen(h);
      }
    },
    _doOpen: function(r) {
      var h = this.toolbar.getWrapper(), u = this.toolbar.getElement(), g = this.container.getElement(), b = g.offset(), O = 0, x = this.$win.width(), S = u.width();
      if (x < r.left + S) {
        var k = this.selection.getPosition();
        O = S - k.width;
      }
      h.css({
        left: r.left - b.left - O + "px",
        top: r.top - b.top + r.height + this.$doc.scrollTop() + "px"
      }), this.app.broadcast("airOpen"), u.addClass("open"), u.show(), this.$doc.on("click.redactor-air-" + this.uuid, this._close.bind(this)), this.$doc.on("keydown.redactor-air-" + this.uuid, this._close.bind(this)), this.app.broadcast("airOpened");
    },
    _close: function(r) {
      var h = r ? c.dom(r.target) : !1, u = r && h.closest("[data-dropdown], .redactor-dropdown-not-close").length !== 0, g = !u && r && h.closest(".re-button").length !== 0;
      !g && (u || !this._isOpened()) || (this.app.broadcast("airClose"), this.close(), this.app.broadcast("airClosed"));
    }
  }), c.add("class", "toolbar.fixed", {
    init: function(r) {
      this.app = r, this.uuid = r.uuid, this.opts = r.opts, this.$doc = r.$doc, this.$win = r.$win, this.editor = r.editor, this.toolbar = r.toolbar, this.detector = r.detector, this.container = r.container, this._init();
    },
    // public
    stop: function() {
      this.$fixedTarget.off(".redactor-toolbar-" + this.uuid), this.$win.off(".redactor-toolbar-" + this.uuid);
    },
    reset: function() {
      var r = this.toolbar.getElement(), h = this.toolbar.getWrapper();
      h.css("height", ""), r.removeClass("redactor-toolbar-fixed"), r.css({ position: "", top: "", left: "", width: "" });
      var u = this.toolbar.getDropdown();
      u && u.updatePosition();
    },
    // private
    _init: function() {
      this.$fixedTarget = this.toolbar.isTarget() ? this.toolbar.getTargetElement() : this.$win, this._doFixed(), this.toolbar.isTarget() && (this.$win.on("scroll.redactor-toolbar-" + this.uuid, this._doFixed.bind(this)), this.$win.on("resize.redactor-toolbar-" + this.uuid, this._doFixed.bind(this))), this.$fixedTarget.on("scroll.redactor-toolbar-" + this.uuid, this._doFixed.bind(this)), this.$fixedTarget.on("resize.redactor-toolbar-" + this.uuid, this._doFixed.bind(this));
    },
    _doFixed: function() {
      var r = this.editor.getElement(), h = this.container.getElement(), u = this.toolbar.getElement(), g = this.toolbar.getWrapper();
      if (!this.editor.isSourceMode()) {
        var b = h.parents().filter(function(P) {
          return getComputedStyle(P, null).display === "none" ? P : !1;
        });
        if (b.length === 0) {
          var O = r.height() < 100, x = this.editor.isEmpty();
          if (O || x) {
            this.reset();
            return;
          }
          if (!this.editor.isSourceMode()) {
            var S = u.height(), k = 60, C = this.toolbar.isTarget() ? h.position() : h.offset(), _ = C.top, $ = _ + h.height() - k, L = this.$fixedTarget.scrollTop() + this.opts.toolbarFixedTopOffset, E = this.toolbar.isTarget() ? this.$fixedTarget.offset().top - this.$win.scrollTop() : 0;
            if (this.toolbar.isTarget() && this.$fixedTarget.css("position") === "fixed") {
              var A = this.$fixedTarget.hasClass("modal") && this.$fixedTarget.hasClass("fade"), y = A ? h.closest(".modal-dialog").position().top : 0;
              E = this.$fixedTarget.scrollTop() - y;
            }
            if (L > _ && L < $) {
              var w = this.detector.isDesktop() ? "fixed" : "absolute";
              E = this.detector.isDesktop() ? E : L - _, this.detector.isMobile() && (this.fixedScrollTimeout && clearTimeout(this.fixedScrollTimeout), u.hide(), this.fixedScrollTimeout = setTimeout(function() {
                u.show();
              }, 250)), g.height(S), u.addClass("redactor-toolbar-fixed"), h.hasClass("redactor-box-fullscreen") ? u.css({
                position: w,
                top: "0px",
                width: h.width() + "px"
              }) : u.css({
                position: w,
                top: E + this.opts.toolbarFixedTopOffset + "px",
                width: h.width() + "px"
              });
              var T = this.toolbar.getDropdown();
              T && T.updatePosition(), this.app.broadcast("toolbar.fixed");
            } else
              this.reset(), this.app.broadcast("toolbar.unfixed");
          }
        }
      }
    }
  }), c.add("class", "toolbar.standard", {
    init: function(r) {
      this.app = r, this.opts = r.opts, this.uuid = r.uuid, this.$body = r.$body, this.toolbar = r.toolbar, this.container = r.container, this.isExternalMultiple = !1, this.toolbarFixed = !1, this._init();
    },
    // public
    stop: function() {
      var r = this.toolbar.getWrapper();
      r.remove(), this.toolbarFixed && this.toolbarFixed.stop(), this.opts.toolbarExternal && this._findToolbars(), this.toolbar.stopObservers(), this.$body.find(".re-button-tooltip-" + this.uuid).remove();
    },
    setExternal: function() {
      if (this._findToolbars(), this.isExternalMultiple) {
        this.$toolbars.hide();
        var r = this.$external.find(".redactor-toolbar-external-" + this.uuid);
        r.show();
      }
    },
    resetPosition: function() {
      this.toolbarFixed && this.toolbarFixed.reset();
    },
    // private
    _init: function() {
      if (this._build(), this.opts.toolbarExternal)
        this._buildExternal();
      else {
        this._buildFixed();
        var r = this.toolbar.getElement();
        r.show();
      }
    },
    _build: function() {
      this.toolbar.create();
      var r = this.toolbar.getWrapper(), h = this.toolbar.getElement();
      if (r.addClass("redactor-toolbar-wrapper"), h.addClass("redactor-toolbar"), h.hide(), r.append(h), !this.opts.toolbarExternal) {
        var u = this.container.getElement();
        u.prepend(r);
      }
    },
    _buildExternal: function() {
      if (this._initExternal(), this._findToolbars(), this.isExternalMultiple)
        this._hideToolbarsExceptFirst();
      else {
        var r = this.toolbar.getElement();
        r.show();
      }
    },
    _buildFixed: function() {
      this.opts.toolbarFixed && (this.toolbarFixed = c.create("toolbar.fixed", this.app));
    },
    _initExternal: function() {
      var r = this.toolbar.getElement(), h = this.toolbar.getElement();
      r.addClass("redactor-toolbar-external redactor-toolbar-external-" + this.uuid), this.$external = c.dom(this.opts.toolbarExternal), this.$external.append(h);
    },
    _findToolbars: function() {
      this.$toolbars = this.$external.find(".redactor-toolbar-external"), this.isExternalMultiple = this.$toolbars.length > 1;
    },
    _hideToolbarsExceptFirst: function() {
      this.$toolbars.hide();
      var r = this.$toolbars.first();
      r.show();
    }
  }), c.add("module", "line", {
    init: function(r) {
      this.app = r, this.lang = r.lang, this.component = r.component, this.inspector = r.inspector, this.insertion = r.insertion;
    },
    // messages
    oncontextbar: function(r, h) {
      var u = this.inspector.parse(r.target);
      if (u.isComponentType("line")) {
        var g = u.getComponent(), b = {
          remove: {
            title: this.lang.get("delete"),
            api: "module.line.remove",
            args: g
          }
        };
        h.set(r, g, b, "bottom");
      }
    },
    // public
    insert: function() {
      var r = this.component.create("line");
      this.insertion.insertRaw(r);
    },
    remove: function(r) {
      this.component.remove(r);
    }
  }), c.add("class", "line.component", {
    mixins: ["dom", "component"],
    init: function(r, h) {
      return this.app = r, h && h.cmnt !== void 0 ? h : this._init(h);
    },
    // private
    _init: function(r) {
      var h, u;
      if (typeof r < "u") {
        var g = c.dom(r), b = g.get();
        b.tagName === "HR" ? u = b : b.tagName === "FIGURE" && (h = b, u = g.find("hr").get());
      }
      this._buildWrapper(h), this._buildElement(u), this._initWrapper();
    },
    _buildElement: function(r) {
      r ? this.$element = c.dom(r) : (this.$element = c.dom("<hr>"), this.append(this.$element));
    },
    _buildWrapper: function(r) {
      r = r || "<figure>", this.parse(r);
    },
    _initWrapper: function() {
      this.addClass("redactor-component"), this.attr({
        "data-redactor-type": "line",
        tabindex: "-1",
        contenteditable: !1
      });
    }
  }), c.add("module", "link", {
    modals: {
      link: '<form action="">                 <div class="form-item">                     <label for="modal-link-url">URL <span class="req">*</span></label>                     <input type="text" id="modal-link-url" name="url">                 </div>                 <div class="form-item">                     <label for="modal-link-text">## text ##</label>                     <input type="text" id="modal-link-text" name="text">                 </div>                 <div class="form-item form-item-title">                     <label for="modal-link-title">## title ##</label>                     <input type="text" id="modal-link-title" name="title">                 </div>                 <div class="form-item form-item-target">                     <label class="checkbox">                         <input type="checkbox" name="target"> ## link-in-new-tab ##                     </label>                 </div>             </form>'
    },
    init: function(r) {
      this.app = r, this.opts = r.opts, this.lang = r.lang, this.caret = r.caret, this.utils = r.utils, this.inline = r.inline, this.editor = r.editor, this.inspector = r.inspector, this.insertion = r.insertion, this.selection = r.selection, this.isCurrentLink = !1, this.currentText = !1;
    },
    // messages
    onmodal: {
      link: {
        open: function(r, h) {
          this._setFormData(h, r);
        },
        opened: function(r, h) {
          this._setFormFocus(h);
        },
        update: function(r, h) {
          var u = h.getData();
          this._validateData(h, u) && this._update(u);
        },
        insert: function(r, h) {
          var u = h.getData();
          this._validateData(h, u) && this._insert(u);
        },
        unlink: function() {
          this._unlink();
        }
      }
    },
    onbutton: {
      link: {
        observe: function(r) {
          this._observeButton(r);
        }
      }
    },
    ondropdown: {
      link: {
        observe: function(r) {
          this._observeUnlink(r), this._observeEdit(r);
        }
      }
    },
    oncontextbar: function(r, h) {
      var u = this._getCurrent(), g = this.inspector.parse(u);
      if (g.isLink() || g.isFile()) {
        var b = g.isFile() ? g.getFile() : g.getLink(), O = c.dom(b), x = c.dom("<a>"), S = O.attr("href");
        x.text(this._truncateText(S)), x.attr("href", S), x.attr("target", "_blank");
        var k = {
          link: {
            title: x,
            html: this._truncateText(S)
          },
          edit: {
            title: this.lang.get("edit"),
            api: "module.link.open"
          },
          unlink: {
            title: this.lang.get("unlink"),
            api: "module.link.unlink"
          }
        };
        h.set(r, b, k, "bottom");
      }
    },
    // public
    open: function() {
      this.$link = this._buildCurrent(), this.app.api("module.modal.build", this._getModalData());
    },
    insert: function(r) {
      this._insert(r);
    },
    update: function(r) {
      this._update(r);
    },
    unlink: function() {
      this._unlink();
    },
    // private
    _observeButton: function(r) {
      var h = this.selection.getCurrent(), u = this.inspector.parse(h);
      u.isPre() || u.isCode() ? r.disable() : r.enable();
    },
    _observeUnlink: function(r) {
      var h = r.getItem("unlink"), u = this._getLinks();
      u.length === 0 ? h.disable() : h.enable();
    },
    _observeEdit: function(r) {
      var h = this._getCurrent(), u = r.getItem("link"), g = this.inspector.parse(h), b = g.isLink() || g.isFile() ? this.lang.get("link-edit") : this.lang.get("link-insert");
      u.setTitle(b);
    },
    _unlink: function() {
      this.app.api("module.modal.close");
      var r = [], h = this._getLinks();
      this.selection.save();
      for (var u = 0; u < h.length; u++) {
        var g = c.create("link.component", this.app, h[u]);
        r.push(this.selection.getElement(h[u])), g.unwrap(), this.app.broadcast("link.deleted", g);
      }
      this.selection.restore();
      for (var u = 0; u < r.length; u++) {
        var b = r[u] ? r[u] : this.editor.getElement();
        this.utils.normalizeTextNodes(b);
      }
      this._resetCurrent();
    },
    _update: function(r) {
      this.app.api("module.modal.close");
      var h = this._getLinks();
      this._setLinkData(h, r, "updated"), this._resetCurrent(), this.app.broadcast("link.changed", h);
    },
    _insert: function(r) {
      this.app.api("module.modal.close");
      var h = this._getLinks();
      this._insertSingle(h, r) || (this._removeInSelection(h), this._insertMultiple(r)), this._resetCurrent();
    },
    _removeInSelection: function(r) {
      this.selection.save();
      for (var h = 0; h < r.length; h++) {
        var u = c.create("link.component", this.app, r[h]), g = u.clone();
        u.unwrap(), this.app.broadcast("link.deleted", g);
      }
      this.selection.restore();
    },
    _insertMultiple: function(r) {
      var h = this.selection.getRange();
      h && this._isCurrentTextChanged(r) && this._deleteContents(h);
      var u = this.inline.format({ tag: "a" });
      this._setLinkData(u, r, "inserted");
    },
    _insertSingle: function(r, h) {
      var u = this.selection.getInline();
      if (r.length === 1 && (r[0].textContext === this.selection.getText() || u && u.tagName === "A")) {
        var g = c.create("link.component", this.app, r[0]);
        return g.setData(h), this.caret.setAfter(g), this.app.broadcast("link.inserted", g), !0;
      }
      return !1;
    },
    _setLinkData: function(r, h, u) {
      h.text = h.text.trim() === "" ? this._truncateText(h.url) : h.text;
      var g = !this.currentText || this.currentText !== h.text;
      this.selection.save();
      for (var b = 0; b < r.length; b++) {
        var O = c.create("link.component", this.app, r[b]), x = {};
        h.text && g && (x.text = h.text), h.url && (x.url = h.url), h.title !== void 0 && (x.title = h.title), h.target !== void 0 && (x.target = h.target), O.setData(x), this.app.broadcast("link." + u, O);
      }
      setTimeout(this.selection.restore.bind(this.selection), 0);
    },
    _deleteContents: function(r) {
      var h = this.selection.getHtml(), u = this.utils.parseHtml(h), g = u.nodes[0];
      if (g && g.nodeType !== 3) {
        var b = g.tagName.toLowerCase(), O = document.createElement(b);
        this.insertion.insertNode(O, "start");
      } else
        r.deleteContents();
    },
    _getModalData: function() {
      var r;
      this._isLink() ? r = {
        update: { title: this.lang.get("save") },
        unlink: { title: this.lang.get("unlink"), type: "danger" },
        cancel: { title: this.lang.get("cancel") }
      } : r = {
        insert: { title: this.lang.get("insert") },
        cancel: { title: this.lang.get("cancel") }
      };
      var h = {
        name: "link",
        title: this._isLink() ? this.lang.get("link-edit") : this.lang.get("link-insert"),
        handle: this._isLink() ? "update" : "insert",
        commands: r
      };
      return h;
    },
    _isLink: function() {
      return this.currentLink;
    },
    _isCurrentTextChanged: function(r) {
      return this.currentText && this.currentText !== r.text;
    },
    _buildCurrent: function() {
      var r = this._getCurrent(), h = this.inspector.parse(r), u;
      if (h.isLink() || h.isFile())
        this.currentLink = !0, u = h.isFile() ? h.getFile() : h.getLink(), u = c.create("link.component", this.app, u);
      else {
        this.currentLink = !1, u = c.create("link.component", this.app);
        var g = {
          text: this.selection.getText()
        };
        u.setData(g);
      }
      return u;
    },
    _getCurrent: function() {
      return this.selection.getInlinesAllSelected({ tags: ["a"] })[0];
    },
    _getLinks: function() {
      for (var r = this.selection.getInlines({ all: !0, tags: ["a"] }), h = [], u = 0; u < r.length; u++) {
        var g = this.inspector.parse(r[u]);
        (g.isLink() || g.isFile()) && h.push(r[u]);
      }
      return h;
    },
    _resetCurrent: function() {
      this.isCurrentLink = !1, this.currentText = !1;
    },
    _truncateText: function(r) {
      return r && r.length > this.opts.linkSize ? r.substring(0, this.opts.linkSize) + "..." : r;
    },
    _validateData: function(r, h) {
      return h.url.trim() === "" ? r.setError("url") : !0;
    },
    _setFormFocus: function(r) {
      r.getField("url").focus();
    },
    _setFormData: function(r, h) {
      var u = this.$link.getData(), g = {
        url: u.url,
        text: u.text,
        title: u.title,
        target: this.opts.linkTarget || u.target
      };
      this.opts.linkNewTab || h.find(".form-item-target").hide(), this.opts.linkTitle || h.find(".form-item-title").hide(), r.setData(g), this.currentText = r.getField("text").val();
    }
  }), c.add("class", "link.component", {
    mixins: ["dom", "component"],
    init: function(r, h) {
      return this.app = r, this.opts = r.opts, this.reUrl = /^(?:(?:(?:https?|ftp):)?\/\/)?(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:[/?#]\S*)?$/i, h && h.cmnt !== void 0 ? h : this._init(h);
    },
    // public
    setData: function(r) {
      for (var h in r)
        this._set(h, r[h]);
    },
    getData: function() {
      for (var r = ["url", "text", "target", "title"], h = {}, u = 0; u < r.length; u++)
        h[r[u]] = this._get(r[u]);
      return h;
    },
    // private
    _init: function(r) {
      var h = c.dom(r);
      r === void 0 ? this.parse("<a>") : this.parse(h);
    },
    _set: function(r, h) {
      this["_set_" + r](h);
    },
    _get: function(r) {
      return this["_get_" + r]();
    },
    _get_target: function() {
      return this.attr("target") ? this.attr("target") : !1;
    },
    _get_url: function() {
      return this.attr("href");
    },
    _get_title: function() {
      return this.attr("title");
    },
    _get_text: function() {
      return this._getContext().text();
    },
    _getContext: function() {
      return this._findDeepestChild(this).element;
    },
    _set_target: function(r) {
      r === !1 ? this.removeAttr("target") : r && this.attr("target", r === !0 ? "_blank" : r);
    },
    _set_text: function(r) {
      r = this._escapeHtml(r), this._getContext().html(r);
    },
    _set_title: function(r) {
      !r || r === "" ? this.removeAttr("title") : this.attr("title", r);
    },
    _set_url: function(r) {
      this.opts.linkValidation && (r = this._cleanUrl(r), this._isMailto(r) ? r = "mailto:" + r.replace("mailto:", "") : this._isUrl(r) && r.search(/^(ftp|https?)/i) === -1 && (r = "http://" + r.replace(/(ftp|https?):\/\//i, ""))), this.attr("href", r);
    },
    _isMailto: function(r) {
      return r.search("@") !== -1 && /(ftp|https?):\/\//i.test(r) === !1;
    },
    _isUrl: function(r) {
      return this.reUrl.test(r);
    },
    _cleanUrl: function(r) {
      return r = this._escapeHtml(r), r.trim().replace(/[^\W\w\D\d+&\'@#/%?=~_|!:,.;\(\)]/gi, "");
    },
    _escapeHtml: function(r) {
      return r.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
    },
    _findDeepestChild: function(r) {
      var h = { depth: 0, element: r };
      return r.children().each(
        (function(u) {
          var g = c.dom(u);
          if (u.outerHTML === r.html()) {
            var b = this._findDeepestChild(g);
            b.depth + 1 > h.depth && (h = {
              depth: 1 + b.depth,
              element: b.element
            });
          }
        }).bind(this)
      ), h;
    }
  }), c.add("module", "modal", {
    init: function(r) {
      this.app = r, this.uuid = r.uuid, this.lang = r.lang, this.$doc = r.$doc, this.$win = r.$win, this.$body = r.$body, this.utils = r.utils, this.editor = r.editor, this.animate = r.animate, this.detector = r.detector, this.selection = r.selection, this.$box = !1, this.$modal = !1, this.selectionMarkers = !1, this.defaults = {
        name: !1,
        url: !1,
        title: !1,
        width: "600px",
        height: !1,
        handle: !1,
        commands: !1
      };
    },
    // public
    build: function(r) {
      this._open(r);
    },
    close: function() {
      this._close();
    },
    onstop: function() {
      this.$body.find("#redactor-modal-" + this.uuid).remove(), this.$body.find("#redactor-overlay-" + this.uuid).remove();
    },
    stop: function() {
      this.$box && (this.$box.remove(), this.$box = !1, this.$modal = !1), this.$overlay && this.$overlay.remove(), this.$doc.off(".redactor.modal"), this.$win.off(".redactor.modal");
    },
    resize: function() {
      this.$modal.setWidth(this.p.width), this.$modal.updatePosition();
    },
    // private
    _isOpened: function() {
      return this.$modal && this.$modal.hasClass("open");
    },
    _open: function(r) {
      this._buildDefaults(r), this.p.url ? this._openUrl() : this._openTemplate();
    },
    _openUrl: function() {
      c.ajax.post({
        url: this.p.url,
        success: this._doOpen.bind(this)
      });
    },
    _openTemplate: function() {
      if (typeof c.modals[this.p.name] < "u") {
        var r = this.lang.parse(c.modals[this.p.name]);
        this._doOpen(r);
      }
    },
    _doOpen: function(r) {
      this.stop(), this.selection.isCollapsed() ? (this.selection.save(), this.selectionMarkers = !1) : (this.selection.saveMarkers(), this.selectionMarkers = !0), this.detector.isDesktop() || document.activeElement.blur(), this._createModal(r), this._buildModalBox(), this._buildOverlay(), this._buildModal(), this._buildModalForm(), this._buildModalCommands(), this._broadcast("open"), this.$modal.updatePosition(), this._buildModalTabs(), this.animate.start(this.$box, "fadeIn", this._opened.bind(this)), this.animate.start(this.$overlay, "fadeIn");
    },
    _opened: function() {
      this.$modal.addClass("open"), this.$box.on("mousedown.redactor.modal", this._close.bind(this)), this.$doc.on("keyup.redactor.modal", this._handleEscape.bind(this)), this.$win.on("resize.redactor.modal", this.resize.bind(this)), this.$modal.getBody().find("input[type=text],input[type=url],input[type=email]").on("keydown.redactor.modal", this._handleEnter.bind(this)), window.jQuery && window.jQuery(document).off("focusin.modal"), this._broadcast("opened");
    },
    _close: function(r) {
      if (!(!this.$box || !this._isOpened())) {
        if (r) {
          if (!this._needToClose(r.target))
            return;
          r.stopPropagation(), r.preventDefault();
        }
        this.selectionMarkers ? this.selection.restoreMarkers() : this.selection.restore(), this.selectionMarkers = !1, this._broadcast("close"), this.animate.start(this.$box, "fadeOut", this._closed.bind(this)), this.animate.start(this.$overlay, "fadeOut");
      }
    },
    _closed: function() {
      this.$modal.removeClass("open"), this.$box.off(".redactor.modal"), this.$doc.off(".redactor.modal"), this.$win.off(".redactor.modal"), this._broadcast("closed");
    },
    _createModal: function(r) {
      this.$modal = c.create("modal.element", this.app, r);
    },
    _broadcast: function(r) {
      this.app.broadcast("modal." + r, this.$modal, this.$modalForm), this.app.broadcast("modal." + this.p.name + "." + r, this.$modal, this.$modalForm);
    },
    _buildDefaults: function(r) {
      this.p = c.extend({}, this.defaults, r);
    },
    _buildModalBox: function() {
      this.$box = c.dom("<div>"), this.$box.attr("id", "redactor-modal-" + this.uuid), this.$box.addClass("redactor-modal-box redactor-animate-hide"), this.$box.html(""), this.$body.append(this.$box);
    },
    _buildOverlay: function() {
      this.$overlay = c.dom("#redactor-overlay-" + this.uuid), this.$overlay.length === 0 && (this.$overlay = c.dom("<div>"), this.$overlay.attr("id", "redactor-overlay-" + this.uuid), this.$overlay.addClass("redactor-overlay redactor-animate-hide"), this.$body.prepend(this.$overlay));
    },
    _buildModal: function() {
      this.$box.append(this.$modal), this.$modal.setTitle(this.p.title), this.$modal.setHeight(this.p.height), this.$modal.setWidth(this.p.width);
    },
    _buildModalCommands: function() {
      if (this.p.commands) {
        var r = this.p.commands, h = this.$modal.getFooter();
        for (var u in r) {
          var g = c.dom("<button>");
          g.html(r[u].title), g.attr("data-command", u), u === "cancel" && (g.attr("data-action", "close"), g.addClass("redactor-button-unstyled")), typeof r[u].type < "u" && r[u].type === "danger" && g.addClass("redactor-button-danger"), g.on("click", this._handleCommand.bind(this)), h.append(g);
        }
      }
    },
    _buildModalTabs: function() {
      var r = this.$modal.getBody(), h = r.find(".redactor-modal-tab"), u = r.find(".redactor-modal-tabs");
      h.length > 1 && (u = u.length === 0 ? c.dom("<div>") : u.html(""), u.addClass("redactor-modal-tabs"), h.each(
        (function(g, b) {
          var O = c.dom(g), x = c.dom("<a>");
          x.attr("href", "#"), x.attr("rel", b), x.text(O.attr("data-title")), x.on("click", this._showTab.bind(this)), b === 0 && x.addClass("active"), u.append(x);
        }).bind(this)
      ), r.prepend(u)), h.length === 1 && h.show();
    },
    _buildModalForm: function() {
      this.$modalForm = c.create("modal.form", this.app, this.$modal.getForm());
    },
    _showTab: function(r) {
      r.preventDefault();
      var h = c.dom(r.target), u = h.attr("rel"), g = this.$modal.getBody(), b = g.find(".redactor-modal-tab");
      b.hide(), b.eq(u).show(), g.find(".redactor-modal-tabs a").removeClass("active"), h.addClass("active");
    },
    _needToClose: function(r) {
      var h = c.dom(r);
      return !!(h.attr("data-action") === "close" || this.$modal.isCloseNode(r) || h.closest(".redactor-modal").length === 0);
    },
    _handleCommand: function(r) {
      var h = c.dom(r.target).closest("button"), u = h.attr("data-command");
      u !== "cancel" && r.preventDefault(), this._broadcast(u);
    },
    _handleEnter: function(r) {
      r.which === 13 && this.p.handle && (r.preventDefault(), this._broadcast(this.p.handle));
    },
    _handleEscape: function(r) {
      r.which === 27 && this._close();
    }
  }), c.add("class", "modal.element", {
    mixins: ["dom"],
    init: function(r, h) {
      this.app = r, this.opts = r.opts, this.$win = r.$win, this._init(h);
    },
    // get
    getForm: function() {
      return this.find("form");
    },
    getHeader: function() {
      return this.$modalHeader;
    },
    getBody: function() {
      return this.$modalBody;
    },
    getFooter: function() {
      return this.$modalFooter;
    },
    // set
    setTitle: function(r) {
      r && this.$modalHeader.html(r);
    },
    setWidth: function(r) {
      r = parseInt(r) >= this.$win.width() ? "96%" : r, this.css("max-width", r);
    },
    setHeight: function(r) {
      r !== !1 && this.$modalBody.css("height", r);
    },
    // update
    updatePosition: function() {
      var r = this.width();
      this.css({ left: "50%", "margin-left": "-" + r / 2 + "px" });
      var h = this.$win.height(), u = this.height(), g = h / 2 - u / 2;
      u < h && g !== 0 && this.css("margin-top", g + "px");
    },
    // is
    isCloseNode: function(r) {
      return r === this.$modalClose.get();
    },
    // private
    _init: function(r) {
      this._build(), this._buildClose(), this._buildHeader(), this._buildBody(), this._buildFooter(), this._buildTemplate(r);
    },
    _build: function() {
      this.parse("<div>"), this.addClass("redactor-modal"), this.attr("dir", this.opts.direction);
    },
    _buildClose: function() {
      this.$modalClose = c.dom("<span>"), this.$modalClose.addClass("redactor-close"), this.append(this.$modalClose);
    },
    _buildHeader: function() {
      this.$modalHeader = c.dom("<div>"), this.$modalHeader.addClass("redactor-modal-header"), this.append(this.$modalHeader);
    },
    _buildBody: function() {
      this.$modalBody = c.dom("<div>"), this.$modalBody.addClass("redactor-modal-body"), this.append(this.$modalBody);
    },
    _buildFooter: function() {
      this.$modalFooter = c.dom("<div>"), this.$modalFooter.addClass("redactor-modal-footer"), this.append(this.$modalFooter);
    },
    _buildTemplate: function(r) {
      this.$modalBody.html(r);
    }
  }), c.add("class", "modal.form", {
    mixins: ["dom"],
    init: function(r, h) {
      this.app = r, this.build(h);
    },
    // public
    build: function(r) {
      this.parse(r);
    },
    getData: function() {
      var r = {};
      return this.find("[name]").each(function(h) {
        var u = c.dom(h);
        r[u.attr("name")] = u.val();
      }), r;
    },
    setData: function(r) {
      this.find("[name]").each(function(h) {
        var u = c.dom(h), g = u.attr("name");
        r.hasOwnProperty(g) && (h.type && h.type === "checkbox" ? h.checked = r[g] : u.val(r[g]));
      });
    },
    getField: function(r) {
      return this.find("[name=" + r + "]");
    },
    setError: function(r) {
      var h = this.getField(r);
      return h.addClass("error"), h.one(this._getFieldEventName(h.get()), this._clearError), !1;
    },
    // private
    _clearError: function() {
      return c.dom(this).removeClass("error");
    },
    _getFieldEventName: function(r) {
      return r.tagName === "SELECT" || r.type === "checkbox" || r.type === "radio" ? "change" : "keyup";
    }
  }), c.add("module", "block", {
    init: function(r) {
      this.app = r, this.block = r.block;
    },
    // public
    format: function(r) {
      var h = this.block.format(r);
      this.app.broadcast("format", "block", h);
    },
    clearformat: function() {
      this.block.clearFormat();
    },
    clearstyle: function() {
      this.block.clearStyle();
    },
    clearclass: function() {
      this.block.clearClass();
    },
    clearattr: function() {
      this.block.clearAttr();
    },
    add: function(r, h) {
      this.block.add(r, h);
    },
    toggle: function(r, h) {
      this.block.toggle(r, h);
    },
    set: function(r, h) {
      this.block.set(r, h);
    },
    remove: function(r, h) {
      this.block.remove(r, h);
    }
  }), c.add("module", "inline", {
    init: function(r) {
      this.app = r, this.inline = r.inline;
    },
    format: function(r) {
      var h = this.inline.format(r);
      this.app.broadcast("format", "inline", h);
    },
    clearformat: function() {
      this.inline.clearFormat();
    },
    clearstyle: function() {
      this.inline.clearStyle();
    },
    clearclass: function() {
      this.inline.clearClass();
    },
    clearattr: function() {
      this.inline.clearAttr();
    },
    add: function(r, h) {
      this.inline.add(r, h);
    },
    toggle: function(r, h) {
      this.inline.toggle(r, h);
    },
    set: function(r, h) {
      this.inline.set(r, h);
    },
    remove: function(r, h) {
      this.inline.remove(r, h);
    }
  }), c.add("module", "autosave", {
    init: function(r) {
      this.app = r, this.opts = r.opts, this.utils = r.utils, this.source = r.source;
    },
    // messages
    onsynced: function() {
      this.opts.autosave && this._send();
    },
    // private
    _send: function() {
      var r = this.opts.autosaveName ? this.opts.autosaveName : this.source.getName(), h = {};
      h[r] = this.source.getCode(), h = this.utils.extendData(h, this.opts.autosaveData), c.ajax.request(this.opts.autosaveMethod, {
        url: this.opts.autosave,
        data: h,
        success: (function(u) {
          this._complete(u, r, h);
        }).bind(this)
      });
    },
    _complete: function(r, h, u) {
      var g = r && r.error ? "autosaveError" : "autosave";
      this.app.broadcast(g, h, u, r);
    }
  }), c.add("module", "input", {
    init: function(r) {
      this.app = r, this.opts = r.opts, this.utils = r.utils, this.editor = r.editor, this.keycodes = r.keycodes, this.element = r.element, this.selection = r.selection, this.insertion = r.insertion, this.inspector = r.inspector, this.autoparser = r.autoparser, this.lastShiftKey = !1;
    },
    // messages
    onpaste: function(r, h) {
      if (this.opts.input)
        return c.create("input.paste", this.app, r, h);
    },
    onkeydown: function(r) {
      if (this.opts.input) {
        var h = r.which, u = c.create("input.shortcut", this.app, r);
        if (!u.is()) {
          if ((r.ctrlKey || r.metaKey) && !r.altKey && h === 65)
            return r.preventDefault(), this._selectAll();
          var g = [this.keycodes.ENTER, this.keycodes.SPACE, this.keycodes.BACKSPACE, this.keycodes.DELETE], b = [this.keycodes.UP, this.keycodes.DOWN, this.keycodes.LEFT, this.keycodes.RIGHT], O = g.indexOf(h) !== -1, x = b.indexOf(h) !== -1, S = (r.ctrlKey || r.metaKey) && h === 88, k = !r.ctrlKey && !r.metaKey && (h >= 48 && h <= 57 || h >= 65 && h <= 90);
          if (this.selection.isAll() && x && (S || !r.ctrlKey && !r.metaKey && !r.altKey && !r.shiftKey)) {
            if (S) {
              this.editor.disableNonEditables(), this.app.broadcast("empty");
              return;
            }
            if (this._isArrowKey(h))
              return !0;
            if (O && r.preventDefault(), this.element.isType("inline")) {
              var C = this.editor.getElement();
              C.html(""), this.editor.startFocus();
            } else
              this.insertion.set(this.opts.emptyHtml);
            if (O)
              return;
            this.app.broadcast("empty");
          }
          if (this.opts.autoparse && this.autoparser.format(r, h), k && this.selection.hasNonEditable()) {
            r.preventDefault();
            return;
          }
          if (h === this.keycodes.ENTER)
            return c.create("input.enter", this.app, r, h);
          if (r.metaKey && h === 219) {
            r.preventDefault(), this.app.api("module.list.outdent");
            return;
          } else {
            if (h === this.keycodes.TAB || r.metaKey && h === 221)
              return c.create("input.tab", this.app, r, h);
            if (h === this.keycodes.SPACE)
              return c.create("input.space", this.app, r, h, this.lastShiftKey);
            if (this._isDeleteKey(h))
              return c.create("input.delete", this.app, r, h);
            if (this._isArrowKey(h))
              return c.create("input.arrow", this.app, r, h);
          }
        }
      }
    },
    onkeyup: function(r) {
      if (this.opts.input) {
        var h = r.which;
        this.lastShiftKey = r.shiftKey, this.app.broadcast("contextbar.close");
        var u = c.create("input.shortcode", this.app, r, h);
        if (!u.is()) {
          if (h === this.keycodes.BACKSPACE) {
            var g = this.editor.getElement(), b = this.utils.trimSpaces(g.html());
            if (b = b.replace(/<br\s?\/?>/g, ""), b = b.replace(/<div><\/div>/, ""), b === "") {
              r.preventDefault(), this.editor.setEmpty(), this.editor.startFocus();
              return;
            }
          }
          this.editor.isEmpty() && this.app.broadcast("empty");
        }
      }
    },
    // public
    start: function() {
      this.opts.shortcutsAdd && (this.opts.shortcuts = c.extend({}, !0, this.opts.shortcuts, this.opts.shortcutsAdd));
    },
    // private
    _selectAll: function() {
      var r = this.selection.getCurrent(), h = this.inspector.parse(r), u;
      if (h.isComponentType("table")) {
        u = h.getTable(), this.selection.setAll(u);
        return;
      } else if (h.isComponentType("code")) {
        u = h.getComponentCodeElement(), this.selection.setAll(u);
        return;
      }
      this.selection.setAll();
    },
    _isArrowKey: function(r) {
      return [this.keycodes.UP, this.keycodes.DOWN, this.keycodes.RIGHT, this.keycodes.LEFT].indexOf(r) !== -1;
    },
    _isDeleteKey: function(r) {
      return r === this.keycodes.BACKSPACE || r === this.keycodes.DELETE;
    }
  }), c.add("class", "input.arrow", {
    init: function(r, h, u) {
      this.app = r, this.opts = r.opts, this.utils = r.utils, this.caret = r.caret, this.offset = r.offset, this.marker = r.marker, this.editor = r.editor, this.keycodes = r.keycodes, this.component = r.component, this.inspector = r.inspector, this.selection = r.selection, this.key = u, this._init(h);
    },
    // private
    _init: function(r) {
      this._isRightLeftKey() && this._isExitVariable(r) || this._isRightDownKey() && (this._isExitOnDownRight(r) || this._selectComponent(r, "End", "next")) || this._isLeftUpKey() && (this._isExitOnUpLeft(r) || this._selectComponent(r, "Start", "prev")) || (this.key === this.keycodes.LEFT ? this.utils.trimInvisibleChars("left") : this.key === this.keycodes.RIGHT && this.utils.trimInvisibleChars("right"));
    },
    _isRightDownKey: function() {
      return [this.keycodes.DOWN, this.keycodes.RIGHT].indexOf(this.key) !== -1;
    },
    _isLeftUpKey: function() {
      return [this.keycodes.UP, this.keycodes.LEFT].indexOf(this.key) !== -1;
    },
    _isRightLeftKey: function() {
      return [this.keycodes.RIGHT, this.keycodes.LEFT].indexOf(this.key) !== -1;
    },
    _isExitVariable: function(r) {
      var h = this.selection.getCurrent(), u = this.inspector.parse(h), g = u.getComponent();
      if (u.isComponentType("variable") && u.isComponentActive()) {
        r.preventDefault();
        var b = this.key === this.keycodes.LEFT ? "setBefore" : "setAfter";
        this.caret[b](g);
        return;
      }
    },
    _isExitOnUpLeft: function(r) {
      var h = this.selection.getCurrent(), u = this.selection.getBlock(h), g = this.inspector.parse(h), b = u.previousElementSibling, O = this.caret.isStart(u);
      if (O && b && b.tagName === "TABLE")
        return r.preventDefault(), this.caret.setEnd(b), !0;
      if (g.isFigcaption()) {
        u = g.getFigcaption(), O = this.caret.isStart(u);
        var x = c.dom(u).closest(".redactor-component");
        if (O && x.length !== 0)
          return r.preventDefault(), this.caret.setEnd(x), !0;
      } else {
        if (g.isTable() && O)
          return r.preventDefault(), this.caret.setEnd(u.previousElementSibling), !0;
        if (!g.isComponentEditable() && g.isComponent() && !g.isComponentType("variable")) {
          var S = g.getComponent();
          if (S.previousElementSibling) {
            if (S.previousElementSibling)
              return r.preventDefault(), this.component.clearActive(), this.caret.setEnd(S.previousElementSibling), !0;
          } else
            return r.preventDefault(), this.component.clearActive(), this._exitPrevElement(r, g.getComponent());
        }
      }
    },
    _isExitOnDownRight: function(r) {
      var h = this.editor.getElement(), u = this.selection.getCurrent(), g = this.inspector.parse(u), b = this.caret.isEnd(), O, x;
      if (g.isTable()) {
        if (O = g.getTable(), x = this.caret.isEnd(O), x || b)
          return this._exitNextElement(r, g.getComponent());
      } else if (g.isFigcaption()) {
        if (O = g.getFigcaption(), x = this.caret.isEnd(O), x || b)
          return this._exitNextElement(r, g.getComponent());
      } else if (g.isComponentType("code")) {
        var S = g.getComponent(), k = c.dom(g.getComponentCodeElement()).closest("pre");
        x = this.caret.isEnd(O);
        var C = k && k.get().nextElementSibling;
        if (x && !C)
          return this._exitNextElement(r, S);
      } else if (g.isPre() || g.isBlockquote() || g.isDl()) {
        if (b) {
          if (g.isPre())
            return this._exitNextElement(r, g.getPre());
          if (g.isBlockquote())
            return this._exitNextElement(r, g.getBlockquote());
          if (g.isDl())
            return this._exitNextElement(r, g.getDl());
        }
      } else if (g.isList()) {
        var _ = c.dom(u).parents("ul, ol", h).last();
        if (x = this.caret.isEnd(_), x || b)
          return this._exitNextElement(r, _.get());
      } else if (g.isComponent() && !g.isComponentType("variable") && g.getTag() !== "span")
        return this.component.clearActive(), this._exitNextElement(r, g.getComponent());
    },
    _exitPrevElement: function(r, h) {
      return r.preventDefault(), h.previousElementSibling ? this.caret.setEnd(h.previousElementSibling) : this.utils.createMarkupBefore(h), !0;
    },
    _exitNextElement: function(r, h) {
      return r.preventDefault(), h.nextElementSibling ? this.caret.setStart(h.nextElementSibling) : this.utils.createMarkup(h), !0;
    },
    _selectComponent: function(r, h, u) {
      var g = this.selection.getCurrent(), b = this.selection.getBlock(g), O = this.utils.findSiblings(g, u), x = this.utils.findSiblings(b, u);
      O && this.caret["is" + h](g) ? this._selectComponentItem(r, O, h) : x && this.caret["is" + h](b) && this._selectComponentItem(r, x, h);
    },
    _selectComponentItem: function(r, h, u) {
      if (this.component.isNonEditable(h))
        return r.preventDefault(), this.caret["set" + u](h), !0;
    }
  }), c.add("class", "input.delete", {
    init: function(r, h, u) {
      this.app = r, this.opts = r.opts, this.caret = r.caret, this.utils = r.utils, this.editor = r.editor, this.marker = r.marker, this.keycodes = r.keycodes, this.component = r.component, this.inspector = r.inspector, this.selection = r.selection, this.insertion = r.insertion, this.key = u, this._init(h);
    },
    // private
    _init: function(r) {
      if (!this._removeActiveComponent(r) && !this._removeAllSelectedTable(r)) {
        if (this.key === this.keycodes.BACKSPACE) {
          var h = this.editor.getElement(), u = this.utils.trimSpaces(h.html());
          if (u === this.opts.emptyHtml) {
            r.preventDefault();
            return;
          }
        }
        if (this._detectVariableOrNonEditable() || this.selection.hasNonEditable()) {
          r.preventDefault();
          return;
        }
        if (this.selection.isAll()) {
          r.preventDefault(), this.insertion.set(this.opts.emptyHtml);
          return;
        }
        this.selection.isCollapsed() && (this.key === this.keycodes.BACKSPACE ? this._traverseBackspace(r) : this.key === this.keycodes.DELETE && this._traverseDelete(r)), this.key === this.keycodes.BACKSPACE && this.utils.trimInvisibleChars("left"), this._removeUnwantedStyles(), this._removeEmptySpans(), this._removeSpanTagsInHeadings(), this._removeInlineTagsInPre();
      }
    },
    _detectVariableOrNonEditable: function() {
      var r = this.selection.getBlock(), h = this.caret.isStart(r), u = this.caret.isEnd(r), g;
      if (this.key === this.keycodes.BACKSPACE && h) {
        if (g = r.previousSibling, this._isNonEditable(g))
          return !0;
      } else if (this.key === this.keycodes.DELETE && u && (g = r.nextSibling, this._isNonEditable(g)))
        return !0;
      var b = this.selection.getCurrent(), O = this.caret.isStart(b), x = this.caret.isEnd(b), S = this.selection.getTextBeforeCaret().trim() === "", k = this.selection.getTextAfterCaret().trim() === "";
      if (this.key === this.keycodes.BACKSPACE && O && !S) {
        if (g = b.previousSibling, this._isVariable(g))
          return this.caret.setEnd(g), !0;
        if (this._isNonEditable(g))
          return !0;
      } else if (this.key === this.keycodes.DELETE && x && !k) {
        if (g = b.nextSibling, this._isVariable(g))
          return this.caret.setStart(g), !0;
        if (this._isNonEditable(g))
          return !0;
      }
    },
    _isVariable: function(r) {
      return c.dom(r).closest('[data-redactor-type="variable"]').length !== 0;
    },
    _isNonEditable: function(r) {
      return c.dom(r).closest(".non-editable").length !== 0;
    },
    _getBlock: function() {
      var r = this.editor.getElement(), h = this.selection.getBlock(), u = this.inspector.parse(h);
      return h = u.isList() ? c.dom(h).parents("ul, ol", r).last().get() : h, h = u.isDl() ? u.getDl() : h, h = u.isTable() ? u.getTable() : h, h;
    },
    _traverseDelete: function(r) {
      var h = this.selection.getCurrent(), u = this.inspector.parse(h), g, b, O;
      if (u.isFigcaption()) {
        if (g = u.getFigcaption(), b = this.caret.isEnd(g), b) {
          r.preventDefault();
          return;
        }
      } else if (u.isComponentType("code") && (g = u.getComponent(), b = this.caret.isEnd(g), b)) {
        r.preventDefault();
        return;
      }
      g = this._getBlock();
      var x = this.utils.findSiblings(g, "next");
      if (x) {
        b = this.caret.isEnd(g);
        var S = this.inspector.parse(x), k = x.tagName === "P" || x.tagName === "DIV";
        if (b && S.isComponentType("table")) {
          r.preventDefault(), this.caret.setStart(x);
          return;
        } else if (b && S.isComponentEditable()) {
          r.preventDefault(), this.component.remove(x, !1);
          return;
        } else if (b && S.isComponent()) {
          r.preventDefault(), this.caret.setStart(x), this.utils.isEmptyHtml(g.innerHTML) && c.dom(g).remove();
          return;
        } else if (b && S.isList()) {
          var C = c.dom(g);
          if (O = c.dom(x), u.isList()) {
            r.preventDefault(), C.append(O), O.unwrap();
            return;
          } else {
            var _ = O.children("li").first(), $ = _.find("ul, ol");
            if ($.length !== 0) {
              r.preventDefault(), O.prepend($), $.unwrap(), C.append(_), _.unwrap();
              return;
            }
          }
        } else if (b && !u.isList() && !u.isTable() && k && !this.utils.isEmptyHtml(g.innerHTML)) {
          r.preventDefault();
          var L = c.dom(g);
          O = c.dom(x), L.append(O), O.unwrap();
          return;
        }
      }
    },
    _traverseBackspace: function(r) {
      var h = this.selection.getCurrent(), u = this.inspector.parse(h), g, b, O, x;
      if (u.isFigcaption()) {
        if (g = u.getFigcaption(), b = this.caret.isStart(g), b) {
          r.preventDefault();
          return;
        }
      } else if (u.isComponentType("code") && (g = u.getComponent(), b = this.caret.isStart(g), b && g.previousElementSibling))
        return r.preventDefault(), this.caret.setEnd(g.previousElementSibling), !0;
      g = this._getBlock();
      var S = this.utils.findSiblings(g, "prev");
      if (!S) {
        setTimeout(this._replaceBlock.bind(this), 1);
        return;
      }
      b = this.caret.isStart(g);
      var k = this.inspector.parse(S), C = S.tagName === "P" || S.tagName === "DIV";
      if (b && k.isComponentType("code")) {
        r.preventDefault(), this.component.remove(S, !1);
        return;
      } else if (b && k.isComponentType("table")) {
        r.preventDefault(), this.caret.setEnd(S);
        return;
      } else if (b && k.isComponent()) {
        r.preventDefault(), this.caret.setStart(S), this.utils.isEmptyHtml(g.innerHTML) && c.dom(g).remove();
        return;
      } else if (b && u.isList()) {
        if (r.preventDefault(), x = c.dom(g), O = c.dom(S), k.isList())
          x.children("li").first().prepend(this.marker.build("start")), O.append(x), x.unwrap(), this.selection.restoreMarkers();
        else {
          var _ = x.children("li").first(), $ = _.get(), L = _.find("ul, ol"), E = this.utils.replaceToTag($, this.opts.markup);
          this.opts.breakline && E.attr("data-redactor-tag", "br"), x.before(E), this.caret.setStart(E), L.length !== 0 && (x.prepend(L), L.unwrap());
        }
        return;
      } else if (b && C) {
        if (r.preventDefault(), this.utils.isEmpty(S)) {
          O = c.dom(S), O.remove();
          return;
        }
        var A = this.utils.createInvisibleChar(), y = c.dom(g);
        O = c.dom(S), this.caret.setEnd(O), y.prepend(A), O.append(y.contents()), y.remove();
        return;
      }
    },
    _replaceBlock: function() {
      var r = this.selection.getBlock(), h = c.dom(r);
      if (this.opts.markup === "p" && r && this._isNeedToReplaceBlock(r)) {
        var u = document.createElement(this.opts.markup);
        h.replaceWith(u), this.caret.setStart(u);
      }
      this.opts.breakline && r && r.tagName === "DIV" && h.attr("data-redactor-tag", "br");
    },
    _isNeedToReplaceBlock: function(r) {
      return r.tagName === "DIV" && this.utils.isEmptyHtml(r.innerHTML);
    },
    _removeActiveComponent: function(r) {
      var h = this.selection.getCurrent(), u = this.inspector.parse(h), g = u.getComponent();
      if (u.isComponent() && this.component.isActive(g))
        return r.preventDefault(), this.component.remove(g), !0;
    },
    _removeAllSelectedTable: function(r) {
      var h = this.selection.getCurrent(), u = this.inspector.parse(h), g = u.getTable();
      if (g && this.selection.isAll(g))
        return r.preventDefault(), this.component.remove(g), !0;
    },
    _removeUnwantedStyles: function() {
      var r = this.editor.getElement();
      setTimeout(function() {
        var h = r.find("*[style]");
        h.not("img, figure, figcaption, iframe, [data-redactor-style-cache], [data-redactor-span]").removeAttr("style");
      }, 0);
    },
    _removeEmptySpans: function() {
      var r = this.editor.getElement();
      setTimeout(function() {
        r.find("span").each(function(h) {
          h.attributes.length === 0 && c.dom(h).replaceWith(h.childNodes);
        });
      }, 0);
    },
    _removeSpanTagsInHeadings: function() {
      var r = this.editor.getElement();
      setTimeout(function() {
        r.find("h1, h2, h3, h4, h5, h6").each(function(h) {
          var u = c.dom(h);
          u.closest("figure").length === 0 && u.find("span").not(
            ".redactor-component, .non-editable, .redactor-selection-marker, [data-redactor-style-cache], [data-redactor-span]"
          ).unwrap();
        });
      }, 1);
    },
    _removeInlineTagsInPre: function() {
      var r = this.editor.getElement(), h = this.opts.inlineTags;
      setTimeout(function() {
        r.find("pre").each(function(u) {
          var g = c.dom(u);
          g.closest("figure").length === 0 && g.find(h.join(",")).not("code, .redactor-selection-marker").unwrap();
        });
      }, 1);
    }
  }), c.add("class", "input.enter", {
    init: function(r, h) {
      this.app = r, this.opts = r.opts, this.utils = r.utils, this.caret = r.caret, this.editor = r.editor, this.keycodes = r.keycodes, this.detector = r.detector, this.insertion = r.insertion, this.selection = r.selection, this.inspector = r.inspector, this._init(h);
    },
    // private
    _init: function(r) {
      if (!this.opts.enterKey)
        return this._disable(r);
      var h = this.app.broadcast("enter", r);
      if (h === !1)
        return r.preventDefault();
      if (this.selection.hasNonEditable()) {
        r.preventDefault();
        return;
      }
      if (r.ctrlKey || r.shiftKey)
        return this._insertBreak(r);
      this._isExit(r) || this._traverse(r);
    },
    _disable: function(r) {
      r.preventDefault();
      var h = this.selection.getRange();
      h && !h.collapsed && h.deleteContents();
    },
    _insertBreak: function(r) {
      r.preventDefault();
      var h = this.selection.getCurrent(), u = this.selection.getBlock(), g = this.inspector.parse(h);
      if (g.isHeading() && this.caret.isStart(u)) {
        var b = c.dom(u), O = b.clone().html("");
        b.before(O), this.caret.setStart(b);
      } else {
        if (g.isComponent() && !g.isComponentEditable() || g.isCode())
          return;
        g.isPre() ? this.insertion.insertNewline() : this.insertion.insertBreakLine();
      }
    },
    _isExit: function(r) {
      var h = this.editor.getElement(), u = this.selection.getBlock(), g = this.inspector.parse(u), b = this.caret.isEnd(u), O = this.selection.getCurrent(), x = O.previousSibling;
      if (g.isBlockquote()) {
        var S = b && this._isExitableBlock(u, "P"), k = b && this._isExitableDblBreak(x);
        if (S || k)
          return this._exitFromElement(r, k ? x : u, g.getBlockquote());
      } else if (!g.isComponentType("code") && g.isPre()) {
        if (b) {
          var C = u.innerHTML;
          if (C = this.utils.removeInvisibleChars(C), C.match(/(\n\n\n)$/) !== null)
            return c.dom(x.previousSibling.previousSibling).remove(), this._exitFromElement(r, x, u);
        }
      } else if (g.isDl()) {
        if (b && this._isExitableBlock(u, "DT"))
          return this._exitFromElement(r, u, g.getDl());
      } else if (g.isList()) {
        var _ = c.dom(O).parents("ul, ol", h).last();
        if (b = this.caret.isEnd(_), b && this._isExitableBlock(u, "LI"))
          return this._exitFromElement(r, u, _);
      } else if (g.isComponent() && g.isComponentActive() && !g.isFigcaption() && !g.isComponentEditable())
        return this._exitFromElement(r, !1, g.getComponent());
    },
    _isExitableDblBreak: function(r) {
      var h = r ? r.nextSibling : !1;
      if (h) {
        var u = this.utils.removeInvisibleChars(h.textContent);
        return h.nodeType === 3 && u.trim() === "";
      }
    },
    _isExitableBlock: function(r, h) {
      return r && r.tagName === h && this.utils.isEmptyHtml(r.innerHTML);
    },
    _exitFromElement: function(r, h, u) {
      return r.preventDefault(), h && c.dom(h).remove(), this.utils.createMarkup(u), !0;
    },
    _exitNextElement: function(r, h) {
      return r.preventDefault(), h.nextSibling ? this.caret.setStart(h.nextSibling) : this.utils.createMarkup(h), !0;
    },
    _traverse: function(r) {
      var h = this.selection.getCurrent(), u = this.selection.isText(), g = this.selection.getBlock(), b = this.inspector.parse(h), O = g ? g.tagName.toLowerCase() : !1, x = c.dom(h).closest("[data-redactor-type=variable]");
      if (x.length !== 0 && this.caret.setAfter(x), b.isPre())
        return r.preventDefault(), this.insertion.insertNewline();
      if (b.isBlockquote()) {
        if (g = this.selection.getBlock(h), g && g.tagName === "BLOCKQUOTE")
          return r.preventDefault(), this.insertion.insertBreakLine();
      } else if (b.isFigcaption()) {
        g = b.getFigcaption();
        var S = this.caret.isEnd(g), k = this.caret.isEnd();
        if (S || k)
          return this._exitNextElement(r, b.getComponent());
        r.preventDefault();
        return;
      } else {
        if (b.isDl())
          return r.preventDefault(), this._traverseDl(h);
        if (this.opts.breakline && O === "div") {
          setTimeout(this._replaceBlock.bind(this), 1);
          return;
        } else {
          if (u)
            return r.preventDefault(), this.insertion.insertBreakLine();
          if (b.isList())
            return;
          var C = this.detector.isDesktop() ? 50 : 1;
          setTimeout(this._replaceBlock.bind(this), C);
          return;
        }
      }
    },
    _traverseDl: function(r) {
      var h = this.selection.getBlock(r), u = this.inspector.parse(h), g = u.getTag(), b = c.dom(h), O = b.get().nextSibling || !1, x = c.dom(O), S = O && x.is("dd"), k = O && x.is("dt"), C = this.caret.isEnd(h);
      if (g === "dt" && !S && C) {
        var _ = document.createElement("dd");
        b.after(_), this.caret.setStart(_);
        return;
      } else if (g === "dd" && !k && C) {
        var $ = document.createElement("dt");
        b.after($), this.caret.setStart($);
        return;
      }
      return this.insertion.insertBreakLine();
    },
    _replaceBlock: function() {
      var r = this.selection.getBlock(), h = c.dom(r);
      if (this.opts.markup === "p" && r && this._isNeedToReplaceBlock(r)) {
        var u = document.createElement(this.opts.markup);
        h.replaceWith(u), this.caret.setStart(u);
      } else if (r)
        if (this.utils.isEmptyHtml(r.innerHTML))
          this._clearBlock(h, r);
        else {
          var g = this.utils.getFirstNode(r);
          g && g.tagName === "BR" && (c.dom(g).remove(), this.caret.setStart(r));
        }
      h.removeAttr("id"), r && this._isNeedToCleanBlockStyle(r) && this.opts.cleanOnEnter && h.removeAttr("class style"), this.opts.breakline && r && r.tagName;
    },
    _clearBlock: function(r, h) {
      h.tagName === "DIV" && r.find("br").remove(), (this.opts.cleanInlineOnEnter || h.innerHTML === "<br>") && r.html(""), this.caret.setStart(h);
    },
    _isNeedToReplaceBlock: function(r) {
      return r.tagName === "DIV" && this.utils.isEmptyHtml(r.innerHTML);
    },
    _isNeedToCleanBlockStyle: function(r) {
      return r.tagName === "P" && this.utils.isEmptyHtml(r.innerHTML);
    }
  }), c.add("class", "input.paste", {
    init: function(r, h, u, g, b) {
      this.app = r, this.opts = r.opts, this.editor = r.editor, this.cleaner = r.cleaner, this.container = r.container, this.inspector = r.inspector, this.insertion = r.insertion, this.selection = r.selection, this.autoparser = r.autoparser, this.pasteHtml = g, this.pointInserted = b, this.dataTransfer = u, this._init(h);
    },
    // private
    _init: function(r) {
      var h = this.dataTransfer || r.clipboardData, u = this.selection.getCurrent(), g = this.inspector.parse(u);
      if (this.dropPasted = this.dataTransfer, this.isRawCode = g.isPre() || g.isCode(), this.editor.enablePasting(), this.editor.saveScroll(), this.dropPasted || this.selection.saveMarkers(), this.isRawCode || !h) {
        var b;
        !this.isRawCode && !h && window.clipboardData ? b = window.clipboardData.getData("text") : b = h.getData("text/plain"), r.preventDefault(), this._insert(r, b);
        return;
      } else if (this.pasteHtml)
        r.preventDefault(), this._insert(r, this.pasteHtml);
      else {
        var O = h.getData("URL"), x = this._isPlainText(h) ? this.cleaner.encodeEntities(h.getData("text/plain")) : h.getData("text/html");
        if (x = !O || O === "" ? x : O, h.files !== null && h.files.length > 0 && x === "") {
          for (var S = [], k = 0; k < h.files.length; k++) {
            var C = h.files[k] || h.items[k].getAsFile();
            C && S.push(C);
          }
          if (S.length > 0) {
            r.preventDefault(), this._insertFiles(r, S);
            return;
          }
        }
        r.preventDefault(), this._insert(r, x);
      }
    },
    _isPlainText: function(r) {
      var h = r.getData("text/plain"), u = r.getData("text/html");
      if (h && u) {
        var g = document.createElement("div");
        if (g.innerHTML = u, g.textContent === h)
          return !g.querySelector(":not(meta)");
      } else
        return h !== null;
    },
    _restoreSelection: function() {
      this.editor.restoreScroll(), this.editor.disablePasting(), this.dropPasted || this.selection.restoreMarkers();
    },
    _insert: function(r, h) {
      var u = this.app.broadcast("pasteBefore", h);
      if (h = u === void 0 ? h : u, h = h.trim(), h = this.isRawCode ? h : this.cleaner.paste(h), h = h.trim(), h = this.isRawCode ? this.cleaner.encodePhpCode(h) : h, u = this.app.broadcast("pasting", h), h = u === void 0 ? h : u, this._restoreSelection(), !!this.opts.input) {
        this.app.broadcast("state", !1);
        var g = [];
        if (this.isRawCode) {
          h = h.replace("&lt;?php", "<?php");
          var b = document.createTextNode(h);
          g = this.insertion.insertNode(b, "after"), this.app.broadcast("pasted", g);
        } else
          this.opts.autoparse && this.opts.autoparsePaste && (h = this.autoparser.parse(h)), g = this.dropPasted ? this.insertion.insertToPoint(r, h, this.pointInserted) : this.insertion.insertHtml(h), this.app.broadcast("pasted", g), this.app.broadcast("autoparseobserve");
      }
    },
    _insertFiles: function(r, h) {
      this._restoreSelection();
      var u = this.opts.imageTypes.indexOf(h[0].type) !== -1, g = typeof this.dropPasted > "u";
      u ? this.app.broadcast("dropimage", r, h, g) : this.app.broadcast("dropfile", r, h, g);
    }
  }), c.add("class", "input.shortcode", {
    init: function(r, h, u) {
      this.app = r, this.opts = r.opts, this.utils = r.utils, this.marker = r.marker, this.keycodes = r.keycodes, this.selection = r.selection, this.worked = !1, u === this.keycodes.SPACE && this._init();
    },
    // public
    is: function() {
      return this.worked;
    },
    // private
    _init: function() {
      var r = this.selection.getCurrent();
      if (r && r.nodeType === 3) {
        var h = this.utils.removeInvisibleChars(r.textContent), u = this.opts.shortcodes;
        for (var g in u) {
          var b = new RegExp("^" + this.utils.escapeRegExp(g)), O = h.match(b);
          if (O !== null && typeof u[g].format < "u")
            return this._format(u[g].format, r, b);
        }
      }
    },
    _format: function(r, h, u) {
      var g = this.marker.insert("start");
      h = g.previousSibling;
      var b = h.textContent;
      b = this.utils.trimSpaces(b), b = b.replace(u, ""), h.textContent = b;
      var O = r === "ul" || r === "ol" ? "module.list.toggle" : "module.block.format";
      this.app.api(O, r), this.selection.restoreMarkers(), this.worked = !0;
    }
  }), c.add("class", "input.shortcut", {
    init: function(r, h) {
      this.app = r, this.opts = r.opts, this.worked = !1, this.hotkeys = {
        8: "backspace",
        9: "tab",
        10: "return",
        13: "return",
        16: "shift",
        17: "ctrl",
        18: "alt",
        19: "pause",
        20: "capslock",
        27: "esc",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down",
        45: "insert",
        46: "del",
        59: ";",
        61: "=",
        96: "0",
        97: "1",
        98: "2",
        99: "3",
        100: "4",
        101: "5",
        102: "6",
        103: "7",
        104: "8",
        105: "9",
        106: "*",
        107: "+",
        109: "-",
        110: ".",
        111: "/",
        112: "f1",
        113: "f2",
        114: "f3",
        115: "f4",
        116: "f5",
        117: "f6",
        118: "f7",
        119: "f8",
        120: "f9",
        121: "f10",
        122: "f11",
        123: "f12",
        144: "numlock",
        145: "scroll",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'"
      }, this.hotkeysShiftNums = {
        "`": "~",
        1: "!",
        2: "@",
        3: "#",
        4: "$",
        5: "%",
        6: "^",
        7: "&",
        8: "*",
        9: "(",
        0: ")",
        "-": "_",
        "=": "+",
        ";": ": ",
        "'": '"',
        ",": "<",
        ".": ">",
        "/": "?",
        "\\": "|"
      }, this._init(h);
    },
    // public
    is: function() {
      return this.worked;
    },
    // private
    _init: function(r) {
      if (this.opts.shortcuts === !1) {
        (r.ctrlKey || r.metaKey) && (r.which === 66 || r.which === 73) && r.preventDefault();
        return;
      }
      for (var h in this.opts.shortcuts)
        this._build(r, h, this.opts.shortcuts[h]);
    },
    _build: function(r, h, u) {
      for (var g = h.split(","), b = g.length, O = 0; O < b; O++)
        typeof g[O] == "string" && this._handler(r, g[O].trim(), u);
    },
    _handler: function(r, h, u) {
      h = h.toLowerCase().split(" ");
      for (var g = this.hotkeys[r.keyCode], b = String.fromCharCode(r.which).toLowerCase(), O = "", x = {}, S = ["meta", "ctrl", "alt", "shift"], k = 0; k < S.length; k++) {
        var C = S[k];
        r[C + "Key"] && g !== C && (O += C + "+");
      }
      g && (x[O + g] = !0), b && (x[O + b] = !0, x[O + this.hotkeysShiftNums[b]] = !0, O === "shift+" && (x[this.hotkeysShiftNums[b]] = !0));
      for (var _ = h.length, k = 0; k < _; k++)
        if (x[h[k]]) {
          r.preventDefault(), this.worked = !0, u.message ? (this.app.broadcast(u.message, u.args), this.app.broadcast("buffer.trigger")) : u.api && (this.app.api(u.api, u.args), this.app.broadcast("buffer.trigger"));
          return;
        }
    }
  }), c.add("class", "input.space", {
    init: function(r, h, u, g) {
      this.app = r, this.keycodes = r.keycodes, this.insertion = r.insertion, this.selection = r.selection, this.key = u, this.lastShiftKey = g, this._init(h);
    },
    // private
    _init: function(r) {
      if (this.selection.hasNonEditable()) {
        r.preventDefault();
        return;
      }
      if (!this.lastShiftKey && this.key === this.keycodes.SPACE && (r.ctrlKey || r.shiftKey) && !r.metaKey) {
        r.preventDefault(), this.insertion.insertChar("&nbsp;");
        return;
      }
    }
  }), c.add("class", "input.tab", {
    init: function(r, h) {
      this.app = r, this.opts = r.opts, this.inspector = r.inspector, this.insertion = r.insertion, this.selection = r.selection, this._init(h);
    },
    // private
    _init: function(r) {
      if (this.opts.tabKey) {
        var h = this.app.broadcast("tab", r);
        if (h === !1)
          return r.preventDefault();
        this._traverse(r);
      }
    },
    _traverse: function(r) {
      var h = this.selection.getCurrent(), u = this.inspector.parse(h);
      if (!u.isComponent() && r.shiftKey)
        return this._insertHardTab(r, 4);
      if (u.isList())
        return r.preventDefault(), this.app.api("module.list.indent");
      if (u.isPre() || u.isComponentType("code") && !u.isFigcaption())
        return this._tabCode(r);
      if (this.opts.tabAsSpaces !== !1)
        return this._insertHardTab(r, this.opts.tabAsSpaces);
    },
    _insertHardTab: function(r, h) {
      r.preventDefault();
      var u = document.createTextNode(Array(h + 1).join(" "));
      return this.insertion.insertNode(u, "end");
    },
    _tabCode: function(r) {
      r.preventDefault();
      var h = this.opts.preSpaces ? document.createTextNode(Array(this.opts.preSpaces + 1).join(" ")) : document.createTextNode("	");
      return this.insertion.insertNode(h, "end");
    }
  }), c.add("module", "upload", {
    init: function(r) {
      this.app = r, this.opts = r.opts, this.lang = r.lang, this.utils = r.utils, this.editor = r.editor, this.progress = r.progress, this.defaults = {
        event: !1,
        element: !1,
        name: !1,
        files: !1,
        url: !1,
        data: !1,
        paramName: !1
      };
    },
    // public
    build: function(r) {
      this.p = c.extend(this.defaults, r), this.$el = c.dom(this.p.element), this.$el.get().tagName === "INPUT" ? this._buildInput() : this._buildBox();
    },
    send: function(r) {
      this.p = c.extend(this.defaults, r), this.$uploadbox = this.editor.getElement(), this._send(this.p.event, this.p.files);
    },
    complete: function(r, h) {
      this._complete(r, h);
    },
    // private
    _buildInput: function() {
      this.box = !1, this.prefix = "", this.$uploadbox = c.dom('<div class="upload-redactor-box" />'), this.$el.hide(), this.$el.after(this.$uploadbox), this.opts.multipleUpload ? this.$el.attr("multiple", "multiple") : this.$el.removeAttr("multiple"), this.p.name !== "file" && this.$el.attr("accept", "image/*"), this._buildPlaceholder(), this._buildEvents();
    },
    _buildBox: function() {
      this.box = !0, this.prefix = "box-", this.$uploadbox = this.$el, this.$uploadbox.attr("ondragstart", "return false;"), this.$uploadbox.on("drop.redactor.upload", this._onDropBox.bind(this)), this.$uploadbox.on("dragover.redactor.upload", this._onDragOver.bind(this)), this.$uploadbox.on("dragleave.redactor.upload", this._onDragLeave.bind(this));
    },
    _buildPlaceholder: function() {
      this.$placeholder = c.dom('<div class="upload-redactor-placeholder" />'), this.$placeholder.html(this.lang.get("upload-label")), this.$uploadbox.append(this.$placeholder);
    },
    _buildEvents: function() {
      this.$el.on("change.redactor.upload", this._onChange.bind(this)), this.$uploadbox.on("click.redactor.upload", this._onClick.bind(this)), this.$uploadbox.on("drop.redactor.upload", this._onDrop.bind(this)), this.$uploadbox.on("dragover.redactor.upload", this._onDragOver.bind(this)), this.$uploadbox.on("dragleave.redactor.upload", this._onDragLeave.bind(this));
    },
    _onClick: function(r) {
      r.preventDefault(), this.$el.click();
    },
    _onChange: function(r) {
      this._send(r, this.$el.get().files);
    },
    _onDrop: function(r) {
      r.preventDefault(), this._clear(), this._setStatusDrop(), this._send(r);
    },
    _onDragOver: function(r) {
      return r.preventDefault(), this._setStatusHover(), !1;
    },
    _onDragLeave: function(r) {
      return r.preventDefault(), this._removeStatusHover(), !1;
    },
    _onDropBox: function(r) {
      r.preventDefault(), this._clear(), this._setStatusDrop(), this._send(r);
    },
    _removeStatusHover: function() {
      this.$uploadbox.removeClass("upload-redactor-" + this.prefix + "hover");
    },
    _setStatusDrop: function() {
      this.$uploadbox.addClass("upload-redactor-" + this.prefix + "drop");
    },
    _setStatusHover: function() {
      this.$uploadbox.addClass("upload-redactor-" + this.prefix + "hover");
    },
    _setStatusError: function() {
      this.$uploadbox.addClass("upload-redactor-" + this.prefix + "error");
    },
    _setStatusSuccess: function() {
      this.$uploadbox.addClass("upload-redactor-" + this.prefix + "success");
    },
    _clear: function() {
      for (var r = ["drop", "hover", "error", "success"], h = 0; h < r.length; h++)
        this.$uploadbox.removeClass("upload-redactor-" + this.prefix + r[h]);
      this.$uploadbox.removeAttr("ondragstart");
    },
    _send: function(r, h) {
      r = r.originalEvent || r, h = h || r.dataTransfer.files;
      var u = new FormData(), g = this._getUploadParam();
      u = this._buildData(g, h, u), u = this.utils.extendData(u, this.p.data);
      var b = this.app.broadcast("upload.start", r, u, h);
      b !== !1 && this._sendData(u, h, r);
    },
    _sendData: function(r, h, u) {
      if (this.progress.show(), typeof this.p.url == "function") {
        var g = this.p.url(r, h, u, this);
        g instanceof Promise || this._complete(g, u);
      } else
        c.ajax.post({
          url: this.p.url,
          data: r,
          before: (function(b) {
            return this.app.broadcast("upload.beforeSend", b);
          }).bind(this),
          success: (function(b) {
            this._complete(b, u);
          }).bind(this),
          error: (function(b, O, x) {
            this._complete(b, u, x);
          }).bind(this)
        });
    },
    _getUploadParam: function() {
      return this.p.paramName ? this.p.paramName : "file";
    },
    _buildData: function(r, h, u) {
      if (h.length === 1)
        u.append(r + "[]", h[0]);
      else if (h.length > 1 && this.opts.multipleUpload !== !1)
        for (var g = 0; g < h.length; g++)
          u.append(r + "[]", h[g]);
      return u;
    },
    _complete: function(r, h, u) {
      this._clear(), this.progress.hide(), r && r.error ? (this._setStatusError(), this.app.broadcast("upload." + this.p.name + ".error", r, h, u), this.app.broadcast("upload.error", r, u)) : (this._setStatusSuccess(), this.app.broadcast("upload." + this.p.name + ".complete", r, h), this.app.broadcast("upload.complete", r), setTimeout(this._clear.bind(this), 500));
    }
  }), c.add("class", "code.component", {
    mixins: ["dom", "component"],
    init: function(r, h) {
      return this.app = r, h && h.cmnt !== void 0 ? h : this._init(h);
    },
    // private
    _init: function(r) {
      var h;
      if (typeof r < "u") {
        var u = c.dom(r), g = u.closest("figure");
        g.length !== 0 ? this.parse(g) : (this.parse("<figure>"), this.append(r)), h = this.find("pre code, pre").last();
      } else
        h = c.dom("<pre>"), this.parse("<figure>"), this.append(h);
      this._initElement(h), this._initWrapper();
    },
    _initElement: function(r) {
      r.attr({
        tabindex: "-1",
        contenteditable: !0
      });
    },
    _initWrapper: function() {
      this.addClass("redactor-component"), this.attr({
        "data-redactor-type": "code",
        tabindex: "-1",
        contenteditable: !1
      });
    }
  }), c.add("module", "form", {
    init: function(r) {
      this.app = r, this.lang = r.lang, this.component = r.component, this.inspector = r.inspector;
    },
    // messages
    onform: {
      remove: function(r) {
        this._remove(r);
      }
    },
    oncontextbar: function(r, h) {
      var u = this.inspector.parse(r.target);
      if (u.isComponentType("form")) {
        var g = u.getComponent(), b = {
          remove: {
            title: this.lang.get("delete"),
            api: "module.form.remove",
            args: g
          }
        };
        h.set(r, g, b, "top");
      }
    },
    // private
    _remove: function(r) {
      this.component.remove(r);
    }
  }), c.add("class", "form.component", {
    mixins: ["dom", "component"],
    init: function(r, h) {
      return this.app = r, this.utils = r.utils, h && h.cmnt !== void 0 ? h : this._init(h);
    },
    // private
    _init: function(r) {
      if (typeof r < "u") {
        var h = c.dom(r), u = h.closest("form");
        if (u.length !== 0) {
          var g = this.utils.replaceToTag(r, "figure");
          this.parse(g);
        } else
          this.parse("<figure>"), this.append(r);
      } else
        this.parse("<figure>");
      this._initWrapper();
    },
    _initWrapper: function() {
      this.addClass("redactor-component"), this.attr({
        "data-redactor-type": "form",
        tabindex: "-1",
        contenteditable: !1
      });
    }
  }), c.add("module", "image", {
    modals: {
      image: '<div class="redactor-modal-tab redactor-modal-tab-upload" data-title="## upload ##"><form action="">                 <input type="file" name="file">             </form></div>',
      imageedit: '<div class="redactor-modal-group">                 <div id="redactor-modal-image-preview" class="redactor-modal-side"></div>                 <form action="" class="redactor-modal-area">                     <div class="form-item">                         <label for="modal-image-title"> ## title ##</label>                         <input type="text" id="modal-image-title" name="title" />                     </div>                     <div class="form-item form-item-caption">                         <label for="modal-image-caption">## caption ##</label>                         <input type="text" id="modal-image-caption" name="caption" aria-label="## caption ##" />                     </div>                     <div class="form-item form-item-align">                         <label>## image-position ##</label>                         <select name="align" aria-label="## image-position ##">                             <option value="none">## none ##</option>                             <option value="left">## left ##</option>                             <option value="center">## center ##</option>                             <option value="right">## right ##</option>                         </select>                     </div>                     <div class="form-item form-item-link">                         <label for="modal-image-url">## link ##</label>                         <input type="text" id="modal-image-url" name="url" aria-label="## link ##" />                     </div>                     <div class="form-item form-item-link">                         <label class="checkbox"><input type="checkbox" name="target" aria-label="## link-in-new-tab ##"> ## link-in-new-tab ##</label>                     </div>                 </form>             </div>'
    },
    init: function(r) {
      this.app = r, this.opts = r.opts, this.lang = r.lang, this.caret = r.caret, this.utils = r.utils, this.editor = r.editor, this.storage = r.storage, this.component = r.component, this.inspector = r.inspector, this.insertion = r.insertion, this.selection = r.selection, this.justResized = !1;
    },
    // messages
    oninsert: function() {
      this._observeImages();
    },
    onstarted: function() {
      this.storage.observeImages(), this.opts.imageResizable && (this.resizer = c.create("image.resize", this.app)), this._observeImages();
    },
    ondropimage: function(r, h, u) {
      if (this.opts.imageUpload) {
        var g = {
          url: this.opts.imageUpload,
          event: u ? !1 : r,
          files: h,
          name: "imagedrop",
          data: this.opts.imageData,
          paramName: this.opts.imageUploadParam
        };
        this.app.api("module.upload.send", g);
      }
    },
    onstop: function() {
      this.resizer && this.resizer.stop();
    },
    onbottomclick: function() {
      this.insertion.insertToEnd(this.editor.getLastNode(), "image");
    },
    onimageresizer: {
      stop: function() {
        this.resizer && this.resizer.hide();
      }
    },
    onsource: {
      open: function() {
        this.resizer && this.resizer.hide();
      },
      closed: function() {
        this._observeImages(), this.resizer && this.resizer.rebuild();
      }
    },
    onupload: {
      complete: function() {
        this._observeImages();
      },
      image: {
        complete: function(r) {
          this._insert(r), this.app.broadcast("state", !1);
        },
        error: function(r) {
          this._uploadError(r);
        }
      },
      imageedit: {
        complete: function(r) {
          this._change(r);
        },
        error: function(r) {
          this._uploadError(r);
        }
      },
      imagedrop: {
        complete: function(r, h) {
          this._insert(r, h);
        },
        error: function(r) {
          this._uploadError(r);
        }
      },
      imagereplace: {
        complete: function(r) {
          this._change(r, !1);
        },
        error: function(r) {
          this._uploadError(r);
        }
      }
    },
    onmodal: {
      image: {
        open: function(r, h) {
          this._setUpload(r, h);
        }
      },
      imageedit: {
        open: function(r, h) {
          this._setFormData(r, h);
        },
        opened: function(r, h) {
          this._setFormFocus(h);
        },
        remove: function() {
          this._remove(this.$image);
        },
        save: function(r, h) {
          this._save(r, h);
        }
      }
    },
    onimage: {
      observe: function() {
        this._observeImages();
      },
      resized: function() {
        this.justResized = !0;
      }
    },
    oncontextbar: function(r, h) {
      if (this.justResized) {
        this.justResized = !1;
        return;
      }
      var u = this.selection.getCurrent(), g = this.inspector.parse(u), b = c.dom(u).closest("img");
      if (!g.isFigcaption() && g.isComponentType("image") || b.length !== 0) {
        var O = b.length !== 0 ? b.get() : g.getComponent(), x = {
          edit: {
            title: this.lang.get("edit"),
            api: "module.image.open"
          },
          remove: {
            title: this.lang.get("delete"),
            api: "module.image.remove",
            args: O
          }
        };
        h.set(r, O, x);
      }
    },
    // public
    open: function() {
      this.$image = this._getCurrent(), this.app.api("module.modal.build", this._getModalData());
    },
    insert: function(r) {
      this._insert(r);
    },
    remove: function(r) {
      this._remove(r);
    },
    // private
    _getModalData: function() {
      var r;
      return this._isImage() && this.opts.imageEditable ? r = {
        name: "imageedit",
        width: "800px",
        title: this.lang.get("edit"),
        handle: "save",
        commands: {
          save: { title: this.lang.get("save") },
          remove: { title: this.lang.get("delete"), type: "danger" },
          cancel: { title: this.lang.get("cancel") }
        }
      } : r = {
        name: "image",
        title: this.lang.get("image")
      }, r;
    },
    _isImage: function() {
      return this.$image;
    },
    _getCurrent: function() {
      var r = this.selection.getCurrent(), h = this.inspector.parse(r), u = c.dom(r).closest("img");
      return u.length !== 0 ? this.component.create("image", u) : h.isComponentType("image") && h.isComponentActive() ? this.component.create("image", h.getComponent()) : !1;
    },
    _insert: function(r, h) {
      if (this.app.api("module.modal.close"), Array.isArray(r)) {
        for (var u = {}, g = 0; g < r.length; g++)
          u = c.extend(u, r[g]);
        r = u;
      } else
        typeof r == "string" && (r = { file: { url: r } });
      if (typeof r == "object") {
        var b = 0;
        for (var O in r)
          typeof r[O] == "object" && b++;
        b > 1 ? this._insertMultiple(r, h) : this._insertSingle(r, h);
      }
    },
    _insertSingle: function(r, h) {
      for (var u in r)
        if (typeof r[u] == "object") {
          var g = this._createImageAndStore(r[u]), b = h ? this.insertion.insertToPoint(h, g, !1, !1) : this.insertion.insertHtml(g, !1);
          this._removeSpaceBeforeFigure(b[0]), this.component.setActive(b[0]), this.app.broadcast("image.uploaded", b[0], r);
        }
    },
    _insertMultiple: function(r, h) {
      var u = 0, g = [], b;
      for (var O in r)
        if (typeof r[O] == "object") {
          u++;
          var x = this._createImageAndStore(r[O]);
          if (u === 1)
            g = h ? this.insertion.insertToPoint(h, x, !1, !1) : this.insertion.insertHtml(x, !1);
          else {
            var S = c.dom(g[0]);
            S.after(x), g = [x.get()], this.app.broadcast("image.inserted", x);
          }
          b = g[0], this._removeSpaceBeforeFigure(g[0]), this.app.broadcast("image.uploaded", g[0], r);
        }
      this.component.setActive(b);
    },
    _createImageAndStore: function(r) {
      var h = this.component.create("image");
      return h.addClass("redactor-uploaded-figure"), h.setData({
        src: r.url,
        id: r.id ? r.id : this.utils.getRandomId()
      }), this.storage.add("image", h.getElement()), h;
    },
    _removeSpaceBeforeFigure: function(r) {
      if (r) {
        var h = r.previousSibling, u = r.nextSibling, g = c.dom(h), b = c.dom(u);
        this.opts.breakline && (u && b.attr("data-redactor-tag") === "br" && b.find("br").first().remove(), h && g.attr("data-redactor-tag") === "br" && g.find("br").last().remove()), h && (this._removeInvisibleSpace(h), this._removeInvisibleSpace(h.previousSibling));
      }
    },
    _removeInvisibleSpace: function(r) {
      r && r.nodeType === 3 && this.utils.searchInvisibleChars(r.textContent) !== -1 && r.parentNode.removeChild(r);
    },
    _save: function(r, h) {
      var u = h.getData(), g = {
        title: u.title
      };
      this.opts.imageLink && (g.link = { url: u.url, target: u.target }), this.opts.imageCaption && (g.caption = u.caption), this.opts.imagePosition && (g.align = u.align), this.$image.setData(g), this.resizer && this.resizer.rebuild(), this.app.broadcast("image.changed", this.$image), this.app.api("module.modal.close");
    },
    _change: function(r, h) {
      if (typeof r == "string" && (r = { file: { url: r } }), typeof r == "object") {
        var u;
        for (var g in r)
          if (typeof r[g] == "object") {
            u = c.dom("<img>"), u.attr("src", r[g].url), this.$image.changeImage(r[g]), this.app.broadcast("image.changed", this.$image, r), this.app.broadcast("image.uploaded", this.$image, r), this.app.broadcast("hardsync");
            break;
          }
        h !== !1 && u.on(
          "load",
          (function() {
            this.$previewBox.html(u);
          }).bind(this)
        );
      }
    },
    _uploadError: function(r) {
      this.app.broadcast("image.uploadError", r);
    },
    _remove: function(r) {
      this.app.api("module.modal.close"), this.component.remove(r);
    },
    _observeImages: function() {
      var r = this.editor.getElement(), h = this;
      r.find("img").each(function(u) {
        var g = c.dom(u);
        g.off(".drop-to-replace"), g.on("dragover.drop-to-replace dragenter.drop-to-replace", function(b) {
          b.preventDefault();
        }), g.on("drop.drop-to-replace", function(b) {
          if (!h.app.isDragComponentInside())
            return h._setReplaceUpload(b, g);
        });
      });
    },
    _setFormData: function(r, h) {
      this._buildPreview(r), this._buildPreviewUpload();
      var u = this.$image.getData(), g = {
        title: u.title
      };
      this.opts.imageCaption ? g.caption = u.caption : r.find(".form-item-caption").hide(), this.opts.imagePosition ? g.align = u.align : r.find(".form-item-align").hide(), this.opts.imageLink ? u.link && (g.url = u.link.url, u.link.target && (g.target = !0)) : r.find(".form-item-link").hide(), h.setData(g);
    },
    _setFormFocus: function(r) {
      r.getField("title").focus();
    },
    _setReplaceUpload: function(r, h) {
      if (r = r.originalEvent || r, r.stopPropagation(), r.preventDefault(), !!this.opts.imageUpload) {
        this.$image = this.component.create("image", h);
        var u = {
          url: this.opts.imageUpload,
          files: r.dataTransfer.files,
          name: "imagereplace",
          data: this.opts.imageData,
          paramName: this.opts.imageUploadParam
        };
        this.app.api("module.upload.send", u);
      }
    },
    _setUpload: function(r, h) {
      if (!this.opts.imageUpload) {
        var u = r.getBody(), g = u.find(".redactor-modal-tab-upload");
        g.remove();
      }
      var b = {
        url: this.opts.imageUpload,
        element: h.getField("file"),
        name: "image",
        data: this.opts.imageData,
        paramName: this.opts.imageUploadParam
      };
      this.app.api("module.upload.build", b);
    },
    _buildPreview: function(r) {
      this.$preview = r.find("#redactor-modal-image-preview");
      var h = this.$image.getData(), u = c.dom("<img>");
      u.attr("src", h.src), this.$previewBox = c.dom("<div>"), this.$previewBox.append(u), this.$preview.html(""), this.$preview.append(this.$previewBox);
    },
    _buildPreviewUpload: function() {
      if (this.opts.imageUpload) {
        var r = c.dom('<div class="desc">');
        r.html(this.lang.get("upload-change-label")), this.$preview.append(r);
        var h = {
          url: this.opts.imageUpload,
          element: this.$previewBox,
          name: "imageedit",
          data: this.opts.imageData,
          paramName: this.opts.imageUploadParam
        };
        this.app.api("module.upload.build", h);
      }
    }
  }), c.add("class", "image.component", {
    mixins: ["dom", "component"],
    init: function(r, h) {
      return this.app = r, this.opts = r.opts, this.selection = r.selection, h && h.cmnt !== void 0 ? h : this._init(h);
    },
    setData: function(r) {
      for (var h in r)
        this._set(h, r[h]);
    },
    getData: function() {
      for (var r = ["src", "title", "caption", "align", "link", "id"], h = {}, u = 0; u < r.length; u++)
        h[r[u]] = this._get(r[u]);
      return h;
    },
    getElement: function() {
      return this.$element;
    },
    changeImage: function(r) {
      this.$element.attr("src", r.url);
    },
    // private
    _init: function(r) {
      var h = c.dom(r), u = h.closest("figure");
      r === void 0 ? (this.$element = c.dom("<img>"), this.parse("<figure>"), this.append(this.$element)) : u.length === 0 ? (this.parse("<figure>"), this.$element = h, this.$element.wrap(this)) : (this.parse(u), this.$element = this.find("img")), this._initWrapper();
    },
    _set: function(r, h) {
      this["_set_" + r](h);
    },
    _get: function(r) {
      return this["_get_" + r]();
    },
    _set_src: function(r) {
      this.$element.attr("src", r);
    },
    _set_id: function(r) {
      this.opts.imageObserve && this.$element.attr("data-image", r);
    },
    _set_title: function(r) {
      r = r.trim().replace(/(<([^>]+)>)/gi, ""), r === "" ? this.$element.removeAttr("alt") : this.$element.attr("alt", r);
    },
    _set_caption: function(r) {
      var h = this.find("figcaption");
      return h.length === 0 && (h = c.dom("<figcaption>"), h.attr("contenteditable", "true"), this.append(h)), r === "" ? h.remove() : h.html(r), h;
    },
    _set_align: function(r) {
      var h = "", u = "", g = "", b = this, O = this.find("img"), x = this.find("figcaption");
      if (typeof this.opts.imagePosition == "object") {
        var S = this.opts.imagePosition;
        for (var k in S)
          b.removeClass(S[k]);
        var C = typeof S[r] < "u" ? S[r] : !1;
        C && b.addClass(C);
      } else {
        var _ = O.width();
        switch (r) {
          case "left":
            h = "left", u = this.opts.imageFloatMargin;
            break;
          case "right":
            h = "right", u = this.opts.imageFloatMargin;
            break;
          case "center":
            g = "center", u = "auto";
            break;
        }
        b.css({
          float: h,
          width: _ + "px",
          maxWidth: _ + "px",
          "margin-left": u,
          "margin-right": u,
          "text-align": g
        }), b.attr("rel", b.attr("style")), r === "none" && (b.css("max-width", ""), b.css("width", "")), r === "center" ? (b.css("max-width", ""), b.css("width", ""), x.css("text-align", "center")) : x.css("text-align", "");
      }
    },
    _set_link: function(r) {
      var h = this._findLink();
      if (r.url === "") {
        h && h.unwrap();
        return;
      }
      return h || (h = c.dom("<a>"), this.$element.wrap(h)), h.attr("href", r.url), r.target ? h.attr("target", r.target === !0 ? "_blank" : r.target) : h.removeAttr("target"), h;
    },
    _get_src: function() {
      return this.$element.attr("src");
    },
    _get_id: function() {
      return this.$element.attr("data-image");
    },
    _get_title: function() {
      var r = this.$element.attr("alt");
      return r || "";
    },
    _get_caption: function() {
      var r = this.find("figcaption");
      return r.length === 0 ? "" : r.html();
    },
    _get_align: function() {
      var r = "";
      if (typeof this.opts.imagePosition == "object") {
        r = "none";
        var h = this.opts.imagePosition;
        for (var u in h)
          if (this.hasClass(h[u])) {
            r = u;
            break;
          }
      } else
        r = this.css("text-align") === "center" ? "center" : this.css("float");
      return r;
    },
    _get_link: function() {
      var r = this._findLink();
      if (r) {
        var h = !!r.attr("target");
        return {
          url: r.attr("href"),
          target: h
        };
      }
    },
    _initWrapper: function() {
      this.addClass("redactor-component"), this.attr({
        "data-redactor-type": "image",
        tabindex: "-1",
        contenteditable: !1
      });
    },
    _findLink: function() {
      var r = this.find("a").filter(function(h) {
        return c.dom(h).closest("figcaption").length === 0;
      });
      return r.length !== 0 ? r : !1;
    }
  }), c.add("class", "image.resize", {
    init: function(r) {
      this.app = r, this.$doc = r.$doc, this.$win = r.$win, this.$body = r.$body, this.editor = r.editor, this.toolbar = r.toolbar, this.inspector = r.inspector, this.$target = this.toolbar.isTarget() ? this.toolbar.getTargetElement() : this.$body, this._init();
    },
    // public
    rebuild: function() {
      this._setResizerPosition();
    },
    hide: function() {
      this.$target.find("#redactor-image-resizer").remove();
    },
    stop: function() {
      var r = this.editor.getElement();
      r.off(".redactor.image-resize"), this.$doc.off(".redactor.image-resize"), this.$win.off("resize.redactor.image-resize"), this.hide();
    },
    // private
    _init: function() {
      var r = this.editor.getElement();
      r.on("click.redactor.image-resize", this._build.bind(this)), this.$win.on("resize.redactor.image-resize", this._setResizerPosition.bind(this));
    },
    _build: function(r) {
      if (this.$target.find("#redactor-image-resizer").remove(), !this.app.isReadOnly()) {
        var h = this.inspector.parse(r.target), u = this.editor.getElement();
        h.isComponentType("image") && (this.$resizableBox = u, this.$resizableImage = c.dom(h.getImageElement()), this.$resizer = c.dom("<span>"), this.$resizer.attr("id", "redactor-image-resizer"), this.$target.append(this.$resizer), this._setResizerPosition(), this.$resizer.on("mousedown touchstart", this._set.bind(this)));
      }
    },
    _setResizerPosition: function() {
      if (this.$resizer) {
        var r = this.toolbar.isTarget(), h = this.$target.offset(), u = 7, g = r ? u - h.top + this.$target.scrollTop() : u, b = r ? u - h.left : u, O = this.$resizableImage.offset(), x = this.$resizableImage.width(), S = this.$resizableImage.height(), k = this.$resizer.width(), C = this.$resizer.height();
        this.$resizer.css({
          top: Math.round(O.top + S - C + g) + "px",
          left: Math.round(O.left + x - k + b) + "px"
        });
      }
    },
    _set: function(r) {
      r.preventDefault(), this.resizeHandle = {
        x: r.pageX,
        y: r.pageY,
        el: this.$resizableImage,
        $figure: this.$resizableImage.closest("figure"),
        ratio: this.$resizableImage.width() / this.$resizableImage.height(),
        h: this.$resizableImage.height()
      }, r = r.originalEvent || r, r.targetTouches && (this.resizeHandle.x = r.targetTouches[0].pageX, this.resizeHandle.y = r.targetTouches[0].pageY), this.app.broadcast("contextbar.close"), this.app.broadcast("image.resize", this.$resizableImage), this._start();
    },
    _start: function() {
      this.$doc.on("mousemove.redactor.image-resize touchmove.redactor.image-resize", this._move.bind(this)), this.$doc.on("mouseup.redactor.image-resize touchend.redactor.image-resize", this._stop.bind(this));
    },
    _stop: function() {
      this.$doc.off(".redactor.image-resize"), this.app.broadcast("image.resized", this.$resizableImage);
    },
    _move: function(r) {
      r.preventDefault(), r = r.originalEvent || r;
      var h = this.resizeHandle.h;
      r.targetTouches ? h += r.targetTouches[0].pageY - this.resizeHandle.y : h += r.pageY - this.resizeHandle.y;
      var u = h * this.resizeHandle.ratio;
      u = Math.round(u), h = Math.round(h), !(h < 20 || u < 100) && (this._getResizableBoxWidth() <= u || (this.resizeHandle.$figure.length !== 0 && this.resizeHandle.$figure.css("max-width") !== "" && this.resizeHandle.$figure.css({ width: u + "px", "max-width": u + "px" }), this.resizeHandle.el.attr({ width: u, height: h }), this.resizeHandle.el.width(u), this.resizeHandle.el.css("max-width", u + "px"), this.resizeHandle.el.height(h), this._setResizerPosition()));
    },
    _getResizableBoxWidth: function() {
      var r = this.$resizableBox.width();
      return r - parseInt(this.$resizableBox.css("padding-left")) - parseInt(this.$resizableBox.css("padding-right"));
    }
  }), c.add("module", "file", {
    modals: {
      file: '<div class="redactor-modal-tab" data-title="## upload ##"><form action="">                 <div class="form-item form-item-title">                     <label for="modal-file-title"> ## filename ## <span class="desc">(## optional ##)</span></label>                     <input type="text" id="modal-file-title" name="title" />                 </div>                 <input type="file" name="file">             </form></div>'
    },
    init: function(r) {
      this.app = r, this.opts = r.opts, this.lang = r.lang, this.caret = r.caret, this.utils = r.utils, this.storage = r.storage, this.component = r.component, this.inspector = r.inspector, this.insertion = r.insertion, this.selection = r.selection;
    },
    // messages
    onstarted: function() {
      this.storage.observeFiles();
    },
    ondropfile: function(r, h, u) {
      if (this.opts.fileUpload) {
        var g = {
          url: this.opts.fileUpload,
          event: u ? !1 : r,
          files: h,
          name: "filedrop",
          data: this.opts.fileData
        };
        this.app.api("module.upload.send", g);
      }
    },
    onmodal: {
      file: {
        open: function(r, h) {
          this._setFormData(r, h), this._setUpload(h);
        },
        opened: function(r, h) {
          this._setFormFocus(h), this.$form = h;
        }
      }
    },
    onupload: {
      file: {
        complete: function(r) {
          this._insert(r);
        },
        error: function(r) {
          this._uploadError(r);
        }
      },
      filedrop: {
        complete: function(r, h) {
          this._insert(r, h);
        },
        error: function(r) {
          this._uploadError(r);
        }
      }
    },
    // public
    open: function() {
      this._open();
    },
    insert: function(r) {
      this._insert(r);
    },
    remove: function(r) {
      this._remove(r);
    },
    // private
    _open: function() {
      this.app.api("module.modal.build", this._getModalData());
    },
    _getModalData: function() {
      var r = {
        name: "file",
        title: this.lang.get("file")
      };
      return r;
    },
    _insert: function(r, h) {
      if (this.app.api("module.modal.close"), typeof r == "object") {
        if (Array.isArray(r)) {
          for (var u = {}, g = 0; g < r.length; g++)
            u = c.extend(u, r[g]);
          r = u;
        }
        var b = Object.keys(r).length > 1;
        b ? this._insertMultiple(r, h) : this._insertSingle(r, h), this.$form = !1;
      }
    },
    _insertSingle: function(r, h) {
      var u = [];
      for (var g in r) {
        var b = this._createFileAndStore(r[g]);
        this.opts.fileAttachment ? u = this._insertAsAttachment(b) : u = h ? this.insertion.insertToPoint(h, b) : this.insertion.insertRaw(b), this.app.broadcast("file.uploaded", u[0], r);
      }
    },
    _insertMultiple: function(r, h) {
      var u = 0, g = [], b;
      for (var O in r) {
        u++;
        var x = this._createFileAndStore(r[O]);
        if (this.opts.fileAttachment)
          g = this._insertAsAttachment(x, r);
        else if (u === 1)
          g = h ? this.insertion.insertToPoint(h, x) : this.insertion.insertRaw(x);
        else {
          var S = c.dom(g[0]);
          S.after(x).after(" "), g = [x.get()], this.app.broadcast("file.inserted", x);
        }
        b = x, this.app.broadcast("file.uploaded", g[0], r);
      }
      this.opts.fileAttachment || this.caret.setAfter(b);
    },
    _insertAsAttachment: function(r, h) {
      var u = c.dom(this.opts.fileAttachment), g = r.wrapAttachment();
      u.append(g);
      var b = [g.get()];
      return this.app.broadcast("file.appended", b[0], h), b;
    },
    _createFileAndStore: function(r) {
      var h = this.$form ? this.$form.getData() : !1, u = r.name ? r.name : r.url, g = !this.opts.fileAttachment && h && h.title !== "" ? h.title : this._truncateUrl(u), b = this.component.create("file");
      return b.attr("href", r.url), b.attr("data-file", r.id ? r.id : this.utils.getRandomId()), b.attr("data-name", r.name), b.html(g), this.storage.add("file", b), b;
    },
    _remove: function(r) {
      this.selection.save();
      var h = this.component.create("file", r), u = this.app.broadcast("file.delete", h);
      u !== !1 ? (h.unwrap(), this.selection.restore(), this.app.broadcast("file.deleted", h)) : this.selection.restore();
    },
    _truncateUrl: function(r) {
      return r.search(/^http/) !== -1 && r.length > 20 ? r.substring(0, 20) + "..." : r;
    },
    _setUpload: function(r) {
      var h = {
        url: this.opts.fileUpload,
        element: r.getField("file"),
        name: "file",
        data: this.opts.fileData,
        paramName: this.opts.fileUploadParam
      };
      this.app.api("module.upload.build", h);
    },
    _setFormData: function(r, h) {
      this.opts.fileAttachment ? r.find(".form-item-title").hide() : h.setData({ title: this.selection.getText() });
    },
    _setFormFocus: function(r) {
      r.getField("title").focus();
    },
    _uploadError: function(r) {
      this.app.broadcast("file.uploadError", r);
    }
  }), c.add("class", "file.component", {
    mixins: ["dom", "component"],
    init: function(r, h) {
      return this.app = r, this.opts = r.opts, h && h.cmnt !== void 0 ? h : this._init(h);
    },
    wrapAttachment: function() {
      return this.$wrapper = c.dom('<span class="redactor-file-item">'), this.$remover = c.dom('<span class="redactor-file-remover">'), this.$remover.html("&times;"), this.$remover.on("click", this.removeAttachment.bind(this)), this.$wrapper.append(this), this.$wrapper.append(this.$remover), this.$wrapper;
    },
    removeAttachment: function(r) {
      r.preventDefault();
      var h = this.app.broadcast("file.delete", this, this.$wrapper);
      h !== !1 && (this.$wrapper.remove(), this.app.broadcast("file.deleted", this), this.app.broadcast("file.removeAttachment", this));
    },
    // private
    _init: function(r) {
      if (r === void 0)
        this.parse("<a>");
      else {
        var h = c.dom(r).closest("a");
        this.parse(h);
      }
    }
  }), c.add("module", "buffer", {
    init: function(r) {
      this.app = r, this.opts = r.opts, this.editor = r.editor, this.offset = r.offset, this.keycodes = r.keycodes, this.selection = r.selection, this.state = !1, this.passed = !1, this.keyPressed = !1, this.undoStorage = [], this.redoStorage = [];
    },
    // messages
    onkeydown: function(r) {
      this._listen(r);
    },
    onsyncing: function() {
      this.keyPressed || this.trigger(), this.keyPressed = !1;
    },
    onbuffer: {
      trigger: function() {
        this.trigger();
      }
    },
    onstate: function(r, h, u) {
      r && (r.ctrlKey || r.metaKey) || r && (this._isUndo(r) || this._isRedo(r)) || (this.passed = !1, this._saveState(h, u), r === !1 && this._setUndo());
    },
    onenable: function() {
      this.clear();
    },
    // public
    clear: function() {
      this.state = !1, this.undoStorage = [], this.redoStorage = [];
    },
    undo: function() {
      this._getUndo();
    },
    redo: function() {
      this._getRedo();
    },
    trigger: function() {
      this.state && this.passed === !1 && this._setUndo();
    },
    // private
    _saveState: function(r, h) {
      var u = this.editor.getElement();
      this.state = {
        html: r || u.html(),
        offset: h || this.offset.get()
      };
    },
    _listen: function(r) {
      var h = r.which, u = r.ctrlKey || r.metaKey, g = u || r.shiftKey || r.altKey, b = [
        this.keycodes.SPACE,
        this.keycodes.ENTER,
        this.keycodes.BACKSPACE,
        this.keycodes.DELETE,
        this.keycodes.TAB,
        this.keycodes.LEFT,
        this.keycodes.RIGHT,
        this.keycodes.UP,
        this.keycodes.DOWN
      ];
      if (this._isUndo(r)) {
        r.preventDefault(), this.undo();
        return;
      } else if (this._isRedo(r)) {
        r.preventDefault(), this.redo();
        return;
      } else
        !u && b.indexOf(h) !== -1 ? (g = !0, this.trigger()) : u && (h === 88 || h === 67) && (g = !0, this.trigger());
      !g && !this._hasUndo() && this.trigger(), this.keyPressed = !0;
    },
    _isUndo: function(r) {
      var h = r.which, u = r.ctrlKey || r.metaKey;
      return u && h === 90 && !r.shiftKey && !r.altKey;
    },
    _isRedo: function(r) {
      var h = r.which, u = r.ctrlKey || r.metaKey;
      return u && (h === 90 && r.shiftKey || h === 89 && !r.shiftKey) && !r.altKey;
    },
    _setUndo: function() {
      var r = this.undoStorage[this.undoStorage.length - 1];
      (typeof r > "u" || r[0] !== this.state.html) && (this.undoStorage.push([this.state.html, this.state.offset]), this._removeOverStorage());
    },
    _setRedo: function() {
      var r = this.editor.getElement(), h = this.offset.get(), u = r.html();
      this.redoStorage.push([u, h]), this.redoStorage = this.redoStorage.slice(0, this.opts.bufferLimit);
    },
    _getUndo: function() {
      if (this._hasUndo()) {
        this.passed = !0;
        var r = this.editor.getElement(), h = this.undoStorage.pop();
        this._setRedo(), r.html(h[0]), this.offset.set(h[1]), this._saveState(h[0], h[1]), this.app.broadcast("undo", h[0], h[1]);
      }
    },
    _getRedo: function() {
      if (this._hasRedo()) {
        this.passed = !0;
        var r = this.editor.getElement(), h = this.redoStorage.pop();
        this._setUndo(), r.html(h[0]), this.offset.set(h[1]), this._saveState(h[0], h[1]), this.app.broadcast("redo", h[0], h[1]);
      }
    },
    _removeOverStorage: function() {
      this.undoStorage.length > this.opts.bufferLimit && (this.undoStorage = this.undoStorage.slice(0, this.undoStorage.length - this.opts.bufferLimit));
    },
    _hasUndo: function() {
      return this.undoStorage.length !== 0;
    },
    _hasRedo: function() {
      return this.redoStorage.length !== 0;
    }
  }), c.add("module", "list", {
    init: function(r) {
      this.app = r, this.uuid = r.uuid, this.opts = r.opts, this.utils = r.utils, this.block = r.block, this.editor = r.editor, this.toolbar = r.toolbar, this.inspector = r.inspector, this.selection = r.selection;
    },
    // messages
    onbutton: {
      list: {
        observe: function(r) {
          this._observeButton(r);
        }
      }
    },
    ondropdown: {
      list: {
        observe: function(r) {
          this._observeDropdown(r);
        }
      }
    },
    // public
    toggle: function(r) {
      var h = this._getBlocks(), u = this.selection.getBlock(), g = c.dom(u).parents("ul, ol", this.editor.getElement()).last();
      return h.length === 0 && g.length !== 0 && (h = [g.get()]), u && (u.tagName === "TD" || u.tagName === "TH") && (h = this.block.format("div")), this.selection.saveMarkers(), h = h.length !== 0 && this._isUnformat(r, h) ? this._unformat(r, h) : this._format(r, h), this.selection.restoreMarkers(), h;
    },
    indent: function() {
      var r = this.selection.isCollapsed(), h = this.selection.getCurrent(), u = this.inspector.parse(h), g = u.isList() ? u.getListItem() : !1, b = c.dom(g), O = b.prevElement(), x = O.get(), S = r && g && x && x.tagName === "LI";
      if (S) {
        this.selection.saveMarkers(), O = c.dom(x);
        var k = O.children("ul, ol"), C = b.closest("ul, ol");
        if (k.length !== 0)
          k.append(b);
        else {
          var _ = C.get().tagName.toLowerCase(), $ = c.dom("<" + _ + ">");
          $.append(b), O.append($);
        }
        this.selection.restoreMarkers(), this.utils.isEmptyHtml(b.html()) && this.app.caret.setStart(b);
      }
    },
    outdent: function() {
      var r = this.selection.isCollapsed(), h = this.selection.getCurrent(), u = this.inspector.parse(h), g = u.isList() ? u.getListItem() : !1, b = c.dom(g);
      if (r && g) {
        var O = b.parent(), x = O.closest("li", ".redactor-in-" + this.uuid), S = b.prevElement(), k = b.nextElement(), C = S.get(), _ = k.get(), $, L, E, A, y = C === !1, w = C !== !1 && _ !== !1, T = !y && _ === !1;
        if (this.selection.saveMarkers(), x.length !== 0)
          if (w) {
            $ = this._getAllNext(b.get()), E = c.dom("<" + O.get().tagName.toLowerCase() + ">");
            for (var P = 0; P < $.length; P++)
              E.append($[P]);
            x.after(b), b.append(E);
          } else
            x.after(b), O.children().length === 0 ? O.remove() : y && b.append(O);
        else {
          var R = this._createUnformatContainer(b), Q = R.find("ul, ol").first();
          if (y)
            O.before(R);
          else if (T)
            O.after(R);
          else if (w) {
            E = c.dom("<" + O.get().tagName.toLowerCase() + ">"), $ = this._getAllNext(b.get());
            for (var P = 0; P < $.length; P++)
              E.append($[P]);
            O.after(R), R.after(E);
          }
          Q.length !== 0 && (A = R.nextElement(), L = A.get(), L && L.tagName === O.get().tagName ? (c.dom(L).prepend(Q), Q.unwrap()) : R.after(Q)), b.remove();
        }
        this.selection.restoreMarkers();
      }
    },
    // private
    _getAllNext: function(r) {
      for (var h = []; r; ) {
        var u = c.dom(r).nextElement();
        if (r = u.get(), r)
          h.push(r);
        else
          return h;
      }
      return h;
    },
    _isUnformat: function(r, h) {
      for (var u = 0, g = 0; g < h.length; g++)
        if (h[g].nodeType !== 3) {
          var b = h[g].tagName.toLowerCase();
          (b === r || b === "figure") && u++;
        }
      return u === h.length;
    },
    _format: function(r, h) {
      var u = ["p", "div", "blockquote", "pre", "h1", "h2", "h3", "h4", "h5", "h6", "ul", "ol"], g = this._uniteBlocks(h, u), b = [];
      for (var O in g) {
        for (var x = g[O], S = this._createList(r, g[O]), k = 0; k < x.length; k++) {
          var C;
          if (x[k].nodeType !== 3 && (x[k].tagName === "UL" || x[k].tagName === "OL")) {
            var _ = c.dom(x[k]);
            C = _.contents(), S.append(C), this.utils.isEmpty(_) && _.remove();
          } else {
            C = this._createListItem(x[k]);
            var $ = C.get().lastChild;
            $ && $.tagName === "BR" && c.dom($).remove(), this.utils.normalizeTextNodes(C), S.append(C);
          }
        }
        b.push(S.get());
      }
      return b;
    },
    _uniteBlocks: function(r, h) {
      for (var u = 0, g = { 0: [] }, b = !1, O = 0; O < r.length; O++) {
        var x = c.dom(r[O]), S = x.closest("th, td");
        S.length !== 0 ? (S.get() !== b && (u++, g[u] = []), this._isUniteBlock(r[O], h) && g[u].push(r[O])) : this._isUniteBlock(r[O], h) ? g[u].push(r[O]) : (u++, g[u] = []), b = S.get();
      }
      return g;
    },
    _isUniteBlock: function(r, h) {
      return r.nodeType === 3 || h.indexOf(r.tagName.toLowerCase()) !== -1;
    },
    _createList: function(r, h) {
      var u = h[h.length - 1], g = c.dom(u), b = c.dom("<" + r + ">");
      return g.after(b), b;
    },
    _createListItem: function(r) {
      var h = c.dom("<li>");
      if (r.nodeType === 3)
        h.append(r);
      else {
        var u = c.dom(r);
        h.append(u.contents()), u.remove();
      }
      return h;
    },
    _unformat: function(r, h) {
      if (h.length === 1) {
        var u = c.dom(h[0]), g = u.find("li"), b = this.selection.getNodes({ tags: ["li"] }), O = this.selection.getBlock(), x = c.dom(O).closest("li");
        if (b.length === 0 && x.length !== 0 && (b = [x.get()]), b.length === g.length)
          return this._unformatEntire(h[0]);
        var S = this._getItemsPosition(g, b);
        if (S === "Top")
          return this._unformatAtSide("before", b, u);
        if (S === "Bottom")
          return b.reverse(), this._unformatAtSide("after", b, u);
        if (S === "Middle") {
          var k = c.dom(b[b.length - 1]), C = !1, _ = !1, $ = c.dom("<" + u.get().tagName.toLowerCase() + ">");
          g.each(function(y) {
            if (C) {
              var w = c.dom(y);
              w.closest(".redactor-split-item").length === 0 && (_ === !1 || w.closest(_).length === 0) && w.addClass("redactor-split-item"), _ = w;
            }
            y === k.get() && (C = !0);
          }), g.filter(".redactor-split-item").each(function(y) {
            var w = c.dom(y);
            w.removeClass("redactor-split-item"), $.append(y);
          }), u.after($), b.reverse();
          for (var L = 0; L < b.length; L++) {
            var E = c.dom(b[L]), A = this._createUnformatContainer(E);
            u.after(A), A.find("ul, ol").remove(), E.remove();
          }
          return;
        }
      } else
        for (var L = 0; L < h.length; L++)
          h[L].nodeType !== 3 && h[L].tagName.toLowerCase() === r && this._unformatEntire(h[L]);
    },
    _unformatEntire: function(r) {
      var h = c.dom(r), u = h.find("li");
      u.each(
        (function(g) {
          var b = c.dom(g), O = this._createUnformatContainer(b);
          b.remove(), h.before(O);
        }).bind(this)
      ), h.remove();
    },
    _unformatAtSide: function(r, h, u) {
      for (var g = 0; g < h.length; g++) {
        var b = c.dom(h[g]), O = this._createUnformatContainer(b);
        u[r](O);
        var x = O.find("ul, ol").first();
        b.append(x), x.each(function(S) {
          var k = c.dom(S), C = k.closest("li");
          C.get() === h[g] && (k.unwrap(), C.addClass("r-unwrapped"));
        }), this.utils.isEmptyHtml(b.html()) && b.remove();
      }
      u.find(".r-unwrapped").each(function(S) {
        var k = c.dom(S);
        k.html().trim() === "" ? k.remove() : k.removeClass("r-unwrapped");
      });
    },
    _getItemsPosition: function(r, h) {
      var u = "Middle", g = h[0], b = h[h.length - 1], O = r.first().get(), x = r.last().get();
      return O === g && x !== b ? u = "Top" : O !== g && x === b && (u = "Bottom"), u;
    },
    _createUnformatContainer: function(r) {
      var h = c.dom("<" + this.opts.markup + ">");
      return this.opts.breakline && h.attr("data-redactor-tag", "br"), h.append(r.contents()), h;
    },
    _getBlocks: function() {
      return this.selection.getBlocks({ first: !0 });
    },
    _observeButton: function() {
      var r = this.selection.getCurrent(), h = this.inspector.parse(r), u = h.isPre() || h.isCode() || h.isFigcaption();
      this._observeButtonsList(u, ["lists", "ul", "ol", "outdent", "indent"]);
      var g = this.toolbar.getButton("outdent"), b = this.toolbar.getButton("indent");
      this._observeIndent(b, g);
    },
    _observeDropdown: function(r) {
      var h = r.getItem("outdent"), u = r.getItem("indent");
      this._observeIndent(u, h);
    },
    _observeIndent: function(r, h) {
      var u = this.selection.isCollapsed(), g = this.selection.getCurrent(), b = this.inspector.parse(g), O = b.isList() ? b.getListItem() : !1, x = c.dom(O), S = x.prevElement(), k = S.get(), C = u && O && k && k.tagName === "LI";
      h && (O && u ? h.enable() : h.disable()), r && (O && C ? r.enable() : r.disable());
    },
    _observeButtonsList: function(r, h) {
      for (var u = 0; u < h.length; u++) {
        var g = this.toolbar.getButton(h[u]);
        g && (r ? g.disable() : g.enable());
      }
    }
  }), c.add("class", "video.component", {
    mixins: ["dom", "component"],
    init: function(r, h) {
      return this.app = r, h && h.cmnt !== void 0 ? h : this._init(h);
    },
    // private
    _init: function(r) {
      if (typeof r < "u") {
        var h = c.dom(r), u = h.closest("figure");
        u.length !== 0 ? this.parse(u) : (this.parse("<figure>"), this.append(r));
      } else
        this.parse("<figure>");
      this._initWrapper();
    },
    _initWrapper: function() {
      this.addClass("redactor-component"), this.attr({
        "data-redactor-type": "video",
        tabindex: "-1",
        contenteditable: !1
      });
    }
  }), c.add("class", "widget.component", {
    mixins: ["dom", "component"],
    init: function(r, h) {
      return this.app = r, h && h.cmnt !== void 0 ? h : this._init(h);
    },
    getData: function() {
      return {
        html: this._getHtml()
      };
    },
    // private
    _init: function(r) {
      if (typeof r < "u") {
        var h = c.dom(r), u = h.closest("figure");
        u.length !== 0 ? this.parse(u) : (this.parse("<figure>"), this.html(r));
      } else
        this.parse("<figure>");
      this._initWrapper();
    },
    _getHtml: function() {
      var r = c.dom("<div>");
      return r.html(this.html()), r.find(".redactor-component-caret").remove(), r.html();
    },
    _initWrapper: function() {
      this.addClass("redactor-component"), this.attr({
        "data-redactor-type": "widget",
        tabindex: "-1",
        contenteditable: !1
      });
    }
  });
  var v = c;
  window.Redactor = window.$R = c, window.addEventListener("load", function() {
    c("[data-redactor]");
  }), typeof module == "object" && module.exports && (module.exports = v, module.exports.Redactor = v);
})();
(function(a) {
  a.add("plugin", "alignment", {
    translations: {
      en: {
        align: "Align",
        "align-left": "Align Left",
        "align-center": "Align Center",
        "align-right": "Align Right",
        "align-justify": "Align Justify"
      }
    },
    init: function(e) {
      this.app = e, this.opts = e.opts, this.lang = e.lang, this.block = e.block, this.toolbar = e.toolbar;
    },
    // public
    start: function() {
      var e = {};
      e.left = { title: this.lang.get("align-left"), api: "plugin.alignment.set", args: "left" }, e.center = { title: this.lang.get("align-center"), api: "plugin.alignment.set", args: "center" }, e.right = { title: this.lang.get("align-right"), api: "plugin.alignment.set", args: "right" }, e.justify = { title: this.lang.get("align-justify"), api: "plugin.alignment.set", args: "justify" };
      var t = this.toolbar.addButton("alignment", { title: this.lang.get("align") });
      t.setIcon('<i class="re-icon-alignment"></i>'), t.setDropdown(e);
    },
    set: function(e) {
      if (e === "left" && this.opts.direction === "ltr")
        return this._remove();
      var t = {
        style: { "text-align": e }
      };
      this.block.toggle(t);
    },
    // private
    _remove: function() {
      this.block.remove({ style: "text-align" });
    }
  });
})(Redactor);
const _$ = { class: "ui-form-richtext" }, C$ = ["for"], T$ = ["name", "placeholder", "value"], wH = j({
  __name: "FormRichtext",
  props: {
    modelValue: {},
    name: {},
    placeholder: {},
    label: {},
    height: { default: 120 },
    config: {},
    configCallbacks: {}
  },
  emits: ["update:modelValue", "update"],
  setup(a, { emit: e }) {
    var d;
    const t = a, i = e;
    let s, n = !1;
    const o = `ui-form-richtext-${(d = yt()) == null ? void 0 : d.uid}`, l = Object.assign(
      {
        lang: "pt_br",
        toolbarFixed: !1,
        imagePosition: !0,
        imageResizable: !0,
        tabAsSpaces: 4,
        plugins: ["source", "video", "table", "alignment", "fullscreen", "imagemanager"],
        buttons: ["html", "formatting", "bold", "italic", "lists", "link", "horizontalrule", "image"],
        maxHeight: "600px",
        minHeight: `${t.height}px`,
        multipleUpload: !1,
        callbacks: Object.assign(
          {
            focus: function() {
              n = !0;
            },
            blur: function() {
              n = !1;
            },
            changed: (f) => (i("update:modelValue", f), f)
          },
          t.configCallbacks
        )
      },
      t.config
    ), c = () => {
      s && s.editor.focus();
    };
    return at(() => {
      s = $R(`#${o}`, l);
    }), Lt(() => {
      const f = t.modelValue;
      s && !n && s.editor.source.setCode(f);
    }), $m(() => {
      setTimeout(() => {
        $R(`#${o}`, "destroy"), s = null;
      }, 300);
    }), (f, p) => (M(), D("div", _$, [
      f.label ? (M(), D("label", {
        key: 0,
        for: f.name,
        class: "form-control-label",
        onClick: c
      }, ne(f.label), 9, C$)) : X("", !0),
      I("textarea", {
        name: f.name,
        placeholder: f.placeholder,
        value: f.modelValue,
        id: o
      }, null, 8, T$)
    ]));
  }
});
class pn extends Error {
}
class A$ extends pn {
  constructor(e) {
    super(`Invalid DateTime: ${e.toMessage()}`);
  }
}
class $$ extends pn {
  constructor(e) {
    super(`Invalid Interval: ${e.toMessage()}`);
  }
}
class E$ extends pn {
  constructor(e) {
    super(`Invalid Duration: ${e.toMessage()}`);
  }
}
class An extends pn {
}
class Tb extends pn {
  constructor(e) {
    super(`Invalid unit ${e}`);
  }
}
class Yt extends pn {
}
class ps extends pn {
  constructor() {
    super("Zone is an abstract class");
  }
}
const le = "numeric", Ei = "short", si = "long", Co = {
  year: le,
  month: le,
  day: le
}, Ab = {
  year: le,
  month: Ei,
  day: le
}, P$ = {
  year: le,
  month: Ei,
  day: le,
  weekday: Ei
}, $b = {
  year: le,
  month: si,
  day: le
}, Eb = {
  year: le,
  month: si,
  day: le,
  weekday: si
}, Pb = {
  hour: le,
  minute: le
}, Lb = {
  hour: le,
  minute: le,
  second: le
}, Mb = {
  hour: le,
  minute: le,
  second: le,
  timeZoneName: Ei
}, Db = {
  hour: le,
  minute: le,
  second: le,
  timeZoneName: si
}, Rb = {
  hour: le,
  minute: le,
  hourCycle: "h23"
}, Ib = {
  hour: le,
  minute: le,
  second: le,
  hourCycle: "h23"
}, Qb = {
  hour: le,
  minute: le,
  second: le,
  hourCycle: "h23",
  timeZoneName: Ei
}, Nb = {
  hour: le,
  minute: le,
  second: le,
  hourCycle: "h23",
  timeZoneName: si
}, Fb = {
  year: le,
  month: le,
  day: le,
  hour: le,
  minute: le
}, Wb = {
  year: le,
  month: le,
  day: le,
  hour: le,
  minute: le,
  second: le
}, Bb = {
  year: le,
  month: Ei,
  day: le,
  hour: le,
  minute: le
}, zb = {
  year: le,
  month: Ei,
  day: le,
  hour: le,
  minute: le,
  second: le
}, L$ = {
  year: le,
  month: Ei,
  day: le,
  weekday: Ei,
  hour: le,
  minute: le
}, Xb = {
  year: le,
  month: si,
  day: le,
  hour: le,
  minute: le,
  timeZoneName: Ei
}, Yb = {
  year: le,
  month: si,
  day: le,
  hour: le,
  minute: le,
  second: le,
  timeZoneName: Ei
}, Vb = {
  year: le,
  month: si,
  day: le,
  weekday: si,
  hour: le,
  minute: le,
  timeZoneName: si
}, Hb = {
  year: le,
  month: si,
  day: le,
  weekday: si,
  hour: le,
  minute: le,
  second: le,
  timeZoneName: si
};
class fa {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ps();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new ps();
  }
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new ps();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(e, t) {
    throw new ps();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(e, t) {
    throw new ps();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(e) {
    throw new ps();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(e) {
    throw new ps();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new ps();
  }
}
let oc = null;
class bl extends fa {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    return oc === null && (oc = new bl()), oc;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName(e, { format: t, locale: i }) {
    return tv(e, t, i);
  }
  /** @override **/
  formatOffset(e, t) {
    return Rr(this.offset(e), t);
  }
  /** @override **/
  offset(e) {
    return -new Date(e).getTimezoneOffset();
  }
  /** @override **/
  equals(e) {
    return e.type === "system";
  }
  /** @override **/
  get isValid() {
    return !0;
  }
}
let ho = {};
function M$(a) {
  return ho[a] || (ho[a] = new Intl.DateTimeFormat("en-US", {
    hour12: !1,
    timeZone: a,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    era: "short"
  })), ho[a];
}
const D$ = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function R$(a, e) {
  const t = a.format(e).replace(/\u200E/g, ""), i = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(t), [, s, n, o, l, c, d, f] = i;
  return [o, s, n, l, c, d, f];
}
function I$(a, e) {
  const t = a.formatToParts(e), i = [];
  for (let s = 0; s < t.length; s++) {
    const { type: n, value: o } = t[s], l = D$[n];
    n === "era" ? i[l] = o : Te(l) || (i[l] = parseInt(o, 10));
  }
  return i;
}
let Qa = {};
class ns extends fa {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(e) {
    return Qa[e] || (Qa[e] = new ns(e)), Qa[e];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    Qa = {}, ho = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
   * @return {boolean}
   */
  static isValidSpecifier(e) {
    return this.isValidZone(e);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(e) {
    if (!e)
      return !1;
    try {
      return new Intl.DateTimeFormat("en-US", { timeZone: e }).format(), !0;
    } catch {
      return !1;
    }
  }
  constructor(e) {
    super(), this.zoneName = e, this.valid = ns.isValidZone(e);
  }
  /** @override **/
  get type() {
    return "iana";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName(e, { format: t, locale: i }) {
    return tv(e, t, i, this.name);
  }
  /** @override **/
  formatOffset(e, t) {
    return Rr(this.offset(e), t);
  }
  /** @override **/
  offset(e) {
    const t = new Date(e);
    if (isNaN(t))
      return NaN;
    const i = M$(this.name);
    let [s, n, o, l, c, d, f] = i.formatToParts ? I$(i, t) : R$(i, t);
    l === "BC" && (s = -Math.abs(s) + 1);
    const m = yl({
      year: s,
      month: n,
      day: o,
      hour: c === 24 ? 0 : c,
      minute: d,
      second: f,
      millisecond: 0
    });
    let v = +t;
    const r = v % 1e3;
    return v -= r >= 0 ? r : 1e3 + r, (m - v) / (60 * 1e3);
  }
  /** @override **/
  equals(e) {
    return e.type === "iana" && e.name === this.name;
  }
  /** @override **/
  get isValid() {
    return this.valid;
  }
}
let vf = {};
function Q$(a, e = {}) {
  const t = JSON.stringify([a, e]);
  let i = vf[t];
  return i || (i = new Intl.ListFormat(a, e), vf[t] = i), i;
}
let ch = {};
function hh(a, e = {}) {
  const t = JSON.stringify([a, e]);
  let i = ch[t];
  return i || (i = new Intl.DateTimeFormat(a, e), ch[t] = i), i;
}
let dh = {};
function N$(a, e = {}) {
  const t = JSON.stringify([a, e]);
  let i = dh[t];
  return i || (i = new Intl.NumberFormat(a, e), dh[t] = i), i;
}
let uh = {};
function F$(a, e = {}) {
  const { base: t, ...i } = e, s = JSON.stringify([a, i]);
  let n = uh[s];
  return n || (n = new Intl.RelativeTimeFormat(a, e), uh[s] = n), n;
}
let Sr = null;
function W$() {
  return Sr || (Sr = new Intl.DateTimeFormat().resolvedOptions().locale, Sr);
}
let yf = {};
function B$(a) {
  let e = yf[a];
  if (!e) {
    const t = new Intl.Locale(a);
    e = "getWeekInfo" in t ? t.getWeekInfo() : t.weekInfo, yf[a] = e;
  }
  return e;
}
function z$(a) {
  const e = a.indexOf("-x-");
  e !== -1 && (a = a.substring(0, e));
  const t = a.indexOf("-u-");
  if (t === -1)
    return [a];
  {
    let i, s;
    try {
      i = hh(a).resolvedOptions(), s = a;
    } catch {
      const c = a.substring(0, t);
      i = hh(c).resolvedOptions(), s = c;
    }
    const { numberingSystem: n, calendar: o } = i;
    return [s, n, o];
  }
}
function X$(a, e, t) {
  return (t || e) && (a.includes("-u-") || (a += "-u"), t && (a += `-ca-${t}`), e && (a += `-nu-${e}`)), a;
}
function Y$(a) {
  const e = [];
  for (let t = 1; t <= 12; t++) {
    const i = tt.utc(2009, t, 1);
    e.push(a(i));
  }
  return e;
}
function V$(a) {
  const e = [];
  for (let t = 1; t <= 7; t++) {
    const i = tt.utc(2016, 11, 13 + t);
    e.push(a(i));
  }
  return e;
}
function Na(a, e, t, i) {
  const s = a.listingMode();
  return s === "error" ? null : s === "en" ? t(e) : i(e);
}
function H$(a) {
  return a.numberingSystem && a.numberingSystem !== "latn" ? !1 : a.numberingSystem === "latn" || !a.locale || a.locale.startsWith("en") || new Intl.DateTimeFormat(a.intl).resolvedOptions().numberingSystem === "latn";
}
class G$ {
  constructor(e, t, i) {
    this.padTo = i.padTo || 0, this.floor = i.floor || !1;
    const { padTo: s, floor: n, ...o } = i;
    if (!t || Object.keys(o).length > 0) {
      const l = { useGrouping: !1, ...i };
      i.padTo > 0 && (l.minimumIntegerDigits = i.padTo), this.inf = N$(e, l);
    }
  }
  format(e) {
    if (this.inf) {
      const t = this.floor ? Math.floor(e) : e;
      return this.inf.format(t);
    } else {
      const t = this.floor ? Math.floor(e) : Id(e, 3);
      return ut(t, this.padTo);
    }
  }
}
class j$ {
  constructor(e, t, i) {
    this.opts = i, this.originalZone = void 0;
    let s;
    if (this.opts.timeZone)
      this.dt = e;
    else if (e.zone.type === "fixed") {
      const o = -1 * (e.offset / 60), l = o >= 0 ? `Etc/GMT+${o}` : `Etc/GMT${o}`;
      e.offset !== 0 && ns.create(l).valid ? (s = l, this.dt = e) : (s = "UTC", this.dt = e.offset === 0 ? e : e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone);
    } else
      e.zone.type === "system" ? this.dt = e : e.zone.type === "iana" ? (this.dt = e, s = e.zone.name) : (s = "UTC", this.dt = e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone);
    const n = { ...this.opts };
    n.timeZone = n.timeZone || s, this.dtf = hh(t, n);
  }
  format() {
    return this.originalZone ? this.formatToParts().map(({ value: e }) => e).join("") : this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const e = this.dtf.formatToParts(this.dt.toJSDate());
    return this.originalZone ? e.map((t) => {
      if (t.type === "timeZoneName") {
        const i = this.originalZone.offsetName(this.dt.ts, {
          locale: this.dt.locale,
          format: this.opts.timeZoneName
        });
        return {
          ...t,
          value: i
        };
      } else
        return t;
    }) : e;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class U$ {
  constructor(e, t, i) {
    this.opts = { style: "long", ...i }, !t && Jb() && (this.rtf = F$(e, i));
  }
  format(e, t) {
    return this.rtf ? this.rtf.format(e, t) : gE(t, e, this.opts.numeric, this.opts.style !== "long");
  }
  formatToParts(e, t) {
    return this.rtf ? this.rtf.formatToParts(e, t) : [];
  }
}
const Z$ = {
  firstDay: 1,
  minimalDays: 4,
  weekend: [6, 7]
};
class Be {
  static fromOpts(e) {
    return Be.create(
      e.locale,
      e.numberingSystem,
      e.outputCalendar,
      e.weekSettings,
      e.defaultToEN
    );
  }
  static create(e, t, i, s, n = !1) {
    const o = e || ct.defaultLocale, l = o || (n ? "en-US" : W$()), c = t || ct.defaultNumberingSystem, d = i || ct.defaultOutputCalendar, f = fh(s) || ct.defaultWeekSettings;
    return new Be(l, c, d, f, o);
  }
  static resetCache() {
    Sr = null, ch = {}, dh = {}, uh = {};
  }
  static fromObject({ locale: e, numberingSystem: t, outputCalendar: i, weekSettings: s } = {}) {
    return Be.create(e, t, i, s);
  }
  constructor(e, t, i, s, n) {
    const [o, l, c] = z$(e);
    this.locale = o, this.numberingSystem = t || l || null, this.outputCalendar = i || c || null, this.weekSettings = s, this.intl = X$(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = { format: {}, standalone: {} }, this.monthsCache = { format: {}, standalone: {} }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = n, this.fastNumbersCached = null;
  }
  get fastNumbers() {
    return this.fastNumbersCached == null && (this.fastNumbersCached = H$(this)), this.fastNumbersCached;
  }
  listingMode() {
    const e = this.isEnglish(), t = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return e && t ? "en" : "intl";
  }
  clone(e) {
    return !e || Object.getOwnPropertyNames(e).length === 0 ? this : Be.create(
      e.locale || this.specifiedLocale,
      e.numberingSystem || this.numberingSystem,
      e.outputCalendar || this.outputCalendar,
      fh(e.weekSettings) || this.weekSettings,
      e.defaultToEN || !1
    );
  }
  redefaultToEN(e = {}) {
    return this.clone({ ...e, defaultToEN: !0 });
  }
  redefaultToSystem(e = {}) {
    return this.clone({ ...e, defaultToEN: !1 });
  }
  months(e, t = !1) {
    return Na(this, e, nv, () => {
      const i = t ? { month: e, day: "numeric" } : { month: e }, s = t ? "format" : "standalone";
      return this.monthsCache[s][e] || (this.monthsCache[s][e] = Y$((n) => this.extract(n, i, "month"))), this.monthsCache[s][e];
    });
  }
  weekdays(e, t = !1) {
    return Na(this, e, ov, () => {
      const i = t ? { weekday: e, year: "numeric", month: "long", day: "numeric" } : { weekday: e }, s = t ? "format" : "standalone";
      return this.weekdaysCache[s][e] || (this.weekdaysCache[s][e] = V$(
        (n) => this.extract(n, i, "weekday")
      )), this.weekdaysCache[s][e];
    });
  }
  meridiems() {
    return Na(
      this,
      void 0,
      () => lv,
      () => {
        if (!this.meridiemCache) {
          const e = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [tt.utc(2016, 11, 13, 9), tt.utc(2016, 11, 13, 19)].map(
            (t) => this.extract(t, e, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(e) {
    return Na(this, e, cv, () => {
      const t = { era: e };
      return this.eraCache[e] || (this.eraCache[e] = [tt.utc(-40, 1, 1), tt.utc(2017, 1, 1)].map(
        (i) => this.extract(i, t, "era")
      )), this.eraCache[e];
    });
  }
  extract(e, t, i) {
    const s = this.dtFormatter(e, t), n = s.formatToParts(), o = n.find((l) => l.type.toLowerCase() === i);
    return o ? o.value : null;
  }
  numberFormatter(e = {}) {
    return new G$(this.intl, e.forceSimple || this.fastNumbers, e);
  }
  dtFormatter(e, t = {}) {
    return new j$(e, this.intl, t);
  }
  relFormatter(e = {}) {
    return new U$(this.intl, this.isEnglish(), e);
  }
  listFormatter(e = {}) {
    return Q$(this.intl, e);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  getWeekSettings() {
    return this.weekSettings ? this.weekSettings : ev() ? B$(this.locale) : Z$;
  }
  getStartOfWeek() {
    return this.getWeekSettings().firstDay;
  }
  getMinDaysInFirstWeek() {
    return this.getWeekSettings().minimalDays;
  }
  getWeekendDays() {
    return this.getWeekSettings().weekend;
  }
  equals(e) {
    return this.locale === e.locale && this.numberingSystem === e.numberingSystem && this.outputCalendar === e.outputCalendar;
  }
}
let lc = null;
class Ft extends fa {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    return lc === null && (lc = new Ft(0)), lc;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(e) {
    return e === 0 ? Ft.utcInstance : new Ft(e);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(e) {
    if (e) {
      const t = e.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (t)
        return new Ft(Ol(t[1], t[2]));
    }
    return null;
  }
  constructor(e) {
    super(), this.fixed = e;
  }
  /** @override **/
  get type() {
    return "fixed";
  }
  /** @override **/
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${Rr(this.fixed, "narrow")}`;
  }
  get ianaName() {
    return this.fixed === 0 ? "Etc/UTC" : `Etc/GMT${Rr(-this.fixed, "narrow")}`;
  }
  /** @override **/
  offsetName() {
    return this.name;
  }
  /** @override **/
  formatOffset(e, t) {
    return Rr(this.fixed, t);
  }
  /** @override **/
  get isUniversal() {
    return !0;
  }
  /** @override **/
  offset() {
    return this.fixed;
  }
  /** @override **/
  equals(e) {
    return e.type === "fixed" && e.fixed === this.fixed;
  }
  /** @override **/
  get isValid() {
    return !0;
  }
}
class q$ extends fa {
  constructor(e) {
    super(), this.zoneName = e;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return !1;
  }
  /** @override **/
  get isValid() {
    return !1;
  }
}
function xs(a, e) {
  if (Te(a) || a === null)
    return e;
  if (a instanceof fa)
    return a;
  if (eE(a)) {
    const t = a.toLowerCase();
    return t === "default" ? e : t === "local" || t === "system" ? bl.instance : t === "utc" || t === "gmt" ? Ft.utcInstance : Ft.parseSpecifier(t) || ns.create(a);
  } else
    return Js(a) ? Ft.instance(a) : typeof a == "object" && "offset" in a && typeof a.offset == "function" ? a : new q$(a);
}
let Of = () => Date.now(), xf = "system", wf = null, Sf = null, kf = null, _f = 60, Cf, Tf = null;
class ct {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return Of;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(e) {
    Of = e;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(e) {
    xf = e;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return xs(xf, bl.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return wf;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(e) {
    wf = e;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return Sf;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(e) {
    Sf = e;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return kf;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(e) {
    kf = e;
  }
  /**
   * @typedef {Object} WeekSettings
   * @property {number} firstDay
   * @property {number} minimalDays
   * @property {number[]} weekend
   */
  /**
   * @return {WeekSettings|null}
   */
  static get defaultWeekSettings() {
    return Tf;
  }
  /**
   * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
   * how many days are required in the first week of a year.
   * Does not affect existing instances.
   *
   * @param {WeekSettings|null} weekSettings
   */
  static set defaultWeekSettings(e) {
    Tf = fh(e);
  }
  /**
   * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return _f;
  }
  /**
   * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpreted as current century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
   */
  static set twoDigitCutoffYear(e) {
    _f = e % 100;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return Cf;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(e) {
    Cf = e;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Be.resetCache(), ns.resetCache();
  }
}
class ki {
  constructor(e, t) {
    this.reason = e, this.explanation = t;
  }
  toMessage() {
    return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason;
  }
}
const Gb = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], jb = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function di(a, e) {
  return new ki(
    "unit out of range",
    `you specified ${e} (of type ${typeof e}) as a ${a}, which is invalid`
  );
}
function Md(a, e, t) {
  const i = new Date(Date.UTC(a, e - 1, t));
  a < 100 && a >= 0 && i.setUTCFullYear(i.getUTCFullYear() - 1900);
  const s = i.getUTCDay();
  return s === 0 ? 7 : s;
}
function Ub(a, e, t) {
  return t + (pa(a) ? jb : Gb)[e - 1];
}
function Zb(a, e) {
  const t = pa(a) ? jb : Gb, i = t.findIndex((n) => n < e), s = e - t[i];
  return { month: i + 1, day: s };
}
function Dd(a, e) {
  return (a - e + 7) % 7 + 1;
}
function To(a, e = 4, t = 1) {
  const { year: i, month: s, day: n } = a, o = Ub(i, s, n), l = Dd(Md(i, s, n), t);
  let c = Math.floor((o - l + 14 - e) / 7), d;
  return c < 1 ? (d = i - 1, c = Gr(d, e, t)) : c > Gr(i, e, t) ? (d = i + 1, c = 1) : d = i, { weekYear: d, weekNumber: c, weekday: l, ...xl(a) };
}
function Af(a, e = 4, t = 1) {
  const { weekYear: i, weekNumber: s, weekday: n } = a, o = Dd(Md(i, 1, e), t), l = Rn(i);
  let c = s * 7 + n - o - 7 + e, d;
  c < 1 ? (d = i - 1, c += Rn(d)) : c > l ? (d = i + 1, c -= Rn(i)) : d = i;
  const { month: f, day: p } = Zb(d, c);
  return { year: d, month: f, day: p, ...xl(a) };
}
function cc(a) {
  const { year: e, month: t, day: i } = a, s = Ub(e, t, i);
  return { year: e, ordinal: s, ...xl(a) };
}
function $f(a) {
  const { year: e, ordinal: t } = a, { month: i, day: s } = Zb(e, t);
  return { year: e, month: i, day: s, ...xl(a) };
}
function Ef(a, e) {
  if (!Te(a.localWeekday) || !Te(a.localWeekNumber) || !Te(a.localWeekYear)) {
    if (!Te(a.weekday) || !Te(a.weekNumber) || !Te(a.weekYear))
      throw new An(
        "Cannot mix locale-based week fields with ISO-based week fields"
      );
    return Te(a.localWeekday) || (a.weekday = a.localWeekday), Te(a.localWeekNumber) || (a.weekNumber = a.localWeekNumber), Te(a.localWeekYear) || (a.weekYear = a.localWeekYear), delete a.localWeekday, delete a.localWeekNumber, delete a.localWeekYear, {
      minDaysInFirstWeek: e.getMinDaysInFirstWeek(),
      startOfWeek: e.getStartOfWeek()
    };
  } else
    return { minDaysInFirstWeek: 4, startOfWeek: 1 };
}
function K$(a, e = 4, t = 1) {
  const i = vl(a.weekYear), s = ui(
    a.weekNumber,
    1,
    Gr(a.weekYear, e, t)
  ), n = ui(a.weekday, 1, 7);
  return i ? s ? n ? !1 : di("weekday", a.weekday) : di("week", a.weekNumber) : di("weekYear", a.weekYear);
}
function J$(a) {
  const e = vl(a.year), t = ui(a.ordinal, 1, Rn(a.year));
  return e ? t ? !1 : di("ordinal", a.ordinal) : di("year", a.year);
}
function qb(a) {
  const e = vl(a.year), t = ui(a.month, 1, 12), i = ui(a.day, 1, Ao(a.year, a.month));
  return e ? t ? i ? !1 : di("day", a.day) : di("month", a.month) : di("year", a.year);
}
function Kb(a) {
  const { hour: e, minute: t, second: i, millisecond: s } = a, n = ui(e, 0, 23) || e === 24 && t === 0 && i === 0 && s === 0, o = ui(t, 0, 59), l = ui(i, 0, 59), c = ui(s, 0, 999);
  return n ? o ? l ? c ? !1 : di("millisecond", s) : di("second", i) : di("minute", t) : di("hour", e);
}
function Te(a) {
  return typeof a > "u";
}
function Js(a) {
  return typeof a == "number";
}
function vl(a) {
  return typeof a == "number" && a % 1 === 0;
}
function eE(a) {
  return typeof a == "string";
}
function tE(a) {
  return Object.prototype.toString.call(a) === "[object Date]";
}
function Jb() {
  try {
    return typeof Intl < "u" && !!Intl.RelativeTimeFormat;
  } catch {
    return !1;
  }
}
function ev() {
  try {
    return typeof Intl < "u" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
  } catch {
    return !1;
  }
}
function iE(a) {
  return Array.isArray(a) ? a : [a];
}
function Pf(a, e, t) {
  if (a.length !== 0)
    return a.reduce((i, s) => {
      const n = [e(s), s];
      return i && t(i[0], n[0]) === i[0] ? i : n;
    }, null)[1];
}
function sE(a, e) {
  return e.reduce((t, i) => (t[i] = a[i], t), {});
}
function Xn(a, e) {
  return Object.prototype.hasOwnProperty.call(a, e);
}
function fh(a) {
  if (a == null)
    return null;
  if (typeof a != "object")
    throw new Yt("Week settings must be an object");
  if (!ui(a.firstDay, 1, 7) || !ui(a.minimalDays, 1, 7) || !Array.isArray(a.weekend) || a.weekend.some((e) => !ui(e, 1, 7)))
    throw new Yt("Invalid week settings");
  return {
    firstDay: a.firstDay,
    minimalDays: a.minimalDays,
    weekend: Array.from(a.weekend)
  };
}
function ui(a, e, t) {
  return vl(a) && a >= e && a <= t;
}
function nE(a, e) {
  return a - e * Math.floor(a / e);
}
function ut(a, e = 2) {
  const t = a < 0;
  let i;
  return t ? i = "-" + ("" + -a).padStart(e, "0") : i = ("" + a).padStart(e, "0"), i;
}
function vs(a) {
  if (!(Te(a) || a === null || a === ""))
    return parseInt(a, 10);
}
function Bs(a) {
  if (!(Te(a) || a === null || a === ""))
    return parseFloat(a);
}
function Rd(a) {
  if (!(Te(a) || a === null || a === "")) {
    const e = parseFloat("0." + a) * 1e3;
    return Math.floor(e);
  }
}
function Id(a, e, t = !1) {
  const i = 10 ** e;
  return (t ? Math.trunc : Math.round)(a * i) / i;
}
function pa(a) {
  return a % 4 === 0 && (a % 100 !== 0 || a % 400 === 0);
}
function Rn(a) {
  return pa(a) ? 366 : 365;
}
function Ao(a, e) {
  const t = nE(e - 1, 12) + 1, i = a + (e - t) / 12;
  return t === 2 ? pa(i) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][t - 1];
}
function yl(a) {
  let e = Date.UTC(
    a.year,
    a.month - 1,
    a.day,
    a.hour,
    a.minute,
    a.second,
    a.millisecond
  );
  return a.year < 100 && a.year >= 0 && (e = new Date(e), e.setUTCFullYear(a.year, a.month - 1, a.day)), +e;
}
function Lf(a, e, t) {
  return -Dd(Md(a, 1, e), t) + e - 1;
}
function Gr(a, e = 4, t = 1) {
  const i = Lf(a, e, t), s = Lf(a + 1, e, t);
  return (Rn(a) - i + s) / 7;
}
function ph(a) {
  return a > 99 ? a : a > ct.twoDigitCutoffYear ? 1900 + a : 2e3 + a;
}
function tv(a, e, t, i = null) {
  const s = new Date(a), n = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  i && (n.timeZone = i);
  const o = { timeZoneName: e, ...n }, l = new Intl.DateTimeFormat(t, o).formatToParts(s).find((c) => c.type.toLowerCase() === "timezonename");
  return l ? l.value : null;
}
function Ol(a, e) {
  let t = parseInt(a, 10);
  Number.isNaN(t) && (t = 0);
  const i = parseInt(e, 10) || 0, s = t < 0 || Object.is(t, -0) ? -i : i;
  return t * 60 + s;
}
function iv(a) {
  const e = Number(a);
  if (typeof a == "boolean" || a === "" || Number.isNaN(e))
    throw new Yt(`Invalid unit value ${a}`);
  return e;
}
function $o(a, e) {
  const t = {};
  for (const i in a)
    if (Xn(a, i)) {
      const s = a[i];
      if (s == null)
        continue;
      t[e(i)] = iv(s);
    }
  return t;
}
function Rr(a, e) {
  const t = Math.trunc(Math.abs(a / 60)), i = Math.trunc(Math.abs(a % 60)), s = a >= 0 ? "+" : "-";
  switch (e) {
    case "short":
      return `${s}${ut(t, 2)}:${ut(i, 2)}`;
    case "narrow":
      return `${s}${t}${i > 0 ? `:${i}` : ""}`;
    case "techie":
      return `${s}${ut(t, 2)}${ut(i, 2)}`;
    default:
      throw new RangeError(`Value format ${e} is out of range for property format`);
  }
}
function xl(a) {
  return sE(a, ["hour", "minute", "second", "millisecond"]);
}
const rE = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
], sv = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
], aE = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function nv(a) {
  switch (a) {
    case "narrow":
      return [...aE];
    case "short":
      return [...sv];
    case "long":
      return [...rE];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const rv = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
], av = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], oE = ["M", "T", "W", "T", "F", "S", "S"];
function ov(a) {
  switch (a) {
    case "narrow":
      return [...oE];
    case "short":
      return [...av];
    case "long":
      return [...rv];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const lv = ["AM", "PM"], lE = ["Before Christ", "Anno Domini"], cE = ["BC", "AD"], hE = ["B", "A"];
function cv(a) {
  switch (a) {
    case "narrow":
      return [...hE];
    case "short":
      return [...cE];
    case "long":
      return [...lE];
    default:
      return null;
  }
}
function dE(a) {
  return lv[a.hour < 12 ? 0 : 1];
}
function uE(a, e) {
  return ov(e)[a.weekday - 1];
}
function fE(a, e) {
  return nv(e)[a.month - 1];
}
function pE(a, e) {
  return cv(e)[a.year < 0 ? 0 : 1];
}
function gE(a, e, t = "always", i = !1) {
  const s = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  }, n = ["hours", "minutes", "seconds"].indexOf(a) === -1;
  if (t === "auto" && n) {
    const p = a === "days";
    switch (e) {
      case 1:
        return p ? "tomorrow" : `next ${s[a][0]}`;
      case -1:
        return p ? "yesterday" : `last ${s[a][0]}`;
      case 0:
        return p ? "today" : `this ${s[a][0]}`;
    }
  }
  const o = Object.is(e, -0) || e < 0, l = Math.abs(e), c = l === 1, d = s[a], f = i ? c ? d[1] : d[2] || d[1] : c ? s[a][0] : a;
  return o ? `${l} ${f} ago` : `in ${l} ${f}`;
}
function Mf(a, e) {
  let t = "";
  for (const i of a)
    i.literal ? t += i.val : t += e(i.val);
  return t;
}
const mE = {
  D: Co,
  DD: Ab,
  DDD: $b,
  DDDD: Eb,
  t: Pb,
  tt: Lb,
  ttt: Mb,
  tttt: Db,
  T: Rb,
  TT: Ib,
  TTT: Qb,
  TTTT: Nb,
  f: Fb,
  ff: Bb,
  fff: Xb,
  ffff: Vb,
  F: Wb,
  FF: zb,
  FFF: Yb,
  FFFF: Hb
};
class Rt {
  static create(e, t = {}) {
    return new Rt(e, t);
  }
  static parseFormat(e) {
    let t = null, i = "", s = !1;
    const n = [];
    for (let o = 0; o < e.length; o++) {
      const l = e.charAt(o);
      l === "'" ? (i.length > 0 && n.push({ literal: s || /^\s+$/.test(i), val: i }), t = null, i = "", s = !s) : s || l === t ? i += l : (i.length > 0 && n.push({ literal: /^\s+$/.test(i), val: i }), i = l, t = l);
    }
    return i.length > 0 && n.push({ literal: s || /^\s+$/.test(i), val: i }), n;
  }
  static macroTokenToFormatOpts(e) {
    return mE[e];
  }
  constructor(e, t) {
    this.opts = t, this.loc = e, this.systemLoc = null;
  }
  formatWithSystemDefault(e, t) {
    return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(e, { ...this.opts, ...t }).format();
  }
  dtFormatter(e, t = {}) {
    return this.loc.dtFormatter(e, { ...this.opts, ...t });
  }
  formatDateTime(e, t) {
    return this.dtFormatter(e, t).format();
  }
  formatDateTimeParts(e, t) {
    return this.dtFormatter(e, t).formatToParts();
  }
  formatInterval(e, t) {
    return this.dtFormatter(e.start, t).dtf.formatRange(e.start.toJSDate(), e.end.toJSDate());
  }
  resolvedOptions(e, t) {
    return this.dtFormatter(e, t).resolvedOptions();
  }
  num(e, t = 0) {
    if (this.opts.forceSimple)
      return ut(e, t);
    const i = { ...this.opts };
    return t > 0 && (i.padTo = t), this.loc.numberFormatter(i).format(e);
  }
  formatDateTimeFromString(e, t) {
    const i = this.loc.listingMode() === "en", s = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", n = (v, r) => this.loc.extract(e, v, r), o = (v) => e.isOffsetFixed && e.offset === 0 && v.allowZ ? "Z" : e.isValid ? e.zone.formatOffset(e.ts, v.format) : "", l = () => i ? dE(e) : n({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), c = (v, r) => i ? fE(e, v) : n(r ? { month: v } : { month: v, day: "numeric" }, "month"), d = (v, r) => i ? uE(e, v) : n(
      r ? { weekday: v } : { weekday: v, month: "long", day: "numeric" },
      "weekday"
    ), f = (v) => {
      const r = Rt.macroTokenToFormatOpts(v);
      return r ? this.formatWithSystemDefault(e, r) : v;
    }, p = (v) => i ? pE(e, v) : n({ era: v }, "era"), m = (v) => {
      switch (v) {
        case "S":
          return this.num(e.millisecond);
        case "u":
        case "SSS":
          return this.num(e.millisecond, 3);
        case "s":
          return this.num(e.second);
        case "ss":
          return this.num(e.second, 2);
        case "uu":
          return this.num(Math.floor(e.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(e.millisecond / 100));
        case "m":
          return this.num(e.minute);
        case "mm":
          return this.num(e.minute, 2);
        case "h":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12);
        case "hh":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12, 2);
        case "H":
          return this.num(e.hour);
        case "HH":
          return this.num(e.hour, 2);
        case "Z":
          return o({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return o({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return o({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return e.zone.offsetName(e.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return e.zone.offsetName(e.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return e.zoneName;
        case "a":
          return l();
        case "d":
          return s ? n({ day: "numeric" }, "day") : this.num(e.day);
        case "dd":
          return s ? n({ day: "2-digit" }, "day") : this.num(e.day, 2);
        case "c":
          return this.num(e.weekday);
        case "ccc":
          return d("short", !0);
        case "cccc":
          return d("long", !0);
        case "ccccc":
          return d("narrow", !0);
        case "E":
          return this.num(e.weekday);
        case "EEE":
          return d("short", !1);
        case "EEEE":
          return d("long", !1);
        case "EEEEE":
          return d("narrow", !1);
        case "L":
          return s ? n({ month: "numeric", day: "numeric" }, "month") : this.num(e.month);
        case "LL":
          return s ? n({ month: "2-digit", day: "numeric" }, "month") : this.num(e.month, 2);
        case "LLL":
          return c("short", !0);
        case "LLLL":
          return c("long", !0);
        case "LLLLL":
          return c("narrow", !0);
        case "M":
          return s ? n({ month: "numeric" }, "month") : this.num(e.month);
        case "MM":
          return s ? n({ month: "2-digit" }, "month") : this.num(e.month, 2);
        case "MMM":
          return c("short", !1);
        case "MMMM":
          return c("long", !1);
        case "MMMMM":
          return c("narrow", !1);
        case "y":
          return s ? n({ year: "numeric" }, "year") : this.num(e.year);
        case "yy":
          return s ? n({ year: "2-digit" }, "year") : this.num(e.year.toString().slice(-2), 2);
        case "yyyy":
          return s ? n({ year: "numeric" }, "year") : this.num(e.year, 4);
        case "yyyyyy":
          return s ? n({ year: "numeric" }, "year") : this.num(e.year, 6);
        case "G":
          return p("short");
        case "GG":
          return p("long");
        case "GGGGG":
          return p("narrow");
        case "kk":
          return this.num(e.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(e.weekYear, 4);
        case "W":
          return this.num(e.weekNumber);
        case "WW":
          return this.num(e.weekNumber, 2);
        case "n":
          return this.num(e.localWeekNumber);
        case "nn":
          return this.num(e.localWeekNumber, 2);
        case "ii":
          return this.num(e.localWeekYear.toString().slice(-2), 2);
        case "iiii":
          return this.num(e.localWeekYear, 4);
        case "o":
          return this.num(e.ordinal);
        case "ooo":
          return this.num(e.ordinal, 3);
        case "q":
          return this.num(e.quarter);
        case "qq":
          return this.num(e.quarter, 2);
        case "X":
          return this.num(Math.floor(e.ts / 1e3));
        case "x":
          return this.num(e.ts);
        default:
          return f(v);
      }
    };
    return Mf(Rt.parseFormat(t), m);
  }
  formatDurationFromString(e, t) {
    const i = (c) => {
      switch (c[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, s = (c) => (d) => {
      const f = i(d);
      return f ? this.num(c.get(f), d.length) : d;
    }, n = Rt.parseFormat(t), o = n.reduce(
      (c, { literal: d, val: f }) => d ? c : c.concat(f),
      []
    ), l = e.shiftTo(...o.map(i).filter((c) => c));
    return Mf(n, s(l));
  }
}
const hv = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function rr(...a) {
  const e = a.reduce((t, i) => t + i.source, "");
  return RegExp(`^${e}$`);
}
function ar(...a) {
  return (e) => a.reduce(
    ([t, i, s], n) => {
      const [o, l, c] = n(e, s);
      return [{ ...t, ...o }, l || i, c];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function or(a, ...e) {
  if (a == null)
    return [null, null];
  for (const [t, i] of e) {
    const s = t.exec(a);
    if (s)
      return i(s);
  }
  return [null, null];
}
function dv(...a) {
  return (e, t) => {
    const i = {};
    let s;
    for (s = 0; s < a.length; s++)
      i[a[s]] = vs(e[t + s]);
    return [i, null, t + s];
  };
}
const uv = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/, bE = `(?:${uv.source}?(?:\\[(${hv.source})\\])?)?`, Qd = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, fv = RegExp(`${Qd.source}${bE}`), Nd = RegExp(`(?:T${fv.source})?`), vE = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, yE = /(\d{4})-?W(\d\d)(?:-?(\d))?/, OE = /(\d{4})-?(\d{3})/, xE = dv("weekYear", "weekNumber", "weekDay"), wE = dv("year", "ordinal"), SE = /(\d{4})-(\d\d)-(\d\d)/, pv = RegExp(
  `${Qd.source} ?(?:${uv.source}|(${hv.source}))?`
), kE = RegExp(`(?: ${pv.source})?`);
function In(a, e, t) {
  const i = a[e];
  return Te(i) ? t : vs(i);
}
function _E(a, e) {
  return [{
    year: In(a, e),
    month: In(a, e + 1, 1),
    day: In(a, e + 2, 1)
  }, null, e + 3];
}
function lr(a, e) {
  return [{
    hours: In(a, e, 0),
    minutes: In(a, e + 1, 0),
    seconds: In(a, e + 2, 0),
    milliseconds: Rd(a[e + 3])
  }, null, e + 4];
}
function ga(a, e) {
  const t = !a[e] && !a[e + 1], i = Ol(a[e + 1], a[e + 2]), s = t ? null : Ft.instance(i);
  return [{}, s, e + 3];
}
function ma(a, e) {
  const t = a[e] ? ns.create(a[e]) : null;
  return [{}, t, e + 1];
}
const CE = RegExp(`^T?${Qd.source}$`), TE = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function AE(a) {
  const [e, t, i, s, n, o, l, c, d] = a, f = e[0] === "-", p = c && c[0] === "-", m = (v, r = !1) => v !== void 0 && (r || v && f) ? -v : v;
  return [
    {
      years: m(Bs(t)),
      months: m(Bs(i)),
      weeks: m(Bs(s)),
      days: m(Bs(n)),
      hours: m(Bs(o)),
      minutes: m(Bs(l)),
      seconds: m(Bs(c), c === "-0"),
      milliseconds: m(Rd(d), p)
    }
  ];
}
const $E = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function Fd(a, e, t, i, s, n, o) {
  const l = {
    year: e.length === 2 ? ph(vs(e)) : vs(e),
    month: sv.indexOf(t) + 1,
    day: vs(i),
    hour: vs(s),
    minute: vs(n)
  };
  return o && (l.second = vs(o)), a && (l.weekday = a.length > 3 ? rv.indexOf(a) + 1 : av.indexOf(a) + 1), l;
}
const EE = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function PE(a) {
  const [
    ,
    e,
    t,
    i,
    s,
    n,
    o,
    l,
    c,
    d,
    f,
    p
  ] = a, m = Fd(e, s, i, t, n, o, l);
  let v;
  return c ? v = $E[c] : d ? v = 0 : v = Ol(f, p), [m, new Ft(v)];
}
function LE(a) {
  return a.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
const ME = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, DE = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, RE = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function Df(a) {
  const [, e, t, i, s, n, o, l] = a;
  return [Fd(e, s, i, t, n, o, l), Ft.utcInstance];
}
function IE(a) {
  const [, e, t, i, s, n, o, l] = a;
  return [Fd(e, l, t, i, s, n, o), Ft.utcInstance];
}
const QE = rr(vE, Nd), NE = rr(yE, Nd), FE = rr(OE, Nd), WE = rr(fv), gv = ar(
  _E,
  lr,
  ga,
  ma
), BE = ar(
  xE,
  lr,
  ga,
  ma
), zE = ar(
  wE,
  lr,
  ga,
  ma
), XE = ar(
  lr,
  ga,
  ma
);
function YE(a) {
  return or(
    a,
    [QE, gv],
    [NE, BE],
    [FE, zE],
    [WE, XE]
  );
}
function VE(a) {
  return or(LE(a), [EE, PE]);
}
function HE(a) {
  return or(
    a,
    [ME, Df],
    [DE, Df],
    [RE, IE]
  );
}
function GE(a) {
  return or(a, [TE, AE]);
}
const jE = ar(lr);
function UE(a) {
  return or(a, [CE, jE]);
}
const ZE = rr(SE, kE), qE = rr(pv), KE = ar(
  lr,
  ga,
  ma
);
function JE(a) {
  return or(
    a,
    [ZE, gv],
    [qE, KE]
  );
}
const Rf = "Invalid Duration", mv = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
}, eP = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...mv
}, oi = 146097 / 400, yn = 146097 / 4800, tP = {
  years: {
    quarters: 4,
    months: 12,
    weeks: oi / 7,
    days: oi,
    hours: oi * 24,
    minutes: oi * 24 * 60,
    seconds: oi * 24 * 60 * 60,
    milliseconds: oi * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: oi / 28,
    days: oi / 4,
    hours: oi * 24 / 4,
    minutes: oi * 24 * 60 / 4,
    seconds: oi * 24 * 60 * 60 / 4,
    milliseconds: oi * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: yn / 7,
    days: yn,
    hours: yn * 24,
    minutes: yn * 24 * 60,
    seconds: yn * 24 * 60 * 60,
    milliseconds: yn * 24 * 60 * 60 * 1e3
  },
  ...mv
}, Us = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
], iP = Us.slice(0).reverse();
function gs(a, e, t = !1) {
  const i = {
    values: t ? e.values : { ...a.values, ...e.values || {} },
    loc: a.loc.clone(e.loc),
    conversionAccuracy: e.conversionAccuracy || a.conversionAccuracy,
    matrix: e.matrix || a.matrix
  };
  return new De(i);
}
function bv(a, e) {
  let t = e.milliseconds ?? 0;
  for (const i of iP.slice(1))
    e[i] && (t += e[i] * a[i].milliseconds);
  return t;
}
function If(a, e) {
  const t = bv(a, e) < 0 ? -1 : 1;
  Us.reduceRight((i, s) => {
    if (Te(e[s]))
      return i;
    if (i) {
      const n = e[i] * t, o = a[s][i], l = Math.floor(n / o);
      e[s] += l * t, e[i] -= l * o * t;
    }
    return s;
  }, null), Us.reduce((i, s) => {
    if (Te(e[s]))
      return i;
    if (i) {
      const n = e[i] % 1;
      e[i] -= n, e[s] += n * a[i][s];
    }
    return s;
  }, null);
}
function sP(a) {
  const e = {};
  for (const [t, i] of Object.entries(a))
    i !== 0 && (e[t] = i);
  return e;
}
class De {
  /**
   * @private
   */
  constructor(e) {
    const t = e.conversionAccuracy === "longterm" || !1;
    let i = t ? tP : eP;
    e.matrix && (i = e.matrix), this.values = e.values, this.loc = e.loc || Be.create(), this.conversionAccuracy = t ? "longterm" : "casual", this.invalid = e.invalid || null, this.matrix = i, this.isLuxonDuration = !0;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(e, t) {
    return De.fromObject({ milliseconds: e }, t);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(e, t = {}) {
    if (e == null || typeof e != "object")
      throw new Yt(
        `Duration.fromObject: argument expected to be an object, got ${e === null ? "null" : typeof e}`
      );
    return new De({
      values: $o(e, De.normalizeUnit),
      loc: Be.fromObject(t),
      conversionAccuracy: t.conversionAccuracy,
      matrix: t.matrix
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(e) {
    if (Js(e))
      return De.fromMillis(e);
    if (De.isDuration(e))
      return e;
    if (typeof e == "object")
      return De.fromObject(e);
    throw new Yt(
      `Unknown duration argument ${e} of type ${typeof e}`
    );
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(e, t) {
    const [i] = GE(e);
    return i ? De.fromObject(i, t) : De.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(e, t) {
    const [i] = UE(e);
    return i ? De.fromObject(i, t) : De.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(e, t = null) {
    if (!e)
      throw new Yt("need to specify a reason the Duration is invalid");
    const i = e instanceof ki ? e : new ki(e, t);
    if (ct.throwOnInvalid)
      throw new E$(i);
    return new De({ invalid: i });
  }
  /**
   * @private
   */
  static normalizeUnit(e) {
    const t = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[e && e.toLowerCase()];
    if (!t)
      throw new Tb(e);
    return t;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(e) {
    return e && e.isLuxonDuration || !1;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(e, t = {}) {
    const i = {
      ...t,
      floor: t.round !== !1 && t.floor !== !1
    };
    return this.isValid ? Rt.create(this.loc, i).formatDurationFromString(this, e) : Rf;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
   * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
   * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(e = {}) {
    if (!this.isValid)
      return Rf;
    const t = Us.map((i) => {
      const s = this.values[i];
      return Te(s) ? null : this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...e, unit: i.slice(0, -1) }).format(s);
    }).filter((i) => i);
    return this.loc.listFormatter({ type: "conjunction", style: e.listStyle || "narrow", ...e }).format(t);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    return this.isValid ? { ...this.values } : {};
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid)
      return null;
    let e = "P";
    return this.years !== 0 && (e += this.years + "Y"), (this.months !== 0 || this.quarters !== 0) && (e += this.months + this.quarters * 3 + "M"), this.weeks !== 0 && (e += this.weeks + "W"), this.days !== 0 && (e += this.days + "D"), (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) && (e += "T"), this.hours !== 0 && (e += this.hours + "H"), this.minutes !== 0 && (e += this.minutes + "M"), (this.seconds !== 0 || this.milliseconds !== 0) && (e += Id(this.seconds + this.milliseconds / 1e3, 3) + "S"), e === "P" && (e += "T0S"), e;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(e = {}) {
    if (!this.isValid)
      return null;
    const t = this.toMillis();
    return t < 0 || t >= 864e5 ? null : (e = {
      suppressMilliseconds: !1,
      suppressSeconds: !1,
      includePrefix: !1,
      format: "extended",
      ...e,
      includeOffset: !1
    }, tt.fromMillis(t, { zone: "UTC" }).toISOTime(e));
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns a string representation of this Duration appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `Duration { values: ${JSON.stringify(this.values)} }` : `Duration { Invalid, reason: ${this.invalidReason} }`;
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? bv(this.matrix, this.values) : NaN;
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(e) {
    if (!this.isValid)
      return this;
    const t = De.fromDurationLike(e), i = {};
    for (const s of Us)
      (Xn(t.values, s) || Xn(this.values, s)) && (i[s] = t.get(s) + this.get(s));
    return gs(this, { values: i }, !0);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(e) {
    if (!this.isValid)
      return this;
    const t = De.fromDurationLike(e);
    return this.plus(t.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(e) {
    if (!this.isValid)
      return this;
    const t = {};
    for (const i of Object.keys(this.values))
      t[i] = iv(e(this.values[i], i));
    return gs(this, { values: t }, !0);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(e) {
    return this[De.normalizeUnit(e)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(e) {
    if (!this.isValid)
      return this;
    const t = { ...this.values, ...$o(e, De.normalizeUnit) };
    return gs(this, { values: t });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale: e, numberingSystem: t, conversionAccuracy: i, matrix: s } = {}) {
    const o = { loc: this.loc.clone({ locale: e, numberingSystem: t }), matrix: s, conversionAccuracy: i };
    return gs(this, o);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(e) {
    return this.isValid ? this.shiftTo(e).get(e) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * Assuming the overall value of the Duration is positive, this means:
   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
   *   the overall value would be negative, see third example)
   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
   *
   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid)
      return this;
    const e = this.toObject();
    return If(this.matrix, e), gs(this, { values: e }, !0);
  }
  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid)
      return this;
    const e = sP(this.normalize().shiftToAll().toObject());
    return gs(this, { values: e }, !0);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...e) {
    if (!this.isValid)
      return this;
    if (e.length === 0)
      return this;
    e = e.map((o) => De.normalizeUnit(o));
    const t = {}, i = {}, s = this.toObject();
    let n;
    for (const o of Us)
      if (e.indexOf(o) >= 0) {
        n = o;
        let l = 0;
        for (const d in i)
          l += this.matrix[d][o] * i[d], i[d] = 0;
        Js(s[o]) && (l += s[o]);
        const c = Math.trunc(l);
        t[o] = c, i[o] = (l * 1e3 - c * 1e3) / 1e3;
      } else
        Js(s[o]) && (i[o] = s[o]);
    for (const o in i)
      i[o] !== 0 && (t[n] += o === n ? i[o] : i[o] / this.matrix[n][o]);
    return If(this.matrix, t), gs(this, { values: t }, !0);
  }
  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    return this.isValid ? this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ) : this;
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid)
      return this;
    const e = {};
    for (const t of Object.keys(this.values))
      e[t] = this.values[t] === 0 ? 0 : -this.values[t];
    return gs(this, { values: e }, !0);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(e) {
    if (!this.isValid || !e.isValid || !this.loc.equals(e.loc))
      return !1;
    function t(i, s) {
      return i === void 0 || i === 0 ? s === void 0 || s === 0 : i === s;
    }
    for (const i of Us)
      if (!t(this.values[i], e.values[i]))
        return !1;
    return !0;
  }
}
const On = "Invalid Interval";
function nP(a, e) {
  return !a || !a.isValid ? nt.invalid("missing or invalid start") : !e || !e.isValid ? nt.invalid("missing or invalid end") : e < a ? nt.invalid(
    "end before start",
    `The end of an interval must be after its start, but you had start=${a.toISO()} and end=${e.toISO()}`
  ) : null;
}
class nt {
  /**
   * @private
   */
  constructor(e) {
    this.s = e.start, this.e = e.end, this.invalid = e.invalid || null, this.isLuxonInterval = !0;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(e, t = null) {
    if (!e)
      throw new Yt("need to specify a reason the Interval is invalid");
    const i = e instanceof ki ? e : new ki(e, t);
    if (ct.throwOnInvalid)
      throw new $$(i);
    return new nt({ invalid: i });
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(e, t) {
    const i = mr(e), s = mr(t), n = nP(i, s);
    return n ?? new nt({
      start: i,
      end: s
    });
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(e, t) {
    const i = De.fromDurationLike(t), s = mr(e);
    return nt.fromDateTimes(s, s.plus(i));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(e, t) {
    const i = De.fromDurationLike(t), s = mr(e);
    return nt.fromDateTimes(s.minus(i), s);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(e, t) {
    const [i, s] = (e || "").split("/", 2);
    if (i && s) {
      let n, o;
      try {
        n = tt.fromISO(i, t), o = n.isValid;
      } catch {
        o = !1;
      }
      let l, c;
      try {
        l = tt.fromISO(s, t), c = l.isValid;
      } catch {
        c = !1;
      }
      if (o && c)
        return nt.fromDateTimes(n, l);
      if (o) {
        const d = De.fromISO(s, t);
        if (d.isValid)
          return nt.after(n, d);
      } else if (c) {
        const d = De.fromISO(i, t);
        if (d.isValid)
          return nt.before(l, d);
      }
    }
    return nt.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(e) {
    return e && e.isLuxonInterval || !1;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(e = "milliseconds") {
    return this.isValid ? this.toDuration(e).get(e) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
   * @return {number}
   */
  count(e = "milliseconds", t) {
    if (!this.isValid)
      return NaN;
    const i = this.start.startOf(e, t);
    let s;
    return t != null && t.useLocaleWeeks ? s = this.end.reconfigure({ locale: i.locale }) : s = this.end, s = s.startOf(e, t), Math.floor(s.diff(i, e).get(e)) + (s.valueOf() !== this.end.valueOf());
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(e) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, e) : !1;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(e) {
    return this.isValid ? this.s > e : !1;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(e) {
    return this.isValid ? this.e <= e : !1;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(e) {
    return this.isValid ? this.s <= e && this.e > e : !1;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start: e, end: t } = {}) {
    return this.isValid ? nt.fromDateTimes(e || this.s, t || this.e) : this;
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...e) {
    if (!this.isValid)
      return [];
    const t = e.map(mr).filter((o) => this.contains(o)).sort((o, l) => o.toMillis() - l.toMillis()), i = [];
    let { s } = this, n = 0;
    for (; s < this.e; ) {
      const o = t[n] || this.e, l = +o > +this.e ? this.e : o;
      i.push(nt.fromDateTimes(s, l)), s = l, n += 1;
    }
    return i;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(e) {
    const t = De.fromDurationLike(e);
    if (!this.isValid || !t.isValid || t.as("milliseconds") === 0)
      return [];
    let { s: i } = this, s = 1, n;
    const o = [];
    for (; i < this.e; ) {
      const l = this.start.plus(t.mapUnits((c) => c * s));
      n = +l > +this.e ? this.e : l, o.push(nt.fromDateTimes(i, n)), i = n, s += 1;
    }
    return o;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(e) {
    return this.isValid ? this.splitBy(this.length() / e).slice(0, e) : [];
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(e) {
    return this.e > e.s && this.s < e.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(e) {
    return this.isValid ? +this.e == +e.s : !1;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(e) {
    return this.isValid ? +e.e == +this.s : !1;
  }
  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(e) {
    return this.isValid ? this.s <= e.s && this.e >= e.e : !1;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(e) {
    return !this.isValid || !e.isValid ? !1 : this.s.equals(e.s) && this.e.equals(e.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(e) {
    if (!this.isValid)
      return this;
    const t = this.s > e.s ? this.s : e.s, i = this.e < e.e ? this.e : e.e;
    return t >= i ? null : nt.fromDateTimes(t, i);
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(e) {
    if (!this.isValid)
      return this;
    const t = this.s < e.s ? this.s : e.s, i = this.e > e.e ? this.e : e.e;
    return nt.fromDateTimes(t, i);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(e) {
    const [t, i] = e.sort((s, n) => s.s - n.s).reduce(
      ([s, n], o) => n ? n.overlaps(o) || n.abutsStart(o) ? [s, n.union(o)] : [s.concat([n]), o] : [s, o],
      [[], null]
    );
    return i && t.push(i), t;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(e) {
    let t = null, i = 0;
    const s = [], n = e.map((c) => [
      { time: c.s, type: "s" },
      { time: c.e, type: "e" }
    ]), o = Array.prototype.concat(...n), l = o.sort((c, d) => c.time - d.time);
    for (const c of l)
      i += c.type === "s" ? 1 : -1, i === 1 ? t = c.time : (t && +t != +c.time && s.push(nt.fromDateTimes(t, c.time)), t = null);
    return nt.merge(s);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...e) {
    return nt.xor([this].concat(e)).map((t) => this.intersection(t)).filter((t) => t && !t.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    return this.isValid ? `[${this.s.toISO()} – ${this.e.toISO()})` : On;
  }
  /**
   * Returns a string representation of this Interval appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }` : `Interval { Invalid, reason: ${this.invalidReason} }`;
  }
  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
   * @return {string}
   */
  toLocaleString(e = Co, t = {}) {
    return this.isValid ? Rt.create(this.s.loc.clone(t), e).formatInterval(this) : On;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(e) {
    return this.isValid ? `${this.s.toISO(e)}/${this.e.toISO(e)}` : On;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : On;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(e) {
    return this.isValid ? `${this.s.toISOTime(e)}/${this.e.toISOTime(e)}` : On;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(e, { separator: t = " – " } = {}) {
    return this.isValid ? `${this.s.toFormat(e)}${t}${this.e.toFormat(e)}` : On;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(e, t) {
    return this.isValid ? this.e.diff(this.s, e, t) : De.invalid(this.invalidReason);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(e) {
    return nt.fromDateTimes(e(this.s), e(this.e));
  }
}
class Fa {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(e = ct.defaultZone) {
    const t = tt.now().setZone(e).set({ month: 12 });
    return !e.isUniversal && t.offset !== t.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(e) {
    return ns.isValidZone(e);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(e) {
    return xs(e, ct.defaultZone);
  }
  /**
   * Get the weekday on which the week starts according to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
   */
  static getStartOfWeek({ locale: e = null, locObj: t = null } = {}) {
    return (t || Be.create(e)).getStartOfWeek();
  }
  /**
   * Get the minimum number of days necessary in a week before it is considered part of the next year according
   * to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number}
   */
  static getMinimumDaysInFirstWeek({ locale: e = null, locObj: t = null } = {}) {
    return (t || Be.create(e)).getMinDaysInFirstWeek();
  }
  /**
   * Get the weekdays, which are considered the weekend according to the given locale
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
   */
  static getWeekendWeekdays({ locale: e = null, locObj: t = null } = {}) {
    return (t || Be.create(e)).getWeekendDays().slice();
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
   * @return {Array}
   */
  static months(e = "long", { locale: t = null, numberingSystem: i = null, locObj: s = null, outputCalendar: n = "gregory" } = {}) {
    return (s || Be.create(t, i, n)).months(e);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(e = "long", { locale: t = null, numberingSystem: i = null, locObj: s = null, outputCalendar: n = "gregory" } = {}) {
    return (s || Be.create(t, i, n)).months(e, !0);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
   * @return {Array}
   */
  static weekdays(e = "long", { locale: t = null, numberingSystem: i = null, locObj: s = null } = {}) {
    return (s || Be.create(t, i, null)).weekdays(e);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(e = "long", { locale: t = null, numberingSystem: i = null, locObj: s = null } = {}) {
    return (s || Be.create(t, i, null)).weekdays(e, !0);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
   * @return {Array}
   */
  static meridiems({ locale: e = null } = {}) {
    return Be.create(e).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
   * @return {Array}
   */
  static eras(e = "short", { locale: t = null } = {}) {
    return Be.create(t, null, "gregory").eras(e);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
   * @example Info.features() //=> { relative: false, localeWeek: true }
   * @return {Object}
   */
  static features() {
    return { relative: Jb(), localeWeek: ev() };
  }
}
function Qf(a, e) {
  const t = (s) => s.toUTC(0, { keepLocalTime: !0 }).startOf("day").valueOf(), i = t(e) - t(a);
  return Math.floor(De.fromMillis(i).as("days"));
}
function rP(a, e, t) {
  const i = [
    ["years", (c, d) => d.year - c.year],
    ["quarters", (c, d) => d.quarter - c.quarter + (d.year - c.year) * 4],
    ["months", (c, d) => d.month - c.month + (d.year - c.year) * 12],
    [
      "weeks",
      (c, d) => {
        const f = Qf(c, d);
        return (f - f % 7) / 7;
      }
    ],
    ["days", Qf]
  ], s = {}, n = a;
  let o, l;
  for (const [c, d] of i)
    t.indexOf(c) >= 0 && (o = c, s[c] = d(a, e), l = n.plus(s), l > e ? (s[c]--, a = n.plus(s), a > e && (l = a, s[c]--, a = n.plus(s))) : a = l);
  return [a, s, l, o];
}
function aP(a, e, t, i) {
  let [s, n, o, l] = rP(a, e, t);
  const c = e - s, d = t.filter(
    (p) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(p) >= 0
  );
  d.length === 0 && (o < e && (o = s.plus({ [l]: 1 })), o !== s && (n[l] = (n[l] || 0) + c / (o - s)));
  const f = De.fromObject(n, i);
  return d.length > 0 ? De.fromMillis(c, i).shiftTo(...d).plus(f) : f;
}
const Wd = {
  arab: "[٠-٩]",
  arabext: "[۰-۹]",
  bali: "[᭐-᭙]",
  beng: "[০-৯]",
  deva: "[०-९]",
  fullwide: "[０-９]",
  gujr: "[૦-૯]",
  hanidec: "[〇|一|二|三|四|五|六|七|八|九]",
  khmr: "[០-៩]",
  knda: "[೦-೯]",
  laoo: "[໐-໙]",
  limb: "[᥆-᥏]",
  mlym: "[൦-൯]",
  mong: "[᠐-᠙]",
  mymr: "[၀-၉]",
  orya: "[୦-୯]",
  tamldec: "[௦-௯]",
  telu: "[౦-౯]",
  thai: "[๐-๙]",
  tibt: "[༠-༩]",
  latn: "\\d"
}, Nf = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
}, oP = Wd.hanidec.replace(/[\[|\]]/g, "").split("");
function lP(a) {
  let e = parseInt(a, 10);
  if (isNaN(e)) {
    e = "";
    for (let t = 0; t < a.length; t++) {
      const i = a.charCodeAt(t);
      if (a[t].search(Wd.hanidec) !== -1)
        e += oP.indexOf(a[t]);
      else
        for (const s in Nf) {
          const [n, o] = Nf[s];
          i >= n && i <= o && (e += i - n);
        }
    }
    return parseInt(e, 10);
  } else
    return e;
}
function Oi({ numberingSystem: a }, e = "") {
  return new RegExp(`${Wd[a || "latn"]}${e}`);
}
const cP = "missing Intl.DateTimeFormat.formatToParts support";
function Fe(a, e = (t) => t) {
  return { regex: a, deser: ([t]) => e(lP(t)) };
}
const hP = String.fromCharCode(160), vv = `[ ${hP}]`, yv = new RegExp(vv, "g");
function dP(a) {
  return a.replace(/\./g, "\\.?").replace(yv, vv);
}
function Ff(a) {
  return a.replace(/\./g, "").replace(yv, " ").toLowerCase();
}
function xi(a, e) {
  return a === null ? null : {
    regex: RegExp(a.map(dP).join("|")),
    deser: ([t]) => a.findIndex((i) => Ff(t) === Ff(i)) + e
  };
}
function Wf(a, e) {
  return { regex: a, deser: ([, t, i]) => Ol(t, i), groups: e };
}
function Wa(a) {
  return { regex: a, deser: ([e]) => e };
}
function uP(a) {
  return a.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function fP(a, e) {
  const t = Oi(e), i = Oi(e, "{2}"), s = Oi(e, "{3}"), n = Oi(e, "{4}"), o = Oi(e, "{6}"), l = Oi(e, "{1,2}"), c = Oi(e, "{1,3}"), d = Oi(e, "{1,6}"), f = Oi(e, "{1,9}"), p = Oi(e, "{2,4}"), m = Oi(e, "{4,6}"), v = (u) => ({ regex: RegExp(uP(u.val)), deser: ([g]) => g, literal: !0 }), h = ((u) => {
    if (a.literal)
      return v(u);
    switch (u.val) {
      case "G":
        return xi(e.eras("short"), 0);
      case "GG":
        return xi(e.eras("long"), 0);
      case "y":
        return Fe(d);
      case "yy":
        return Fe(p, ph);
      case "yyyy":
        return Fe(n);
      case "yyyyy":
        return Fe(m);
      case "yyyyyy":
        return Fe(o);
      case "M":
        return Fe(l);
      case "MM":
        return Fe(i);
      case "MMM":
        return xi(e.months("short", !0), 1);
      case "MMMM":
        return xi(e.months("long", !0), 1);
      case "L":
        return Fe(l);
      case "LL":
        return Fe(i);
      case "LLL":
        return xi(e.months("short", !1), 1);
      case "LLLL":
        return xi(e.months("long", !1), 1);
      case "d":
        return Fe(l);
      case "dd":
        return Fe(i);
      case "o":
        return Fe(c);
      case "ooo":
        return Fe(s);
      case "HH":
        return Fe(i);
      case "H":
        return Fe(l);
      case "hh":
        return Fe(i);
      case "h":
        return Fe(l);
      case "mm":
        return Fe(i);
      case "m":
        return Fe(l);
      case "q":
        return Fe(l);
      case "qq":
        return Fe(i);
      case "s":
        return Fe(l);
      case "ss":
        return Fe(i);
      case "S":
        return Fe(c);
      case "SSS":
        return Fe(s);
      case "u":
        return Wa(f);
      case "uu":
        return Wa(l);
      case "uuu":
        return Fe(t);
      case "a":
        return xi(e.meridiems(), 0);
      case "kkkk":
        return Fe(n);
      case "kk":
        return Fe(p, ph);
      case "W":
        return Fe(l);
      case "WW":
        return Fe(i);
      case "E":
      case "c":
        return Fe(t);
      case "EEE":
        return xi(e.weekdays("short", !1), 1);
      case "EEEE":
        return xi(e.weekdays("long", !1), 1);
      case "ccc":
        return xi(e.weekdays("short", !0), 1);
      case "cccc":
        return xi(e.weekdays("long", !0), 1);
      case "Z":
      case "ZZ":
        return Wf(new RegExp(`([+-]${l.source})(?::(${i.source}))?`), 2);
      case "ZZZ":
        return Wf(new RegExp(`([+-]${l.source})(${i.source})?`), 2);
      case "z":
        return Wa(/[a-z_+-/]{1,256}?/i);
      case " ":
        return Wa(/[^\S\n\r]/);
      default:
        return v(u);
    }
  })(a) || {
    invalidReason: cP
  };
  return h.token = a, h;
}
const pP = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function gP(a, e, t) {
  const { type: i, value: s } = a;
  if (i === "literal") {
    const c = /^\s+$/.test(s);
    return {
      literal: !c,
      val: c ? " " : s
    };
  }
  const n = e[i];
  let o = i;
  i === "hour" && (e.hour12 != null ? o = e.hour12 ? "hour12" : "hour24" : e.hourCycle != null ? e.hourCycle === "h11" || e.hourCycle === "h12" ? o = "hour12" : o = "hour24" : o = t.hour12 ? "hour12" : "hour24");
  let l = pP[o];
  if (typeof l == "object" && (l = l[n]), l)
    return {
      literal: !1,
      val: l
    };
}
function mP(a) {
  return [`^${a.map((t) => t.regex).reduce((t, i) => `${t}(${i.source})`, "")}$`, a];
}
function bP(a, e, t) {
  const i = a.match(e);
  if (i) {
    const s = {};
    let n = 1;
    for (const o in t)
      if (Xn(t, o)) {
        const l = t[o], c = l.groups ? l.groups + 1 : 1;
        !l.literal && l.token && (s[l.token.val[0]] = l.deser(i.slice(n, n + c))), n += c;
      }
    return [i, s];
  } else
    return [i, {}];
}
function vP(a) {
  const e = (n) => {
    switch (n) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let t = null, i;
  return Te(a.z) || (t = ns.create(a.z)), Te(a.Z) || (t || (t = new Ft(a.Z)), i = a.Z), Te(a.q) || (a.M = (a.q - 1) * 3 + 1), Te(a.h) || (a.h < 12 && a.a === 1 ? a.h += 12 : a.h === 12 && a.a === 0 && (a.h = 0)), a.G === 0 && a.y && (a.y = -a.y), Te(a.u) || (a.S = Rd(a.u)), [Object.keys(a).reduce((n, o) => {
    const l = e(o);
    return l && (n[l] = a[o]), n;
  }, {}), t, i];
}
let hc = null;
function yP() {
  return hc || (hc = tt.fromMillis(1555555555555)), hc;
}
function OP(a, e) {
  if (a.literal)
    return a;
  const t = Rt.macroTokenToFormatOpts(a.val), i = wv(t, e);
  return i == null || i.includes(void 0) ? a : i;
}
function Ov(a, e) {
  return Array.prototype.concat(...a.map((t) => OP(t, e)));
}
function xv(a, e, t) {
  const i = Ov(Rt.parseFormat(t), a), s = i.map((o) => fP(o, a)), n = s.find((o) => o.invalidReason);
  if (n)
    return { input: e, tokens: i, invalidReason: n.invalidReason };
  {
    const [o, l] = mP(s), c = RegExp(o, "i"), [d, f] = bP(e, c, l), [p, m, v] = f ? vP(f) : [null, null, void 0];
    if (Xn(f, "a") && Xn(f, "H"))
      throw new An(
        "Can't include meridiem when specifying 24-hour format"
      );
    return { input: e, tokens: i, regex: c, rawMatches: d, matches: f, result: p, zone: m, specificOffset: v };
  }
}
function xP(a, e, t) {
  const { result: i, zone: s, specificOffset: n, invalidReason: o } = xv(a, e, t);
  return [i, s, n, o];
}
function wv(a, e) {
  if (!a)
    return null;
  const i = Rt.create(e, a).dtFormatter(yP()), s = i.formatToParts(), n = i.resolvedOptions();
  return s.map((o) => gP(o, a, n));
}
const dc = "Invalid DateTime", Bf = 864e13;
function Ba(a) {
  return new ki("unsupported zone", `the zone "${a.name}" is not supported`);
}
function uc(a) {
  return a.weekData === null && (a.weekData = To(a.c)), a.weekData;
}
function fc(a) {
  return a.localWeekData === null && (a.localWeekData = To(
    a.c,
    a.loc.getMinDaysInFirstWeek(),
    a.loc.getStartOfWeek()
  )), a.localWeekData;
}
function zs(a, e) {
  const t = {
    ts: a.ts,
    zone: a.zone,
    c: a.c,
    o: a.o,
    loc: a.loc,
    invalid: a.invalid
  };
  return new tt({ ...t, ...e, old: t });
}
function Sv(a, e, t) {
  let i = a - e * 60 * 1e3;
  const s = t.offset(i);
  if (e === s)
    return [i, e];
  i -= (s - e) * 60 * 1e3;
  const n = t.offset(i);
  return s === n ? [i, s] : [a - Math.min(s, n) * 60 * 1e3, Math.max(s, n)];
}
function za(a, e) {
  a += e * 60 * 1e3;
  const t = new Date(a);
  return {
    year: t.getUTCFullYear(),
    month: t.getUTCMonth() + 1,
    day: t.getUTCDate(),
    hour: t.getUTCHours(),
    minute: t.getUTCMinutes(),
    second: t.getUTCSeconds(),
    millisecond: t.getUTCMilliseconds()
  };
}
function uo(a, e, t) {
  return Sv(yl(a), e, t);
}
function zf(a, e) {
  const t = a.o, i = a.c.year + Math.trunc(e.years), s = a.c.month + Math.trunc(e.months) + Math.trunc(e.quarters) * 3, n = {
    ...a.c,
    year: i,
    month: s,
    day: Math.min(a.c.day, Ao(i, s)) + Math.trunc(e.days) + Math.trunc(e.weeks) * 7
  }, o = De.fromObject({
    years: e.years - Math.trunc(e.years),
    quarters: e.quarters - Math.trunc(e.quarters),
    months: e.months - Math.trunc(e.months),
    weeks: e.weeks - Math.trunc(e.weeks),
    days: e.days - Math.trunc(e.days),
    hours: e.hours,
    minutes: e.minutes,
    seconds: e.seconds,
    milliseconds: e.milliseconds
  }).as("milliseconds"), l = yl(n);
  let [c, d] = Sv(l, t, a.zone);
  return o !== 0 && (c += o, d = a.zone.offset(c)), { ts: c, o: d };
}
function gr(a, e, t, i, s, n) {
  const { setZone: o, zone: l } = t;
  if (a && Object.keys(a).length !== 0 || e) {
    const c = e || l, d = tt.fromObject(a, {
      ...t,
      zone: c,
      specificOffset: n
    });
    return o ? d : d.setZone(l);
  } else
    return tt.invalid(
      new ki("unparsable", `the input "${s}" can't be parsed as ${i}`)
    );
}
function Xa(a, e, t = !0) {
  return a.isValid ? Rt.create(Be.create("en-US"), {
    allowZ: t,
    forceSimple: !0
  }).formatDateTimeFromString(a, e) : null;
}
function pc(a, e) {
  const t = a.c.year > 9999 || a.c.year < 0;
  let i = "";
  return t && a.c.year >= 0 && (i += "+"), i += ut(a.c.year, t ? 6 : 4), e ? (i += "-", i += ut(a.c.month), i += "-", i += ut(a.c.day)) : (i += ut(a.c.month), i += ut(a.c.day)), i;
}
function Xf(a, e, t, i, s, n) {
  let o = ut(a.c.hour);
  return e ? (o += ":", o += ut(a.c.minute), (a.c.millisecond !== 0 || a.c.second !== 0 || !t) && (o += ":")) : o += ut(a.c.minute), (a.c.millisecond !== 0 || a.c.second !== 0 || !t) && (o += ut(a.c.second), (a.c.millisecond !== 0 || !i) && (o += ".", o += ut(a.c.millisecond, 3))), s && (a.isOffsetFixed && a.offset === 0 && !n ? o += "Z" : a.o < 0 ? (o += "-", o += ut(Math.trunc(-a.o / 60)), o += ":", o += ut(Math.trunc(-a.o % 60))) : (o += "+", o += ut(Math.trunc(a.o / 60)), o += ":", o += ut(Math.trunc(a.o % 60)))), n && (o += "[" + a.zone.ianaName + "]"), o;
}
const kv = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, wP = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, SP = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, _v = ["year", "month", "day", "hour", "minute", "second", "millisecond"], kP = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
], _P = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function CP(a) {
  const e = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[a.toLowerCase()];
  if (!e)
    throw new Tb(a);
  return e;
}
function Yf(a) {
  switch (a.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
      return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
      return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
      return "localWeekYear";
    default:
      return CP(a);
  }
}
function Vf(a, e) {
  const t = xs(e.zone, ct.defaultZone), i = Be.fromObject(e), s = ct.now();
  let n, o;
  if (Te(a.year))
    n = s;
  else {
    for (const d of _v)
      Te(a[d]) && (a[d] = kv[d]);
    const l = qb(a) || Kb(a);
    if (l)
      return tt.invalid(l);
    const c = t.offset(s);
    [n, o] = uo(a, c, t);
  }
  return new tt({ ts: n, zone: t, loc: i, o });
}
function Hf(a, e, t) {
  const i = Te(t.round) ? !0 : t.round, s = (o, l) => (o = Id(o, i || t.calendary ? 0 : 2, !0), e.loc.clone(t).relFormatter(t).format(o, l)), n = (o) => t.calendary ? e.hasSame(a, o) ? 0 : e.startOf(o).diff(a.startOf(o), o).get(o) : e.diff(a, o).get(o);
  if (t.unit)
    return s(n(t.unit), t.unit);
  for (const o of t.units) {
    const l = n(o);
    if (Math.abs(l) >= 1)
      return s(l, o);
  }
  return s(a > e ? -0 : 0, t.units[t.units.length - 1]);
}
function Gf(a) {
  let e = {}, t;
  return a.length > 0 && typeof a[a.length - 1] == "object" ? (e = a[a.length - 1], t = Array.from(a).slice(0, a.length - 1)) : t = Array.from(a), [e, t];
}
let tt = class st {
  /**
   * @access private
   */
  constructor(e) {
    const t = e.zone || ct.defaultZone;
    let i = e.invalid || (Number.isNaN(e.ts) ? new ki("invalid input") : null) || (t.isValid ? null : Ba(t));
    this.ts = Te(e.ts) ? ct.now() : e.ts;
    let s = null, n = null;
    if (!i)
      if (e.old && e.old.ts === this.ts && e.old.zone.equals(t))
        [s, n] = [e.old.c, e.old.o];
      else {
        const l = t.offset(this.ts);
        s = za(this.ts, l), i = Number.isNaN(s.year) ? new ki("invalid input") : null, s = i ? null : s, n = i ? null : l;
      }
    this._zone = t, this.loc = e.loc || Be.create(), this.invalid = i, this.weekData = null, this.localWeekData = null, this.c = s, this.o = n, this.isLuxonDateTime = !0;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new st({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [e, t] = Gf(arguments), [i, s, n, o, l, c, d] = t;
    return Vf({ year: i, month: s, day: n, hour: o, minute: l, second: c, millisecond: d }, e);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [e, t] = Gf(arguments), [i, s, n, o, l, c, d] = t;
    return e.zone = Ft.utcInstance, Vf({ year: i, month: s, day: n, hour: o, minute: l, second: c, millisecond: d }, e);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(e, t = {}) {
    const i = tE(e) ? e.valueOf() : NaN;
    if (Number.isNaN(i))
      return st.invalid("invalid input");
    const s = xs(t.zone, ct.defaultZone);
    return s.isValid ? new st({
      ts: i,
      zone: s,
      loc: Be.fromObject(t)
    }) : st.invalid(Ba(s));
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(e, t = {}) {
    if (Js(e))
      return e < -Bf || e > Bf ? st.invalid("Timestamp out of range") : new st({
        ts: e,
        zone: xs(t.zone, ct.defaultZone),
        loc: Be.fromObject(t)
      });
    throw new Yt(
      `fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`
    );
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(e, t = {}) {
    if (Js(e))
      return new st({
        ts: e * 1e3,
        zone: xs(t.zone, ct.defaultZone),
        loc: Be.fromObject(t)
      });
    throw new Yt("fromSeconds requires a numerical input");
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.localWeekYear - a week year, according to the locale
   * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
   * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
   * @return {DateTime}
   */
  static fromObject(e, t = {}) {
    e = e || {};
    const i = xs(t.zone, ct.defaultZone);
    if (!i.isValid)
      return st.invalid(Ba(i));
    const s = Be.fromObject(t), n = $o(e, Yf), { minDaysInFirstWeek: o, startOfWeek: l } = Ef(n, s), c = ct.now(), d = Te(t.specificOffset) ? i.offset(c) : t.specificOffset, f = !Te(n.ordinal), p = !Te(n.year), m = !Te(n.month) || !Te(n.day), v = p || m, r = n.weekYear || n.weekNumber;
    if ((v || f) && r)
      throw new An(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (m && f)
      throw new An("Can't mix ordinal dates with month/day");
    const h = r || n.weekday && !v;
    let u, g, b = za(c, d);
    h ? (u = kP, g = wP, b = To(b, o, l)) : f ? (u = _P, g = SP, b = cc(b)) : (u = _v, g = kv);
    let O = !1;
    for (const L of u) {
      const E = n[L];
      Te(E) ? O ? n[L] = g[L] : n[L] = b[L] : O = !0;
    }
    const x = h ? K$(n, o, l) : f ? J$(n) : qb(n), S = x || Kb(n);
    if (S)
      return st.invalid(S);
    const k = h ? Af(n, o, l) : f ? $f(n) : n, [C, _] = uo(k, d, i), $ = new st({
      ts: C,
      zone: i,
      o: _,
      loc: s
    });
    return n.weekday && v && e.weekday !== $.weekday ? st.invalid(
      "mismatched weekday",
      `you can't specify both a weekday of ${n.weekday} and a date of ${$.toISO()}`
    ) : $;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(e, t = {}) {
    const [i, s] = YE(e);
    return gr(i, s, t, "ISO 8601", e);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(e, t = {}) {
    const [i, s] = VE(e);
    return gr(i, s, t, "RFC 2822", e);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(e, t = {}) {
    const [i, s] = HE(e);
    return gr(i, s, t, "HTTP", t);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(e, t, i = {}) {
    if (Te(e) || Te(t))
      throw new Yt("fromFormat requires an input string and a format");
    const { locale: s = null, numberingSystem: n = null } = i, o = Be.fromOpts({
      locale: s,
      numberingSystem: n,
      defaultToEN: !0
    }), [l, c, d, f] = xP(o, e, t);
    return f ? st.invalid(f) : gr(l, c, i, `format ${t}`, e, d);
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(e, t, i = {}) {
    return st.fromFormat(e, t, i);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(e, t = {}) {
    const [i, s] = JE(e);
    return gr(i, s, t, "SQL", e);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(e, t = null) {
    if (!e)
      throw new Yt("need to specify a reason the DateTime is invalid");
    const i = e instanceof ki ? e : new ki(e, t);
    if (ct.throwOnInvalid)
      throw new A$(i);
    return new st({ invalid: i });
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(e) {
    return e && e.isLuxonDateTime || !1;
  }
  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(e, t = {}) {
    const i = wv(e, Be.fromObject(t));
    return i ? i.map((s) => s ? s.val : null).join("") : null;
  }
  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(e, t = {}) {
    return Ov(Rt.parseFormat(e), Be.fromObject(t)).map((s) => s.val).join("");
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(e) {
    return this[e];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? uc(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? uc(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? uc(this).weekday : NaN;
  }
  /**
   * Returns true if this date is on a weekend according to the locale, false otherwise
   * @returns {boolean}
   */
  get isWeekend() {
    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
  }
  /**
   * Get the day of the week according to the locale.
   * 1 is the first day of the week and 7 is the last day of the week.
   * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
   * @returns {number}
   */
  get localWeekday() {
    return this.isValid ? fc(this).weekday : NaN;
  }
  /**
   * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
   * because the week can start on different days of the week (see localWeekday) and because a different number of days
   * is required for a week to count as the first week of a year.
   * @returns {number}
   */
  get localWeekNumber() {
    return this.isValid ? fc(this).weekNumber : NaN;
  }
  /**
   * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
   * differently, see localWeekNumber.
   * @returns {number}
   */
  get localWeekYear() {
    return this.isValid ? fc(this).weekYear : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? cc(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Fa.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Fa.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Fa.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Fa.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "short",
      locale: this.locale
    }) : null;
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "long",
      locale: this.locale
    }) : null;
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    return this.isOffsetFixed ? !1 : this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
  }
  /**
   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
   * in this DateTime's zone. During DST changes local time can be ambiguous, for example
   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
   * @returns {DateTime[]}
   */
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed)
      return [this];
    const e = 864e5, t = 6e4, i = yl(this.c), s = this.zone.offset(i - e), n = this.zone.offset(i + e), o = this.zone.offset(i - s * t), l = this.zone.offset(i - n * t);
    if (o === l)
      return [this];
    const c = i - o * t, d = i - l * t, f = za(c, o), p = za(d, l);
    return f.hour === p.hour && f.minute === p.minute && f.second === p.second && f.millisecond === p.millisecond ? [zs(this, { ts: c }), zs(this, { ts: d })] : [this];
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return pa(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return Ao(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? Rn(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? Gr(this.weekYear) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's local week year
   * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
   * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
   * @type {number}
   */
  get weeksInLocalWeekYear() {
    return this.isValid ? Gr(
      this.localWeekYear,
      this.loc.getMinDaysInFirstWeek(),
      this.loc.getStartOfWeek()
    ) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(e = {}) {
    const { locale: t, numberingSystem: i, calendar: s } = Rt.create(
      this.loc.clone(e),
      e
    ).resolvedOptions(this);
    return { locale: t, numberingSystem: i, outputCalendar: s };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(e = 0, t = {}) {
    return this.setZone(Ft.instance(e), t);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(ct.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(e, { keepLocalTime: t = !1, keepCalendarTime: i = !1 } = {}) {
    if (e = xs(e, ct.defaultZone), e.equals(this.zone))
      return this;
    if (e.isValid) {
      let s = this.ts;
      if (t || i) {
        const n = e.offset(this.ts), o = this.toObject();
        [s] = uo(o, n, e);
      }
      return zs(this, { ts: s, zone: e });
    } else
      return st.invalid(Ba(e));
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale: e, numberingSystem: t, outputCalendar: i } = {}) {
    const s = this.loc.clone({ locale: e, numberingSystem: t, outputCalendar: i });
    return zs(this, { loc: s });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(e) {
    return this.reconfigure({ locale: e });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   *
   * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
   * They cannot be mixed with ISO-week units like `weekday`.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(e) {
    if (!this.isValid)
      return this;
    const t = $o(e, Yf), { minDaysInFirstWeek: i, startOfWeek: s } = Ef(t, this.loc), n = !Te(t.weekYear) || !Te(t.weekNumber) || !Te(t.weekday), o = !Te(t.ordinal), l = !Te(t.year), c = !Te(t.month) || !Te(t.day), d = l || c, f = t.weekYear || t.weekNumber;
    if ((d || o) && f)
      throw new An(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (c && o)
      throw new An("Can't mix ordinal dates with month/day");
    let p;
    n ? p = Af(
      { ...To(this.c, i, s), ...t },
      i,
      s
    ) : Te(t.ordinal) ? (p = { ...this.toObject(), ...t }, Te(t.day) && (p.day = Math.min(Ao(p.year, p.month), p.day))) : p = $f({ ...cc(this.c), ...t });
    const [m, v] = uo(p, this.o, this.zone);
    return zs(this, { ts: m, o: v });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(e) {
    if (!this.isValid)
      return this;
    const t = De.fromDurationLike(e);
    return zs(this, zf(this, t));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(e) {
    if (!this.isValid)
      return this;
    const t = De.fromDurationLike(e).negate();
    return zs(this, zf(this, t));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(e, { useLocaleWeeks: t = !1 } = {}) {
    if (!this.isValid)
      return this;
    const i = {}, s = De.normalizeUnit(e);
    switch (s) {
      case "years":
        i.month = 1;
      case "quarters":
      case "months":
        i.day = 1;
      case "weeks":
      case "days":
        i.hour = 0;
      case "hours":
        i.minute = 0;
      case "minutes":
        i.second = 0;
      case "seconds":
        i.millisecond = 0;
        break;
    }
    if (s === "weeks")
      if (t) {
        const n = this.loc.getStartOfWeek(), { weekday: o } = this;
        o < n && (i.weekNumber = this.weekNumber - 1), i.weekday = n;
      } else
        i.weekday = 1;
    if (s === "quarters") {
      const n = Math.ceil(this.month / 3);
      i.month = (n - 1) * 3 + 1;
    }
    return this.set(i);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(e, t) {
    return this.isValid ? this.plus({ [e]: 1 }).startOf(e, t).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(e, t = {}) {
    return this.isValid ? Rt.create(this.loc.redefaultToEN(t)).formatDateTimeFromString(this, e) : dc;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(e = Co, t = {}) {
    return this.isValid ? Rt.create(this.loc.clone(t), e).formatDateTime(this) : dc;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(e = {}) {
    return this.isValid ? Rt.create(this.loc.clone(e), e).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format: e = "extended",
    suppressSeconds: t = !1,
    suppressMilliseconds: i = !1,
    includeOffset: s = !0,
    extendedZone: n = !1
  } = {}) {
    if (!this.isValid)
      return null;
    const o = e === "extended";
    let l = pc(this, o);
    return l += "T", l += Xf(this, o, t, i, s, n), l;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format: e = "extended" } = {}) {
    return this.isValid ? pc(this, e === "extended") : null;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return Xa(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds: e = !1,
    suppressSeconds: t = !1,
    includeOffset: i = !0,
    includePrefix: s = !1,
    extendedZone: n = !1,
    format: o = "extended"
  } = {}) {
    return this.isValid ? (s ? "T" : "") + Xf(
      this,
      o === "extended",
      t,
      e,
      i,
      n
    ) : null;
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return Xa(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return Xa(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    return this.isValid ? pc(this, !0) : null;
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset: e = !0, includeZone: t = !1, includeOffsetSpace: i = !0 } = {}) {
    let s = "HH:mm:ss.SSS";
    return (t || e) && (i && (s += " "), t ? s += "z" : e && (s += "ZZ")), Xa(this, s, !0);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(e = {}) {
    return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(e)}` : null;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : dc;
  }
  /**
   * Returns a string representation of this DateTime appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }` : `DateTime { Invalid, reason: ${this.invalidReason} }`;
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(e = {}) {
    if (!this.isValid)
      return {};
    const t = { ...this.c };
    return e.includeConfig && (t.outputCalendar = this.outputCalendar, t.numberingSystem = this.loc.numberingSystem, t.locale = this.loc.locale), t;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(e, t = "milliseconds", i = {}) {
    if (!this.isValid || !e.isValid)
      return De.invalid("created by diffing an invalid DateTime");
    const s = { locale: this.locale, numberingSystem: this.numberingSystem, ...i }, n = iE(t).map(De.normalizeUnit), o = e.valueOf() > this.valueOf(), l = o ? this : e, c = o ? e : this, d = aP(l, c, n, s);
    return o ? d.negate() : d;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(e = "milliseconds", t = {}) {
    return this.diff(st.now(), e, t);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(e) {
    return this.isValid ? nt.fromDateTimes(this, e) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(e, t, i) {
    if (!this.isValid)
      return !1;
    const s = e.valueOf(), n = this.setZone(e.zone, { keepLocalTime: !0 });
    return n.startOf(t, i) <= s && s <= n.endOf(t, i);
  }
  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(e) {
    return this.isValid && e.isValid && this.valueOf() === e.valueOf() && this.zone.equals(e.zone) && this.loc.equals(e.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(e = {}) {
    if (!this.isValid)
      return null;
    const t = e.base || st.fromObject({}, { zone: this.zone }), i = e.padding ? this < t ? -e.padding : e.padding : 0;
    let s = ["years", "months", "days", "hours", "minutes", "seconds"], n = e.unit;
    return Array.isArray(e.unit) && (s = e.unit, n = void 0), Hf(t, this.plus(i), {
      ...e,
      numeric: "always",
      units: s,
      unit: n
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(e = {}) {
    return this.isValid ? Hf(e.base || st.fromObject({}, { zone: this.zone }), this, {
      ...e,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: !0
    }) : null;
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...e) {
    if (!e.every(st.isDateTime))
      throw new Yt("min requires all arguments be DateTimes");
    return Pf(e, (t) => t.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...e) {
    if (!e.every(st.isDateTime))
      throw new Yt("max requires all arguments be DateTimes");
    return Pf(e, (t) => t.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(e, t, i = {}) {
    const { locale: s = null, numberingSystem: n = null } = i, o = Be.fromOpts({
      locale: s,
      numberingSystem: n,
      defaultToEN: !0
    });
    return xv(o, e, t);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(e, t, i = {}) {
    return st.fromFormatExplain(e, t, i);
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return Co;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return Ab;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return P$;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return $b;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return Eb;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return Pb;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return Lb;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return Mb;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return Db;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return Rb;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return Ib;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return Qb;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return Nb;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return Fb;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return Wb;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return Bb;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return zb;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return L$;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return Xb;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return Yb;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return Vb;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return Hb;
  }
};
function mr(a) {
  if (tt.isDateTime(a))
    return a;
  if (a && a.valueOf && Js(a.valueOf()))
    return tt.fromJSDate(a);
  if (a && typeof a == "object")
    return tt.fromObject(a);
  throw new Yt(
    `Unknown datetime argument: ${a}, of type ${typeof a}`
  );
}
var dt;
let Ct = (dt = class extends Date {
  constructor(t = null, i = "YYYY-MM-DD", s = "en-US") {
    super(dt.parseDateTime(t, i, s));
    je(this, "lang");
    this.lang = s;
  }
  static parseDateTime(t, i = "YYYY-MM-DD", s = "en-US") {
    if (!t)
      return new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
    if (t instanceof dt)
      return t.toJSDate();
    if (t instanceof Date)
      return t;
    if (/^-?\d{10,}$/.test(String(t)))
      return new Date(Number(t));
    if (typeof t == "string") {
      const n = [];
      let o = null;
      for (; (o = dt.regex.exec(i)) != null; )
        o[1] !== "\\" && n.push(o);
      if (n.length) {
        const l = { year: null, month: null, shortMonth: null, longMonth: null, day: null, hour: 0, minute: 0, second: 0, ampm: null, value: "" };
        n[0].index > 0 && (l.value += ".*?");
        for (const [d, f] of Object.entries(n)) {
          const p = Number(d), { group: m, pattern: v } = dt.formatPatterns(f[0], s);
          l[m] = p + 1, l.value += v, l.value += ".*?";
        }
        const c = new RegExp(`^${l.value}$`);
        if (c.test(t)) {
          const d = c.exec(t), f = Number(d[l.year]);
          let p = null;
          l.month ? p = Number(d[l.month]) - 1 : l.shortMonth ? p = dt.shortMonths(s).indexOf(d[l.shortMonth]) : l.longMonth && (p = dt.longMonths(s).indexOf(d[l.longMonth]));
          const m = Number(d[l.day]) || 1, v = Number(d[l.hour]);
          let r = Number.isNaN(v) ? 0 : v;
          const h = Number(d[l.minute]), u = Number.isNaN(h) ? 0 : h, g = Number(d[l.second]), b = Number.isNaN(g) ? 0 : g, O = d[l.ampm];
          return O && O === "PM" && (r += 12, r === 24 && (r = 0)), new Date(f, p, m, r, u, b, 0);
        }
      }
    }
    return new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
  }
  static shortMonths(t) {
    return dt.MONTH_JS.map((i) => new Date(2019, i).toLocaleString(t, { month: "short" }));
  }
  static longMonths(t) {
    return dt.MONTH_JS.map((i) => new Date(2019, i).toLocaleString(t, { month: "long" }));
  }
  static formatPatterns(t, i) {
    switch (t) {
      case "YY":
      case "YYYY":
        return { group: "year", pattern: `(\\d{${t.length}})` };
      case "M":
        return { group: "month", pattern: "(\\d{1,2})" };
      case "MM":
        return { group: "month", pattern: "(\\d{2})" };
      case "MMM":
        return { group: "shortMonth", pattern: `(${dt.shortMonths(i).join("|")})` };
      case "MMMM":
        return { group: "longMonth", pattern: `(${dt.longMonths(i).join("|")})` };
      case "D":
        return { group: "day", pattern: "(\\d{1,2})" };
      case "DD":
        return { group: "day", pattern: "(\\d{2})" };
      case "h":
      case "H":
        return { group: "hour", pattern: "(\\d{1,2})" };
      case "hh":
      case "HH":
        return { group: "hour", pattern: "(\\d{2})" };
      case "m":
        return { group: "minute", pattern: "(\\d{1,2})" };
      case "mm":
        return { group: "minute", pattern: "(\\d{2})" };
      case "s":
        return { group: "second", pattern: "(\\d{1,2})" };
      case "ss":
        return { group: "second", pattern: "(\\d{2})" };
      case "a":
      case "A":
        return { group: "ampm", pattern: "(AM|PM|am|pm)" };
    }
  }
  getWeek(t) {
    const i = new Date(this.midnight_ts(this)), s = (this.getDay() + (7 - t)) % 7;
    i.setDate(i.getDate() - s);
    const n = i.getTime();
    return i.setMonth(0, 1), i.getDay() !== t && i.setMonth(0, 1 + (4 - i.getDay() + 7) % 7), 1 + Math.ceil((n - i.getTime()) / 6048e5);
  }
  clone() {
    return new dt(this);
  }
  toJSDate() {
    return new Date(this);
  }
  inArray(t, i = "[]") {
    return t.some((s) => s instanceof Array ? this.isBetween(s[0], s[1], i) : this.isSame(s, "day"));
  }
  isBetween(t, i, s = "()") {
    switch (s) {
      default:
      case "()":
        return this.midnight_ts(this) > this.midnight_ts(t) && this.midnight_ts(this) < this.midnight_ts(i);
      case "[)":
        return this.midnight_ts(this) >= this.midnight_ts(t) && this.midnight_ts(this) < this.midnight_ts(i);
      case "(]":
        return this.midnight_ts(this) > this.midnight_ts(t) && this.midnight_ts(this) <= this.midnight_ts(i);
      case "[]":
        return this.midnight_ts() >= this.midnight_ts(t) && this.midnight_ts() <= this.midnight_ts(i);
    }
  }
  isBefore(t, i = "days") {
    switch (i) {
      case "day":
      case "days":
        return new Date(t.getFullYear(), t.getMonth(), t.getDate()).getTime() > new Date(this.getFullYear(), this.getMonth(), this.getDate()).getTime();
      case "month":
      case "months":
        return new Date(t.getFullYear(), t.getMonth(), 1).getTime() > new Date(this.getFullYear(), this.getMonth(), 1).getTime();
      case "year":
      case "years":
        return t.getFullYear() > this.getFullYear();
    }
    throw new Error("isBefore: Invalid unit!");
  }
  isSameOrBefore(t, i = "days") {
    switch (i) {
      case "day":
      case "days":
        return new Date(t.getFullYear(), t.getMonth(), t.getDate()).getTime() >= new Date(this.getFullYear(), this.getMonth(), this.getDate()).getTime();
      case "month":
      case "months":
        return new Date(t.getFullYear(), t.getMonth(), 1).getTime() >= new Date(this.getFullYear(), this.getMonth(), 1).getTime();
    }
    throw new Error("isSameOrBefore: Invalid unit!");
  }
  isAfter(t, i = "days") {
    switch (i) {
      case "day":
      case "days":
        return new Date(this.getFullYear(), this.getMonth(), this.getDate()).getTime() > new Date(t.getFullYear(), t.getMonth(), t.getDate()).getTime();
      case "month":
      case "months":
        return new Date(this.getFullYear(), this.getMonth(), 1).getTime() > new Date(t.getFullYear(), t.getMonth(), 1).getTime();
      case "year":
      case "years":
        return this.getFullYear() > t.getFullYear();
    }
    throw new Error("isAfter: Invalid unit!");
  }
  isSameOrAfter(t, i = "days") {
    switch (i) {
      case "day":
      case "days":
        return new Date(this.getFullYear(), this.getMonth(), this.getDate()).getTime() >= new Date(t.getFullYear(), t.getMonth(), t.getDate()).getTime();
      case "month":
      case "months":
        return new Date(this.getFullYear(), this.getMonth(), 1).getTime() >= new Date(t.getFullYear(), t.getMonth(), 1).getTime();
    }
    throw new Error("isSameOrAfter: Invalid unit!");
  }
  isSame(t, i = "days") {
    switch (i) {
      case "day":
      case "days":
        return new Date(this.getFullYear(), this.getMonth(), this.getDate()).getTime() === new Date(t.getFullYear(), t.getMonth(), t.getDate()).getTime();
      case "month":
      case "months":
        return new Date(this.getFullYear(), this.getMonth(), 1).getTime() === new Date(t.getFullYear(), t.getMonth(), 1).getTime();
    }
    throw new Error("isSame: Invalid unit!");
  }
  add(t, i = "days") {
    switch (i) {
      case "day":
      case "days":
        this.setDate(this.getDate() + t);
        break;
      case "month":
      case "months":
        this.setMonth(this.getMonth() + t);
    }
    return this;
  }
  subtract(t, i = "days") {
    switch (i) {
      case "day":
      case "days":
        this.setDate(this.getDate() - t);
        break;
      case "month":
      case "months":
        this.setMonth(this.getMonth() - t);
    }
    return this;
  }
  diff(t, i = "days") {
    switch (i) {
      default:
      case "day":
      case "days":
        return Math.round((this.midnight_ts() - this.midnight_ts(t)) / 864e5);
      case "month":
      case "months":
        let s = 12 * (t.getFullYear() - this.getFullYear());
        return s -= t.getMonth(), s += this.getMonth(), s;
    }
  }
  format(t, i = "en-US") {
    let s = "";
    const n = [];
    let o = null;
    for (; (o = dt.regex.exec(t)) != null; )
      o[1] !== "\\" && n.push(o);
    if (n.length) {
      n[0].index > 0 && (s += t.substring(0, n[0].index));
      for (const [l, c] of Object.entries(n)) {
        const d = Number(l);
        s += this.formatTokens(c[0], i), n[d + 1] && (s += t.substring(c.index + c[0].length, n[d + 1].index)), d === n.length - 1 && (s += t.substring(c.index + c[0].length));
      }
    }
    return s.replace(/\\/g, "");
  }
  midnight_ts(t) {
    return t ? new Date(t.getFullYear(), t.getMonth(), t.getDate(), 0, 0, 0, 0).getTime() : new Date(this.getFullYear(), this.getMonth(), this.getDate(), 0, 0, 0, 0).getTime();
  }
  formatTokens(t, i) {
    switch (t) {
      case "YY":
        return String(this.getFullYear()).slice(-2);
      case "YYYY":
        return String(this.getFullYear());
      case "M":
        return String(this.getMonth() + 1);
      case "MM":
        return `0${this.getMonth() + 1}`.slice(-2);
      case "MMM":
        return dt.shortMonths(i)[this.getMonth()];
      case "MMMM":
        return dt.longMonths(i)[this.getMonth()];
      case "D":
        return String(this.getDate());
      case "DD":
        return `0${this.getDate()}`.slice(-2);
      case "H":
        return String(this.getHours());
      case "HH":
        return `0${this.getHours()}`.slice(-2);
      case "h":
        return String(this.getHours() % 12 || 12);
      case "hh":
        return `0${this.getHours() % 12 || 12}`.slice(-2);
      case "m":
        return String(this.getMinutes());
      case "mm":
        return `0${this.getMinutes()}`.slice(-2);
      case "s":
        return String(this.getSeconds());
      case "ss":
        return `0${this.getSeconds()}`.slice(-2);
      case "a":
        return this.getHours() < 12 || this.getHours() === 24 ? "am" : "pm";
      case "A":
        return this.getHours() < 12 || this.getHours() === 24 ? "AM" : "PM";
      default:
        return "";
    }
  }
}, je(dt, "regex", /(\\)?(Y{2,4}|M{1,4}|D{1,2}|H{1,2}|h{1,2}|m{1,2}|s{1,2}|A|a)/g), je(dt, "MONTH_JS", [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), dt);
class TP {
  constructor(e) {
    je(this, "picker");
    this.picker = e;
  }
  render(e, t) {
    e || (e = new Ct()), e.setDate(1), e.setHours(0, 0, 0, 0), typeof this[`get${t}View`] == "function" && this[`get${t}View`](e);
  }
  getContainerView(e) {
    this.picker.ui.container.innerHTML = "", this.picker.options.header && this.picker.trigger("render", { date: e.clone(), view: "Header" }), this.picker.trigger("render", { date: e.clone(), view: "Main" }), this.picker.options.autoApply || this.picker.trigger("render", { date: e.clone(), view: "Footer" });
  }
  getHeaderView(e) {
    const t = document.createElement("header");
    this.picker.options.header instanceof HTMLElement && t.appendChild(this.picker.options.header), typeof this.picker.options.header == "string" && (t.innerHTML = this.picker.options.header), this.picker.ui.container.appendChild(t), this.picker.trigger("view", { target: t, date: e.clone(), view: "Header" });
  }
  getMainView(e) {
    const t = document.createElement("main");
    this.picker.ui.container.appendChild(t);
    const i = document.createElement("div");
    i.className = `calendars grid-${this.picker.options.grid}`;
    for (let s = 0; s < this.picker.options.calendars; s++) {
      const n = document.createElement("div");
      n.className = "calendar", i.appendChild(n);
      const o = this.getCalendarHeaderView(e.clone());
      n.appendChild(o), this.picker.trigger("view", { date: e.clone(), view: "CalendarHeader", index: s, target: o });
      const l = this.getCalendarDayNamesView();
      n.appendChild(l), this.picker.trigger("view", { date: e.clone(), view: "CalendarDayNames", index: s, target: l });
      const c = this.getCalendarDaysView(e.clone());
      n.appendChild(c), this.picker.trigger("view", { date: e.clone(), view: "CalendarDays", index: s, target: c });
      const d = this.getCalendarFooterView(this.picker.options.lang, e.clone());
      n.appendChild(d), this.picker.trigger("view", { date: e.clone(), view: "CalendarFooter", index: s, target: d }), this.picker.trigger("view", { date: e.clone(), view: "CalendarItem", index: s, target: n }), e.add(1, "month");
    }
    t.appendChild(i), this.picker.trigger("view", { date: e.clone(), view: "Calendars", target: i }), this.picker.trigger("view", { date: e.clone(), view: "Main", target: t });
  }
  getFooterView(e) {
    const t = document.createElement("footer"), i = document.createElement("div");
    i.className = "footer-buttons";
    const s = document.createElement("button");
    s.className = "cancel-button unit", s.innerHTML = this.picker.options.locale.cancel, i.appendChild(s);
    const n = document.createElement("button");
    n.className = "apply-button unit", n.innerHTML = this.picker.options.locale.apply, n.disabled = !0, i.appendChild(n), t.appendChild(i), this.picker.ui.container.appendChild(t), this.picker.trigger("view", { date: e, target: t, view: "Footer" });
  }
  getCalendarHeaderView(e) {
    const t = document.createElement("div");
    t.className = "header";
    const i = document.createElement("div");
    i.className = "month-name", i.innerHTML = `<span>${e.toLocaleString(this.picker.options.lang, { month: "long" })}</span> ${e.format("YYYY")}`, t.appendChild(i);
    const s = document.createElement("button");
    s.className = "previous-button unit", s.innerHTML = this.picker.options.locale.previousMonth, t.appendChild(s);
    const n = document.createElement("button");
    return n.className = "next-button unit", n.innerHTML = this.picker.options.locale.nextMonth, t.appendChild(n), t;
  }
  getCalendarDayNamesView() {
    const e = document.createElement("div");
    e.className = "daynames-row";
    for (let t = 1; t <= 7; t++) {
      const i = 3 + this.picker.options.firstDay + t, s = document.createElement("div");
      s.className = "dayname", s.innerHTML = new Date(1970, 0, i, 12, 0, 0, 0).toLocaleString(this.picker.options.lang, { weekday: "short" }), s.title = new Date(1970, 0, i, 12, 0, 0, 0).toLocaleString(this.picker.options.lang, { weekday: "long" }), e.appendChild(s), this.picker.trigger("view", { dayIdx: i, view: "CalendarDayName", target: s });
    }
    return e;
  }
  getCalendarDaysView(e) {
    const t = document.createElement("div");
    t.className = "days-grid";
    const i = this.calcOffsetDays(e, this.picker.options.firstDay), s = 32 - new Date(e.getFullYear(), e.getMonth(), 32).getDate();
    for (let n = 0; n < i; n++) {
      const o = document.createElement("div");
      o.className = "offset", t.appendChild(o);
    }
    for (let n = 1; n <= s; n++) {
      e.setDate(n);
      const o = this.getCalendarDayView(e);
      t.appendChild(o), this.picker.trigger("view", { date: e, view: "CalendarDay", target: o });
    }
    return t;
  }
  getCalendarDayView(e) {
    const t = this.picker.options.date ? new Ct(this.picker.options.date) : null, i = new Ct(), s = document.createElement("div");
    return s.className = "day unit", s.innerHTML = e.format("D"), s.dataset.time = String(e.getTime()), e.isSame(i, "day") && s.classList.add("today"), [0, 6].includes(e.getDay()) && s.classList.add("weekend"), this.picker.datePicked.length ? this.picker.datePicked[0].isSame(e, "day") && s.classList.add("selected") : t && e.isSame(t, "day") && s.classList.add("selected"), this.picker.trigger("view", { date: e, view: "CalendarDay", target: s }), s;
  }
  getCalendarFooterView(e, t) {
    const i = document.createElement("div");
    return i.className = "footer", i;
  }
  calcOffsetDays(e, t) {
    let i = e.getDay() - t;
    return i < 0 && (i += 7), i;
  }
}
let AP = class {
  constructor(e) {
    je(this, "picker");
    je(this, "instances", {});
    this.picker = e;
  }
  initialize() {
    const e = [];
    this.picker.options.plugins.forEach((t) => {
      typeof t == "function" ? e.push(new t()) : typeof t == "string" && typeof easepick < "u" && Object.prototype.hasOwnProperty.call(easepick, t) ? e.push(new easepick[t]()) : console.warn(`easepick: ${t} not found.`);
    }), e.sort((t, i) => t.priority > i.priority ? -1 : t.priority < i.priority || t.dependencies.length > i.dependencies.length ? 1 : t.dependencies.length < i.dependencies.length ? -1 : 0), e.forEach((t) => {
      t.attach(this.picker), this.instances[t.getName()] = t;
    });
  }
  getInstance(e) {
    return this.instances[e];
  }
  addInstance(e) {
    if (Object.prototype.hasOwnProperty.call(this.instances, e))
      console.warn(`easepick: ${e} already added.`);
    else {
      if (typeof easepick < "u" && Object.prototype.hasOwnProperty.call(easepick, e)) {
        const t = new easepick[e]();
        return t.attach(this.picker), this.instances[t.getName()] = t, t;
      }
      if (this.getPluginFn(e) !== "undefined") {
        const t = new (this.getPluginFn(e))();
        return t.attach(this.picker), this.instances[t.getName()] = t, t;
      }
      console.warn(`easepick: ${e} not found.`);
    }
    return null;
  }
  removeInstance(e) {
    return e in this.instances && this.instances[e].detach(), delete this.instances[e];
  }
  reloadInstance(e) {
    return this.removeInstance(e), this.addInstance(e);
  }
  getPluginFn(e) {
    return [...this.picker.options.plugins].filter((t) => typeof t == "function" && new t().getName() === e).shift();
  }
};
class jf {
  constructor(e) {
    je(this, "Calendar", new TP(this));
    je(this, "PluginManager", new AP(this));
    je(this, "calendars", []);
    je(this, "datePicked", []);
    je(this, "cssLoaded", 0);
    je(this, "binds", { hidePicker: this.hidePicker.bind(this), show: this.show.bind(this) });
    je(this, "options", { doc: document, css: [], element: null, firstDay: 1, grid: 1, calendars: 1, lang: "en-US", date: null, format: "YYYY-MM-DD", readonly: !0, autoApply: !0, header: !1, inline: !1, scrollToDate: !0, locale: { nextMonth: '<svg width="11" height="16" xmlns="http://www.w3.org/2000/svg"><path d="M2.748 16L0 13.333 5.333 8 0 2.667 2.748 0l7.919 8z" fill-rule="nonzero"/></svg>', previousMonth: '<svg width="11" height="16" xmlns="http://www.w3.org/2000/svg"><path d="M7.919 0l2.748 2.667L5.333 8l5.334 5.333L7.919 16 0 8z" fill-rule="nonzero"/></svg>', cancel: "Cancel", apply: "Apply" }, documentClick: this.binds.hidePicker, plugins: [] });
    je(this, "ui", { container: null, shadowRoot: null, wrapper: null });
    je(this, "version", "1.2.1");
    const t = { ...this.options.locale, ...e.locale };
    this.options = { ...this.options, ...e }, this.options.locale = t, this.handleOptions(), this.ui.wrapper = document.createElement("span"), this.ui.wrapper.style.display = "none", this.ui.wrapper.style.position = "absolute", this.ui.wrapper.style.pointerEvents = "none", this.ui.wrapper.className = "easepick-wrapper", this.ui.wrapper.attachShadow({ mode: "open" }), this.ui.shadowRoot = this.ui.wrapper.shadowRoot, this.ui.container = document.createElement("div"), this.ui.container.className = "container", this.options.zIndex && (this.ui.container.style.zIndex = String(this.options.zIndex)), this.options.inline && (this.ui.wrapper.style.position = "relative", this.ui.container.classList.add("inline")), this.ui.shadowRoot.appendChild(this.ui.container), this.options.element.after(this.ui.wrapper), this.handleCSS(), this.options.element.addEventListener("click", this.binds.show), this.on("view", this.onView.bind(this)), this.on("render", this.onRender.bind(this)), this.PluginManager.initialize(), this.parseValues(), typeof this.options.setup == "function" && this.options.setup(this), this.on("click", this.onClick.bind(this));
    const i = this.options.scrollToDate ? this.getDate() : null;
    this.renderAll(i);
  }
  on(e, t, i = {}) {
    this.ui.container.addEventListener(e, t, i);
  }
  off(e, t, i = {}) {
    this.ui.container.removeEventListener(e, t, i);
  }
  trigger(e, t = {}) {
    return this.ui.container.dispatchEvent(new CustomEvent(e, { detail: t }));
  }
  destroy() {
    this.options.element.removeEventListener("click", this.binds.show), typeof this.options.documentClick == "function" && document.removeEventListener("click", this.options.documentClick, !0), Object.keys(this.PluginManager.instances).forEach((e) => {
      this.PluginManager.removeInstance(e);
    }), this.ui.wrapper.remove();
  }
  onRender(e) {
    const { view: t, date: i } = e.detail;
    this.Calendar.render(i, t);
  }
  onView(e) {
    const { view: t, target: i } = e.detail;
    t === "Footer" && this.datePicked.length && (i.querySelector(".apply-button").disabled = !1);
  }
  onClickHeaderButton(e) {
    this.isCalendarHeaderButton(e) && (e.classList.contains("next-button") ? this.calendars[0].add(1, "month") : this.calendars[0].subtract(1, "month"), this.renderAll(this.calendars[0]));
  }
  onClickCalendarDay(e) {
    if (this.isCalendarDay(e)) {
      const t = new Ct(e.dataset.time);
      this.options.autoApply ? (this.setDate(t), this.trigger("select", { date: this.getDate() }), this.hide()) : (this.datePicked[0] = t, this.trigger("preselect", { date: this.getDate() }), this.renderAll());
    }
  }
  onClickApplyButton(e) {
    if (this.isApplyButton(e)) {
      if (this.datePicked[0] instanceof Date) {
        const t = this.datePicked[0].clone();
        this.setDate(t);
      }
      this.hide(), this.trigger("select", { date: this.getDate() });
    }
  }
  onClickCancelButton(e) {
    this.isCancelButton(e) && this.hide();
  }
  onClick(e) {
    const t = e.target;
    if (t instanceof HTMLElement) {
      const i = t.closest(".unit");
      if (!(i instanceof HTMLElement))
        return;
      this.onClickHeaderButton(i), this.onClickCalendarDay(i), this.onClickApplyButton(i), this.onClickCancelButton(i);
    }
  }
  isShown() {
    return this.ui.container.classList.contains("inline") || this.ui.container.classList.contains("show");
  }
  show(e) {
    if (this.isShown())
      return;
    const t = e && "target" in e ? e.target : this.options.element, { top: i, left: s } = this.adjustPosition(t);
    this.ui.container.style.top = `${i}px`, this.ui.container.style.left = `${s}px`, this.ui.container.classList.add("show"), this.trigger("show", { target: t });
  }
  hide() {
    this.ui.container.classList.remove("show"), this.datePicked.length = 0, this.renderAll(), this.trigger("hide");
  }
  setDate(e) {
    const t = new Ct(e, this.options.format);
    this.options.date = t.clone(), this.updateValues(), this.calendars.length && this.renderAll();
  }
  getDate() {
    return this.options.date instanceof Ct ? this.options.date.clone() : null;
  }
  parseValues() {
    this.options.date ? this.setDate(this.options.date) : this.options.element instanceof HTMLInputElement && this.options.element.value.length && this.setDate(this.options.element.value), this.options.date instanceof Date || (this.options.date = null);
  }
  updateValues() {
    const e = this.getDate(), t = e instanceof Date ? e.format(this.options.format, this.options.lang) : "", i = this.options.element;
    i instanceof HTMLInputElement ? i.value = t : i instanceof HTMLElement && (i.innerText = t);
  }
  hidePicker(e) {
    let t = e.target, i = null;
    t.shadowRoot && (t = e.composedPath()[0], i = t.getRootNode().host), this.isShown() && i !== this.ui.wrapper && t !== this.options.element && this.hide();
  }
  renderAll(e) {
    this.trigger("render", { view: "Container", date: (e || this.calendars[0]).clone() });
  }
  isCalendarHeaderButton(e) {
    return ["previous-button", "next-button"].some((t) => e.classList.contains(t));
  }
  isCalendarDay(e) {
    return e.classList.contains("day");
  }
  isApplyButton(e) {
    return e.classList.contains("apply-button");
  }
  isCancelButton(e) {
    return e.classList.contains("cancel-button");
  }
  gotoDate(e) {
    const t = new Ct(e, this.options.format);
    t.setDate(1), this.calendars[0] = t.clone(), this.renderAll();
  }
  clear() {
    this.options.date = null, this.datePicked.length = 0, this.updateValues(), this.renderAll(), this.trigger("clear");
  }
  handleOptions() {
    this.options.element instanceof HTMLElement || (this.options.element = this.options.doc.querySelector(this.options.element)), typeof this.options.documentClick == "function" && document.addEventListener("click", this.options.documentClick, !0), this.options.element instanceof HTMLInputElement && (this.options.element.readOnly = this.options.readonly), this.options.date ? this.calendars[0] = new Ct(this.options.date, this.options.format) : this.calendars[0] = new Ct();
  }
  handleCSS() {
    if (Array.isArray(this.options.css))
      this.options.css.forEach((e) => {
        const t = document.createElement("link");
        t.href = e, t.rel = "stylesheet";
        const i = () => {
          this.cssLoaded++, this.cssLoaded === this.options.css.length && (this.ui.wrapper.style.display = "");
        };
        t.addEventListener("load", i), t.addEventListener("error", i), this.ui.shadowRoot.append(t);
      });
    else if (typeof this.options.css == "string") {
      const e = document.createElement("style"), t = document.createTextNode(this.options.css);
      e.appendChild(t), this.ui.shadowRoot.append(e), this.ui.wrapper.style.display = "";
    } else
      typeof this.options.css == "function" && (this.options.css.call(this, this), this.ui.wrapper.style.display = "");
  }
  adjustPosition(e) {
    const t = e.getBoundingClientRect(), i = this.ui.wrapper.getBoundingClientRect();
    this.ui.container.classList.add("calc");
    const s = this.ui.container.getBoundingClientRect();
    this.ui.container.classList.remove("calc");
    let n = t.bottom - i.bottom, o = t.left - i.left;
    return typeof window < "u" && (window.innerHeight < n + s.height && n - s.height >= 0 && (n = t.top - i.top - s.height), window.innerWidth < o + s.width && t.right - s.width >= 0 && (o = t.right - i.right - s.width)), { left: o, top: n };
  }
}
var $P = Object.freeze({ __proto__: null, Core: jf, create: jf });
class EP {
  constructor() {
    je(this, "picker");
    je(this, "options");
    je(this, "priority", 0);
    je(this, "dependencies", []);
  }
  attach(e) {
    const t = this.getName(), i = { ...this.options };
    this.options = { ...this.options, ...e.options[t] || {} };
    for (const n of Object.keys(i))
      if (i[n] !== null && typeof i[n] == "object" && Object.keys(i[n]).length && t in e.options && n in e.options[t]) {
        const o = { ...e.options[t][n] };
        o !== null && typeof o == "object" && Object.keys(o).length && Object.keys(o).every((l) => Object.keys(i[n]).includes(l)) && (this.options[n] = { ...i[n], ...o });
      }
    if (this.picker = e, this.dependenciesNotFound()) {
      const n = this.dependencies.filter((o) => !this.pluginsAsStringArray().includes(o));
      return void console.warn(`${this.getName()}: required dependencies (${n.join(", ")}).`);
    }
    const s = this.camelCaseToKebab(this.getName());
    this.picker.ui.container.classList.add(s), this.onAttach();
  }
  detach() {
    const e = this.camelCaseToKebab(this.getName());
    this.picker.ui.container.classList.remove(e), typeof this.onDetach == "function" && this.onDetach();
  }
  dependenciesNotFound() {
    return this.dependencies.length && !this.dependencies.every((e) => this.pluginsAsStringArray().includes(e));
  }
  pluginsAsStringArray() {
    return this.picker.options.plugins.map((e) => typeof e == "function" ? new e().getName() : e);
  }
  camelCaseToKebab(e) {
    return e.replace(/([a-zA-Z])(?=[A-Z])/g, "$1-").toLowerCase();
  }
}
class PP extends EP {
  constructor() {
    super(...arguments);
    je(this, "tooltipElement");
    je(this, "triggerElement");
    je(this, "binds", { setStartDate: this.setStartDate.bind(this), setEndDate: this.setEndDate.bind(this), setDateRange: this.setDateRange.bind(this), getStartDate: this.getStartDate.bind(this), getEndDate: this.getEndDate.bind(this), onView: this.onView.bind(this), onShow: this.onShow.bind(this), onMouseEnter: this.onMouseEnter.bind(this), onMouseLeave: this.onMouseLeave.bind(this), onClickCalendarDay: this.onClickCalendarDay.bind(this), onClickApplyButton: this.onClickApplyButton.bind(this), parseValues: this.parseValues.bind(this), updateValues: this.updateValues.bind(this), clear: this.clear.bind(this) });
    je(this, "options", { elementEnd: null, startDate: null, endDate: null, repick: !1, strict: !0, delimiter: " - ", tooltip: !0, tooltipNumber: (t) => t, locale: { zero: "", one: "day", two: "", few: "", many: "", other: "days" }, documentClick: this.hidePicker.bind(this) });
  }
  getName() {
    return "RangePlugin";
  }
  onAttach() {
    this.binds._setStartDate = this.picker.setStartDate, this.binds._setEndDate = this.picker.setEndDate, this.binds._setDateRange = this.picker.setDateRange, this.binds._getStartDate = this.picker.getStartDate, this.binds._getEndDate = this.picker.getEndDate, this.binds._parseValues = this.picker.parseValues, this.binds._updateValues = this.picker.updateValues, this.binds._clear = this.picker.clear, this.binds._onClickCalendarDay = this.picker.onClickCalendarDay, this.binds._onClickApplyButton = this.picker.onClickApplyButton, Object.defineProperties(this.picker, { setStartDate: { configurable: !0, value: this.binds.setStartDate }, setEndDate: { configurable: !0, value: this.binds.setEndDate }, setDateRange: { configurable: !0, value: this.binds.setDateRange }, getStartDate: { configurable: !0, value: this.binds.getStartDate }, getEndDate: { configurable: !0, value: this.binds.getEndDate }, parseValues: { configurable: !0, value: this.binds.parseValues }, updateValues: { configurable: !0, value: this.binds.updateValues }, clear: { configurable: !0, value: this.binds.clear }, onClickCalendarDay: { configurable: !0, value: this.binds.onClickCalendarDay }, onClickApplyButton: { configurable: !0, value: this.binds.onClickApplyButton } }), this.options.elementEnd && (this.options.elementEnd instanceof HTMLElement || (this.options.elementEnd = this.picker.options.doc.querySelector(this.options.elementEnd)), this.options.elementEnd instanceof HTMLInputElement && (this.options.elementEnd.readOnly = this.picker.options.readonly), typeof this.picker.options.documentClick == "function" && (document.removeEventListener("click", this.picker.options.documentClick, !0), typeof this.options.documentClick == "function" && document.addEventListener("click", this.options.documentClick, !0)), this.options.elementEnd.addEventListener("click", this.picker.show.bind(this.picker))), this.options.repick = this.options.repick && this.options.elementEnd instanceof HTMLElement, this.picker.options.date = null, this.picker.on("view", this.binds.onView), this.picker.on("show", this.binds.onShow), this.picker.on("mouseenter", this.binds.onMouseEnter, !0), this.picker.on("mouseleave", this.binds.onMouseLeave, !0), this.checkIntlPluralLocales();
  }
  onDetach() {
    Object.defineProperties(this.picker, { setStartDate: { configurable: !0, value: this.binds._setStartDate }, setEndDate: { configurable: !0, value: this.binds._setEndDate }, setDateRange: { configurable: !0, value: this.binds._setDateRange }, getStartDate: { configurable: !0, value: this.binds._getStartDate }, getEndDate: { configurable: !0, value: this.binds._getEndDate }, parseValues: { configurable: !0, value: this.binds._parseValues }, updateValues: { configurable: !0, value: this.binds._updateValues }, clear: { configurable: !0, value: this.binds._clear }, onClickCalendarDay: { configurable: !0, value: this.binds._onClickCalendarDay }, onClickApplyButton: { configurable: !0, value: this.binds._onClickApplyButton } }), this.picker.off("view", this.binds.onView), this.picker.off("show", this.binds.onShow), this.picker.off("mouseenter", this.binds.onMouseEnter, !0), this.picker.off("mouseleave", this.binds.onMouseLeave, !0);
  }
  parseValues() {
    if (this.options.startDate || this.options.endDate)
      this.options.strict ? this.options.startDate && this.options.endDate ? this.setDateRange(this.options.startDate, this.options.endDate) : (this.options.startDate = null, this.options.endDate = null) : (this.options.startDate && this.setStartDate(this.options.startDate), this.options.endDate && this.setEndDate(this.options.endDate));
    else if (this.options.elementEnd)
      this.options.strict ? this.picker.options.element instanceof HTMLInputElement && this.picker.options.element.value.length && this.options.elementEnd instanceof HTMLInputElement && this.options.elementEnd.value.length && this.setDateRange(this.picker.options.element.value, this.options.elementEnd.value) : (this.picker.options.element instanceof HTMLInputElement && this.picker.options.element.value.length && this.setStartDate(this.picker.options.element.value), this.options.elementEnd instanceof HTMLInputElement && this.options.elementEnd.value.length && this.setEndDate(this.options.elementEnd.value));
    else if (this.picker.options.element instanceof HTMLInputElement && this.picker.options.element.value.length) {
      const [t, i] = this.picker.options.element.value.split(this.options.delimiter);
      this.options.strict ? t && i && this.setDateRange(t, i) : (t && this.setStartDate(t), i && this.setEndDate(i));
    }
  }
  updateValues() {
    const t = this.picker.options.element, i = this.options.elementEnd, s = this.picker.getStartDate(), n = this.picker.getEndDate(), o = s instanceof Date ? s.format(this.picker.options.format, this.picker.options.lang) : "", l = n instanceof Date ? n.format(this.picker.options.format, this.picker.options.lang) : "";
    if (i)
      t instanceof HTMLInputElement ? t.value = o : t instanceof HTMLElement && (t.innerText = o), i instanceof HTMLInputElement ? i.value = l : i instanceof HTMLElement && (i.innerText = l);
    else {
      const c = `${o}${o || l ? this.options.delimiter : ""}${l}`;
      t instanceof HTMLInputElement ? t.value = c : t instanceof HTMLElement && (t.innerText = c);
    }
  }
  clear() {
    this.options.startDate = null, this.options.endDate = null, this.picker.datePicked.length = 0, this.updateValues(), this.picker.renderAll(), this.picker.trigger("clear");
  }
  onShow(t) {
    const { target: i } = t.detail;
    this.triggerElement = i, this.picker.options.scrollToDate && this.getStartDate() instanceof Date && this.picker.gotoDate(this.getStartDate()), this.initializeRepick();
  }
  onView(t) {
    const { view: i, target: s } = t.detail;
    if (i === "Main" && (this.tooltipElement = document.createElement("span"), this.tooltipElement.className = "range-plugin-tooltip", s.appendChild(this.tooltipElement)), i === "CalendarDay") {
      const n = new Ct(s.dataset.time), o = this.picker.datePicked, l = o.length ? this.picker.datePicked[0] : this.getStartDate(), c = o.length ? this.picker.datePicked[1] : this.getEndDate();
      l && l.isSame(n, "day") && s.classList.add("start"), l && c && (c.isSame(n, "day") && s.classList.add("end"), n.isBetween(l, c) && s.classList.add("in-range"));
    }
    if (i === "Footer") {
      const n = this.picker.datePicked.length === 1 && !this.options.strict || this.picker.datePicked.length === 2;
      s.querySelector(".apply-button").disabled = !n;
    }
  }
  hidePicker(t) {
    let i = t.target, s = null;
    i.shadowRoot && (i = t.composedPath()[0], s = i.getRootNode().host), this.picker.isShown() && s !== this.picker.ui.wrapper && i !== this.picker.options.element && i !== this.options.elementEnd && this.picker.hide();
  }
  setStartDate(t) {
    const i = new Ct(t, this.picker.options.format);
    this.options.startDate = i ? i.clone() : null, this.updateValues(), this.picker.renderAll();
  }
  setEndDate(t) {
    const i = new Ct(t, this.picker.options.format);
    this.options.endDate = i ? i.clone() : null, this.updateValues(), this.picker.renderAll();
  }
  setDateRange(t, i) {
    const s = new Ct(t, this.picker.options.format), n = new Ct(i, this.picker.options.format);
    this.options.startDate = s ? s.clone() : null, this.options.endDate = n ? n.clone() : null, this.updateValues(), this.picker.renderAll();
  }
  getStartDate() {
    return this.options.startDate instanceof Date ? this.options.startDate.clone() : null;
  }
  getEndDate() {
    return this.options.endDate instanceof Date ? this.options.endDate.clone() : null;
  }
  onMouseEnter(t) {
    const i = t.target;
    if (i instanceof HTMLElement) {
      this.isContainer(i) && this.initializeRepick();
      const s = i.closest(".unit");
      if (!(s instanceof HTMLElement))
        return;
      if (this.picker.isCalendarDay(s)) {
        if (this.picker.datePicked.length !== 1)
          return;
        let n = this.picker.datePicked[0].clone(), o = new Ct(s.dataset.time), l = !1;
        if (n.isAfter(o, "day")) {
          const c = n.clone();
          n = o.clone(), o = c.clone(), l = !0;
        }
        if ([...this.picker.ui.container.querySelectorAll(".day")].forEach((c) => {
          const d = new Ct(c.dataset.time), f = this.picker.Calendar.getCalendarDayView(d);
          d.isBetween(n, o) && f.classList.add("in-range"), d.isSame(this.picker.datePicked[0], "day") && (f.classList.add("start"), f.classList.toggle("flipped", l)), c === s && (f.classList.add("end"), f.classList.toggle("flipped", l)), c.className = f.className;
        }), this.options.tooltip) {
          const c = this.options.tooltipNumber(o.diff(n, "day") + 1);
          if (c > 0) {
            const d = new Intl.PluralRules(this.picker.options.lang).select(c), f = `${c} ${this.options.locale[d]}`;
            this.showTooltip(s, f);
          } else
            this.hideTooltip();
        }
      }
    }
  }
  onMouseLeave(t) {
    if (this.isContainer(t.target) && this.options.repick) {
      const i = this.getStartDate(), s = this.getEndDate();
      i && s && (this.picker.datePicked.length = 0, this.picker.renderAll());
    }
  }
  onClickCalendarDay(t) {
    if (this.picker.isCalendarDay(t)) {
      this.picker.datePicked.length === 2 && (this.picker.datePicked.length = 0);
      const i = new Ct(t.dataset.time);
      if (this.picker.datePicked[this.picker.datePicked.length] = i, this.picker.datePicked.length === 2 && this.picker.datePicked[0].isAfter(this.picker.datePicked[1])) {
        const s = this.picker.datePicked[1].clone();
        this.picker.datePicked[1] = this.picker.datePicked[0].clone(), this.picker.datePicked[0] = s.clone();
      }
      this.picker.datePicked.length !== 1 && this.picker.options.autoApply || this.picker.trigger("preselect", { start: this.picker.datePicked[0] instanceof Date ? this.picker.datePicked[0].clone() : null, end: this.picker.datePicked[1] instanceof Date ? this.picker.datePicked[1].clone() : null }), this.picker.datePicked.length === 1 && (!this.options.strict && this.picker.options.autoApply && (this.picker.options.element === this.triggerElement && this.setStartDate(this.picker.datePicked[0]), this.options.elementEnd === this.triggerElement && this.setEndDate(this.picker.datePicked[0]), this.picker.trigger("select", { start: this.picker.getStartDate(), end: this.picker.getEndDate() })), this.picker.renderAll()), this.picker.datePicked.length === 2 && (this.picker.options.autoApply ? (this.setDateRange(this.picker.datePicked[0], this.picker.datePicked[1]), this.picker.trigger("select", { start: this.picker.getStartDate(), end: this.picker.getEndDate() }), this.picker.hide()) : (this.hideTooltip(), this.picker.renderAll()));
    }
  }
  onClickApplyButton(t) {
    this.picker.isApplyButton(t) && (this.picker.datePicked.length !== 1 || this.options.strict || (this.picker.options.element === this.triggerElement && (this.options.endDate = null, this.setStartDate(this.picker.datePicked[0])), this.options.elementEnd === this.triggerElement && (this.options.startDate = null, this.setEndDate(this.picker.datePicked[0]))), this.picker.datePicked.length === 2 && this.setDateRange(this.picker.datePicked[0], this.picker.datePicked[1]), this.picker.trigger("select", { start: this.picker.getStartDate(), end: this.picker.getEndDate() }), this.picker.hide());
  }
  showTooltip(t, i) {
    this.tooltipElement.style.visibility = "visible", this.tooltipElement.innerHTML = i;
    const s = this.picker.ui.container.getBoundingClientRect(), n = this.tooltipElement.getBoundingClientRect(), o = t.getBoundingClientRect();
    let l = o.top, c = o.left;
    l -= s.top, c -= s.left, l -= n.height, c -= n.width / 2, c += o.width / 2, this.tooltipElement.style.top = `${l}px`, this.tooltipElement.style.left = `${c}px`;
  }
  hideTooltip() {
    this.tooltipElement.style.visibility = "hidden";
  }
  checkIntlPluralLocales() {
    if (!this.options.tooltip)
      return;
    const t = [.../* @__PURE__ */ new Set([new Intl.PluralRules(this.picker.options.lang).select(0), new Intl.PluralRules(this.picker.options.lang).select(1), new Intl.PluralRules(this.picker.options.lang).select(2), new Intl.PluralRules(this.picker.options.lang).select(6), new Intl.PluralRules(this.picker.options.lang).select(18)])], i = Object.keys(this.options.locale);
    t.every((s) => i.includes(s)) || console.warn(`${this.getName()}: provide locales (${t.join(", ")}) for correct tooltip text.`);
  }
  initializeRepick() {
    if (!this.options.repick)
      return;
    const t = this.getStartDate(), i = this.getEndDate();
    i && this.triggerElement === this.picker.options.element && (this.picker.datePicked[0] = i), t && this.triggerElement === this.options.elementEnd && (this.picker.datePicked[0] = t);
  }
  isContainer(t) {
    return t === this.picker.ui.container;
  }
}
const LP = ["placeholder"], MP = "DD/MM/YYYY", DP = j({
  __name: "FormDatepicker",
  props: {
    modelValue: {},
    config: { default: () => ({}) },
    placeholder: {},
    label: {},
    range: { type: Boolean },
    noClear: { type: Boolean },
    size: {},
    disabled: { type: Boolean },
    loading: { type: Boolean },
    float: { type: Boolean },
    labelInfo: {},
    state: { type: Boolean, default: void 0 },
    invalidFeedback: {},
    last: { type: Boolean },
    autofocus: { type: Boolean }
  },
  emits: ["update:modelValue", "update"],
  setup(a, { expose: e, emit: t }) {
    var p;
    const i = a, s = t, n = Ci(), o = `ui-form-datepicker-${(p = yt()) == null ? void 0 : p.uid}`, l = ge(() => [
      i.range && "-range",
      i.size && `-${i.size}`,
      i.state === !0 ? "-valid" : i.state === !1 ? "-invalid" : ""
    ]), c = (m) => {
      s("update:modelValue", m), s("update", m);
    }, d = Lt(() => {
      if (n.value && i.modelValue) {
        const m = i.modelValue.split("--"), v = tt.fromSQL(m[0]).toFormat("dd/MM/yyyy");
        if (i.range && m.length > 1) {
          const r = tt.fromSQL(m[1]).toFormat("dd/MM/yyyy");
          n.value.setDateRange(v, r);
        } else
          n.value.setDate(v);
      }
      i.range && (i.config.singleMode = !1, i.config.numberOfMonths = 2, i.config.numberOfColumns = 2);
    });
    at(() => {
      const m = document.getElementById(o);
      if (m) {
        const v = {
          element: m,
          format: MP,
          plugins: [],
          css: ".calendar,.calendar>.header,.container>footer,.container>header{padding:10px}.container.inline,.container.range-plugin .calendar>.days-grid>.day{position:relative}:host{--color-bg-default:var(--s-color-fill-default);--color-bg-secondary:var(--s-color-fill-default-light);--color-fg-default:var(--s-color-content-default);--color-fg-primary:var(--s-color-fill-highlight);--color-fg-secondary:var(--s-color-fill-highlight-light);--color-fg-selected:#fff;--color-fg-muted:var(--s-color-content-light);--color-fg-accent:var(--s-color-content-critical);--color-btn-primary-bg:#fff;--color-btn-primary-fg:#6b82ff;--color-btn-primary-border:var(--s-color-border-default);--color-btn-primary-hover-bg:#6b82ff;--color-btn-primary-hover-fg:#fff;--color-btn-primary-hover-border:#6b82ff;--color-btn-primary-disabled-bg:#a2b0ff;--color-btn-primary-disabled-fg:#fff;--color-btn-primary-disabled-border:#a2b0ff;--color-btn-secondary-bg:#fff;--color-btn-secondary-fg:var(--s-color-content-light);--color-btn-secondary-border:#748194;--color-btn-secondary-hover-bg:#748194;--color-btn-secondary-hover-fg:#fff;--color-btn-secondary-hover-border:#748194;--color-btn-secondary-disabled-bg:#b5bbc4;--color-btn-secondary-disabled-fg:#fff;--color-btn-secondary-disabled-border:#b5bbc4;--color-border-default:var(--s-color-border-default);--color-border-locked:#f9f9f9;--day-width:var(--s-spacing-large);--day-height:var(--s-spacing-large);--border-radius:var(--s-border-radius-small);--primary-color:var(--b-color-base);--secondary-color:#748194;--white-color:#fff;--black-color:#333;--lightgray-color:#f9f9f9;--gray-color:#9e9e9e;--red-color:#e63757}*{box-sizing:border-box}.container{border-radius:4px;border:var(--s-border-light);color:var(--color-fg-default);cursor:default;display:inline-block;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,sans-serif;font-size:.8em;height:0;overflow:hidden;pointer-events:all;position:absolute;transform:scale(0);transform-origin:top left;transition:transform .3s ease-out}.container.calc{height:auto;transform:none;transition:none;visibility:hidden}.container.show{box-shadow:var(--s-shadow-level-2);height:auto;transform:scale(1);z-index:var(--s-index-max);left:0!important;}.container.inline{box-shadow:0 7px 14px 0 rgba(65,69,88,.1),0 3px 6px 0 rgba(0,0,0,.07);height:auto;left:0;top:0;transform:scaleY(1)}.container>main{background-color:var(--color-bg-default)}.calendar>.header button:hover,.container>footer,.container>header,.preset-plugin-container{background-color:var(--color-bg-secondary)}.container>footer .footer-buttons{-moz-column-gap:5px;column-gap:5px;display:flex;justify-content:flex-end}.container>footer .footer-buttons>button{background-color:transparent;border:1px solid transparent;border-radius:var(--border-radius);cursor:pointer;padding:5px 10px}.container>footer .footer-buttons>button.apply-button{background-color:var(--color-btn-primary-bg);border-color:var(--color-btn-primary-border);color:var(--color-btn-primary-fg)}.container>footer .footer-buttons>button.apply-button:hover{background-color:var(--color-btn-primary-hover-bg);border-color:var(--color-btn-primary-hover-border);color:var(--color-btn-primary-hover-fg)}.container>footer .footer-buttons>button.apply-button:disabled{background-color:var(--color-btn-primary-disabled-bg);border-color:var(--color-btn-primary-disabled-border);color:var(--color-btn-primary-disabled-fg);cursor:default}.container>footer .footer-buttons>button.cancel-button{background-color:var(--color-btn-secondary-bg);border-color:var(--color-btn-secondary-border);color:var(--color-btn-secondary-fg)}.container>footer .footer-buttons>button.cancel-button:hover{background-color:var(--color-btn-secondary-hover-bg);border-color:var(--color-btn-secondary-hover-border);color:var(--color-btn-secondary-hover-fg)}.container>footer .footer-buttons>button.cancel-button:disabled{background-color:var(--color-btn-secondary-disabled-bg);border-color:var(--color-btn-secondary-disabled-border);color:var(--color-btn-secondary-disabled-fg);cursor:default}.grid-1{grid-template-columns:repeat(1,1fr)}.grid-2{grid-template-columns:repeat(2,1fr)}.grid-3{grid-template-columns:repeat(3,1fr)}.grid-4{grid-template-columns:repeat(4,1fr)}.grid-5{grid-template-columns:repeat(5,1fr)}.grid-6{grid-template-columns:repeat(6,1fr)}.grid-7{grid-template-columns:repeat(7,1fr)}.grid-8{grid-template-columns:repeat(8,1fr)}.grid-9{grid-template-columns:repeat(9,1fr)}.grid-10{grid-template-columns:repeat(10,1fr)}.grid-11{grid-template-columns:repeat(11,1fr)}.grid-12{grid-template-columns:repeat(12,1fr)}.calendars,.container.preset-plugin main{display:grid}.calendars:not(.grid-1) .calendar>.header .month-name{order:2;text-align:center}.calendars:not(.grid-1) .calendar>.header .previous-button{order:1;visibility:hidden}.calendars:not(.grid-1) .calendar>.header .next-button{order:3;visibility:hidden}.calendars:not(.grid-1) .calendar:first-child>.header .previous-button,.calendars:not(.grid-1) .calendar:last-child>.header .next-button,.container.amp-plugin .calendars.calendars:not(.grid-1) .calendar:last-child>.header .reset-button{visibility:visible}.calendar>.header{align-items:center;-moz-column-gap:5px;column-gap:5px;display:flex;justify-content:space-between}.calendar>.header .month-name{flex:1;font-size:15px;font-weight:500}.calendar>.header .month-name>span,.container.amp-plugin .calendars .calendar>.header .month-name select.month-name--dropdown{font-weight:700}.calendar>.header button{align-items:center;background-color:transparent;border:1px solid transparent;border-radius:2px;color:var(--color-btn-secondary-fg);cursor:pointer;display:flex;justify-content:center;padding:4px 7px}.calendar>.header button:hover>img,.calendar>.header button:hover>svg{fill:var(--color-fg-primary);color:var(--color-fg-primary)}.calendar>.header button>img,.calendar>.header button>svg{fill:var(--color-btn-secondary-fg);color:var(--color-btn-secondary-fg);pointer-events:none;transform:scale(.7)}.calendar>.daynames-row,.calendar>.days-grid{display:grid;grid-template-columns:repeat(7,1fr);row-gap:2px}.calendar>.daynames-row>.day,.calendar>.daynames-row>.dayname,.calendar>.days-grid>.day,.calendar>.days-grid>.dayname{align-items:center;cursor:default;display:flex;flex-direction:column;font-size:13px;justify-content:center}.calendar>.daynames-row>.dayname{color:var(--color-fg-muted);font-size:12px;padding:5px 0}.calendar>.days-grid>.day{border:1px solid transparent;border-radius:2px;height:var(--day-height);max-height:var(--day-height);max-width:var(--day-width);min-height:var(--day-height);min-width:var(--day-width);padding:10px 0;width:var(--day-width)}.calendar>.days-grid>.day:hover{border:1px solid var(--s-color-border-highlight);color:var(--s-color-content-highlight)}.calendar>.days-grid>.day.today{color:var(--s-color-content-highlight)}.calendar>.days-grid>.day.selected,.container.range-plugin .calendar>.days-grid>.day.end,.container.range-plugin .calendar>.days-grid>.day.start{background-color:var(--s-color-fill-highlight);color:var(--color-fg-selected)}@media (max-width:480px){.container:not(.inline){transform:scaleY(0)!important;transform-origin:bottom center!important}.container:not(.inline).show{top:var(--s-spacing-large)!important;left:0!important;position:absolute!important;right:0!important;bottom:auto!important;transform:scaleY(1)!important}.container{width:100%}.calendars{grid-template-columns:repeat(1,1fr)}.calendars .calendar{box-sizing:border-box;width:100%}.calendars .calendar:nth-child(n+2){display:none}.calendars .calendar>.days-grid>.day{height:auto;max-height:unset;max-width:unset;min-height:unset;min-width:unset;width:auto}.calendars .calendar>.header:not(.no-next-month) .next-button{visibility:visible}}:host{--color-fg-locked:#9e9e9e;--color-bg-locked:#ffab91;--color-bg-unavailable:#f9f9f9;--color-bg-inrange:var(--s-color-fill-highlight-light);--color-bg-tooltip:#fff;--color-fg-tooltip:#333}.container.amp-plugin .calendars.calendars:not(.grid-1) .calendar>.header .reset-button,.container.lock-plugin .calendars .calendar:first-child>.header.no-previous-month .previous-button,.container.lock-plugin .calendars .calendar:last-child>.header.no-next-month .next-button{visibility:hidden}.container.lock-plugin .calendar>.days-grid>.day.not-available{background-color:var(--color-bg-unavailable);color:var(--color-fg-locked);font-style:italic;pointer-events:none}.container.lock-plugin .calendar>.days-grid>.day.locked{background-color:transparent;border:1px solid var(--color-border-locked);color:var(--color-fg-locked);pointer-events:none}.container.lock-plugin .calendar>.days-grid>.day.locked:not(.start):not(.end){background-image:repeating-linear-gradient(135deg,transparent,var(--color-bg-locked) 2px,transparent 2px,transparent 4px);font-style:italic}.container.lock-plugin .preset-plugin-container>button:disabled{color:var(--color-fg-locked);pointer-events:none}.container.preset-plugin>main{display:flex}.container.preset-plugin>main.preset-left{flex-direction:row-reverse}.container.preset-plugin>main.preset-bottom .preset-plugin-container,.container.preset-plugin>main.preset-right,.container.preset-plugin>main.preset-top .preset-plugin-container{flex-direction:row}.container.preset-plugin>main.preset-left .preset-plugin-container,.container.preset-plugin>main.preset-right .preset-plugin-container{flex-direction:column;width:130px}.container.preset-plugin>main.preset-top{flex-direction:column-reverse}.container.preset-plugin>main.preset-bottom,.container>main:not([class*=preset-]){flex-direction:column}.preset-plugin-container{display:flex;justify-content:space-between;padding:10px}.preset-plugin-container>button{background-color:var(--color-bg-default);border:1px solid transparent;border-radius:4px;color:var(--color-fg-default);padding:5px}.preset-plugin-container>button:hover{border:1px solid var(--color-fg-primary);color:var(--color-fg-primary);cursor:pointer}.range-plugin-tooltip{background-color:var(--color-bg-tooltip);border-radius:var(--border-radius);box-shadow:0 1px 3px rgba(0,0,0,.25);color:var(--color-fg-tooltip);font-size:12px;margin-top:-4px;padding:4px 8px;pointer-events:none;position:absolute;visibility:hidden;white-space:nowrap;z-index:1}.range-plugin-tooltip:before{border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid rgba(0,0,0,.12);bottom:-5px;content:'';left:calc(50% - 5px);position:absolute}.range-plugin-tooltip:after{border-left:4px solid transparent;border-right:4px solid transparent;border-top:4px solid var(--color-bg-tooltip);bottom:-4px;content:'';left:calc(50% - 4px);position:absolute}.container.range-plugin .calendar>.days-grid>.day.in-range:last-of-type,.container.range-plugin .calendar>.days-grid>div:nth-child(7n).in-range{border-bottom-right-radius:var(--border-radius);border-top-right-radius:var(--border-radius)}.container.range-plugin .calendar>.days-grid>.day.in-range{background-color:var(--color-bg-inrange);border-radius:0}.container.range-plugin .calendar>.days-grid>.day.start{border-bottom-right-radius:0;border-top-right-radius:0}.container.range-plugin .calendar>.days-grid>.day.start:after{border:8px solid transparent;border-left:8px solid var(--color-fg-primary);content:'';pointer-events:none;position:absolute;right:-14px;z-index:1}.container.range-plugin .calendar>.days-grid>.day.start.flipped{border-bottom-left-radius:0;border-bottom-right-radius:var(--border-radius);border-top-left-radius:0;border-top-right-radius:var(--border-radius)}.container.range-plugin .calendar>.days-grid>.day.start.flipped:after{border-left-color:transparent;border-right-color:var(--color-fg-primary);left:-14px;right:auto}.container.range-plugin .calendar>.days-grid>.day.end{border-bottom-left-radius:0;border-top-left-radius:0}.container.range-plugin .calendar>.days-grid>.day.end:after{border:8px solid transparent;border-right:8px solid var(--color-fg-primary);content:'';left:-14px;pointer-events:none;position:absolute;z-index:1}.container.range-plugin .calendar>.days-grid>.day.end.flipped,.container.range-plugin .calendar>.days-grid>div:not(.day)+.day.in-range,.container.range-plugin .calendar>.days-grid>div:nth-child(7n+1).in-range{border-bottom-left-radius:var(--border-radius);border-top-left-radius:var(--border-radius)}.container.range-plugin .calendar>.days-grid>.day.end.flipped{border-bottom-right-radius:0;border-top-right-radius:0}.container.range-plugin .calendar>.days-grid>.day.end.flipped:after{border-left-color:var(--color-fg-primary);border-right-color:transparent;left:auto;right:-14px}.container.range-plugin .calendar>.days-grid>.day.start.end{border-radius:var(--border-radius)}.container.range-plugin .calendar>.days-grid>.day.start.end:after{content:none}.container.preset-plugin main.preset-left>.calendars,.container.preset-plugin main.preset-top>.calendars{order:2}.container.preset-plugin main.preset-left>.preset-plugin-container,.container.preset-plugin main.preset-top>.preset-plugin-container{order:1}.container.preset-plugin main.preset-left,.container.preset-plugin main.preset-right{grid-template-columns:auto auto}.container.preset-plugin main.preset-left .preset-plugin-container,.container.preset-plugin main.preset-right .preset-plugin-container{grid-row:span 2;width:130px}.container.amp-plugin .calendars .calendar>.header .reset-button,.container.preset-plugin main.preset-bottom>.preset-plugin-container{order:4}.container.preset-plugin main.preset-bottom,.container.preset-plugin main.preset-top{grid-template-columns:auto}.container.preset-plugin main>.time-plugin-container{order:3}.time-plugin-container{background-color:var(--color-bg-secondary);border-bottom:1px solid var(--color-border-default);display:flex;justify-content:space-around;padding:10px}.time-plugin-container input[type=time]{font-size:18px}.time-plugin-container input[type=time],.time-plugin-container select{background-color:var(--color-bg-default);border:1px solid transparent;border-radius:4px;color:var(--color-fg-default)}.time-plugin-container select{margin:0 3px}.container.amp-plugin .calendars .calendar>.header .month-name{align-items:center;-moz-column-gap:5px;column-gap:5px;display:flex;justify-content:center}.container.amp-plugin .calendars .calendar>.header .month-name select{border:none;font-size:14px;padding:3px}.container.amp-plugin.week-numbers .calendar>.daynames-row,.container.amp-plugin.week-numbers .calendar>.days-grid{grid-template-columns:30px repeat(7,1fr)}.container.amp-plugin.week-numbers .calendar>.daynames-row .wnum-header,.container.amp-plugin.week-numbers .calendar>.daynames-row .wnum-item,.container.amp-plugin.week-numbers .calendar>.days-grid .wnum-header,.container.amp-plugin.week-numbers .calendar>.days-grid .wnum-item{align-items:center;color:var(--color-fg-muted);display:flex;font-size:12px;justify-content:center}.container[data-theme=dark]{--color-bg-default:#22272e;--color-bg-secondary:#2d333b;--color-bg-inrange:#2c542e;--color-bg-locked:#ec775c;--color-bg-unavailable:#545d68;--color-bg-tooltip:#9e9e9e;--color-fg-default:#adbac7;--color-fg-primary:#46954a;--color-fg-secondary:#202122;--color-fg-muted:#9e9e9e;--color-fg-accent:#ec775c;--color-fg-locked:#9e9e9e;--color-btn-primary-bg:#2d333b;--color-btn-primary-fg:#46954a;--color-btn-primary-border:#46954a;--color-btn-primary-hover-bg:#46954a;--color-btn-primary-hover-fg:#fff;--color-btn-primary-hover-border:#46954a;--color-btn-secondary-bg:#2d333b;--color-btn-secondary-fg:#adbac7;--color-btn-secondary-border:#adbac7;--color-btn-secondary-hover-bg:#adbac7;--color-btn-secondary-hover-fg:#202122;--color-btn-secondary-hover-border:#adbac7;--color-border-default:#373e47;--color-border-locked:#2d333b}",
          setup(r) {
            r.on("select", (h) => {
              d();
              const { start: u, end: g, date: b } = h.detail, O = "YYYY-MM-DD";
              let x = null;
              i.range ? u instanceof Date && g instanceof Date && (x = `${u.format(O)}--${g.format(O)}`) : b instanceof Date && (x = b.format(O)), c(x);
            });
          },
          ...i.config
        };
        i.range && (v.plugins.push(PP), v.RangePlugin = {
          delimiter: " ~ "
        }), n.value = new $P.create(v);
      }
    });
    const f = () => {
      n.value.clear(), c(null);
    };
    return e({
      clearDate: f
    }), (m, v) => (M(), q(ca, {
      size: m.size,
      class: he(["ui-form-datepicker", l.value]),
      state: m.state,
      invalidFeedback: m.invalidFeedback,
      leadingIcon: "event",
      disabled: m.disabled,
      loading: m.loading,
      float: m.float,
      label: m.label,
      labelInfo: m.labelInfo,
      last: m.last,
      autofocus: m.autofocus
    }, dd({
      default: U(() => [
        I("input", {
          class: he(["form-control", l.value]),
          id: o,
          autocomplete: "off",
          placeholder: m.placeholder,
          readonly: ""
        }, null, 10, LP)
      ]),
      _: 2
    }, [
      !m.noClear && !m.loading ? {
        name: "trailingIcon",
        fn: U(() => [
          m.modelValue ? (M(), q(Ti, {
            key: 0,
            icon: "close",
            onClick: f,
            variant: "plain",
            size: "sm",
            class: "btn-remove"
          })) : X("", !0)
        ]),
        key: "0"
      } : void 0
    ]), 1032, ["size", "class", "state", "invalidFeedback", "disabled", "loading", "float", "label", "labelInfo", "last", "autofocus"]));
  }
});
const RP = ["autofocus", "readonly", "tabindex", "name", "title", "id", "required", "disabled"], IP = {
  key: 0,
  class: "form-select-option",
  value: "",
  selected: "",
  disabled: ""
}, QP = ["value", "disabled"], NP = j({
  __name: "FormSelect",
  props: {
    leadingIcon: {},
    trailingIcon: {},
    labelInfo: {},
    trailingText: {},
    loading: { type: Boolean },
    last: { type: Boolean },
    float: { type: Boolean },
    modelValue: {},
    value: {},
    placeholder: {},
    label: {},
    id: {},
    size: {},
    autofocus: { type: Boolean },
    readonly: { type: Boolean },
    tabindex: {},
    name: {},
    title: {},
    required: { type: Boolean },
    options: { default: () => [] },
    disabled: { type: Boolean },
    state: { type: Boolean, default: void 0 },
    invalidFeedback: {}
  },
  emits: ["update:modelValue", "update"],
  setup(a, { emit: e }) {
    const t = a, i = e, s = (f) => /\{/.test(f) ? JSON.parse(f) : f, n = (f) => ni(f) ? JSON.stringify(f) : f === null ? "" : f, o = (f) => {
      const p = f.target, m = p.value;
      i("update:modelValue", s(m)), i("update", s(m)), l.value = p.value;
    }, l = Z(n(t.modelValue)), c = ge(() => [
      t.size && `-${t.size}`,
      t.float && "-float",
      t.loading && "-loading",
      t.last && "-last",
      (t.disabled || t.loading) && "-disabled"
    ]);
    return Lt(() => {
      const f = t.value !== void 0 ? t.value : t.modelValue;
      l.value = n(f), t.modelValue === null && (l.value = "");
    }), (f, p) => (M(), q(ca, {
      id: f.id,
      leadingIcon: f.leadingIcon,
      trailingIcon: f.trailingIcon,
      trailingText: f.trailingText,
      label: f.label,
      loading: f.loading,
      last: f.last,
      disabled: f.disabled,
      float: f.float,
      labelInfo: f.labelInfo,
      autofocus: f.autofocus,
      size: f.size,
      state: f.state,
      invalidFeedback: f.invalidFeedback,
      class: "ui-form-select"
    }, {
      default: U(() => [
        Ze(I("select", {
          "onUpdate:modelValue": p[0] || (p[0] = (m) => l.value = m),
          onInput: o,
          class: he(["form-control -select", c.value]),
          autofocus: f.autofocus,
          readonly: f.readonly,
          tabindex: f.tabindex,
          name: f.name,
          title: f.title,
          id: f.id,
          required: f.required,
          disabled: f.disabled
        }, [
          f.placeholder ? (M(), D("option", IP, ne(f.placeholder), 1)) : X("", !0),
          te(f.$slots, "default"),
          (M(!0), D(ke, null, Ae(f.options, (m) => Ze((M(), D("option", {
            class: "form-select-option",
            value: n(m.value),
            key: m.value,
            disabled: m.disabled
          }, ne(m.label), 9, QP)), [
            [bt, f.options.length]
          ])), 128))
        ], 42, RP), [
          [_0, l.value]
        ])
      ]),
      _: 3
    }, 8, ["id", "leadingIcon", "trailingIcon", "trailingText", "label", "loading", "last", "disabled", "float", "labelInfo", "autofocus", "size", "state", "invalidFeedback"]));
  }
}), FP = ["value"], kH = j({
  __name: "FormSelectOption",
  props: {
    value: {}
  },
  setup(a) {
    const e = (t) => ni(t) ? JSON.stringify(t) : t;
    return (t, i) => (M(), D("option", {
      class: "form-select-option",
      value: e(t.value)
    }, [
      te(t.$slots, "default")
    ], 8, FP));
  }
});
const WP = { class: "ui-layout-sidebar" }, BP = { class: "ui-layout-navbar" }, zP = {
  class: "ui-layout-content",
  id: "ui-layout-content"
}, XP = { class: "ui-layout-content-page" }, _H = j({
  __name: "Layout",
  setup(a) {
    const e = Z(!1);
    return (t, i) => {
      const s = ud("router-view");
      return M(), D("div", {
        class: he(["ui-layout", { "-scrolled": e.value }]),
        _scroll: "onScroll",
        id: "wrapper"
      }, [
        I("div", WP, [
          te(t.$slots, "sidebar")
        ]),
        I("div", BP, [
          te(t.$slots, "navbar")
        ]),
        I("div", zP, [
          I("div", XP, [
            B(s, null, {
              default: U(({ Component: n }) => [
                (M(), q(Ut(n)))
              ]),
              _: 1
            })
          ])
        ])
      ], 2);
    };
  }
});
const rn = j({
  __name: "Col",
  props: {
    cols: {},
    sm: {},
    md: {},
    offset: {},
    offsetSm: {},
    auto: { type: Boolean }
  },
  setup(a) {
    const e = a, t = Z(["ui-col"]);
    return e.cols == "auto" || e.auto ? t.value.push("ui-col-auto") : e.cols && t.value.push(`-col-${e.cols}`), e.sm && t.value.push(`-sm-${e.sm}`), e.md && t.value.push(`-md-${e.md}`), e.offset && t.value.push(`-offset-${e.offset}`), e.offsetSm && t.value.push(`-offset-sm-${e.offsetSm}`), (i, s) => (M(), D("div", {
      class: he(t.value)
    }, [
      te(i.$slots, "default")
    ], 2));
  }
});
const wl = j({
  __name: "Row",
  props: {
    alignV: {}
  },
  setup(a) {
    const e = a, t = Z([]);
    return e.alignV && t.value.push(`-align-items-${e.alignV}`), (i, s) => (M(), D("div", {
      class: he(["ui-row", t.value])
    }, [
      te(i.$slots, "default")
    ], 2));
  }
});
const YP = { class: "ui-card-annotation" }, VP = {
  key: 0,
  class: "ui-card-annotation-title"
}, HP = { class: "ui-card-annotation-text" }, GP = {
  key: 1,
  class: "ui-card-annotation-link"
}, jP = j({
  __name: "CardAnnotation",
  props: {
    title: {},
    text: {}
  },
  setup(a) {
    const e = oa(), t = (i = "default") => !!e[i];
    return (i, s) => (M(), D("div", YP, [
      i.title ? (M(), D("h5", VP, ne(i.title), 1)) : X("", !0),
      I("div", HP, [
        te(i.$slots, "default")
      ]),
      t("link") ? (M(), D("div", GP, [
        te(i.$slots, "link")
      ])) : X("", !0)
    ]));
  }
});
const UP = { class: "ui-frame-annotation" }, ZP = { class: "pr-4" }, CH = j({
  __name: "FrameAnnotation",
  props: {
    title: {},
    annotation: {}
  },
  setup(a) {
    return (e, t) => (M(), D("div", UP, [
      B(wl, null, {
        default: U(() => [
          B(rn, {
            cols: "4",
            sm: "12"
          }, {
            default: U(() => [
              I("div", ZP, [
                B(jP, { title: e.title }, {
                  default: U(() => [
                    te(e.$slots, "annotation", {}, () => [
                      ye(ne(e.annotation), 1)
                    ])
                  ]),
                  _: 3
                }, 8, ["title"])
              ])
            ]),
            _: 3
          }),
          B(rn, {
            cols: "8",
            sm: "12"
          }, {
            default: U(() => [
              te(e.$slots, "default")
            ]),
            _: 3
          })
        ]),
        _: 3
      })
    ]));
  }
});
let N = class Sn {
  static bind(e, t) {
    return function() {
      return e.apply(t, arguments);
    };
  }
  static isObject(e) {
    return e && typeof e == "object" && !Array.isArray(e) && e != null;
  }
  // Type checking that works across different window objects
  static is(e, t) {
    return Object.prototype.toString.call(t) === "[object " + e + "]";
  }
  static listToArray(e) {
    let t, i = [];
    for (t = 0; t < e.length; t++)
      i[t] = e[t];
    return i;
  }
  // to extend defaults with user options
  // credit: http://stackoverflow.com/questions/27936772/deep-object-merging-in-es6-es7#answer-34749873
  static extend(e, t) {
    typeof Object.assign != "function" && function() {
      Object.assign = function(s) {
        if (s == null)
          throw new TypeError("Cannot convert undefined or null to object");
        let n = Object(s);
        for (let o = 1; o < arguments.length; o++) {
          let l = arguments[o];
          if (l != null)
            for (let c in l)
              l.hasOwnProperty(c) && (n[c] = l[c]);
        }
        return n;
      };
    }();
    let i = Object.assign({}, e);
    return this.isObject(e) && this.isObject(t) && Object.keys(t).forEach((s) => {
      this.isObject(t[s]) ? s in e ? i[s] = this.extend(e[s], t[s]) : Object.assign(i, {
        [s]: t[s]
      }) : Object.assign(i, {
        [s]: t[s]
      });
    }), i;
  }
  static extendArray(e, t) {
    let i = [];
    return e.map((s) => {
      i.push(Sn.extend(t, s));
    }), e = i, e;
  }
  // If month counter exceeds 12, it starts again from 1
  static monthMod(e) {
    return e % 12;
  }
  static clone(e) {
    if (Sn.is("Array", e)) {
      let t = [];
      for (let i = 0; i < e.length; i++)
        t[i] = this.clone(e[i]);
      return t;
    } else {
      if (Sn.is("Null", e))
        return null;
      if (Sn.is("Date", e))
        return e;
      if (typeof e == "object") {
        let t = {};
        for (let i in e)
          e.hasOwnProperty(i) && (t[i] = this.clone(e[i]));
        return t;
      } else
        return e;
    }
  }
  static log10(e) {
    return Math.log(e) / Math.LN10;
  }
  static roundToBase10(e) {
    return Math.pow(10, Math.floor(Math.log10(e)));
  }
  static roundToBase(e, t) {
    return Math.pow(t, Math.floor(Math.log(e) / Math.log(t)));
  }
  static parseNumber(e) {
    return e === null ? e : parseFloat(e);
  }
  static stripNumber(e, t = 2) {
    return Number.isInteger(e) ? e : parseFloat(e.toPrecision(t));
  }
  static randomId() {
    return (Math.random() + 1).toString(36).substring(4);
  }
  static noExponents(e) {
    let t = String(e).split(/[eE]/);
    if (t.length === 1)
      return t[0];
    let i = "", s = e < 0 ? "-" : "", n = t[0].replace(".", ""), o = Number(t[1]) + 1;
    if (o < 0) {
      for (i = s + "0."; o++; )
        i += "0";
      return i + n.replace(/^-/, "");
    }
    for (o -= n.length; o--; )
      i += "0";
    return n + i;
  }
  static getDimensions(e) {
    const t = getComputedStyle(e, null);
    let i = e.clientHeight, s = e.clientWidth;
    return i -= parseFloat(t.paddingTop) + parseFloat(t.paddingBottom), s -= parseFloat(t.paddingLeft) + parseFloat(t.paddingRight), [s, i];
  }
  static getBoundingClientRect(e) {
    const t = e.getBoundingClientRect();
    return {
      top: t.top,
      right: t.right,
      bottom: t.bottom,
      left: t.left,
      width: e.clientWidth,
      height: e.clientHeight,
      x: t.left,
      y: t.top
    };
  }
  static getLargestStringFromArr(e) {
    return e.reduce((t, i) => (Array.isArray(i) && (i = i.reduce((s, n) => s.length > n.length ? s : n)), t.length > i.length ? t : i), 0);
  }
  // http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb#answer-12342275
  static hexToRgba(e = "#999999", t = 0.6) {
    e.substring(0, 1) !== "#" && (e = "#999999");
    let i = e.replace("#", "");
    i = i.match(new RegExp("(.{" + i.length / 3 + "})", "g"));
    for (let s = 0; s < i.length; s++)
      i[s] = parseInt(i[s].length === 1 ? i[s] + i[s] : i[s], 16);
    return typeof t < "u" && i.push(t), "rgba(" + i.join(",") + ")";
  }
  static getOpacityFromRGBA(e) {
    return parseFloat(e.replace(/^.*,(.+)\)/, "$1"));
  }
  static rgb2hex(e) {
    return e = e.match(
      /^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i
    ), e && e.length === 4 ? "#" + ("0" + parseInt(e[1], 10).toString(16)).slice(-2) + ("0" + parseInt(e[2], 10).toString(16)).slice(-2) + ("0" + parseInt(e[3], 10).toString(16)).slice(-2) : "";
  }
  shadeRGBColor(e, t) {
    let i = t.split(","), s = e < 0 ? 0 : 255, n = e < 0 ? e * -1 : e, o = parseInt(i[0].slice(4), 10), l = parseInt(i[1], 10), c = parseInt(i[2], 10);
    return "rgb(" + (Math.round((s - o) * n) + o) + "," + (Math.round((s - l) * n) + l) + "," + (Math.round((s - c) * n) + c) + ")";
  }
  shadeHexColor(e, t) {
    let i = parseInt(t.slice(1), 16), s = e < 0 ? 0 : 255, n = e < 0 ? e * -1 : e, o = i >> 16, l = i >> 8 & 255, c = i & 255;
    return "#" + (16777216 + (Math.round((s - o) * n) + o) * 65536 + (Math.round((s - l) * n) + l) * 256 + (Math.round((s - c) * n) + c)).toString(16).slice(1);
  }
  // beautiful color shading blending code
  // http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors
  shadeColor(e, t) {
    return Sn.isColorHex(t) ? this.shadeHexColor(e, t) : this.shadeRGBColor(e, t);
  }
  static isColorHex(e) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(e);
  }
  static getPolygonPos(e, t) {
    let i = [], s = Math.PI * 2 / t;
    for (let n = 0; n < t; n++) {
      let o = {};
      o.x = e * Math.sin(n * s), o.y = -e * Math.cos(n * s), i.push(o);
    }
    return i;
  }
  static polarToCartesian(e, t, i, s) {
    let n = (s - 90) * Math.PI / 180;
    return {
      x: e + i * Math.cos(n),
      y: t + i * Math.sin(n)
    };
  }
  static escapeString(e, t = "x") {
    let i = e.toString().slice();
    return i = i.replace(
      /[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi,
      t
    ), i;
  }
  static negToZero(e) {
    return e < 0 ? 0 : e;
  }
  static moveIndexInArray(e, t, i) {
    if (i >= e.length) {
      let s = i - e.length + 1;
      for (; s--; )
        e.push(void 0);
    }
    return e.splice(i, 0, e.splice(t, 1)[0]), e;
  }
  static extractNumber(e) {
    return parseFloat(e.replace(/[^\d.]*/g, ""));
  }
  static findAncestor(e, t) {
    for (; (e = e.parentElement) && !e.classList.contains(t); )
      ;
    return e;
  }
  static setELstyles(e, t) {
    for (let i in t)
      t.hasOwnProperty(i) && (e.style.key = t[i]);
  }
  static isNumber(e) {
    return !isNaN(e) && parseFloat(Number(e)) === e && !isNaN(parseInt(e, 10));
  }
  static isFloat(e) {
    return Number(e) === e && e % 1 !== 0;
  }
  static isSafari() {
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  }
  static isFirefox() {
    return navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
  }
  static isIE11() {
    if (window.navigator.userAgent.indexOf("MSIE") !== -1 || window.navigator.appVersion.indexOf("Trident/") > -1)
      return !0;
  }
  static isIE() {
    let e = window.navigator.userAgent, t = e.indexOf("MSIE ");
    if (t > 0)
      return parseInt(e.substring(t + 5, e.indexOf(".", t)), 10);
    if (e.indexOf("Trident/") > 0) {
      let n = e.indexOf("rv:");
      return parseInt(e.substring(n + 3, e.indexOf(".", n)), 10);
    }
    let s = e.indexOf("Edge/");
    return s > 0 ? parseInt(e.substring(s + 5, e.indexOf(".", s)), 10) : !1;
  }
  // 
  // Find the Greatest Common Divisor of two numbers
  //
  static getGCD(e, t, i = 7) {
    let s = Math.pow(10, i - Math.floor(Math.log10(Math.max(e, t))));
    for (e = Math.round(Math.abs(e) * s), t = Math.round(Math.abs(t) * s); t; ) {
      let n = t;
      t = e % t, e = n;
    }
    return e / s;
  }
  static getPrimeFactors(e) {
    const t = [];
    let i = 2;
    for (; e >= 2; )
      e % i == 0 ? (t.push(i), e = e / i) : i++;
    return t;
  }
  static mod(e, t, i = 7) {
    let s = Math.pow(10, i - Math.floor(Math.log10(Math.max(e, t))));
    return e = Math.round(Math.abs(e) * s), t = Math.round(Math.abs(t) * s), e % t / s;
  }
};
class cr {
  constructor(e) {
    this.ctx = e, this.w = e.w, this.setEasingFunctions();
  }
  setEasingFunctions() {
    let e;
    if (this.w.globals.easing)
      return;
    switch (this.w.config.chart.animations.easing) {
      case "linear": {
        e = "-";
        break;
      }
      case "easein": {
        e = "<";
        break;
      }
      case "easeout": {
        e = ">";
        break;
      }
      case "easeinout": {
        e = "<>";
        break;
      }
      case "swing": {
        e = (i) => {
          let s = 1.70158;
          return (i -= 1) * i * ((s + 1) * i + s) + 1;
        };
        break;
      }
      case "bounce": {
        e = (i) => {
          let s = "";
          return i < 1 / 2.75 ? s = 7.5625 * i * i : i < 2 / 2.75 ? s = 7.5625 * (i -= 1.5 / 2.75) * i + 0.75 : i < 2.5 / 2.75 ? s = 7.5625 * (i -= 2.25 / 2.75) * i + 0.9375 : s = 7.5625 * (i -= 2.625 / 2.75) * i + 0.984375, s;
        };
        break;
      }
      case "elastic": {
        e = (i) => i === !!i ? i : Math.pow(2, -10 * i) * Math.sin((i - 0.075) * (2 * Math.PI) / 0.3) + 1;
        break;
      }
      default:
        e = "<>";
    }
    this.w.globals.easing = e;
  }
  animateLine(e, t, i, s) {
    e.attr(t).animate(s).attr(i);
  }
  /*
   ** Animate radius of a circle element
   */
  animateMarker(e, t, i, s, n, o) {
    t || (t = 0), e.attr({
      r: t,
      width: t,
      height: t
    }).animate(s, n).attr({
      r: i,
      width: i.width,
      height: i.height
    }).afterAll(() => {
      o();
    });
  }
  /*
   ** Animate radius and position of a circle element
   */
  animateCircle(e, t, i, s, n) {
    e.attr({
      r: t.r,
      cx: t.cx,
      cy: t.cy
    }).animate(s, n).attr({
      r: i.r,
      cx: i.cx,
      cy: i.cy
    });
  }
  /*
   ** Animate rect properties
   */
  animateRect(e, t, i, s, n) {
    e.attr(t).animate(s).attr(i).afterAll(() => n());
  }
  animatePathsGradually(e) {
    let { el: t, realIndex: i, j: s, fill: n, pathFrom: o, pathTo: l, speed: c, delay: d } = e, f = this, p = this.w, m = 0;
    p.config.chart.animations.animateGradually.enabled && (m = p.config.chart.animations.animateGradually.delay), p.config.chart.animations.dynamicAnimation.enabled && p.globals.dataChanged && p.config.chart.type !== "bar" && (m = 0), f.morphSVG(
      t,
      i,
      s,
      p.config.chart.type === "line" && !p.globals.comboCharts ? "stroke" : n,
      o,
      l,
      c,
      d * m
    );
  }
  showDelayedElements() {
    this.w.globals.delayedElements.forEach((e) => {
      const t = e.el;
      t.classList.remove("apexcharts-element-hidden"), t.classList.add("apexcharts-hidden-element-shown");
    });
  }
  animationCompleted(e) {
    const t = this.w;
    t.globals.animationEnded || (t.globals.animationEnded = !0, this.showDelayedElements(), typeof t.config.chart.events.animationEnd == "function" && t.config.chart.events.animationEnd(this.ctx, { el: e, w: t }));
  }
  // SVG.js animation for morphing one path to another
  morphSVG(e, t, i, s, n, o, l, c) {
    let d = this.w;
    n || (n = e.attr("pathFrom")), o || (o = e.attr("pathTo"));
    const f = (p) => (d.config.chart.type === "radar" && (l = 1), `M 0 ${d.globals.gridHeight}`);
    (!n || n.indexOf("undefined") > -1 || n.indexOf("NaN") > -1) && (n = f()), (!o || o.indexOf("undefined") > -1 || o.indexOf("NaN") > -1) && (o = f()), d.globals.shouldAnimate || (l = 1), e.plot(n).animate(1, d.globals.easing, c).plot(n).animate(l, d.globals.easing, c).plot(o).afterAll(() => {
      N.isNumber(i) ? i === d.globals.series[d.globals.maxValsInArrayIndex].length - 2 && d.globals.shouldAnimate && this.animationCompleted(e) : s !== "none" && d.globals.shouldAnimate && (!d.globals.comboCharts && t === d.globals.series.length - 1 || d.globals.comboCharts) && this.animationCompleted(e), this.showDelayedElements();
    });
  }
}
class It {
  constructor(e) {
    this.ctx = e, this.w = e.w;
  }
  // create a re-usable filter which can be appended other filter effects and applied to multiple elements
  getDefaultFilter(e, t) {
    const i = this.w;
    e.unfilter(!0), new window.SVG.Filter().size("120%", "180%", "-5%", "-40%"), i.config.states.normal.filter !== "none" ? this.applyFilter(
      e,
      t,
      i.config.states.normal.filter.type,
      i.config.states.normal.filter.value
    ) : i.config.chart.dropShadow.enabled && this.dropShadow(e, i.config.chart.dropShadow, t);
  }
  addNormalFilter(e, t) {
    const i = this.w;
    i.config.chart.dropShadow.enabled && !e.node.classList.contains("apexcharts-marker") && this.dropShadow(e, i.config.chart.dropShadow, t);
  }
  // appends dropShadow to the filter object which can be chained with other filter effects
  addLightenFilter(e, t, i) {
    const s = this.w, { intensity: n } = i;
    e.unfilter(!0);
    let o = new window.SVG.Filter();
    e.filter((l) => {
      const c = s.config.chart.dropShadow;
      c.enabled ? o = this.addShadow(l, t, c) : o = l, o.componentTransfer({
        rgb: { type: "linear", slope: 1.5, intercept: n }
      });
    }), e.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(e.filterer.node);
  }
  // appends dropShadow to the filter object which can be chained with other filter effects
  addDarkenFilter(e, t, i) {
    const s = this.w, { intensity: n } = i;
    e.unfilter(!0);
    let o = new window.SVG.Filter();
    e.filter((l) => {
      const c = s.config.chart.dropShadow;
      c.enabled ? o = this.addShadow(l, t, c) : o = l, o.componentTransfer({
        rgb: { type: "linear", slope: n }
      });
    }), e.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(e.filterer.node);
  }
  applyFilter(e, t, i, s = 0.5) {
    switch (i) {
      case "none": {
        this.addNormalFilter(e, t);
        break;
      }
      case "lighten": {
        this.addLightenFilter(e, t, {
          intensity: s
        });
        break;
      }
      case "darken": {
        this.addDarkenFilter(e, t, {
          intensity: s
        });
        break;
      }
    }
  }
  // appends dropShadow to the filter object which can be chained with other filter effects
  addShadow(e, t, i) {
    var p;
    const s = this.w, { blur: n, top: o, left: l, color: c, opacity: d } = i;
    if (((p = s.config.chart.dropShadow.enabledOnSeries) == null ? void 0 : p.length) > 0 && s.config.chart.dropShadow.enabledOnSeries.indexOf(t) === -1)
      return e;
    let f = e.flood(Array.isArray(c) ? c[t] : c, d).composite(e.sourceAlpha, "in").offset(l, o).gaussianBlur(n).merge(e.source);
    return e.blend(e.source, f);
  }
  // directly adds dropShadow to the element and returns the same element.
  // the only way it is different from the addShadow() function is that addShadow is chainable to other filters, while this function discards all filters and add dropShadow
  dropShadow(e, t, i = 0) {
    var p, m;
    let { top: s, left: n, blur: o, color: l, opacity: c, noUserSpaceOnUse: d } = t;
    const f = this.w;
    return e.unfilter(!0), N.isIE() && f.config.chart.type === "radialBar" || ((p = f.config.chart.dropShadow.enabledOnSeries) == null ? void 0 : p.length) > 0 && ((m = f.config.chart.dropShadow.enabledOnSeries) == null ? void 0 : m.indexOf(i)) === -1 || (l = Array.isArray(l) ? l[i] : l, e.filter((v) => {
      let r = null;
      N.isSafari() || N.isFirefox() || N.isIE() ? r = v.flood(l, c).composite(v.sourceAlpha, "in").offset(n, s).gaussianBlur(o) : r = v.flood(l, c).composite(v.sourceAlpha, "in").offset(n, s).gaussianBlur(o).merge(v.source), v.blend(v.source, r);
    }), d || e.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(e.filterer.node)), e;
  }
  setSelectionFilter(e, t, i) {
    const s = this.w;
    if (typeof s.globals.selectedDataPoints[t] < "u" && s.globals.selectedDataPoints[t].indexOf(i) > -1) {
      e.node.setAttribute("selected", !0);
      let n = s.config.states.active.filter;
      n !== "none" && this.applyFilter(e, t, n.type, n.value);
    }
  }
  _scaleFilterSize(e) {
    ((i) => {
      for (let s in i)
        i.hasOwnProperty(s) && e.setAttribute(s, i[s]);
    })({
      width: "200%",
      height: "200%",
      x: "-50%",
      y: "-50%"
    });
  }
}
class K {
  constructor(e) {
    this.ctx = e, this.w = e.w;
  }
  /*****************************************************************************
   *                                                                            *
   *  SVG Path Rounding Function                                                *
   *  Copyright (C) 2014 Yona Appletree                                         *
   *                                                                            *
   *  Licensed under the Apache License, Version 2.0 (the "License");           *
   *  you may not use this file except in compliance with the License.          *
   *  You may obtain a copy of the License at                                   *
   *                                                                            *
   *      http://www.apache.org/licenses/LICENSE-2.0                            *
   *                                                                            *
   *  Unless required by applicable law or agreed to in writing, software       *
   *  distributed under the License is distributed on an "AS IS" BASIS,         *
   *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *
   *  See the License for the specific language governing permissions and       *
   *  limitations under the License.                                            *
   *                                                                            *
   *****************************************************************************/
  /**
   * SVG Path rounding function. Takes an input path string and outputs a path
   * string where all line-line corners have been rounded. Only supports absolute
   * commands at the moment.
   *
   * @param pathString The SVG input path
   * @param radius The amount to round the corners, either a value in the SVG
   *               coordinate space, or, if useFractionalRadius is true, a value
   *               from 0 to 1.
   * @returns A new SVG path string with the rounding
   */
  roundPathCorners(e, t) {
    e.indexOf("NaN") > -1 && (e = "");
    function i($, L, E) {
      var A = L.x - $.x, y = L.y - $.y, w = Math.sqrt(A * A + y * y);
      return s(
        $,
        L,
        Math.min(1, E / w)
      );
    }
    function s($, L, E) {
      return {
        x: $.x + (L.x - $.x) * E,
        y: $.y + (L.y - $.y) * E
      };
    }
    function n($, L) {
      $.length > 2 && ($[$.length - 2] = L.x, $[$.length - 1] = L.y);
    }
    function o($) {
      return {
        x: parseFloat($[$.length - 2]),
        y: parseFloat($[$.length - 1])
      };
    }
    var l = e.split(/[,\s]/).reduce(function($, L) {
      var E = L.match("([a-zA-Z])(.+)");
      return E ? ($.push(E[1]), $.push(E[2])) : $.push(L), $;
    }, []), c = l.reduce(function($, L) {
      return parseFloat(L) == L && $.length ? $[$.length - 1].push(L) : $.push([L]), $;
    }, []), d = [];
    if (c.length > 1) {
      var f = o(c[0]), p = null;
      c[c.length - 1][0] == "Z" && c[0].length > 2 && (p = ["L", f.x, f.y], c[c.length - 1] = p), d.push(c[0]);
      for (var m = 1; m < c.length; m++) {
        var v = d[d.length - 1], r = c[m], h = r == p ? c[1] : c[m + 1];
        if (h && v && v.length > 2 && r[0] == "L" && h.length > 2 && h[0] == "L") {
          var u = o(v), g = o(r), b = o(h), O, x;
          O = i(g, u, t), x = i(g, b, t), n(r, O), r.origPoint = g, d.push(r);
          var S = s(O, g, 0.5), k = s(g, x, 0.5), C = [
            "C",
            S.x,
            S.y,
            k.x,
            k.y,
            x.x,
            x.y
          ];
          C.origPoint = g, d.push(C);
        } else
          d.push(r);
      }
      if (p) {
        var _ = o(
          d[d.length - 1]
        );
        d.push(["Z"]), n(d[0], _);
      }
    } else
      d = c;
    return d.reduce(function($, L) {
      return $ + L.join(" ") + " ";
    }, "");
  }
  drawLine(e, t, i, s, n = "#a8a8a8", o = 0, l = null, c = "butt") {
    return this.w.globals.dom.Paper.line().attr({
      x1: e,
      y1: t,
      x2: i,
      y2: s,
      stroke: n,
      "stroke-dasharray": o,
      "stroke-width": l,
      "stroke-linecap": c
    });
  }
  drawRect(e = 0, t = 0, i = 0, s = 0, n = 0, o = "#fefefe", l = 1, c = null, d = null, f = 0) {
    let m = this.w.globals.dom.Paper.rect();
    return m.attr({
      x: e,
      y: t,
      width: i > 0 ? i : 0,
      height: s > 0 ? s : 0,
      rx: n,
      ry: n,
      opacity: l,
      "stroke-width": c !== null ? c : 0,
      stroke: d !== null ? d : "none",
      "stroke-dasharray": f
    }), m.node.setAttribute("fill", o), m;
  }
  drawPolygon(e, t = "#e1e1e1", i = 1, s = "none") {
    return this.w.globals.dom.Paper.polygon(e).attr({
      fill: s,
      stroke: t,
      "stroke-width": i
    });
  }
  drawCircle(e, t = null) {
    const i = this.w;
    e < 0 && (e = 0);
    const s = i.globals.dom.Paper.circle(e * 2);
    return t !== null && s.attr(t), s;
  }
  drawPath({
    d: e = "",
    stroke: t = "#a8a8a8",
    strokeWidth: i = 1,
    fill: s,
    fillOpacity: n = 1,
    strokeOpacity: o = 1,
    classes: l,
    strokeLinecap: c = null,
    strokeDashArray: d = 0
  }) {
    let f = this.w;
    return c === null && (c = f.config.stroke.lineCap), (e.indexOf("undefined") > -1 || e.indexOf("NaN") > -1) && (e = `M 0 ${f.globals.gridHeight}`), f.globals.dom.Paper.path(e).attr({
      fill: s,
      "fill-opacity": n,
      stroke: t,
      "stroke-opacity": o,
      "stroke-linecap": c,
      "stroke-width": i,
      "stroke-dasharray": d,
      class: l
    });
  }
  group(e = null) {
    const i = this.w.globals.dom.Paper.group();
    return e !== null && i.attr(e), i;
  }
  move(e, t) {
    return ["M", e, t].join(" ");
  }
  line(e, t, i = null) {
    let s = null;
    return i === null ? s = [" L", e, t].join(" ") : i === "H" ? s = [" H", e].join(" ") : i === "V" && (s = [" V", t].join(" ")), s;
  }
  curve(e, t, i, s, n, o) {
    return ["C", e, t, i, s, n, o].join(" ");
  }
  quadraticCurve(e, t, i, s) {
    return ["Q", e, t, i, s].join(" ");
  }
  arc(e, t, i, s, n, o, l, c = !1) {
    let d = "A";
    return c && (d = "a"), [d, e, t, i, s, n, o, l].join(
      " "
    );
  }
  /**
   * @memberof Graphics
   * @param {object}
   *  i = series's index
   *  realIndex = realIndex is series's actual index when it was drawn time. After several redraws, the iterating "i" may change in loops, but realIndex doesn't
   *  pathFrom = existing pathFrom to animateTo
   *  pathTo = new Path to which d attr will be animated from pathFrom to pathTo
   *  stroke = line Color
   *  strokeWidth = width of path Line
   *  fill = it can be gradient, single color, pattern or image
   *  animationDelay = how much to delay when starting animation (in milliseconds)
   *  dataChangeSpeed = for dynamic animations, when data changes
   *  className = class attribute to add
   * @return {object} svg.js path object
   **/
  renderPaths({
    j: e,
    realIndex: t,
    pathFrom: i,
    pathTo: s,
    stroke: n,
    strokeWidth: o,
    strokeLinecap: l,
    fill: c,
    animationDelay: d,
    initialSpeed: f,
    dataChangeSpeed: p,
    className: m,
    shouldClipToGrid: v = !0,
    bindEventsOnPaths: r = !0,
    drawShadow: h = !0
  }) {
    let u = this.w;
    const g = new It(this.ctx), b = new cr(this.ctx);
    let O = this.w.config.chart.animations.enabled, x = O && this.w.config.chart.animations.dynamicAnimation.enabled, S, k = !!(O && !u.globals.resized || x && u.globals.dataChanged && u.globals.shouldAnimate);
    k ? S = i : (S = s, u.globals.animationEnded = !0);
    let C = u.config.stroke.dashArray, _ = 0;
    Array.isArray(C) ? _ = C[t] : _ = u.config.stroke.dashArray;
    let $ = this.drawPath({
      d: S,
      stroke: n,
      strokeWidth: o,
      fill: c,
      fillOpacity: 1,
      classes: m,
      strokeLinecap: l,
      strokeDashArray: _
    });
    if ($.attr("index", t), v && $.attr({
      "clip-path": `url(#gridRectMask${u.globals.cuid})`
    }), u.config.states.normal.filter.type !== "none")
      g.getDefaultFilter($, t);
    else if (u.config.chart.dropShadow.enabled && h) {
      const E = u.config.chart.dropShadow;
      g.dropShadow($, E, t);
    }
    r && ($.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, $)), $.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, $)), $.node.addEventListener("mousedown", this.pathMouseDown.bind(this, $))), $.attr({
      pathTo: s,
      pathFrom: i
    });
    const L = {
      el: $,
      j: e,
      realIndex: t,
      pathFrom: i,
      pathTo: s,
      fill: c,
      strokeWidth: o,
      delay: d
    };
    return O && !u.globals.resized && !u.globals.dataChanged ? b.animatePathsGradually({
      ...L,
      speed: f
    }) : (u.globals.resized || !u.globals.dataChanged) && b.showDelayedElements(), u.globals.dataChanged && x && k && b.animatePathsGradually({
      ...L,
      speed: p
    }), $;
  }
  drawPattern(e, t, i, s = "#a8a8a8", n = 0, o = 1) {
    return this.w.globals.dom.Paper.pattern(t, i, (d) => {
      e === "horizontalLines" ? d.line(0, 0, i, 0).stroke({ color: s, width: n + 1 }) : e === "verticalLines" ? d.line(0, 0, 0, t).stroke({ color: s, width: n + 1 }) : e === "slantedLines" ? d.line(0, 0, t, i).stroke({ color: s, width: n }) : e === "squares" ? d.rect(t, i).fill("none").stroke({ color: s, width: n }) : e === "circles" && d.circle(t).fill("none").stroke({ color: s, width: n });
    });
  }
  drawGradient(e, t, i, s, n, o = null, l = null, c = null, d = 0) {
    let f = this.w, p;
    t.length < 9 && t.indexOf("#") === 0 && (t = N.hexToRgba(t, s)), i.length < 9 && i.indexOf("#") === 0 && (i = N.hexToRgba(i, n));
    let m = 0, v = 1, r = 1, h = null;
    l !== null && (m = typeof l[0] < "u" ? l[0] / 100 : 0, v = typeof l[1] < "u" ? l[1] / 100 : 1, r = typeof l[2] < "u" ? l[2] / 100 : 1, h = typeof l[3] < "u" ? l[3] / 100 : null);
    let u = f.config.chart.type === "donut" || f.config.chart.type === "pie" || f.config.chart.type === "polarArea" || f.config.chart.type === "bubble";
    if (c === null || c.length === 0 ? p = f.globals.dom.Paper.gradient(u ? "radial" : "linear", (g) => {
      g.at(m, t, s), g.at(v, i, n), g.at(r, i, n), h !== null && g.at(h, t, s);
    }) : p = f.globals.dom.Paper.gradient(u ? "radial" : "linear", (g) => {
      (Array.isArray(c[d]) ? c[d] : c).forEach((O) => {
        g.at(O.offset / 100, O.color, O.opacity);
      });
    }), !u)
      e === "vertical" ? p.from(0, 0).to(0, 1) : e === "diagonal" ? p.from(0, 0).to(1, 1) : e === "horizontal" ? p.from(0, 1).to(1, 1) : e === "diagonal2" && p.from(1, 0).to(0, 1);
    else {
      let g = f.globals.gridWidth / 2, b = f.globals.gridHeight / 2;
      f.config.chart.type !== "bubble" ? p.attr({
        gradientUnits: "userSpaceOnUse",
        cx: g,
        cy: b,
        r: o
      }) : p.attr({
        cx: 0.5,
        cy: 0.5,
        r: 0.8,
        fx: 0.2,
        fy: 0.2
      });
    }
    return p;
  }
  getTextBasedOnMaxWidth({ text: e, maxWidth: t, fontSize: i, fontFamily: s }) {
    const n = this.getTextRects(e, i, s), o = n.width / e.length, l = Math.floor(t / o);
    return t < n.width ? e.slice(0, l - 3) + "..." : e;
  }
  drawText({
    x: e,
    y: t,
    text: i,
    textAnchor: s,
    fontSize: n,
    fontFamily: o,
    fontWeight: l,
    foreColor: c,
    opacity: d,
    maxWidth: f,
    cssClass: p = "",
    isPlainText: m = !0,
    dominantBaseline: v = "auto"
  }) {
    let r = this.w;
    typeof i > "u" && (i = "");
    let h = i;
    s || (s = "start"), (!c || !c.length) && (c = r.config.chart.foreColor), o = o || r.config.chart.fontFamily, n = n || "11px", l = l || "regular";
    const u = {
      maxWidth: f,
      fontSize: n,
      fontFamily: o
    };
    let g;
    return Array.isArray(i) ? g = r.globals.dom.Paper.text((b) => {
      for (let O = 0; O < i.length; O++)
        h = i[O], f && (h = this.getTextBasedOnMaxWidth({
          text: i[O],
          ...u
        })), O === 0 ? b.tspan(h) : b.tspan(h).newLine();
    }) : (f && (h = this.getTextBasedOnMaxWidth({
      text: i,
      ...u
    })), g = m ? r.globals.dom.Paper.plain(i) : r.globals.dom.Paper.text((b) => b.tspan(h))), g.attr({
      x: e,
      y: t,
      "text-anchor": s,
      "dominant-baseline": v,
      "font-size": n,
      "font-family": o,
      "font-weight": l,
      fill: c,
      class: "apexcharts-text " + p
    }), g.node.style.fontFamily = o, g.node.style.opacity = d, g;
  }
  /**
   * Creates a group with given attributes.
   * @param {number} x - The x-coordinate of the group.
   * @param {number} y - The y-coordinate of the group.
   * @param {Array} lines - The lines to be added to the group.
   * @param {Object} opts - The options for the group.
   * @returns {Object} The created group.
   */
  createGroupWithAttributes(e, t, i, s) {
    let n = this.group();
    return i.forEach((o) => n.add(o)), n.attr({
      class: s.class ? s.class : "",
      cy: t,
      cx: e
    }), n;
  }
  /**
   * Draws a plus sign at the given coordinates.
   * @param {number} x - The x-coordinate of the plus sign.
   * @param {number} y - The y-coordinate of the plus sign.
   * @param {number} size - The size of the plus sign.
   * @param {Object} opts - The options for the plus sign.
   * @returns {Object} The created plus sign.
   */
  drawPlus(e, t, i, s) {
    let n = i / 2, o = this.drawLine(
      e,
      t - n,
      e,
      t + n,
      s.pointStrokeColor,
      s.pointStrokeDashArray,
      s.pointStrokeWidth,
      s.pointStrokeLineCap
    ), l = this.drawLine(
      e - n,
      t,
      e + n,
      t,
      s.pointStrokeColor,
      s.pointStrokeDashArray,
      s.pointStrokeWidth,
      s.pointStrokeLineCap
    );
    return this.createGroupWithAttributes(e, t, [o, l], s);
  }
  /**
   * Draws an 'X' at the given coordinates.
   * @param {number} x - The x-coordinate of the 'X'.
   * @param {number} y - The y-coordinate of the 'X'.
   * @param {number} size - The size of the 'X'.
   * @param {Object} opts - The options for the 'X'.
   * @returns {Object} The created 'X'.
   */
  drawX(e, t, i, s) {
    let n = i / 2, o = this.drawLine(
      e - n,
      t - n,
      e + n,
      t + n,
      s.pointStrokeColor,
      s.pointStrokeDashArray,
      s.pointStrokeWidth,
      s.pointStrokeLineCap
    ), l = this.drawLine(
      e - n,
      t + n,
      e + n,
      t - n,
      s.pointStrokeColor,
      s.pointStrokeDashArray,
      s.pointStrokeWidth,
      s.pointStrokeLineCap
    );
    return this.createGroupWithAttributes(e, t, [o, l], s);
  }
  drawMarker(e, t, i) {
    e = e || 0;
    let s = i.pSize || 0, n = null;
    if ((i == null ? void 0 : i.shape) === "X" || (i == null ? void 0 : i.shape) === "x")
      n = this.drawX(e, t, s, i);
    else if ((i == null ? void 0 : i.shape) === "plus" || (i == null ? void 0 : i.shape) === "+")
      n = this.drawPlus(e, t, s, i);
    else if (i.shape === "square" || i.shape === "rect") {
      let o = i.pRadius === void 0 ? s / 2 : i.pRadius;
      (t === null || !s) && (s = 0, o = 0);
      let l = s * 1.2 + o, c = this.drawRect(l, l, l, l, o);
      c.attr({
        x: e - l / 2,
        y: t - l / 2,
        cx: e,
        cy: t,
        class: i.class ? i.class : "",
        fill: i.pointFillColor,
        "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1,
        stroke: i.pointStrokeColor,
        "stroke-width": i.pointStrokeWidth ? i.pointStrokeWidth : 0,
        "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1
      }), n = c;
    } else
      (i.shape === "circle" || !i.shape) && (N.isNumber(t) || (s = 0, t = 0), n = this.drawCircle(s, {
        cx: e,
        cy: t,
        class: i.class ? i.class : "",
        stroke: i.pointStrokeColor,
        fill: i.pointFillColor,
        "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1,
        "stroke-width": i.pointStrokeWidth ? i.pointStrokeWidth : 0,
        "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1
      }));
    return n;
  }
  pathMouseEnter(e, t) {
    let i = this.w;
    const s = new It(this.ctx), n = parseInt(e.node.getAttribute("index"), 10), o = parseInt(e.node.getAttribute("j"), 10);
    if (typeof i.config.chart.events.dataPointMouseEnter == "function" && i.config.chart.events.dataPointMouseEnter(t, this.ctx, {
      seriesIndex: n,
      dataPointIndex: o,
      w: i
    }), this.ctx.events.fireEvent("dataPointMouseEnter", [
      t,
      this.ctx,
      { seriesIndex: n, dataPointIndex: o, w: i }
    ]), !(i.config.states.active.filter.type !== "none" && e.node.getAttribute("selected") === "true") && i.config.states.hover.filter.type !== "none" && !i.globals.isTouchDevice) {
      let l = i.config.states.hover.filter;
      s.applyFilter(e, n, l.type, l.value);
    }
  }
  pathMouseLeave(e, t) {
    let i = this.w;
    const s = new It(this.ctx), n = parseInt(e.node.getAttribute("index"), 10), o = parseInt(e.node.getAttribute("j"), 10);
    typeof i.config.chart.events.dataPointMouseLeave == "function" && i.config.chart.events.dataPointMouseLeave(t, this.ctx, {
      seriesIndex: n,
      dataPointIndex: o,
      w: i
    }), this.ctx.events.fireEvent("dataPointMouseLeave", [
      t,
      this.ctx,
      { seriesIndex: n, dataPointIndex: o, w: i }
    ]), !(i.config.states.active.filter.type !== "none" && e.node.getAttribute("selected") === "true") && i.config.states.hover.filter.type !== "none" && s.getDefaultFilter(e, n);
  }
  pathMouseDown(e, t) {
    let i = this.w;
    const s = new It(this.ctx), n = parseInt(e.node.getAttribute("index"), 10), o = parseInt(e.node.getAttribute("j"), 10);
    let l = "false";
    if (e.node.getAttribute("selected") === "true") {
      if (e.node.setAttribute("selected", "false"), i.globals.selectedDataPoints[n].indexOf(o) > -1) {
        let d = i.globals.selectedDataPoints[n].indexOf(o);
        i.globals.selectedDataPoints[n].splice(d, 1);
      }
    } else {
      if (!i.config.states.active.allowMultipleDataPointsSelection && i.globals.selectedDataPoints.length > 0) {
        i.globals.selectedDataPoints = [];
        const d = i.globals.dom.Paper.select(
          ".apexcharts-series path"
        ).members, f = i.globals.dom.Paper.select(
          ".apexcharts-series circle, .apexcharts-series rect"
        ).members, p = (m) => {
          Array.prototype.forEach.call(m, (v) => {
            v.node.setAttribute("selected", "false"), s.getDefaultFilter(v, n);
          });
        };
        p(d), p(f);
      }
      e.node.setAttribute("selected", "true"), l = "true", typeof i.globals.selectedDataPoints[n] > "u" && (i.globals.selectedDataPoints[n] = []), i.globals.selectedDataPoints[n].push(o);
    }
    if (l === "true") {
      let d = i.config.states.active.filter;
      if (d !== "none")
        s.applyFilter(e, n, d.type, d.value);
      else if (i.config.states.hover.filter !== "none" && !i.globals.isTouchDevice) {
        var c = i.config.states.hover.filter;
        s.applyFilter(e, n, c.type, c.value);
      }
    } else if (i.config.states.active.filter.type !== "none")
      if (i.config.states.hover.filter.type !== "none" && !i.globals.isTouchDevice) {
        var c = i.config.states.hover.filter;
        s.applyFilter(e, n, c.type, c.value);
      } else
        s.getDefaultFilter(e, n);
    typeof i.config.chart.events.dataPointSelection == "function" && i.config.chart.events.dataPointSelection(t, this.ctx, {
      selectedDataPoints: i.globals.selectedDataPoints,
      seriesIndex: n,
      dataPointIndex: o,
      w: i
    }), t && this.ctx.events.fireEvent("dataPointSelection", [
      t,
      this.ctx,
      {
        selectedDataPoints: i.globals.selectedDataPoints,
        seriesIndex: n,
        dataPointIndex: o,
        w: i
      }
    ]);
  }
  rotateAroundCenter(e) {
    let t = {};
    e && typeof e.getBBox == "function" && (t = e.getBBox());
    let i = t.x + t.width / 2, s = t.y + t.height / 2;
    return {
      x: i,
      y: s
    };
  }
  static setAttrs(e, t) {
    for (let i in t)
      t.hasOwnProperty(i) && e.setAttribute(i, t[i]);
  }
  getTextRects(e, t, i, s, n = !0) {
    let o = this.w, l = this.drawText({
      x: -200,
      y: -200,
      text: e,
      textAnchor: "start",
      fontSize: t,
      fontFamily: i,
      foreColor: "#fff",
      opacity: 0
    });
    s && l.attr("transform", s), o.globals.dom.Paper.add(l);
    let c = l.bbox();
    return n || (c = l.node.getBoundingClientRect()), l.remove(), {
      width: c.width,
      height: c.height
    };
  }
  /**
   * append ... to long text
   * http://stackoverflow.com/questions/9241315/trimming-text-to-a-given-pixel-width-in-svg
   * @memberof Graphics
   **/
  placeTextWithEllipsis(e, t, i) {
    if (typeof e.getComputedTextLength == "function" && (e.textContent = t, t.length > 0 && e.getComputedTextLength() >= i / 1.1)) {
      for (let s = t.length - 3; s > 0; s -= 3)
        if (e.getSubStringLength(0, s) <= i / 1.1) {
          e.textContent = t.substring(0, s) + "...";
          return;
        }
      e.textContent = ".";
    }
  }
}
class vt {
  constructor(e) {
    this.ctx = e, this.w = e.w;
  }
  static checkComboSeries(e, t) {
    let i = !1, s = 0, n = 0;
    return t === void 0 && (t = "line"), e.length && typeof e[0].type < "u" && e.forEach((o) => {
      (o.type === "bar" || o.type === "column" || o.type === "candlestick" || o.type === "boxPlot") && s++, typeof o.type < "u" && o.type !== t && n++;
    }), n > 0 && (i = !0), {
      comboBarCount: s,
      comboCharts: i
    };
  }
  /**
   * @memberof CoreUtils
   * returns the sum of all individual values in a multiple stacked series
   * Eg. w.globals.series = [[32,33,43,12], [2,3,5,1]]
   *  @return [34,36,48,13]
   **/
  getStackedSeriesTotals(e = []) {
    const t = this.w;
    let i = [];
    if (t.globals.series.length === 0)
      return i;
    for (let s = 0; s < t.globals.series[t.globals.maxValsInArrayIndex].length; s++) {
      let n = 0;
      for (let o = 0; o < t.globals.series.length; o++)
        typeof t.globals.series[o][s] < "u" && e.indexOf(o) === -1 && (n += t.globals.series[o][s]);
      i.push(n);
    }
    return i;
  }
  // get total of the all values inside all series
  getSeriesTotalByIndex(e = null) {
    return e === null ? this.w.config.series.reduce((t, i) => t + i, 0) : this.w.globals.series[e].reduce((t, i) => t + i, 0);
  }
  /**
   * @memberof CoreUtils
   * returns the sum of values in a multiple stacked grouped charts
   * Eg. w.globals.series = [[32,33,43,12], [2,3,5,1], [43, 23, 34, 22]]
   * series 1 and 2 are in a group, while series 3 is in another group
   *  @return [[34, 36, 48, 12], [43, 23, 34, 22]]
   **/
  getStackedSeriesTotalsByGroups() {
    const e = this.w;
    let t = [];
    return e.globals.seriesGroups.forEach((i) => {
      let s = [];
      e.config.series.forEach((o, l) => {
        i.indexOf(o.name) > -1 && s.push(l);
      });
      const n = e.globals.series.map((o, l) => s.indexOf(l) === -1 ? l : -1).filter((o) => o !== -1);
      t.push(this.getStackedSeriesTotals(n));
    }), t;
  }
  isSeriesNull(e = null) {
    let t = [];
    return e === null ? t = this.w.config.series.filter((i) => i !== null) : t = this.w.config.series[e].data.filter((i) => i !== null), t.length === 0;
  }
  seriesHaveSameValues(e) {
    return this.w.globals.series[e].every((t, i, s) => t === s[0]);
  }
  getCategoryLabels(e) {
    const t = this.w;
    let i = e.slice();
    return t.config.xaxis.convertedCatToNumeric && (i = e.map((s, n) => t.config.xaxis.labels.formatter(s - t.globals.minX + 1))), i;
  }
  // maxValsInArrayIndex is the index of series[] which has the largest number of items
  getLargestSeries() {
    const e = this.w;
    e.globals.maxValsInArrayIndex = e.globals.series.map((t) => t.length).indexOf(
      Math.max.apply(
        Math,
        e.globals.series.map((t) => t.length)
      )
    );
  }
  getLargestMarkerSize() {
    const e = this.w;
    let t = 0;
    return e.globals.markers.size.forEach((i) => {
      t = Math.max(t, i);
    }), e.config.markers.discrete && e.config.markers.discrete.length && e.config.markers.discrete.forEach((i) => {
      t = Math.max(t, i.size);
    }), t > 0 && (t += e.config.markers.hover.sizeOffset + 1), e.globals.markers.largestSize = t, t;
  }
  /**
   * @memberof Core
   * returns the sum of all values in a series
   * Eg. w.globals.series = [[32,33,43,12], [2,3,5,1]]
   *  @return [120, 11]
   **/
  getSeriesTotals() {
    const e = this.w;
    e.globals.seriesTotals = e.globals.series.map((t, i) => {
      let s = 0;
      if (Array.isArray(t))
        for (let n = 0; n < t.length; n++)
          s += t[n];
      else
        s += t;
      return s;
    });
  }
  getSeriesTotalsXRange(e, t) {
    const i = this.w;
    return i.globals.series.map((n, o) => {
      let l = 0;
      for (let c = 0; c < n.length; c++)
        i.globals.seriesX[o][c] > e && i.globals.seriesX[o][c] < t && (l += n[c]);
      return l;
    });
  }
  /**
   * @memberof CoreUtils
   * returns the percentage value of all individual values which can be used in a 100% stacked series
   * Eg. w.globals.series = [[32, 33, 43, 12], [2, 3, 5, 1]]
   *  @return [[94.11, 91.66, 89.58, 92.30], [5.88, 8.33, 10.41, 7.7]]
   **/
  getPercentSeries() {
    const e = this.w;
    e.globals.seriesPercent = e.globals.series.map((t, i) => {
      let s = [];
      if (Array.isArray(t))
        for (let n = 0; n < t.length; n++) {
          let o = e.globals.stackedSeriesTotals[n], l = 0;
          o && (l = 100 * t[n] / o), s.push(l);
        }
      else {
        const n = e.globals.seriesTotals.reduce((l, c) => l + c, 0);
        let o = 100 * t / n;
        s.push(o);
      }
      return s;
    });
  }
  getCalculatedRatios() {
    let e = this.w, t = e.globals, i = [], s = 0, n = 0, o = 0, l = 0, c = [], d = 0.1, f = 0;
    if (t.yRange = [], t.isMultipleYAxis)
      for (let p = 0; p < t.minYArr.length; p++)
        t.yRange.push(Math.abs(t.minYArr[p] - t.maxYArr[p])), c.push(0);
    else
      t.yRange.push(Math.abs(t.minY - t.maxY));
    t.xRange = Math.abs(t.maxX - t.minX), t.zRange = Math.abs(t.maxZ - t.minZ);
    for (let p = 0; p < t.yRange.length; p++)
      i.push(t.yRange[p] / t.gridHeight);
    if (n = t.xRange / t.gridWidth, s = t.yRange / t.gridWidth, o = t.xRange / t.gridHeight, l = t.zRange / t.gridHeight * 16, l || (l = 1), t.minY !== Number.MIN_VALUE && Math.abs(t.minY) !== 0 && (t.hasNegs = !0), e.globals.seriesYAxisReverseMap.length > 0) {
      let p = (m, v) => {
        let r = e.config.yaxis[e.globals.seriesYAxisReverseMap[v]], h = m < 0 ? -1 : 1;
        return m = Math.abs(m), r.logarithmic && (m = this.getBaseLog(r.logBase, m)), -h * m / i[v];
      };
      if (t.isMultipleYAxis) {
        c = [];
        for (let m = 0; m < i.length; m++)
          c.push(p(t.minYArr[m], m));
      } else
        c = [], c.push(p(t.minY, 0)), t.minY !== Number.MIN_VALUE && Math.abs(t.minY) !== 0 && (d = -t.minY / s, f = t.minX / n);
    } else
      c = [], c.push(0), d = 0, f = 0;
    return {
      yRatio: i,
      invertedYRatio: s,
      zRatio: l,
      xRatio: n,
      invertedXRatio: o,
      baseLineInvertedY: d,
      baseLineY: c,
      baseLineX: f
    };
  }
  getLogSeries(e) {
    const t = this.w;
    return t.globals.seriesLog = e.map((i, s) => {
      let n = t.globals.seriesYAxisReverseMap[s];
      return t.config.yaxis[n] && t.config.yaxis[n].logarithmic ? i.map((o) => o === null ? null : this.getLogVal(t.config.yaxis[n].logBase, o, s)) : i;
    }), t.globals.invalidLogScale ? e : t.globals.seriesLog;
  }
  getBaseLog(e, t) {
    return Math.log(t) / Math.log(e);
  }
  getLogVal(e, t, i) {
    if (t <= 0)
      return 0;
    const s = this.w, n = s.globals.minYArr[i] === 0 ? -1 : this.getBaseLog(e, s.globals.minYArr[i]), l = (s.globals.maxYArr[i] === 0 ? 0 : this.getBaseLog(e, s.globals.maxYArr[i])) - n;
    return t < 1 ? t / l : (this.getBaseLog(e, t) - n) / l;
  }
  getLogYRatios(e) {
    const t = this.w, i = this.w.globals;
    return i.yLogRatio = e.slice(), i.logYRange = i.yRange.map((s, n) => {
      let o = t.globals.seriesYAxisReverseMap[n];
      if (t.config.yaxis[o] && this.w.config.yaxis[o].logarithmic) {
        let l = -Number.MAX_VALUE, c = Number.MIN_VALUE, d = 1;
        return i.seriesLog.forEach((f, p) => {
          f.forEach((m) => {
            t.config.yaxis[p] && t.config.yaxis[p].logarithmic && (l = Math.max(m, l), c = Math.min(m, c));
          });
        }), d = Math.pow(i.yRange[n], Math.abs(c - l) / i.yRange[n]), i.yLogRatio[n] = d / i.gridHeight, d;
      }
    }), i.invalidLogScale ? e.slice() : i.yLogRatio;
  }
  // Some config objects can be array - and we need to extend them correctly
  static extendArrayProps(e, t, i) {
    var s, n;
    return t != null && t.yaxis && (t = e.extendYAxis(t, i)), t != null && t.annotations && (t.annotations.yaxis && (t = e.extendYAxisAnnotations(t)), (s = t == null ? void 0 : t.annotations) != null && s.xaxis && (t = e.extendXAxisAnnotations(t)), (n = t == null ? void 0 : t.annotations) != null && n.points && (t = e.extendPointAnnotations(t))), t;
  }
}
let Sl = class {
  constructor(e) {
    this.w = e.w, this.annoCtx = e;
  }
  setOrientations(e, t = null) {
    let i = this.w;
    if (e.label.orientation === "vertical") {
      const s = t !== null ? t : 0;
      let n = i.globals.dom.baseEl.querySelector(
        `.apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='${s}']`
      );
      if (n !== null) {
        const o = n.getBoundingClientRect();
        n.setAttribute(
          "x",
          parseFloat(n.getAttribute("x")) - o.height + 4
        ), e.label.position === "top" ? n.setAttribute(
          "y",
          parseFloat(n.getAttribute("y")) + o.width
        ) : n.setAttribute(
          "y",
          parseFloat(n.getAttribute("y")) - o.width
        );
        let l = this.annoCtx.graphics.rotateAroundCenter(n);
        const c = l.x, d = l.y;
        n.setAttribute("transform", `rotate(-90 ${c} ${d})`);
      }
    }
  }
  addBackgroundToAnno(e, t) {
    const i = this.w;
    if (!e || typeof t.label.text > "u" || typeof t.label.text < "u" && !String(t.label.text).trim())
      return null;
    const s = i.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(), n = e.getBoundingClientRect();
    let o = t.label.style.padding.left, l = t.label.style.padding.right, c = t.label.style.padding.top, d = t.label.style.padding.bottom;
    t.label.orientation === "vertical" && (c = t.label.style.padding.left, d = t.label.style.padding.right, o = t.label.style.padding.top, l = t.label.style.padding.bottom);
    const f = n.left - s.left - o, p = n.top - s.top - c, m = this.annoCtx.graphics.drawRect(
      f - i.globals.barPadForNumericAxis,
      p,
      n.width + o + l,
      n.height + c + d,
      t.label.borderRadius,
      t.label.style.background,
      1,
      t.label.borderWidth,
      t.label.borderColor,
      0
    );
    return t.id && m.node.classList.add(t.id), m;
  }
  annotationsBackground() {
    const e = this.w, t = (i, s, n) => {
      let o = e.globals.dom.baseEl.querySelector(
        `.apexcharts-${n}-annotations .apexcharts-${n}-annotation-label[rel='${s}']`
      );
      if (o) {
        const l = o.parentNode, c = this.addBackgroundToAnno(o, i);
        c && (l.insertBefore(c.node, o), i.label.mouseEnter && c.node.addEventListener(
          "mouseenter",
          i.label.mouseEnter.bind(this, i)
        ), i.label.mouseLeave && c.node.addEventListener(
          "mouseleave",
          i.label.mouseLeave.bind(this, i)
        ), i.label.click && c.node.addEventListener(
          "click",
          i.label.click.bind(this, i)
        ));
      }
    };
    e.config.annotations.xaxis.map((i, s) => {
      t(i, s, "xaxis");
    }), e.config.annotations.yaxis.map((i, s) => {
      t(i, s, "yaxis");
    }), e.config.annotations.points.map((i, s) => {
      t(i, s, "point");
    });
  }
  getY1Y2(e, t) {
    let i = e === "y1" ? t.y : t.y2, s, n = !1;
    const o = this.w;
    if (this.annoCtx.invertAxis) {
      let l = o.globals.labels;
      o.config.xaxis.convertedCatToNumeric && (l = o.globals.categoryLabels);
      let c = l.indexOf(i);
      const d = o.globals.dom.baseEl.querySelector(
        ".apexcharts-yaxis-texts-g text:nth-child(" + (c + 1) + ")"
      );
      d ? s = parseFloat(d.getAttribute("y")) : s = (o.globals.gridHeight / l.length - 1) * (c + 1) - o.globals.barHeight, typeof t.seriesIndex < "u" && o.globals.barHeight && (s = s - o.globals.barHeight / 2 * (o.globals.series.length - 1) + o.globals.barHeight * t.seriesIndex);
    } else {
      let l, c = o.globals.seriesYAxisMap[t.yAxisIndex][0];
      o.config.yaxis[t.yAxisIndex].logarithmic ? (i = new vt(this.annoCtx.ctx).getLogVal(
        o.config.yaxis[t.yAxisIndex].logBase,
        i,
        c
      ), l = i / o.globals.yLogRatio[c]) : l = (i - o.globals.minYArr[c]) / (o.globals.yRange[c] / o.globals.gridHeight), l > o.globals.gridHeight ? (l = o.globals.gridHeight, n = !0) : l < 0 && (l = 0, n = !0), s = o.globals.gridHeight - l, t.marker && (t.y === void 0 || t.y === null) && (s = 0), o.config.yaxis[t.yAxisIndex] && o.config.yaxis[t.yAxisIndex].reversed && (s = l);
    }
    return typeof i == "string" && i.indexOf("px") > -1 && (s = parseFloat(i)), { yP: s, clipped: n };
  }
  getX1X2(e, t) {
    let i = e === "x1" ? t.x : t.x2;
    const s = this.w;
    let n = this.annoCtx.invertAxis ? s.globals.minY : s.globals.minX, o = this.annoCtx.invertAxis ? s.globals.maxY : s.globals.maxX;
    const l = this.annoCtx.invertAxis ? s.globals.yRange[0] : s.globals.xRange;
    let c = !1, d;
    return this.annoCtx.inversedReversedAxis ? d = (o - i) / (l / s.globals.gridWidth) : d = (i - n) / (l / s.globals.gridWidth), (s.config.xaxis.type === "category" || s.config.xaxis.convertedCatToNumeric) && !this.annoCtx.invertAxis && !s.globals.dataFormatXNumeric && (s.config.chart.sparkline.enabled || (d = this.getStringX(i))), typeof i == "string" && i.indexOf("px") > -1 && (d = parseFloat(i)), i == null && t.marker && (d = s.globals.gridWidth), typeof t.seriesIndex < "u" && s.globals.barWidth && !this.annoCtx.invertAxis && (d = d - s.globals.barWidth / 2 * (s.globals.series.length - 1) + s.globals.barWidth * t.seriesIndex), d > s.globals.gridWidth ? (d = s.globals.gridWidth, c = !0) : d < 0 && (d = 0, c = !0), { x: d, clipped: c };
  }
  getStringX(e) {
    const t = this.w;
    let i = e;
    t.config.xaxis.convertedCatToNumeric && t.globals.categoryLabels.length && (e = t.globals.categoryLabels.indexOf(e) + 1);
    let s = t.globals.labels.indexOf(e);
    const n = t.globals.dom.baseEl.querySelector(
      ".apexcharts-xaxis-texts-g text:nth-child(" + (s + 1) + ")"
    );
    return n && (i = parseFloat(n.getAttribute("x"))), i;
  }
};
class qP {
  constructor(e) {
    this.w = e.w, this.annoCtx = e, this.invertAxis = this.annoCtx.invertAxis, this.helpers = new Sl(this.annoCtx);
  }
  addXaxisAnnotation(e, t, i) {
    let s = this.w, n = this.helpers.getX1X2("x1", e), o = n.x, l = n.clipped, c = !0, d;
    const f = e.label.text;
    let p = e.strokeDashArray;
    if (N.isNumber(o)) {
      if (e.x2 === null || typeof e.x2 > "u") {
        if (!l) {
          let m = this.annoCtx.graphics.drawLine(
            o + e.offsetX,
            // x1
            0 + e.offsetY,
            // y1
            o + e.offsetX,
            // x2
            s.globals.gridHeight + e.offsetY,
            // y2
            e.borderColor,
            // lineColor
            p,
            //dashArray
            e.borderWidth
          );
          t.appendChild(m.node), e.id && m.node.classList.add(e.id);
        }
      } else {
        let m = this.helpers.getX1X2("x2", e);
        if (d = m.x, c = m.clipped, !(l && c)) {
          if (d < o) {
            let r = o;
            o = d, d = r;
          }
          let v = this.annoCtx.graphics.drawRect(
            o + e.offsetX,
            // x1
            0 + e.offsetY,
            // y1
            d - o,
            // x2
            s.globals.gridHeight + e.offsetY,
            // y2
            0,
            // radius
            e.fillColor,
            // color
            e.opacity,
            // opacity,
            1,
            // strokeWidth
            e.borderColor,
            // strokeColor
            p
            // stokeDashArray
          );
          v.node.classList.add("apexcharts-annotation-rect"), v.attr("clip-path", `url(#gridRectMask${s.globals.cuid})`), t.appendChild(v.node), e.id && v.node.classList.add(e.id);
        }
      }
      if (!(l && c)) {
        let m = this.annoCtx.graphics.getTextRects(
          f,
          parseFloat(e.label.style.fontSize)
        ), v = e.label.position === "top" ? 4 : e.label.position === "center" ? s.globals.gridHeight / 2 + (e.label.orientation === "vertical" ? m.width / 2 : 0) : s.globals.gridHeight, r = this.annoCtx.graphics.drawText({
          x: o + e.label.offsetX,
          y: v + e.label.offsetY - (e.label.orientation === "vertical" ? e.label.position === "top" ? m.width / 2 - 12 : -m.width / 2 : 0),
          text: f,
          textAnchor: e.label.textAnchor,
          fontSize: e.label.style.fontSize,
          fontFamily: e.label.style.fontFamily,
          fontWeight: e.label.style.fontWeight,
          foreColor: e.label.style.color,
          cssClass: `apexcharts-xaxis-annotation-label ${e.label.style.cssClass} ${e.id ? e.id : ""}`
        });
        r.attr({
          rel: i
        }), t.appendChild(r.node), this.annoCtx.helpers.setOrientations(e, i);
      }
    }
  }
  drawXAxisAnnotations() {
    let e = this.w, t = this.annoCtx.graphics.group({
      class: "apexcharts-xaxis-annotations"
    });
    return e.config.annotations.xaxis.map((i, s) => {
      this.addXaxisAnnotation(i, t.node, s);
    }), t;
  }
}
class Tt {
  constructor(e) {
    this.ctx = e, this.w = e.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  }
  isValidDate(e) {
    return typeof e == "number" ? !1 : !isNaN(this.parseDate(e));
  }
  getTimeStamp(e) {
    return Date.parse(e) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(e).toISOString().substr(0, 25)).getTime() : new Date(e).getTime() : e;
  }
  getDate(e) {
    return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(e).toUTCString()) : new Date(e);
  }
  parseDate(e) {
    const t = Date.parse(e);
    if (!isNaN(t))
      return this.getTimeStamp(e);
    let i = Date.parse(e.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
    return i = this.getTimeStamp(i), i;
  }
  // This fixes the difference of x-axis labels between chrome/safari
  // Fixes #1726, #1544, #1485, #1255
  parseDateWithTimezone(e) {
    return Date.parse(e.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
  }
  // http://stackoverflow.com/questions/14638018/current-time-formatting-with-javascript#answer-14638191
  formatDate(e, t) {
    const i = this.w.globals.locale, s = this.w.config.xaxis.labels.datetimeUTC;
    let n = ["\0", ...i.months], o = ["", ...i.shortMonths], l = ["", ...i.days], c = ["", ...i.shortDays];
    function d(C, _) {
      let $ = C + "";
      for (_ = _ || 2; $.length < _; )
        $ = "0" + $;
      return $;
    }
    let f = s ? e.getUTCFullYear() : e.getFullYear();
    t = t.replace(/(^|[^\\])yyyy+/g, "$1" + f), t = t.replace(/(^|[^\\])yy/g, "$1" + f.toString().substr(2, 2)), t = t.replace(/(^|[^\\])y/g, "$1" + f);
    let p = (s ? e.getUTCMonth() : e.getMonth()) + 1;
    t = t.replace(/(^|[^\\])MMMM+/g, "$1" + n[0]), t = t.replace(/(^|[^\\])MMM/g, "$1" + o[0]), t = t.replace(/(^|[^\\])MM/g, "$1" + d(p)), t = t.replace(/(^|[^\\])M/g, "$1" + p);
    let m = s ? e.getUTCDate() : e.getDate();
    t = t.replace(/(^|[^\\])dddd+/g, "$1" + l[0]), t = t.replace(/(^|[^\\])ddd/g, "$1" + c[0]), t = t.replace(/(^|[^\\])dd/g, "$1" + d(m)), t = t.replace(/(^|[^\\])d/g, "$1" + m);
    let v = s ? e.getUTCHours() : e.getHours();
    t = t.replace(/(^|[^\\])HH+/g, "$1" + d(v)), t = t.replace(/(^|[^\\])H/g, "$1" + v);
    let r = v > 12 ? v - 12 : v === 0 ? 12 : v;
    t = t.replace(/(^|[^\\])hh+/g, "$1" + d(r)), t = t.replace(/(^|[^\\])h/g, "$1" + r);
    let h = s ? e.getUTCMinutes() : e.getMinutes();
    t = t.replace(/(^|[^\\])mm+/g, "$1" + d(h)), t = t.replace(/(^|[^\\])m/g, "$1" + h);
    let u = s ? e.getUTCSeconds() : e.getSeconds();
    t = t.replace(/(^|[^\\])ss+/g, "$1" + d(u)), t = t.replace(/(^|[^\\])s/g, "$1" + u);
    let g = s ? e.getUTCMilliseconds() : e.getMilliseconds();
    t = t.replace(/(^|[^\\])fff+/g, "$1" + d(g, 3)), g = Math.round(g / 10), t = t.replace(/(^|[^\\])ff/g, "$1" + d(g)), g = Math.round(g / 10), t = t.replace(/(^|[^\\])f/g, "$1" + g);
    let b = v < 12 ? "AM" : "PM";
    t = t.replace(/(^|[^\\])TT+/g, "$1" + b), t = t.replace(/(^|[^\\])T/g, "$1" + b.charAt(0));
    let O = b.toLowerCase();
    t = t.replace(/(^|[^\\])tt+/g, "$1" + O), t = t.replace(/(^|[^\\])t/g, "$1" + O.charAt(0));
    let x = -e.getTimezoneOffset(), S = s || !x ? "Z" : x > 0 ? "+" : "-";
    if (!s) {
      x = Math.abs(x);
      let C = Math.floor(x / 60), _ = x % 60;
      S += d(C) + ":" + d(_);
    }
    t = t.replace(/(^|[^\\])K/g, "$1" + S);
    let k = (s ? e.getUTCDay() : e.getDay()) + 1;
    return t = t.replace(new RegExp(l[0], "g"), l[k]), t = t.replace(new RegExp(c[0], "g"), c[k]), t = t.replace(new RegExp(n[0], "g"), n[p]), t = t.replace(new RegExp(o[0], "g"), o[p]), t = t.replace(/\\(.)/g, "$1"), t;
  }
  getTimeUnitsfromTimestamp(e, t, i) {
    let s = this.w;
    s.config.xaxis.min !== void 0 && (e = s.config.xaxis.min), s.config.xaxis.max !== void 0 && (t = s.config.xaxis.max);
    const n = this.getDate(e), o = this.getDate(t), l = this.formatDate(n, "yyyy MM dd HH mm ss fff").split(" "), c = this.formatDate(o, "yyyy MM dd HH mm ss fff").split(" ");
    return {
      minMillisecond: parseInt(l[6], 10),
      maxMillisecond: parseInt(c[6], 10),
      minSecond: parseInt(l[5], 10),
      maxSecond: parseInt(c[5], 10),
      minMinute: parseInt(l[4], 10),
      maxMinute: parseInt(c[4], 10),
      minHour: parseInt(l[3], 10),
      maxHour: parseInt(c[3], 10),
      minDate: parseInt(l[2], 10),
      maxDate: parseInt(c[2], 10),
      minMonth: parseInt(l[1], 10) - 1,
      maxMonth: parseInt(c[1], 10) - 1,
      minYear: parseInt(l[0], 10),
      maxYear: parseInt(c[0], 10)
    };
  }
  isLeapYear(e) {
    return e % 4 === 0 && e % 100 !== 0 || e % 400 === 0;
  }
  calculcateLastDaysOfMonth(e, t, i) {
    return this.determineDaysOfMonths(e, t) - i;
  }
  determineDaysOfYear(e) {
    let t = 365;
    return this.isLeapYear(e) && (t = 366), t;
  }
  determineRemainingDaysOfYear(e, t, i) {
    let s = this.daysCntOfYear[t] + i;
    return t > 1 && this.isLeapYear() && s++, s;
  }
  determineDaysOfMonths(e, t) {
    let i = 30;
    switch (e = N.monthMod(e), !0) {
      case this.months30.indexOf(e) > -1:
        e === 2 && (this.isLeapYear(t) ? i = 29 : i = 28);
        break;
      case this.months31.indexOf(e) > -1:
        i = 31;
        break;
      default:
        i = 31;
        break;
    }
    return i;
  }
}
class ba {
  constructor(e) {
    this.ctx = e, this.w = e.w, this.tooltipKeyFormat = "dd MMM";
  }
  xLabelFormat(e, t, i, s) {
    let n = this.w;
    if (n.config.xaxis.type === "datetime" && n.config.xaxis.labels.formatter === void 0 && n.config.tooltip.x.formatter === void 0) {
      let o = new Tt(this.ctx);
      return o.formatDate(
        o.getDate(t),
        n.config.tooltip.x.format
      );
    }
    return e(t, i, s);
  }
  defaultGeneralFormatter(e) {
    return Array.isArray(e) ? e.map((t) => t) : e;
  }
  defaultYFormatter(e, t, i) {
    let s = this.w;
    if (N.isNumber(e))
      if (s.globals.yValueDecimal !== 0)
        e = e.toFixed(
          t.decimalsInFloat !== void 0 ? t.decimalsInFloat : s.globals.yValueDecimal
        );
      else {
        const n = e.toFixed(0);
        e = e == n ? n : e.toFixed(1);
      }
    return e;
  }
  setLabelFormatters() {
    let e = this.w;
    return e.globals.xaxisTooltipFormatter = (t) => this.defaultGeneralFormatter(t), e.globals.ttKeyFormatter = (t) => this.defaultGeneralFormatter(t), e.globals.ttZFormatter = (t) => t, e.globals.legendFormatter = (t) => this.defaultGeneralFormatter(t), e.config.xaxis.labels.formatter !== void 0 ? e.globals.xLabelFormatter = e.config.xaxis.labels.formatter : e.globals.xLabelFormatter = (t) => {
      if (N.isNumber(t)) {
        if (!e.config.xaxis.convertedCatToNumeric && e.config.xaxis.type === "numeric") {
          if (N.isNumber(e.config.xaxis.decimalsInFloat))
            return t.toFixed(e.config.xaxis.decimalsInFloat);
          {
            const i = e.globals.maxX - e.globals.minX;
            return i > 0 && i < 100 ? t.toFixed(1) : t.toFixed(0);
          }
        }
        return e.globals.isBarHorizontal && e.globals.maxY - e.globals.minYArr < 4 ? t.toFixed(1) : t.toFixed(0);
      }
      return t;
    }, typeof e.config.tooltip.x.formatter == "function" ? e.globals.ttKeyFormatter = e.config.tooltip.x.formatter : e.globals.ttKeyFormatter = e.globals.xLabelFormatter, typeof e.config.xaxis.tooltip.formatter == "function" && (e.globals.xaxisTooltipFormatter = e.config.xaxis.tooltip.formatter), (Array.isArray(e.config.tooltip.y) || e.config.tooltip.y.formatter !== void 0) && (e.globals.ttVal = e.config.tooltip.y), e.config.tooltip.z.formatter !== void 0 && (e.globals.ttZFormatter = e.config.tooltip.z.formatter), e.config.legend.formatter !== void 0 && (e.globals.legendFormatter = e.config.legend.formatter), e.config.yaxis.forEach((t, i) => {
      t.labels.formatter !== void 0 ? e.globals.yLabelFormatters[i] = t.labels.formatter : e.globals.yLabelFormatters[i] = (s) => e.globals.xyCharts ? Array.isArray(s) ? s.map((n) => this.defaultYFormatter(n, t, i)) : this.defaultYFormatter(s, t, i) : s;
    }), e.globals;
  }
  heatmapLabelFormatters() {
    const e = this.w;
    if (e.config.chart.type === "heatmap") {
      e.globals.yAxisScale[0].result = e.globals.seriesNames.slice();
      let t = e.globals.seriesNames.reduce(
        (i, s) => i.length > s.length ? i : s,
        0
      );
      e.globals.yAxisScale[0].niceMax = t, e.globals.yAxisScale[0].niceMin = t;
    }
  }
}
class Es {
  constructor(e) {
    this.ctx = e, this.w = e.w;
  }
  // Based on the formatter function, get the label text and position
  getLabel(e, t, i, s, n = [], o = "12px", l = !0) {
    const c = this.w;
    let d = typeof e[s] > "u" ? "" : e[s], f = d, p = c.globals.xLabelFormatter, m = c.config.xaxis.labels.formatter, v = !1, r = new ba(this.ctx), h = d;
    l && (f = r.xLabelFormat(p, d, h, {
      i: s,
      dateFormatter: new Tt(this.ctx).formatDate,
      w: c
    }), m !== void 0 && (f = m(d, e[s], {
      i: s,
      dateFormatter: new Tt(this.ctx).formatDate,
      w: c
    })));
    const u = (x) => {
      let S = null;
      return t.forEach((k) => {
        k.unit === "month" ? S = "year" : k.unit === "day" ? S = "month" : k.unit === "hour" ? S = "day" : k.unit === "minute" && (S = "hour");
      }), S === x;
    };
    t.length > 0 ? (v = u(t[s].unit), i = t[s].position, f = t[s].value) : c.config.xaxis.type === "datetime" && m === void 0 && (f = ""), typeof f > "u" && (f = ""), f = Array.isArray(f) ? f : f.toString();
    let g = new K(this.ctx), b = {};
    c.globals.rotateXLabels && l ? b = g.getTextRects(
      f,
      parseInt(o, 10),
      null,
      `rotate(${c.config.xaxis.labels.rotate} 0 0)`,
      !1
    ) : b = g.getTextRects(f, parseInt(o, 10));
    const O = !c.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
    return !Array.isArray(f) && (String(f) === "NaN" || n.indexOf(f) >= 0 && O) && (f = ""), {
      x: i,
      text: f,
      textRect: b,
      isBold: v
    };
  }
  checkLabelBasedOnTickamount(e, t, i) {
    const s = this.w;
    let n = s.config.xaxis.tickAmount;
    if (n === "dataPoints" && (n = Math.round(s.globals.gridWidth / 120)), n > i)
      return t;
    let o = Math.round(i / (n + 1));
    return e % o === 0 || (t.text = ""), t;
  }
  checkForOverflowingLabels(e, t, i, s, n) {
    const o = this.w;
    if (e === 0 && o.globals.skipFirstTimelinelabel && (t.text = ""), e === i - 1 && o.globals.skipLastTimelinelabel && (t.text = ""), o.config.xaxis.labels.hideOverlappingLabels && s.length > 0) {
      const l = n[n.length - 1];
      t.x < l.textRect.width / (o.globals.rotateXLabels ? Math.abs(o.config.xaxis.labels.rotate) / 12 : 1.01) + l.x && (t.text = "");
    }
    return t;
  }
  checkForReversedLabels(e, t) {
    const i = this.w;
    return i.config.yaxis[e] && i.config.yaxis[e].reversed && t.reverse(), t;
  }
  isYAxisHidden(e) {
    const t = this.w, i = new vt(this.ctx);
    return !t.globals.seriesYAxisMap[e].some((n) => t.globals.collapsedSeriesIndices.indexOf(n) === -1) || !t.config.yaxis[e].show || !t.config.yaxis[e].showForNullSeries && i.isSeriesNull(e);
  }
  // get the label color for y-axis
  // realIndex is the actual series index, while i is the tick Index
  getYAxisForeColor(e, t) {
    const i = this.w;
    return Array.isArray(e) && i.globals.yAxisScale[t] && this.ctx.theme.pushExtraColors(
      e,
      i.globals.yAxisScale[t].result.length,
      !1
    ), e;
  }
  drawYAxisTicks(e, t, i, s, n, o, l) {
    let c = this.w, d = new K(this.ctx), f = c.globals.translateY;
    if (s.show && t > 0) {
      c.config.yaxis[n].opposite === !0 && (e = e + s.width);
      for (let p = t; p >= 0; p--) {
        let m = f + t / 10 + c.config.yaxis[n].labels.offsetY - 1;
        c.globals.isBarHorizontal && (m = o * p), c.config.chart.type === "heatmap" && (m = m + o / 2);
        let v = d.drawLine(
          e + i.offsetX - s.width + s.offsetX,
          m + s.offsetY,
          e + i.offsetX + s.offsetX,
          m + s.offsetY,
          s.color
        );
        l.add(v), f = f + o;
      }
    }
  }
}
class KP {
  constructor(e) {
    this.w = e.w, this.annoCtx = e, this.helpers = new Sl(this.annoCtx), this.axesUtils = new Es(this.annoCtx);
  }
  addYaxisAnnotation(e, t, i) {
    let s = this.w, n = e.strokeDashArray, o = this.helpers.getY1Y2("y1", e), l = o.yP, c = o.clipped, d, f = !0, p = !1;
    const m = e.label.text;
    if (e.y2 === null || typeof e.y2 > "u") {
      if (!c) {
        p = !0;
        let v = this.annoCtx.graphics.drawLine(
          0 + e.offsetX,
          // x1
          l + e.offsetY,
          // y1
          this._getYAxisAnnotationWidth(e),
          // x2
          l + e.offsetY,
          // y2
          e.borderColor,
          // lineColor
          n,
          // dashArray
          e.borderWidth
        );
        t.appendChild(v.node), e.id && v.node.classList.add(e.id);
      }
    } else {
      if (o = this.helpers.getY1Y2("y2", e), d = o.yP, f = o.clipped, d > l) {
        let v = l;
        l = d, d = v;
      }
      if (!(c && f)) {
        p = !0;
        let v = this.annoCtx.graphics.drawRect(
          0 + e.offsetX,
          // x1
          d + e.offsetY,
          // y1
          this._getYAxisAnnotationWidth(e),
          // x2
          l - d,
          // y2
          0,
          // radius
          e.fillColor,
          // color
          e.opacity,
          // opacity,
          1,
          // strokeWidth
          e.borderColor,
          // strokeColor
          n
          // stokeDashArray
        );
        v.node.classList.add("apexcharts-annotation-rect"), v.attr("clip-path", `url(#gridRectMask${s.globals.cuid})`), t.appendChild(v.node), e.id && v.node.classList.add(e.id);
      }
    }
    if (p) {
      let v = e.label.position === "right" ? s.globals.gridWidth : e.label.position === "center" ? s.globals.gridWidth / 2 : 0, r = this.annoCtx.graphics.drawText({
        x: v + e.label.offsetX,
        y: (d ?? l) + e.label.offsetY - 3,
        text: m,
        textAnchor: e.label.textAnchor,
        fontSize: e.label.style.fontSize,
        fontFamily: e.label.style.fontFamily,
        fontWeight: e.label.style.fontWeight,
        foreColor: e.label.style.color,
        cssClass: `apexcharts-yaxis-annotation-label ${e.label.style.cssClass} ${e.id ? e.id : ""}`
      });
      r.attr({
        rel: i
      }), t.appendChild(r.node);
    }
  }
  _getYAxisAnnotationWidth(e) {
    const t = this.w;
    let i = t.globals.gridWidth;
    return e.width.indexOf("%") > -1 ? i = t.globals.gridWidth * parseInt(e.width, 10) / 100 : i = parseInt(e.width, 10), i + e.offsetX;
  }
  drawYAxisAnnotations() {
    let e = this.w, t = this.annoCtx.graphics.group({
      class: "apexcharts-yaxis-annotations"
    });
    return e.config.annotations.yaxis.forEach((i, s) => {
      e.globals.seriesYAxisMap[i.yAxisIndex][0], this.axesUtils.isYAxisHidden(i.yAxisIndex) || this.addYaxisAnnotation(i, t.node, s);
    }), t;
  }
}
class JP {
  constructor(e) {
    this.w = e.w, this.annoCtx = e, this.helpers = new Sl(this.annoCtx);
  }
  addPointAnnotation(e, t, i) {
    this.w;
    let s = this.helpers.getX1X2("x1", e), n = s.x, o = s.clipped;
    s = this.helpers.getY1Y2("y1", e);
    let l = s.yP, c = s.clipped;
    if (N.isNumber(n) && !(c || o)) {
      let d = {
        pSize: e.marker.size,
        pointStrokeWidth: e.marker.strokeWidth,
        pointFillColor: e.marker.fillColor,
        pointStrokeColor: e.marker.strokeColor,
        shape: e.marker.shape,
        pRadius: e.marker.radius,
        class: `apexcharts-point-annotation-marker ${e.marker.cssClass} ${e.id ? e.id : ""}`
      }, f = this.annoCtx.graphics.drawMarker(
        n + e.marker.offsetX,
        l + e.marker.offsetY,
        d
      );
      t.appendChild(f.node);
      const p = e.label.text ? e.label.text : "";
      let m = this.annoCtx.graphics.drawText({
        x: n + e.label.offsetX,
        y: l + e.label.offsetY - e.marker.size - parseFloat(e.label.style.fontSize) / 1.6,
        text: p,
        textAnchor: e.label.textAnchor,
        fontSize: e.label.style.fontSize,
        fontFamily: e.label.style.fontFamily,
        fontWeight: e.label.style.fontWeight,
        foreColor: e.label.style.color,
        cssClass: `apexcharts-point-annotation-label ${e.label.style.cssClass} ${e.id ? e.id : ""}`
      });
      if (m.attr({
        rel: i
      }), t.appendChild(m.node), e.customSVG.SVG) {
        let v = this.annoCtx.graphics.group({
          class: "apexcharts-point-annotations-custom-svg " + e.customSVG.cssClass
        });
        v.attr({
          transform: `translate(${n + e.customSVG.offsetX}, ${l + e.customSVG.offsetY})`
        }), v.node.innerHTML = e.customSVG.SVG, t.appendChild(v.node);
      }
      if (e.image.path) {
        let v = e.image.width ? e.image.width : 20, r = e.image.height ? e.image.height : 20;
        f = this.annoCtx.addImage({
          x: n + e.image.offsetX - v / 2,
          y: l + e.image.offsetY - r / 2,
          width: v,
          height: r,
          path: e.image.path,
          appendTo: ".apexcharts-point-annotations"
        });
      }
      e.mouseEnter && f.node.addEventListener(
        "mouseenter",
        e.mouseEnter.bind(this, e)
      ), e.mouseLeave && f.node.addEventListener(
        "mouseleave",
        e.mouseLeave.bind(this, e)
      ), e.click && f.node.addEventListener("click", e.click.bind(this, e));
    }
  }
  drawPointAnnotations() {
    let e = this.w, t = this.annoCtx.graphics.group({
      class: "apexcharts-point-annotations"
    });
    return e.config.annotations.points.map((i, s) => {
      this.addPointAnnotation(i, t.node, s);
    }), t;
  }
}
const eL = "en", tL = {
  months: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  shortMonths: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  days: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  shortDays: [
    "Sun",
    "Mon",
    "Tue",
    "Wed",
    "Thu",
    "Fri",
    "Sat"
  ],
  toolbar: {
    exportToSVG: "Download SVG",
    exportToPNG: "Download PNG",
    exportToCSV: "Download CSV",
    menu: "Menu",
    selection: "Selection",
    selectionZoom: "Selection Zoom",
    zoomIn: "Zoom In",
    zoomOut: "Zoom Out",
    pan: "Panning",
    reset: "Reset Zoom"
  }
}, Cv = {
  name: eL,
  options: tL
};
class Gs {
  constructor() {
    this.yAxis = {
      show: !0,
      showAlways: !1,
      showForNullSeries: !0,
      seriesName: void 0,
      opposite: !1,
      reversed: !1,
      logarithmic: !1,
      logBase: 10,
      tickAmount: void 0,
      stepSize: void 0,
      forceNiceScale: !1,
      max: void 0,
      min: void 0,
      floating: !1,
      decimalsInFloat: void 0,
      labels: {
        show: !0,
        minWidth: 0,
        maxWidth: 160,
        offsetX: 0,
        offsetY: 0,
        align: void 0,
        rotate: 0,
        padding: 20,
        style: {
          colors: [],
          fontSize: "11px",
          fontWeight: 400,
          fontFamily: void 0,
          cssClass: ""
        },
        formatter: void 0
      },
      axisBorder: {
        show: !1,
        color: "#e0e0e0",
        width: 1,
        offsetX: 0,
        offsetY: 0
      },
      axisTicks: {
        show: !1,
        color: "#e0e0e0",
        width: 6,
        offsetX: 0,
        offsetY: 0
      },
      title: {
        text: void 0,
        rotate: -90,
        offsetY: 0,
        offsetX: 0,
        style: {
          color: void 0,
          fontSize: "11px",
          fontWeight: 900,
          fontFamily: void 0,
          cssClass: ""
        }
      },
      tooltip: {
        enabled: !1,
        offsetX: 0
      },
      crosshairs: {
        show: !0,
        position: "front",
        stroke: {
          color: "#b6b6b6",
          width: 1,
          dashArray: 0
        }
      }
    }, this.pointAnnotation = {
      id: void 0,
      x: 0,
      y: null,
      yAxisIndex: 0,
      seriesIndex: void 0,
      mouseEnter: void 0,
      mouseLeave: void 0,
      click: void 0,
      marker: {
        size: 4,
        fillColor: "#fff",
        strokeWidth: 2,
        strokeColor: "#333",
        shape: "circle",
        offsetX: 0,
        offsetY: 0,
        radius: 2,
        cssClass: ""
      },
      label: {
        borderColor: "#c2c2c2",
        borderWidth: 1,
        borderRadius: 2,
        text: void 0,
        textAnchor: "middle",
        offsetX: 0,
        offsetY: 0,
        mouseEnter: void 0,
        mouseLeave: void 0,
        click: void 0,
        style: {
          background: "#fff",
          color: void 0,
          fontSize: "11px",
          fontFamily: void 0,
          fontWeight: 400,
          cssClass: "",
          padding: {
            left: 5,
            right: 5,
            top: 2,
            bottom: 2
          }
        }
      },
      customSVG: {
        // this will be deprecated in the next major version as it is going to be replaced with a better alternative below
        SVG: void 0,
        cssClass: void 0,
        offsetX: 0,
        offsetY: 0
      },
      image: {
        path: void 0,
        width: 20,
        height: 20,
        offsetX: 0,
        offsetY: 0
      }
    }, this.yAxisAnnotation = {
      id: void 0,
      y: 0,
      y2: null,
      strokeDashArray: 1,
      fillColor: "#c2c2c2",
      borderColor: "#c2c2c2",
      borderWidth: 1,
      opacity: 0.3,
      offsetX: 0,
      offsetY: 0,
      width: "100%",
      yAxisIndex: 0,
      label: {
        borderColor: "#c2c2c2",
        borderWidth: 1,
        borderRadius: 2,
        text: void 0,
        textAnchor: "end",
        position: "right",
        offsetX: 0,
        offsetY: -3,
        mouseEnter: void 0,
        mouseLeave: void 0,
        click: void 0,
        style: {
          background: "#fff",
          color: void 0,
          fontSize: "11px",
          fontFamily: void 0,
          fontWeight: 400,
          cssClass: "",
          padding: {
            left: 5,
            right: 5,
            top: 2,
            bottom: 2
          }
        }
      }
    }, this.xAxisAnnotation = {
      id: void 0,
      x: 0,
      x2: null,
      strokeDashArray: 1,
      fillColor: "#c2c2c2",
      borderColor: "#c2c2c2",
      borderWidth: 1,
      opacity: 0.3,
      offsetX: 0,
      offsetY: 0,
      label: {
        borderColor: "#c2c2c2",
        borderWidth: 1,
        borderRadius: 2,
        text: void 0,
        textAnchor: "middle",
        orientation: "vertical",
        position: "top",
        offsetX: 0,
        offsetY: 0,
        mouseEnter: void 0,
        mouseLeave: void 0,
        click: void 0,
        style: {
          background: "#fff",
          color: void 0,
          fontSize: "11px",
          fontFamily: void 0,
          fontWeight: 400,
          cssClass: "",
          padding: {
            left: 5,
            right: 5,
            top: 2,
            bottom: 2
          }
        }
      }
    }, this.text = {
      x: 0,
      y: 0,
      text: "",
      textAnchor: "start",
      foreColor: void 0,
      fontSize: "13px",
      fontFamily: void 0,
      fontWeight: 400,
      appendTo: ".apexcharts-annotations",
      backgroundColor: "transparent",
      borderColor: "#c2c2c2",
      borderRadius: 0,
      borderWidth: 0,
      paddingLeft: 4,
      paddingRight: 4,
      paddingTop: 2,
      paddingBottom: 2
    };
  }
  init() {
    return {
      annotations: {
        yaxis: [this.yAxisAnnotation],
        xaxis: [this.xAxisAnnotation],
        points: [this.pointAnnotation],
        texts: [],
        images: [],
        shapes: []
      },
      chart: {
        animations: {
          enabled: !0,
          easing: "easeinout",
          // linear, easeout, easein, easeinout, swing, bounce, elastic
          speed: 800,
          animateGradually: {
            delay: 150,
            enabled: !0
          },
          dynamicAnimation: {
            enabled: !0,
            speed: 350
          }
        },
        background: "transparent",
        locales: [Cv],
        defaultLocale: "en",
        dropShadow: {
          enabled: !1,
          enabledOnSeries: void 0,
          top: 2,
          left: 2,
          blur: 4,
          color: "#000",
          opacity: 0.35
        },
        events: {
          animationEnd: void 0,
          beforeMount: void 0,
          mounted: void 0,
          updated: void 0,
          click: void 0,
          mouseMove: void 0,
          mouseLeave: void 0,
          xAxisLabelClick: void 0,
          legendClick: void 0,
          markerClick: void 0,
          selection: void 0,
          dataPointSelection: void 0,
          dataPointMouseEnter: void 0,
          dataPointMouseLeave: void 0,
          beforeZoom: void 0,
          beforeResetZoom: void 0,
          zoomed: void 0,
          scrolled: void 0,
          brushScrolled: void 0
        },
        foreColor: "#373d3f",
        fontFamily: "Helvetica, Arial, sans-serif",
        height: "auto",
        parentHeightOffset: 15,
        redrawOnParentResize: !0,
        redrawOnWindowResize: !0,
        id: void 0,
        group: void 0,
        nonce: void 0,
        offsetX: 0,
        offsetY: 0,
        selection: {
          enabled: !1,
          type: "x",
          // selectedPoints: undefined, // default datapoints that should be selected automatically
          fill: {
            color: "#24292e",
            opacity: 0.1
          },
          stroke: {
            width: 1,
            color: "#24292e",
            opacity: 0.4,
            dashArray: 3
          },
          xaxis: {
            min: void 0,
            max: void 0
          },
          yaxis: {
            min: void 0,
            max: void 0
          }
        },
        sparkline: {
          enabled: !1
        },
        brush: {
          enabled: !1,
          autoScaleYaxis: !0,
          target: void 0,
          targets: void 0
        },
        stacked: !1,
        stackOnlyBar: !0,
        // mixed chart with stacked bars and line series - incorrect line draw #907
        stackType: "normal",
        toolbar: {
          show: !0,
          offsetX: 0,
          offsetY: 0,
          tools: {
            download: !0,
            selection: !0,
            zoom: !0,
            zoomin: !0,
            zoomout: !0,
            pan: !0,
            reset: !0,
            customIcons: []
          },
          export: {
            csv: {
              filename: void 0,
              columnDelimiter: ",",
              headerCategory: "category",
              headerValue: "value",
              dateFormatter(e) {
                return new Date(e).toDateString();
              }
            },
            png: {
              filename: void 0
            },
            svg: {
              filename: void 0
            }
          },
          autoSelected: "zoom"
          // accepts -> zoom, pan, selection
        },
        type: "line",
        width: "100%",
        zoom: {
          enabled: !0,
          type: "x",
          autoScaleYaxis: !1,
          zoomedArea: {
            fill: {
              color: "#90CAF9",
              opacity: 0.4
            },
            stroke: {
              color: "#0D47A1",
              opacity: 0.4,
              width: 1
            }
          }
        }
      },
      plotOptions: {
        area: {
          fillTo: "origin"
        },
        bar: {
          horizontal: !1,
          columnWidth: "70%",
          // should be in percent 0 - 100
          barHeight: "70%",
          // should be in percent 0 - 100
          distributed: !1,
          borderRadius: 0,
          borderRadiusApplication: "around",
          // [around, end]
          borderRadiusWhenStacked: "last",
          // [all, last]
          rangeBarOverlap: !0,
          rangeBarGroupRows: !1,
          hideZeroBarsWhenGrouped: !1,
          isDumbbell: !1,
          dumbbellColors: void 0,
          isFunnel: !1,
          isFunnel3d: !0,
          colors: {
            ranges: [],
            backgroundBarColors: [],
            backgroundBarOpacity: 1,
            backgroundBarRadius: 0
          },
          dataLabels: {
            position: "top",
            // top, center, bottom
            maxItems: 100,
            hideOverflowingLabels: !0,
            orientation: "horizontal",
            total: {
              enabled: !1,
              formatter: void 0,
              offsetX: 0,
              offsetY: 0,
              style: {
                color: "#373d3f",
                fontSize: "12px",
                fontFamily: void 0,
                fontWeight: 600
              }
            }
          }
        },
        bubble: {
          zScaling: !0,
          minBubbleRadius: void 0,
          maxBubbleRadius: void 0
        },
        candlestick: {
          colors: {
            upward: "#00B746",
            downward: "#EF403C"
          },
          wick: {
            useFillColor: !0
          }
        },
        boxPlot: {
          colors: {
            upper: "#00E396",
            lower: "#008FFB"
          }
        },
        heatmap: {
          radius: 2,
          enableShades: !0,
          shadeIntensity: 0.5,
          reverseNegativeShade: !1,
          distributed: !1,
          useFillColorAsStroke: !1,
          colorScale: {
            inverse: !1,
            ranges: [],
            min: void 0,
            max: void 0
          }
        },
        treemap: {
          enableShades: !0,
          shadeIntensity: 0.5,
          distributed: !1,
          reverseNegativeShade: !1,
          useFillColorAsStroke: !1,
          borderRadius: 4,
          dataLabels: {
            format: "scale"
            // scale | truncate
          },
          colorScale: {
            inverse: !1,
            ranges: [],
            min: void 0,
            max: void 0
          }
        },
        radialBar: {
          inverseOrder: !1,
          startAngle: 0,
          endAngle: 360,
          offsetX: 0,
          offsetY: 0,
          hollow: {
            margin: 5,
            size: "50%",
            background: "transparent",
            image: void 0,
            imageWidth: 150,
            imageHeight: 150,
            imageOffsetX: 0,
            imageOffsetY: 0,
            imageClipped: !0,
            position: "front",
            dropShadow: {
              enabled: !1,
              top: 0,
              left: 0,
              blur: 3,
              color: "#000",
              opacity: 0.5
            }
          },
          track: {
            show: !0,
            startAngle: void 0,
            endAngle: void 0,
            background: "#f2f2f2",
            strokeWidth: "97%",
            opacity: 1,
            margin: 5,
            // margin is in pixels
            dropShadow: {
              enabled: !1,
              top: 0,
              left: 0,
              blur: 3,
              color: "#000",
              opacity: 0.5
            }
          },
          dataLabels: {
            show: !0,
            name: {
              show: !0,
              fontSize: "16px",
              fontFamily: void 0,
              fontWeight: 600,
              color: void 0,
              offsetY: 0,
              formatter(e) {
                return e;
              }
            },
            value: {
              show: !0,
              fontSize: "14px",
              fontFamily: void 0,
              fontWeight: 400,
              color: void 0,
              offsetY: 16,
              formatter(e) {
                return e + "%";
              }
            },
            total: {
              show: !1,
              label: "Total",
              fontSize: "16px",
              fontWeight: 600,
              fontFamily: void 0,
              color: void 0,
              formatter(e) {
                return e.globals.seriesTotals.reduce((t, i) => t + i, 0) / e.globals.series.length + "%";
              }
            }
          },
          barLabels: {
            enabled: !1,
            margin: 5,
            useSeriesColors: !0,
            fontFamily: void 0,
            fontWeight: 600,
            fontSize: "16px",
            formatter(e) {
              return e;
            },
            onClick: void 0
          }
        },
        pie: {
          customScale: 1,
          offsetX: 0,
          offsetY: 0,
          startAngle: 0,
          endAngle: 360,
          expandOnClick: !0,
          dataLabels: {
            // These are the percentage values which are displayed on slice
            offset: 0,
            // offset by which labels will move outside
            minAngleToShowLabel: 10
          },
          donut: {
            size: "65%",
            background: "transparent",
            labels: {
              // These are the inner labels appearing inside donut
              show: !1,
              name: {
                show: !0,
                fontSize: "16px",
                fontFamily: void 0,
                fontWeight: 600,
                color: void 0,
                offsetY: -10,
                formatter(e) {
                  return e;
                }
              },
              value: {
                show: !0,
                fontSize: "20px",
                fontFamily: void 0,
                fontWeight: 400,
                color: void 0,
                offsetY: 10,
                formatter(e) {
                  return e;
                }
              },
              total: {
                show: !1,
                showAlways: !1,
                label: "Total",
                fontSize: "16px",
                fontWeight: 400,
                fontFamily: void 0,
                color: void 0,
                formatter(e) {
                  return e.globals.seriesTotals.reduce((t, i) => t + i, 0);
                }
              }
            }
          }
        },
        polarArea: {
          rings: {
            strokeWidth: 1,
            strokeColor: "#e8e8e8"
          },
          spokes: {
            strokeWidth: 1,
            connectorColors: "#e8e8e8"
          }
        },
        radar: {
          size: void 0,
          offsetX: 0,
          offsetY: 0,
          polygons: {
            // strokeColor: '#e8e8e8', // should be deprecated in the minor version i.e 3.2
            strokeWidth: 1,
            strokeColors: "#e8e8e8",
            connectorColors: "#e8e8e8",
            fill: {
              colors: void 0
            }
          }
        }
      },
      colors: void 0,
      dataLabels: {
        enabled: !0,
        enabledOnSeries: void 0,
        formatter(e) {
          return e !== null ? e : "";
        },
        textAnchor: "middle",
        distributed: !1,
        offsetX: 0,
        offsetY: 0,
        style: {
          fontSize: "12px",
          fontFamily: void 0,
          fontWeight: 600,
          colors: void 0
        },
        background: {
          enabled: !0,
          foreColor: "#fff",
          borderRadius: 2,
          padding: 4,
          opacity: 0.9,
          borderWidth: 1,
          borderColor: "#fff",
          dropShadow: {
            enabled: !1,
            top: 1,
            left: 1,
            blur: 1,
            color: "#000",
            opacity: 0.45
          }
        },
        dropShadow: {
          enabled: !1,
          top: 1,
          left: 1,
          blur: 1,
          color: "#000",
          opacity: 0.45
        }
      },
      fill: {
        type: "solid",
        colors: void 0,
        // array of colors
        opacity: 0.85,
        gradient: {
          shade: "dark",
          type: "horizontal",
          shadeIntensity: 0.5,
          gradientToColors: void 0,
          inverseColors: !0,
          opacityFrom: 1,
          opacityTo: 1,
          stops: [0, 50, 100],
          colorStops: []
        },
        image: {
          src: [],
          width: void 0,
          // optional
          height: void 0
          // optional
        },
        pattern: {
          style: "squares",
          // String | Array of Strings
          width: 6,
          height: 6,
          strokeWidth: 2
        }
      },
      forecastDataPoints: {
        count: 0,
        fillOpacity: 0.5,
        strokeWidth: void 0,
        dashArray: 4
      },
      grid: {
        show: !0,
        borderColor: "#e0e0e0",
        strokeDashArray: 0,
        position: "back",
        xaxis: {
          lines: {
            show: !1
          }
        },
        yaxis: {
          lines: {
            show: !0
          }
        },
        row: {
          colors: void 0,
          // takes as array which will be repeated on rows
          opacity: 0.5
        },
        column: {
          colors: void 0,
          // takes an array which will be repeated on columns
          opacity: 0.5
        },
        padding: {
          top: 0,
          right: 10,
          bottom: 0,
          left: 12
        }
      },
      labels: [],
      legend: {
        show: !0,
        showForSingleSeries: !1,
        showForNullSeries: !0,
        showForZeroSeries: !0,
        floating: !1,
        position: "bottom",
        // whether to position legends in 1 of 4
        // direction - top, bottom, left, right
        horizontalAlign: "center",
        // when position top/bottom, you can specify whether to align legends left, right or center
        inverseOrder: !1,
        fontSize: "12px",
        fontFamily: void 0,
        fontWeight: 400,
        width: void 0,
        height: void 0,
        formatter: void 0,
        tooltipHoverFormatter: void 0,
        offsetX: -20,
        offsetY: 4,
        customLegendItems: [],
        labels: {
          colors: void 0,
          useSeriesColors: !1
        },
        markers: {
          width: 12,
          height: 12,
          strokeWidth: 0,
          fillColors: void 0,
          strokeColor: "#fff",
          radius: 12,
          customHTML: void 0,
          offsetX: 0,
          offsetY: 0,
          onClick: void 0
        },
        itemMargin: {
          horizontal: 5,
          vertical: 2
        },
        onItemClick: {
          toggleDataSeries: !0
        },
        onItemHover: {
          highlightDataSeries: !0
        }
      },
      markers: {
        discrete: [],
        size: 0,
        colors: void 0,
        //strokeColor: '#fff', // TODO: deprecate in major version 4.0
        strokeColors: "#fff",
        strokeWidth: 2,
        strokeOpacity: 0.9,
        strokeDashArray: 0,
        fillOpacity: 1,
        shape: "circle",
        width: 8,
        // only applicable when shape is rect/square
        height: 8,
        // only applicable when shape is rect/square
        radius: 2,
        offsetX: 0,
        offsetY: 0,
        onClick: void 0,
        onDblClick: void 0,
        showNullDataPoints: !0,
        hover: {
          size: void 0,
          sizeOffset: 3
        }
      },
      noData: {
        text: void 0,
        align: "center",
        verticalAlign: "middle",
        offsetX: 0,
        offsetY: 0,
        style: {
          color: void 0,
          fontSize: "14px",
          fontFamily: void 0
        }
      },
      responsive: [],
      // breakpoints should follow ascending order 400, then 700, then 1000
      series: void 0,
      states: {
        normal: {
          filter: {
            type: "none",
            value: 0
          }
        },
        hover: {
          filter: {
            type: "lighten",
            value: 0.1
          }
        },
        active: {
          allowMultipleDataPointsSelection: !1,
          filter: {
            type: "darken",
            value: 0.5
          }
        }
      },
      title: {
        text: void 0,
        align: "left",
        margin: 5,
        offsetX: 0,
        offsetY: 0,
        floating: !1,
        style: {
          fontSize: "14px",
          fontWeight: 900,
          fontFamily: void 0,
          color: void 0
        }
      },
      subtitle: {
        text: void 0,
        align: "left",
        margin: 5,
        offsetX: 0,
        offsetY: 30,
        floating: !1,
        style: {
          fontSize: "12px",
          fontWeight: 400,
          fontFamily: void 0,
          color: void 0
        }
      },
      stroke: {
        show: !0,
        curve: "smooth",
        // "smooth" / "straight" / "monotoneCubic" / "stepline" / "linestep"
        lineCap: "butt",
        // round, butt , square
        width: 2,
        colors: void 0,
        // array of colors
        dashArray: 0,
        // single value or array of values
        fill: {
          type: "solid",
          colors: void 0,
          // array of colors
          opacity: 0.85,
          gradient: {
            shade: "dark",
            type: "horizontal",
            shadeIntensity: 0.5,
            gradientToColors: void 0,
            inverseColors: !0,
            opacityFrom: 1,
            opacityTo: 1,
            stops: [0, 50, 100],
            colorStops: []
          }
        }
      },
      tooltip: {
        enabled: !0,
        enabledOnSeries: void 0,
        shared: !0,
        hideEmptySeries: !1,
        followCursor: !1,
        // when disabled, the tooltip will show on top of the series instead of mouse position
        intersect: !1,
        // when enabled, tooltip will only show when user directly hovers over point
        inverseOrder: !1,
        custom: void 0,
        fillSeriesColor: !1,
        theme: "light",
        cssClass: "",
        style: {
          fontSize: "12px",
          fontFamily: void 0
        },
        onDatasetHover: {
          highlightDataSeries: !1
        },
        x: {
          // x value
          show: !0,
          format: "dd MMM",
          // dd/MM, dd MMM yy, dd MMM yyyy
          formatter: void 0
          // a custom user supplied formatter function
        },
        y: {
          formatter: void 0,
          title: {
            formatter(e) {
              return e ? e + ": " : "";
            }
          }
        },
        z: {
          formatter: void 0,
          title: "Size: "
        },
        marker: {
          show: !0,
          fillColors: void 0
        },
        items: {
          display: "flex"
        },
        fixed: {
          enabled: !1,
          position: "topRight",
          // topRight, topLeft, bottomRight, bottomLeft
          offsetX: 0,
          offsetY: 0
        }
      },
      xaxis: {
        type: "category",
        categories: [],
        convertedCatToNumeric: !1,
        // internal property which should not be altered outside
        offsetX: 0,
        offsetY: 0,
        overwriteCategories: void 0,
        labels: {
          show: !0,
          rotate: -45,
          rotateAlways: !1,
          hideOverlappingLabels: !0,
          trim: !1,
          minHeight: void 0,
          maxHeight: 120,
          showDuplicates: !0,
          style: {
            colors: [],
            fontSize: "12px",
            fontWeight: 400,
            fontFamily: void 0,
            cssClass: ""
          },
          offsetX: 0,
          offsetY: 0,
          format: void 0,
          formatter: void 0,
          // custom formatter function which will override format
          datetimeUTC: !0,
          datetimeFormatter: {
            year: "yyyy",
            month: "MMM 'yy",
            day: "dd MMM",
            hour: "HH:mm",
            minute: "HH:mm:ss",
            second: "HH:mm:ss"
          }
        },
        group: {
          groups: [],
          style: {
            colors: [],
            fontSize: "12px",
            fontWeight: 400,
            fontFamily: void 0,
            cssClass: ""
          }
        },
        axisBorder: {
          show: !0,
          color: "#e0e0e0",
          width: "100%",
          height: 1,
          offsetX: 0,
          offsetY: 0
        },
        axisTicks: {
          show: !0,
          color: "#e0e0e0",
          height: 6,
          offsetX: 0,
          offsetY: 0
        },
        stepSize: void 0,
        tickAmount: void 0,
        tickPlacement: "on",
        min: void 0,
        max: void 0,
        range: void 0,
        floating: !1,
        decimalsInFloat: void 0,
        position: "bottom",
        title: {
          text: void 0,
          offsetX: 0,
          offsetY: 0,
          style: {
            color: void 0,
            fontSize: "12px",
            fontWeight: 900,
            fontFamily: void 0,
            cssClass: ""
          }
        },
        crosshairs: {
          show: !0,
          width: 1,
          // tickWidth/barWidth or an integer
          position: "back",
          opacity: 0.9,
          stroke: {
            color: "#b6b6b6",
            width: 1,
            dashArray: 3
          },
          fill: {
            type: "solid",
            // solid, gradient
            color: "#B1B9C4",
            gradient: {
              colorFrom: "#D8E3F0",
              colorTo: "#BED1E6",
              stops: [0, 100],
              opacityFrom: 0.4,
              opacityTo: 0.5
            }
          },
          dropShadow: {
            enabled: !1,
            left: 0,
            top: 0,
            blur: 1,
            opacity: 0.4
          }
        },
        tooltip: {
          enabled: !0,
          offsetY: 0,
          formatter: void 0,
          style: {
            fontSize: "12px",
            fontFamily: void 0
          }
        }
      },
      yaxis: this.yAxis,
      theme: {
        mode: "light",
        palette: "palette1",
        // If defined, it will overwrite globals.colors variable
        monochrome: {
          // monochrome allows you to select just 1 color and fill out the rest with light/dark shade (intensity can be selected)
          enabled: !1,
          color: "#008FFB",
          shadeTo: "light",
          shadeIntensity: 0.65
        }
      }
    };
  }
}
class iL {
  constructor(e) {
    this.ctx = e, this.w = e.w, this.graphics = new K(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = !0), this.helpers = new Sl(this), this.xAxisAnnotations = new qP(this), this.yAxisAnnotations = new KP(this), this.pointsAnnotations = new JP(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = !0), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
  }
  drawAxesAnnotations() {
    const e = this.w;
    if (e.globals.axisCharts) {
      let t = this.yAxisAnnotations.drawYAxisAnnotations(), i = this.xAxisAnnotations.drawXAxisAnnotations(), s = this.pointsAnnotations.drawPointAnnotations();
      const n = e.config.chart.animations.enabled, o = [t, i, s], l = [
        i.node,
        t.node,
        s.node
      ];
      for (let c = 0; c < 3; c++)
        e.globals.dom.elGraphical.add(o[c]), n && !e.globals.resized && !e.globals.dataChanged && e.config.chart.type !== "scatter" && e.config.chart.type !== "bubble" && e.globals.dataPoints > 1 && l[c].classList.add("apexcharts-element-hidden"), e.globals.delayedElements.push({ el: l[c], index: 0 });
      this.helpers.annotationsBackground();
    }
  }
  drawImageAnnos() {
    this.w.config.annotations.images.map((t, i) => {
      this.addImage(t, i);
    });
  }
  drawTextAnnos() {
    this.w.config.annotations.texts.map((t, i) => {
      this.addText(t, i);
    });
  }
  addXaxisAnnotation(e, t, i) {
    this.xAxisAnnotations.addXaxisAnnotation(e, t, i);
  }
  addYaxisAnnotation(e, t, i) {
    this.yAxisAnnotations.addYaxisAnnotation(e, t, i);
  }
  addPointAnnotation(e, t, i) {
    this.pointsAnnotations.addPointAnnotation(e, t, i);
  }
  addText(e, t) {
    const {
      x: i,
      y: s,
      text: n,
      textAnchor: o,
      foreColor: l,
      fontSize: c,
      fontFamily: d,
      fontWeight: f,
      cssClass: p,
      backgroundColor: m,
      borderWidth: v,
      strokeDashArray: r,
      borderRadius: h,
      borderColor: u,
      appendTo: g = ".apexcharts-svg",
      paddingLeft: b = 4,
      paddingRight: O = 4,
      paddingBottom: x = 2,
      paddingTop: S = 2
    } = e, k = this.w;
    let C = this.graphics.drawText({
      x: i,
      y: s,
      text: n,
      textAnchor: o || "start",
      fontSize: c || "12px",
      fontWeight: f || "regular",
      fontFamily: d || k.config.chart.fontFamily,
      foreColor: l || k.config.chart.foreColor,
      cssClass: "apexcharts-text " + p ? p : ""
    });
    const _ = k.globals.dom.baseEl.querySelector(g);
    _ && _.appendChild(C.node);
    const $ = C.bbox();
    if (n) {
      const L = this.graphics.drawRect(
        $.x - b,
        $.y - S,
        $.width + b + O,
        $.height + x + S,
        h,
        m || "transparent",
        1,
        v,
        u,
        r
      );
      _.insertBefore(L.node, C.node);
    }
  }
  addImage(e, t) {
    const i = this.w, {
      path: s,
      x: n = 0,
      y: o = 0,
      width: l = 20,
      height: c = 20,
      appendTo: d = ".apexcharts-svg"
    } = e;
    let f = i.globals.dom.Paper.image(s);
    f.size(l, c).move(n, o);
    const p = i.globals.dom.baseEl.querySelector(d);
    return p && p.appendChild(f.node), f;
  }
  // The addXaxisAnnotation method requires a parent class, and user calling this method externally on the chart instance may not specify parent, hence a different method
  addXaxisAnnotationExternal(e, t, i) {
    return this.addAnnotationExternal({
      params: e,
      pushToMemory: t,
      context: i,
      type: "xaxis",
      contextMethod: i.addXaxisAnnotation
    }), i;
  }
  addYaxisAnnotationExternal(e, t, i) {
    return this.addAnnotationExternal({
      params: e,
      pushToMemory: t,
      context: i,
      type: "yaxis",
      contextMethod: i.addYaxisAnnotation
    }), i;
  }
  addPointAnnotationExternal(e, t, i) {
    return typeof this.invertAxis > "u" && (this.invertAxis = i.w.globals.isBarHorizontal), this.addAnnotationExternal({
      params: e,
      pushToMemory: t,
      context: i,
      type: "point",
      contextMethod: i.addPointAnnotation
    }), i;
  }
  addAnnotationExternal({
    params: e,
    pushToMemory: t,
    context: i,
    type: s,
    contextMethod: n
  }) {
    const o = i, l = o.w, c = l.globals.dom.baseEl.querySelector(
      `.apexcharts-${s}-annotations`
    ), d = c.childNodes.length + 1, f = new Gs(), p = Object.assign(
      {},
      s === "xaxis" ? f.xAxisAnnotation : s === "yaxis" ? f.yAxisAnnotation : f.pointAnnotation
    ), m = N.extend(p, e);
    switch (s) {
      case "xaxis":
        this.addXaxisAnnotation(m, c, d);
        break;
      case "yaxis":
        this.addYaxisAnnotation(m, c, d);
        break;
      case "point":
        this.addPointAnnotation(m, c, d);
        break;
    }
    let v = l.globals.dom.baseEl.querySelector(
      `.apexcharts-${s}-annotations .apexcharts-${s}-annotation-label[rel='${d}']`
    );
    const r = this.helpers.addBackgroundToAnno(v, m);
    return r && c.insertBefore(r.node, v), t && l.globals.memory.methodsToExec.push({
      context: o,
      id: m.id ? m.id : N.randomId(),
      method: n,
      label: "addAnnotation",
      params: e
    }), i;
  }
  clearAnnotations(e) {
    const t = e.w;
    let i = t.globals.dom.baseEl.querySelectorAll(
      ".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations"
    );
    t.globals.memory.methodsToExec.map((s, n) => {
      (s.label === "addText" || s.label === "addAnnotation") && t.globals.memory.methodsToExec.splice(n, 1);
    }), i = N.listToArray(i), Array.prototype.forEach.call(i, (s) => {
      for (; s.firstChild; )
        s.removeChild(s.firstChild);
    });
  }
  removeAnnotation(e, t) {
    const i = e.w;
    let s = i.globals.dom.baseEl.querySelectorAll(`.${t}`);
    s && (i.globals.memory.methodsToExec.map((n, o) => {
      n.id === t && i.globals.memory.methodsToExec.splice(o, 1);
    }), Array.prototype.forEach.call(s, (n) => {
      n.parentElement.removeChild(n);
    }));
  }
}
const gc = ({
  isTimeline: a,
  ctx: e,
  seriesIndex: t,
  dataPointIndex: i,
  y1: s,
  y2: n,
  w: o
}) => {
  var g;
  let l = o.globals.seriesRangeStart[t][i], c = o.globals.seriesRangeEnd[t][i], d = o.globals.labels[i], f = o.config.series[t].name ? o.config.series[t].name : "";
  const p = o.globals.ttKeyFormatter, m = o.config.tooltip.y.title.formatter, v = {
    w: o,
    seriesIndex: t,
    dataPointIndex: i,
    start: l,
    end: c
  };
  typeof m == "function" && (f = m(f, v)), (g = o.config.series[t].data[i]) != null && g.x && (d = o.config.series[t].data[i].x), a || o.config.xaxis.type === "datetime" && (d = new ba(e).xLabelFormat(o.globals.ttKeyFormatter, d, d, {
    i: void 0,
    dateFormatter: new Tt(e).formatDate,
    w: o
  })), typeof p == "function" && (d = p(d, v)), Number.isFinite(s) && Number.isFinite(n) && (l = s, c = n);
  let r = "", h = "";
  const u = o.globals.colors[t];
  if (o.config.tooltip.x.formatter === void 0)
    if (o.config.xaxis.type === "datetime") {
      let b = new Tt(e);
      r = b.formatDate(
        b.getDate(l),
        o.config.tooltip.x.format
      ), h = b.formatDate(
        b.getDate(c),
        o.config.tooltip.x.format
      );
    } else
      r = l, h = c;
  else
    r = o.config.tooltip.x.formatter(l), h = o.config.tooltip.x.formatter(c);
  return { start: l, end: c, startVal: r, endVal: h, ylabel: d, color: u, seriesName: f };
}, mc = (a) => {
  let { color: e, seriesName: t, ylabel: i, start: s, end: n, seriesIndex: o, dataPointIndex: l } = a;
  const c = a.ctx.tooltip.tooltipLabels.getFormatters(o);
  s = c.yLbFormatter(s), n = c.yLbFormatter(n);
  const d = c.yLbFormatter(
    a.w.globals.series[o][l]
  );
  let f = "";
  const p = `<span class="value start-value">
  ${s}
  </span> <span class="separator">-</span> <span class="value end-value">
  ${n}
  </span>`;
  return a.w.globals.comboCharts ? a.w.config.series[o].type === "rangeArea" || a.w.config.series[o].type === "rangeBar" ? f = p : f = `<span>${d}</span>` : f = p, '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + e + '">' + (t || "") + '</span></div><div> <span class="category">' + i + ": </span> " + f + " </div></div>";
};
class jr {
  constructor(e) {
    this.opts = e;
  }
  hideYAxis() {
    this.opts.yaxis[0].show = !1, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = !1, this.opts.yaxis[0].axisTicks.show = !1, this.opts.yaxis[0].floating = !0;
  }
  line() {
    return {
      chart: {
        animations: {
          easing: "swing"
        }
      },
      dataLabels: {
        enabled: !1
      },
      stroke: {
        width: 5,
        curve: "straight"
      },
      markers: {
        size: 0,
        hover: {
          sizeOffset: 6
        }
      },
      xaxis: {
        crosshairs: {
          width: 1
        }
      }
    };
  }
  sparkline(e) {
    this.hideYAxis();
    const t = {
      grid: {
        show: !1,
        padding: {
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        }
      },
      legend: {
        show: !1
      },
      xaxis: {
        labels: {
          show: !1
        },
        tooltip: {
          enabled: !1
        },
        axisBorder: {
          show: !1
        },
        axisTicks: {
          show: !1
        }
      },
      chart: {
        toolbar: {
          show: !1
        },
        zoom: {
          enabled: !1
        }
      },
      dataLabels: {
        enabled: !1
      }
    };
    return N.extend(e, t);
  }
  bar() {
    return {
      chart: {
        stacked: !1,
        animations: {
          easing: "swing"
        }
      },
      plotOptions: {
        bar: {
          dataLabels: {
            position: "center"
          }
        }
      },
      dataLabels: {
        style: {
          colors: ["#fff"]
        },
        background: {
          enabled: !1
        }
      },
      stroke: {
        width: 0,
        lineCap: "round"
      },
      fill: {
        opacity: 0.85
      },
      legend: {
        markers: {
          shape: "square",
          radius: 2,
          size: 8
        }
      },
      tooltip: {
        shared: !1,
        intersect: !0
      },
      xaxis: {
        tooltip: {
          enabled: !1
        },
        tickPlacement: "between",
        crosshairs: {
          width: "barWidth",
          position: "back",
          fill: {
            type: "gradient"
          },
          dropShadow: {
            enabled: !1
          },
          stroke: {
            width: 0
          }
        }
      }
    };
  }
  funnel() {
    return this.hideYAxis(), {
      ...this.bar(),
      chart: {
        animations: {
          easing: "linear",
          speed: 800,
          animateGradually: {
            enabled: !1
          }
        }
      },
      plotOptions: {
        bar: {
          horizontal: !0,
          borderRadiusApplication: "around",
          borderRadius: 0,
          dataLabels: {
            position: "center"
          }
        }
      },
      grid: {
        show: !1,
        padding: {
          left: 0,
          right: 0
        }
      },
      xaxis: {
        labels: {
          show: !1
        },
        tooltip: {
          enabled: !1
        },
        axisBorder: {
          show: !1
        },
        axisTicks: {
          show: !1
        }
      }
    };
  }
  candlestick() {
    return {
      stroke: {
        width: 1,
        colors: ["#333"]
      },
      fill: {
        opacity: 1
      },
      dataLabels: {
        enabled: !1
      },
      tooltip: {
        shared: !0,
        custom: ({ seriesIndex: e, dataPointIndex: t, w: i }) => this._getBoxTooltip(
          i,
          e,
          t,
          ["Open", "High", "", "Low", "Close"],
          "candlestick"
        )
      },
      states: {
        active: {
          filter: {
            type: "none"
          }
        }
      },
      xaxis: {
        crosshairs: {
          width: 1
        }
      }
    };
  }
  boxPlot() {
    return {
      chart: {
        animations: {
          dynamicAnimation: {
            enabled: !1
          }
        }
      },
      stroke: {
        width: 1,
        colors: ["#24292e"]
      },
      dataLabels: {
        enabled: !1
      },
      tooltip: {
        shared: !0,
        custom: ({ seriesIndex: e, dataPointIndex: t, w: i }) => this._getBoxTooltip(
          i,
          e,
          t,
          ["Minimum", "Q1", "Median", "Q3", "Maximum"],
          "boxPlot"
        )
      },
      markers: {
        size: 5,
        strokeWidth: 1,
        strokeColors: "#111"
      },
      xaxis: {
        crosshairs: {
          width: 1
        }
      }
    };
  }
  rangeBar() {
    const e = (i) => {
      const { color: s, seriesName: n, ylabel: o, startVal: l, endVal: c } = gc({
        ...i,
        isTimeline: !0
      });
      return mc({
        ...i,
        color: s,
        seriesName: n,
        ylabel: o,
        start: l,
        end: c
      });
    }, t = (i) => {
      const { color: s, seriesName: n, ylabel: o, start: l, end: c } = gc(i);
      return mc({
        ...i,
        color: s,
        seriesName: n,
        ylabel: o,
        start: l,
        end: c
      });
    };
    return {
      chart: {
        animations: {
          animateGradually: !1
        }
      },
      stroke: {
        width: 0,
        lineCap: "square"
      },
      plotOptions: {
        bar: {
          borderRadius: 0,
          dataLabels: {
            position: "center"
          }
        }
      },
      dataLabels: {
        enabled: !1,
        formatter(i, { ctx: s, seriesIndex: n, dataPointIndex: o, w: l }) {
          const c = () => {
            const d = l.globals.seriesRangeStart[n][o];
            return l.globals.seriesRangeEnd[n][o] - d;
          };
          return l.globals.comboCharts ? l.config.series[n].type === "rangeBar" || l.config.series[n].type === "rangeArea" ? c() : i : c();
        },
        background: {
          enabled: !1
        },
        style: {
          colors: ["#fff"]
        }
      },
      markers: {
        size: 10
      },
      tooltip: {
        shared: !1,
        followCursor: !0,
        custom(i) {
          return i.w.config.plotOptions && i.w.config.plotOptions.bar && i.w.config.plotOptions.bar.horizontal ? e(i) : t(i);
        }
      },
      xaxis: {
        tickPlacement: "between",
        tooltip: {
          enabled: !1
        },
        crosshairs: {
          stroke: {
            width: 0
          }
        }
      }
    };
  }
  dumbbell(e) {
    var t, i;
    return (t = e.plotOptions.bar) != null && t.barHeight || (e.plotOptions.bar.barHeight = 2), (i = e.plotOptions.bar) != null && i.columnWidth || (e.plotOptions.bar.columnWidth = 2), e;
  }
  area() {
    return {
      stroke: {
        width: 4,
        fill: {
          type: "solid",
          gradient: {
            inverseColors: !1,
            shade: "light",
            type: "vertical",
            opacityFrom: 0.65,
            opacityTo: 0.5,
            stops: [0, 100, 100]
          }
        }
      },
      fill: {
        type: "gradient",
        gradient: {
          inverseColors: !1,
          shade: "light",
          type: "vertical",
          opacityFrom: 0.65,
          opacityTo: 0.5,
          stops: [0, 100, 100]
        }
      },
      markers: {
        size: 0,
        hover: {
          sizeOffset: 6
        }
      },
      tooltip: {
        followCursor: !1
      }
    };
  }
  rangeArea() {
    const e = (t) => {
      const { color: i, seriesName: s, ylabel: n, start: o, end: l } = gc(t);
      return mc({
        ...t,
        color: i,
        seriesName: s,
        ylabel: n,
        start: o,
        end: l
      });
    };
    return {
      stroke: {
        curve: "straight",
        width: 0
      },
      fill: {
        type: "solid",
        opacity: 0.6
      },
      markers: {
        size: 0
      },
      states: {
        hover: {
          filter: {
            type: "none"
          }
        },
        active: {
          filter: {
            type: "none"
          }
        }
      },
      tooltip: {
        intersect: !1,
        shared: !0,
        followCursor: !0,
        custom(t) {
          return e(t);
        }
      }
    };
  }
  brush(e) {
    const t = {
      chart: {
        toolbar: {
          autoSelected: "selection",
          show: !1
        },
        zoom: {
          enabled: !1
        }
      },
      dataLabels: {
        enabled: !1
      },
      stroke: {
        width: 1
      },
      tooltip: {
        enabled: !1
      },
      xaxis: {
        tooltip: {
          enabled: !1
        }
      }
    };
    return N.extend(e, t);
  }
  stacked100(e) {
    e.dataLabels = e.dataLabels || {}, e.dataLabels.formatter = e.dataLabels.formatter || void 0;
    const t = e.dataLabels.formatter;
    return e.yaxis.forEach((s, n) => {
      e.yaxis[n].min = 0, e.yaxis[n].max = 100;
    }), e.chart.type === "bar" && (e.dataLabels.formatter = t || function(s) {
      return typeof s == "number" ? s && s.toFixed(0) + "%" : s;
    }), e;
  }
  stackedBars() {
    const e = this.bar();
    return {
      ...e,
      plotOptions: {
        ...e.plotOptions,
        bar: {
          ...e.plotOptions.bar,
          borderRadiusApplication: "end",
          borderRadiusWhenStacked: "last"
        }
      }
    };
  }
  // This function removes the left and right spacing in chart for line/area/scatter if xaxis type = category for those charts by converting xaxis = numeric. Numeric/Datetime xaxis prevents the unnecessary spacing in the left/right of the chart area
  convertCatToNumeric(e) {
    return e.xaxis.convertedCatToNumeric = !0, e;
  }
  convertCatToNumericXaxis(e, t, i) {
    e.xaxis.type = "numeric", e.xaxis.labels = e.xaxis.labels || {}, e.xaxis.labels.formatter = e.xaxis.labels.formatter || function(o) {
      return N.isNumber(o) ? Math.floor(o) : o;
    };
    const s = e.xaxis.labels.formatter;
    let n = e.xaxis.categories && e.xaxis.categories.length ? e.xaxis.categories : e.labels;
    return i && i.length && (n = i.map((o) => Array.isArray(o) ? o : String(o))), n && n.length && (e.xaxis.labels.formatter = function(o) {
      return N.isNumber(o) ? s(n[Math.floor(o) - 1]) : s(o);
    }), e.xaxis.categories = [], e.labels = [], e.xaxis.tickAmount = e.xaxis.tickAmount || "dataPoints", e;
  }
  bubble() {
    return {
      dataLabels: {
        style: {
          colors: ["#fff"]
        }
      },
      tooltip: {
        shared: !1,
        intersect: !0
      },
      xaxis: {
        crosshairs: {
          width: 0
        }
      },
      fill: {
        type: "solid",
        gradient: {
          shade: "light",
          inverse: !0,
          shadeIntensity: 0.55,
          opacityFrom: 0.4,
          opacityTo: 0.8
        }
      }
    };
  }
  scatter() {
    return {
      dataLabels: {
        enabled: !1
      },
      tooltip: {
        shared: !1,
        intersect: !0
      },
      markers: {
        size: 6,
        strokeWidth: 1,
        hover: {
          sizeOffset: 2
        }
      }
    };
  }
  heatmap() {
    return {
      chart: {
        stacked: !1
      },
      fill: {
        opacity: 1
      },
      dataLabels: {
        style: {
          colors: ["#fff"]
        }
      },
      stroke: {
        colors: ["#fff"]
      },
      tooltip: {
        followCursor: !0,
        marker: {
          show: !1
        },
        x: {
          show: !1
        }
      },
      legend: {
        position: "top",
        markers: {
          shape: "square",
          size: 10,
          offsetY: 2
        }
      },
      grid: {
        padding: {
          right: 20
        }
      }
    };
  }
  treemap() {
    return {
      chart: {
        zoom: {
          enabled: !1
        }
      },
      dataLabels: {
        style: {
          fontSize: 14,
          fontWeight: 600,
          colors: ["#fff"]
        }
      },
      stroke: {
        show: !0,
        width: 2,
        colors: ["#fff"]
      },
      legend: {
        show: !1
      },
      fill: {
        gradient: {
          stops: [0, 100]
        }
      },
      tooltip: {
        followCursor: !0,
        x: {
          show: !1
        }
      },
      grid: {
        padding: {
          left: 0,
          right: 0
        }
      },
      xaxis: {
        crosshairs: {
          show: !1
        },
        tooltip: {
          enabled: !1
        }
      }
    };
  }
  pie() {
    return {
      chart: {
        toolbar: {
          show: !1
        }
      },
      plotOptions: {
        pie: {
          donut: {
            labels: {
              show: !1
            }
          }
        }
      },
      dataLabels: {
        formatter(e) {
          return e.toFixed(1) + "%";
        },
        style: {
          colors: ["#fff"]
        },
        background: {
          enabled: !1
        },
        dropShadow: {
          enabled: !0
        }
      },
      stroke: {
        colors: ["#fff"]
      },
      fill: {
        opacity: 1,
        gradient: {
          shade: "light",
          stops: [0, 100]
        }
      },
      tooltip: {
        theme: "dark",
        fillSeriesColor: !0
      },
      legend: {
        position: "right"
      }
    };
  }
  donut() {
    return {
      chart: {
        toolbar: {
          show: !1
        }
      },
      dataLabels: {
        formatter(e) {
          return e.toFixed(1) + "%";
        },
        style: {
          colors: ["#fff"]
        },
        background: {
          enabled: !1
        },
        dropShadow: {
          enabled: !0
        }
      },
      stroke: {
        colors: ["#fff"]
      },
      fill: {
        opacity: 1,
        gradient: {
          shade: "light",
          shadeIntensity: 0.35,
          stops: [80, 100],
          opacityFrom: 1,
          opacityTo: 1
        }
      },
      tooltip: {
        theme: "dark",
        fillSeriesColor: !0
      },
      legend: {
        position: "right"
      }
    };
  }
  polarArea() {
    return {
      chart: {
        toolbar: {
          show: !1
        }
      },
      dataLabels: {
        formatter(e) {
          return e.toFixed(1) + "%";
        },
        enabled: !1
      },
      stroke: {
        show: !0,
        width: 2
      },
      fill: {
        opacity: 0.7
      },
      tooltip: {
        theme: "dark",
        fillSeriesColor: !0
      },
      legend: {
        position: "right"
      }
    };
  }
  radar() {
    return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, {
      dataLabels: {
        enabled: !1,
        style: {
          fontSize: "11px"
        }
      },
      stroke: {
        width: 2
      },
      markers: {
        size: 3,
        strokeWidth: 1,
        strokeOpacity: 1
      },
      fill: {
        opacity: 0.2
      },
      tooltip: {
        shared: !1,
        intersect: !0,
        followCursor: !0
      },
      grid: {
        show: !1
      },
      xaxis: {
        labels: {
          formatter: (e) => e,
          style: {
            colors: ["#a8a8a8"],
            fontSize: "11px"
          }
        },
        tooltip: {
          enabled: !1
        },
        crosshairs: {
          show: !1
        }
      }
    };
  }
  radialBar() {
    return {
      chart: {
        animations: {
          dynamicAnimation: {
            enabled: !0,
            speed: 800
          }
        },
        toolbar: {
          show: !1
        }
      },
      fill: {
        gradient: {
          shade: "dark",
          shadeIntensity: 0.4,
          inverseColors: !1,
          type: "diagonal2",
          opacityFrom: 1,
          opacityTo: 1,
          stops: [70, 98, 100]
        }
      },
      legend: {
        show: !1,
        position: "right"
      },
      tooltip: {
        enabled: !1,
        fillSeriesColor: !0
      }
    };
  }
  _getBoxTooltip(e, t, i, s, n) {
    const o = e.globals.seriesCandleO[t][i], l = e.globals.seriesCandleH[t][i], c = e.globals.seriesCandleM[t][i], d = e.globals.seriesCandleL[t][i], f = e.globals.seriesCandleC[t][i];
    return e.config.series[t].type && e.config.series[t].type !== n ? `<div class="apexcharts-custom-tooltip">
          ${e.config.series[t].name ? e.config.series[t].name : "series-" + (t + 1)}: <strong>${e.globals.series[t][i]}</strong>
        </div>` : `<div class="apexcharts-tooltip-box apexcharts-tooltip-${e.config.chart.type}"><div>${s[0]}: <span class="value">` + o + `</span></div><div>${s[1]}: <span class="value">` + l + "</span></div>" + (c ? `<div>${s[2]}: <span class="value">` + c + "</span></div>" : "") + `<div>${s[3]}: <span class="value">` + d + `</span></div><div>${s[4]}: <span class="value">` + f + "</span></div></div>";
  }
}
class Ur {
  constructor(e) {
    this.opts = e;
  }
  init({ responsiveOverride: e }) {
    var c, d, f, p, m, v, r, h;
    let t = this.opts, i = new Gs(), s = new jr(t);
    this.chartType = t.chart.type, t = this.extendYAxis(t), t = this.extendAnnotations(t);
    let n = i.init(), o = {};
    if (t && typeof t == "object") {
      let u = {};
      [
        "line",
        "area",
        "bar",
        "candlestick",
        "boxPlot",
        "rangeBar",
        "rangeArea",
        "bubble",
        "scatter",
        "heatmap",
        "treemap",
        "pie",
        "polarArea",
        "donut",
        "radar",
        "radialBar"
      ].indexOf(t.chart.type) !== -1 ? u = s[t.chart.type]() : u = s.line(), (d = (c = t.plotOptions) == null ? void 0 : c.bar) != null && d.isFunnel && (u = s.funnel()), t.chart.stacked && t.chart.type === "bar" && (u = s.stackedBars()), (f = t.chart.brush) != null && f.enabled && (u = s.brush(u)), t.chart.stacked && t.chart.stackType === "100%" && (t = s.stacked100(t)), (m = (p = t.plotOptions) == null ? void 0 : p.bar) != null && m.isDumbbell && (t = s.dumbbell(t)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(t), t.xaxis = t.xaxis || window.Apex.xaxis || {}, e || (t.xaxis.convertedCatToNumeric = !1), t = this.checkForCatToNumericXAxis(this.chartType, u, t), ((v = t.chart.sparkline) != null && v.enabled || (h = (r = window.Apex.chart) == null ? void 0 : r.sparkline) != null && h.enabled) && (u = s.sparkline(u)), o = N.extend(n, u);
    }
    let l = N.extend(o, window.Apex);
    return n = N.extend(l, t), n = this.handleUserInputErrors(n), n;
  }
  checkForCatToNumericXAxis(e, t, i) {
    var d, f;
    let s = new jr(i);
    const n = (e === "bar" || e === "boxPlot") && ((f = (d = i.plotOptions) == null ? void 0 : d.bar) == null ? void 0 : f.horizontal), o = e === "pie" || e === "polarArea" || e === "donut" || e === "radar" || e === "radialBar" || e === "heatmap", l = i.xaxis.type !== "datetime" && i.xaxis.type !== "numeric";
    let c = i.xaxis.tickPlacement ? i.xaxis.tickPlacement : t.xaxis && t.xaxis.tickPlacement;
    return !n && !o && l && c !== "between" && (i = s.convertCatToNumeric(i)), i;
  }
  extendYAxis(e, t) {
    let i = new Gs();
    (typeof e.yaxis > "u" || !e.yaxis || Array.isArray(e.yaxis) && e.yaxis.length === 0) && (e.yaxis = {}), e.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (e.yaxis = N.extend(e.yaxis, window.Apex.yaxis)), e.yaxis.constructor !== Array ? e.yaxis = [N.extend(i.yAxis, e.yaxis)] : e.yaxis = N.extendArray(e.yaxis, i.yAxis);
    let s = !1;
    e.yaxis.forEach((o) => {
      o.logarithmic && (s = !0);
    });
    let n = e.series;
    return t && !n && (n = t.config.series), s && n.length !== e.yaxis.length && n.length && (e.yaxis = n.map((o, l) => {
      if (o.name || (n[l].name = `series-${l + 1}`), e.yaxis[l])
        return e.yaxis[l].seriesName = n[l].name, e.yaxis[l];
      {
        const c = N.extend(i.yAxis, e.yaxis[0]);
        return c.show = !1, c;
      }
    })), s && n.length > 1 && n.length !== e.yaxis.length && console.warn(
      "A multi-series logarithmic chart should have equal number of series and y-axes"
    ), e;
  }
  // annotations also accepts array, so we need to extend them manually
  extendAnnotations(e) {
    return typeof e.annotations > "u" && (e.annotations = {}, e.annotations.yaxis = [], e.annotations.xaxis = [], e.annotations.points = []), e = this.extendYAxisAnnotations(e), e = this.extendXAxisAnnotations(e), e = this.extendPointAnnotations(e), e;
  }
  extendYAxisAnnotations(e) {
    let t = new Gs();
    return e.annotations.yaxis = N.extendArray(
      typeof e.annotations.yaxis < "u" ? e.annotations.yaxis : [],
      t.yAxisAnnotation
    ), e;
  }
  extendXAxisAnnotations(e) {
    let t = new Gs();
    return e.annotations.xaxis = N.extendArray(
      typeof e.annotations.xaxis < "u" ? e.annotations.xaxis : [],
      t.xAxisAnnotation
    ), e;
  }
  extendPointAnnotations(e) {
    let t = new Gs();
    return e.annotations.points = N.extendArray(
      typeof e.annotations.points < "u" ? e.annotations.points : [],
      t.pointAnnotation
    ), e;
  }
  checkForDarkTheme(e) {
    e.theme && e.theme.mode === "dark" && (e.tooltip || (e.tooltip = {}), e.tooltip.theme !== "light" && (e.tooltip.theme = "dark"), e.chart.foreColor || (e.chart.foreColor = "#f6f7f8"), e.chart.background || (e.chart.background = "#424242"), e.theme.palette || (e.theme.palette = "palette4"));
  }
  handleUserInputErrors(e) {
    let t = e;
    if (t.tooltip.shared && t.tooltip.intersect)
      throw new Error(
        "tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false."
      );
    if (t.chart.type === "bar" && t.plotOptions.bar.horizontal) {
      if (t.yaxis.length > 1)
        throw new Error(
          "Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false"
        );
      t.yaxis[0].reversed && (t.yaxis[0].opposite = !0), t.xaxis.tooltip.enabled = !1, t.yaxis[0].tooltip.enabled = !1, t.chart.zoom.enabled = !1;
    }
    return (t.chart.type === "bar" || t.chart.type === "rangeBar") && t.tooltip.shared && t.xaxis.crosshairs.width === "barWidth" && t.series.length > 1 && (t.xaxis.crosshairs.width = "tickWidth"), (t.chart.type === "candlestick" || t.chart.type === "boxPlot") && t.yaxis[0].reversed && (console.warn(
      `Reversed y-axis in ${t.chart.type} chart is not supported.`
    ), t.yaxis[0].reversed = !1), t;
  }
}
class Tv {
  initGlobalVars(e) {
    e.series = [], e.seriesCandleO = [], e.seriesCandleH = [], e.seriesCandleM = [], e.seriesCandleL = [], e.seriesCandleC = [], e.seriesRangeStart = [], e.seriesRangeEnd = [], e.seriesRange = [], e.seriesPercent = [], e.seriesGoals = [], e.seriesX = [], e.seriesZ = [], e.seriesNames = [], e.seriesTotals = [], e.seriesLog = [], e.seriesColors = [], e.stackedSeriesTotals = [], e.seriesXvalues = [], e.seriesYvalues = [], e.labels = [], e.hasXaxisGroups = !1, e.groups = [], e.hasSeriesGroups = !1, e.seriesGroups = [], e.categoryLabels = [], e.timescaleLabels = [], e.noLabelsProvided = !1, e.resizeTimer = null, e.selectionResizeTimer = null, e.delayedElements = [], e.pointsArray = [], e.dataLabelsRects = [], e.isXNumeric = !1, e.skipLastTimelinelabel = !1, e.skipFirstTimelinelabel = !1, e.isDataXYZ = !1, e.isMultiLineX = !1, e.isMultipleYAxis = !1, e.maxY = -Number.MAX_VALUE, e.minY = Number.MIN_VALUE, e.minYArr = [], e.maxYArr = [], e.maxX = -Number.MAX_VALUE, e.minX = Number.MAX_VALUE, e.initialMaxX = -Number.MAX_VALUE, e.initialMinX = Number.MAX_VALUE, e.maxDate = 0, e.minDate = Number.MAX_VALUE, e.minZ = Number.MAX_VALUE, e.maxZ = -Number.MAX_VALUE, e.minXDiff = Number.MAX_VALUE, e.yAxisScale = [], e.xAxisScale = null, e.xAxisTicksPositions = [], e.yLabelsCoords = [], e.yTitleCoords = [], e.barPadForNumericAxis = 0, e.padHorizontal = 0, e.xRange = 0, e.yRange = [], e.zRange = 0, e.dataPoints = 0, e.xTickAmount = 0, e.multiAxisTickAmount = 0;
  }
  globalVars(e) {
    return {
      chartID: null,
      // chart ID - apexcharts-cuid
      cuid: null,
      // chart ID - random numbers excluding "apexcharts" part
      events: {
        beforeMount: [],
        mounted: [],
        updated: [],
        clicked: [],
        selection: [],
        dataPointSelection: [],
        zoomed: [],
        scrolled: []
      },
      colors: [],
      clientX: null,
      clientY: null,
      fill: {
        colors: []
      },
      stroke: {
        colors: []
      },
      dataLabels: {
        style: {
          colors: []
        }
      },
      radarPolygons: {
        fill: {
          colors: []
        }
      },
      markers: {
        colors: [],
        size: e.markers.size,
        largestSize: 0
      },
      animationEnded: !1,
      isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints,
      isDirty: !1,
      // chart has been updated after the initial render. This is different than dataChanged property. isDirty means user manually called some method to update
      isExecCalled: !1,
      // whether user updated the chart through the exec method
      initialConfig: null,
      // we will store the first config user has set to go back when user finishes interactions like zooming and come out of it
      initialSeries: [],
      lastXAxis: [],
      lastYAxis: [],
      columnSeries: null,
      labels: [],
      // store the text to draw on x axis
      // Don't mutate the labels, many things including tooltips depends on it!
      timescaleLabels: [],
      // store the timescaleLabels Labels in another variable
      noLabelsProvided: !1,
      // if user didn't provide any categories/labels or x values, fallback to 1,2,3,4...
      allSeriesCollapsed: !1,
      collapsedSeries: [],
      // when user collapses a series, it goes into this array
      collapsedSeriesIndices: [],
      // this stores the index of the collapsedSeries instead of whole object for quick access
      ancillaryCollapsedSeries: [],
      // when user collapses an "alwaysVisible" series, it goes into this array
      ancillaryCollapsedSeriesIndices: [],
      // this stores the index of the ancillaryCollapsedSeries whose y-axis is always visible
      risingSeries: [],
      // when user re-opens a collapsed series, it goes here
      dataFormatXNumeric: !1,
      // boolean value to indicate user has passed numeric x values
      capturedSeriesIndex: -1,
      capturedDataPointIndex: -1,
      selectedDataPoints: [],
      goldenPadding: 35,
      // this value is used at a lot of places for spacing purpose
      invalidLogScale: !1,
      // if a user enabled log scale but the data provided is not valid to generate a log scale, turn on this flag
      ignoreYAxisIndexes: [],
      // when series are being collapsed in multiple y axes, ignore certain index
      maxValsInArrayIndex: 0,
      radialSize: 0,
      selection: void 0,
      zoomEnabled: e.chart.toolbar.autoSelected === "zoom" && e.chart.toolbar.tools.zoom && e.chart.zoom.enabled,
      panEnabled: e.chart.toolbar.autoSelected === "pan" && e.chart.toolbar.tools.pan,
      selectionEnabled: e.chart.toolbar.autoSelected === "selection" && e.chart.toolbar.tools.selection,
      yaxis: null,
      mousedown: !1,
      lastClientPosition: {},
      // don't reset this variable this the chart is destroyed. It is used to detect right or left mousemove in panning
      visibleXRange: void 0,
      yValueDecimal: 0,
      // are there floating numbers in the series. If yes, this represent the len of the decimals
      total: 0,
      SVGNS: "http://www.w3.org/2000/svg",
      // svg namespace
      svgWidth: 0,
      // the whole svg width
      svgHeight: 0,
      // the whole svg height
      noData: !1,
      // whether there is any data to display or not
      locale: {},
      // the current locale values will be preserved here for global access
      dom: {},
      // for storing all dom nodes in this particular property
      memory: {
        methodsToExec: []
      },
      shouldAnimate: !0,
      skipLastTimelinelabel: !1,
      // when last label is cropped, skip drawing it
      skipFirstTimelinelabel: !1,
      // when first label is cropped, skip drawing it
      delayedElements: [],
      // element which appear after animation has finished
      axisCharts: !0,
      // chart type = line or area or bar
      // (refer them also as plot charts in the code)
      isDataXYZ: !1,
      // bool: data was provided in a {[x,y,z]} pattern
      resized: !1,
      // bool: user has resized
      resizeTimer: null,
      // timeout function to make a small delay before
      // drawing when user resized
      comboCharts: !1,
      // bool: whether it's a combination of line/column
      dataChanged: !1,
      // bool: has data changed dynamically
      previousPaths: [],
      // array: when data is changed, it will animate from
      // previous paths
      allSeriesHasEqualX: !0,
      pointsArray: [],
      // store the points positions here to draw later on hover
      // format is - [[x,y],[x,y]... [x,y]]
      dataLabelsRects: [],
      // store the positions of datalabels to prevent collision
      lastDrawnDataLabelsIndexes: [],
      hasNullValues: !1,
      // bool: whether series contains null values
      easing: null,
      // function: animation effect to apply
      zoomed: !1,
      // whether user has zoomed or not
      gridWidth: 0,
      // drawable width of actual graphs (series paths)
      gridHeight: 0,
      // drawable height of actual graphs (series paths)
      rotateXLabels: !1,
      defaultLabels: !1,
      xLabelFormatter: void 0,
      // formatter for x axis labels
      yLabelFormatters: [],
      xaxisTooltipFormatter: void 0,
      // formatter for x axis tooltip
      ttKeyFormatter: void 0,
      ttVal: void 0,
      ttZFormatter: void 0,
      LINE_HEIGHT_RATIO: 1.618,
      xAxisLabelsHeight: 0,
      xAxisGroupLabelsHeight: 0,
      xAxisLabelsWidth: 0,
      yAxisLabelsWidth: 0,
      scaleX: 1,
      scaleY: 1,
      translateX: 0,
      translateY: 0,
      translateYAxisX: [],
      yAxisWidths: [],
      translateXAxisY: 0,
      translateXAxisX: 0,
      tooltip: null,
      // Rules for niceScaleAllowedMagMsd:
      // 1) An array of two arrays only ([[],[]]):
      //    * array[0][]: influences labelling of data series that contain only integers
      //       - must contain only integers (or expect ugly ticks)
      //    * array[1][]: influences labelling of data series that contain at least one float
      //       - may contain floats
      //    * both arrays:
      //       - each array[][i] ideally satisfy: 10 mod array[][i] == 0 (or expect ugly ticks)
      //       - to avoid clipping data point keep each array[][i] >= i
      // 2) each array[i][] contains 11 values, for all possible index values 0..10.
      //    array[][0] should not be needed (not proven) but ensures non-zero is returned.
      // 
      // Users can effectively force their preferred "magMsd" through stepSize and
      // forceNiceScale. With forceNiceScale: true, stepSize becomes normalizable to the
      // axis's min..max range, which allows users to set stepSize to an integer 1..10, for
      // example, stepSize: 3. This value will be preferred to the value determined through
      // this array. The range-normalized value is checked for consistency with other
      // user defined options and will be ignored if inconsistent.
      niceScaleAllowedMagMsd: [[1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10], [1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10]],
      // Default ticks based on SVG size. These values have high numbers
      // of divisors. The array is indexed using a calculated maxTicks value
      // divided by 2 simply to halve the array size. See Scales.niceScale().
      niceScaleDefaultTicks: [1, 2, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 12, 12, 12, 12, 12, 12, 12, 12, 12, 24],
      seriesYAxisMap: [],
      // Given yAxis index, return all series indices belonging to it. Multiple series can be referenced to each yAxis.
      seriesYAxisReverseMap: []
      // Given a Series index, return its yAxis index.
    };
  }
  init(e) {
    let t = this.globalVars(e);
    return this.initGlobalVars(t), t.initialConfig = N.extend({}, e), t.initialSeries = N.clone(e.series), t.lastXAxis = N.clone(t.initialConfig.xaxis), t.lastYAxis = N.clone(t.initialConfig.yaxis), t;
  }
}
class sL {
  constructor(e) {
    this.opts = e;
  }
  init() {
    const e = new Ur(this.opts).init({ responsiveOverride: !1 }), t = new Tv().init(e);
    return {
      config: e,
      globals: t
    };
  }
}
class _i {
  constructor(e) {
    this.ctx = e, this.w = e.w, this.opts = null, this.seriesIndex = 0;
  }
  clippedImgArea(e) {
    let t = this.w, i = t.config, s = parseInt(t.globals.gridWidth, 10), n = parseInt(t.globals.gridHeight, 10), o = s > n ? s : n, l = e.image, c = 0, d = 0;
    typeof e.width > "u" && typeof e.height > "u" ? i.fill.image.width !== void 0 && i.fill.image.height !== void 0 ? (c = i.fill.image.width + 1, d = i.fill.image.height) : (c = o + 1, d = o) : (c = e.width, d = e.height);
    let f = document.createElementNS(t.globals.SVGNS, "pattern");
    K.setAttrs(f, {
      id: e.patternID,
      patternUnits: e.patternUnits ? e.patternUnits : "userSpaceOnUse",
      width: c + "px",
      height: d + "px"
    });
    let p = document.createElementNS(t.globals.SVGNS, "image");
    f.appendChild(p), p.setAttributeNS(window.SVG.xlink, "href", l), K.setAttrs(p, {
      x: 0,
      y: 0,
      preserveAspectRatio: "none",
      width: c + "px",
      height: d + "px"
    }), p.style.opacity = e.opacity, t.globals.dom.elDefs.node.appendChild(f);
  }
  getSeriesIndex(e) {
    const t = this.w, i = t.config.chart.type;
    return (i === "bar" || i === "rangeBar") && t.config.plotOptions.bar.distributed || i === "heatmap" || i === "treemap" ? this.seriesIndex = e.seriesNumber : this.seriesIndex = e.seriesNumber % t.globals.series.length, this.seriesIndex;
  }
  fillPath(e) {
    let t = this.w;
    this.opts = e;
    let i = this.w.config, s, n, o;
    this.seriesIndex = this.getSeriesIndex(e);
    let c = this.getFillColors()[this.seriesIndex];
    t.globals.seriesColors[this.seriesIndex] !== void 0 && (c = t.globals.seriesColors[this.seriesIndex]), typeof c == "function" && (c = c({
      seriesIndex: this.seriesIndex,
      dataPointIndex: e.dataPointIndex,
      value: e.value,
      w: t
    }));
    let d = e.fillType ? e.fillType : this.getFillType(this.seriesIndex), f = Array.isArray(i.fill.opacity) ? i.fill.opacity[this.seriesIndex] : i.fill.opacity;
    e.color && (c = e.color), c || (c = "#fff", console.warn("undefined color - ApexCharts"));
    let p = c;
    if (c.indexOf("rgb") === -1 ? c.length < 9 && (p = N.hexToRgba(c, f)) : c.indexOf("rgba") > -1 && (f = N.getOpacityFromRGBA(c)), e.opacity && (f = e.opacity), d === "pattern" && (n = this.handlePatternFill({
      fillConfig: e.fillConfig,
      patternFill: n,
      fillColor: c,
      fillOpacity: f,
      defaultColor: p
    })), d === "gradient" && (o = this.handleGradientFill({
      fillConfig: e.fillConfig,
      fillColor: c,
      fillOpacity: f,
      i: this.seriesIndex
    })), d === "image") {
      let m = i.fill.image.src, v = e.patternID ? e.patternID : "";
      this.clippedImgArea({
        opacity: f,
        image: Array.isArray(m) ? e.seriesNumber < m.length ? m[e.seriesNumber] : m[0] : m,
        width: e.width ? e.width : void 0,
        height: e.height ? e.height : void 0,
        patternUnits: e.patternUnits,
        patternID: `pattern${t.globals.cuid}${e.seriesNumber + 1}${v}`
      }), s = `url(#pattern${t.globals.cuid}${e.seriesNumber + 1}${v})`;
    } else
      d === "gradient" ? s = o : d === "pattern" ? s = n : s = p;
    return e.solid && (s = p), s;
  }
  getFillType(e) {
    const t = this.w;
    return Array.isArray(t.config.fill.type) ? t.config.fill.type[e] : t.config.fill.type;
  }
  getFillColors() {
    const e = this.w, t = e.config, i = this.opts;
    let s = [];
    return e.globals.comboCharts ? e.config.series[this.seriesIndex].type === "line" ? Array.isArray(e.globals.stroke.colors) ? s = e.globals.stroke.colors : s.push(e.globals.stroke.colors) : Array.isArray(e.globals.fill.colors) ? s = e.globals.fill.colors : s.push(e.globals.fill.colors) : t.chart.type === "line" ? Array.isArray(e.globals.stroke.colors) ? s = e.globals.stroke.colors : s.push(e.globals.stroke.colors) : Array.isArray(e.globals.fill.colors) ? s = e.globals.fill.colors : s.push(e.globals.fill.colors), typeof i.fillColors < "u" && (s = [], Array.isArray(i.fillColors) ? s = i.fillColors.slice() : s.push(i.fillColors)), s;
  }
  handlePatternFill({
    fillConfig: e,
    patternFill: t,
    fillColor: i,
    fillOpacity: s,
    defaultColor: n
  }) {
    let o = this.w.config.fill;
    e && (o = e);
    const l = this.opts;
    let c = new K(this.ctx), d = Array.isArray(o.pattern.strokeWidth) ? o.pattern.strokeWidth[this.seriesIndex] : o.pattern.strokeWidth, f = i;
    return Array.isArray(o.pattern.style) ? typeof o.pattern.style[l.seriesNumber] < "u" ? t = c.drawPattern(
      o.pattern.style[l.seriesNumber],
      o.pattern.width,
      o.pattern.height,
      f,
      d,
      s
    ) : t = n : t = c.drawPattern(
      o.pattern.style,
      o.pattern.width,
      o.pattern.height,
      f,
      d,
      s
    ), t;
  }
  handleGradientFill({ fillColor: e, fillOpacity: t, fillConfig: i, i: s }) {
    let n = this.w.config.fill;
    i && (n = {
      ...n,
      ...i
    });
    const o = this.opts;
    let l = new K(this.ctx), c = new N(), d = n.gradient.type, f = e, p, m = n.gradient.opacityFrom === void 0 ? t : Array.isArray(n.gradient.opacityFrom) ? n.gradient.opacityFrom[s] : n.gradient.opacityFrom;
    f.indexOf("rgba") > -1 && (m = N.getOpacityFromRGBA(f));
    let v = n.gradient.opacityTo === void 0 ? t : Array.isArray(n.gradient.opacityTo) ? n.gradient.opacityTo[s] : n.gradient.opacityTo;
    if (n.gradient.gradientToColors === void 0 || n.gradient.gradientToColors.length === 0)
      n.gradient.shade === "dark" ? p = c.shadeColor(
        parseFloat(n.gradient.shadeIntensity) * -1,
        e.indexOf("rgb") > -1 ? N.rgb2hex(e) : e
      ) : p = c.shadeColor(
        parseFloat(n.gradient.shadeIntensity),
        e.indexOf("rgb") > -1 ? N.rgb2hex(e) : e
      );
    else if (n.gradient.gradientToColors[o.seriesNumber]) {
      const r = n.gradient.gradientToColors[o.seriesNumber];
      p = r, r.indexOf("rgba") > -1 && (v = N.getOpacityFromRGBA(r));
    } else
      p = e;
    if (n.gradient.gradientFrom && (f = n.gradient.gradientFrom), n.gradient.gradientTo && (p = n.gradient.gradientTo), n.gradient.inverseColors) {
      let r = f;
      f = p, p = r;
    }
    return f.indexOf("rgb") > -1 && (f = N.rgb2hex(f)), p.indexOf("rgb") > -1 && (p = N.rgb2hex(p)), l.drawGradient(
      d,
      f,
      p,
      m,
      v,
      o.size,
      n.gradient.stops,
      n.gradient.colorStops,
      s
    );
  }
}
class va {
  constructor(e, t) {
    this.ctx = e, this.w = e.w;
  }
  setGlobalMarkerSize() {
    const e = this.w;
    if (e.globals.markers.size = Array.isArray(e.config.markers.size) ? e.config.markers.size : [e.config.markers.size], e.globals.markers.size.length > 0) {
      if (e.globals.markers.size.length < e.globals.series.length + 1)
        for (let t = 0; t <= e.globals.series.length; t++)
          typeof e.globals.markers.size[t] > "u" && e.globals.markers.size.push(e.globals.markers.size[0]);
    } else
      e.globals.markers.size = e.config.series.map((t) => e.config.markers.size);
  }
  plotChartMarkers(e, t, i, s, n = !1) {
    let o = this.w, l = t, c = e, d = null, f = new K(this.ctx), p;
    const m = o.config.markers.discrete && o.config.markers.discrete.length;
    if ((o.globals.markers.size[t] > 0 || n || m) && (d = f.group({
      class: n || m ? "" : "apexcharts-series-markers"
    }), d.attr(
      "clip-path",
      `url(#gridRectMarkerMask${o.globals.cuid})`
    )), Array.isArray(c.x))
      for (let v = 0; v < c.x.length; v++) {
        let r = i;
        i === 1 && v === 0 && (r = 0), i === 1 && v === 1 && (r = 1);
        let h = "apexcharts-marker";
        if ((o.config.chart.type === "line" || o.config.chart.type === "area") && !o.globals.comboCharts && !o.config.tooltip.intersect && (h += " no-pointer-events"), (Array.isArray(o.config.markers.size) ? o.globals.markers.size[t] > 0 : o.config.markers.size > 0) || n || m) {
          N.isNumber(c.y[v]) ? h += ` w${N.randomId()}` : h = "apexcharts-nullpoint";
          let g = this.getMarkerConfig({
            cssClass: h,
            seriesIndex: t,
            dataPointIndex: r
          });
          o.config.series[l].data[r] && (o.config.series[l].data[r].fillColor && (g.pointFillColor = o.config.series[l].data[r].fillColor), o.config.series[l].data[r].strokeColor && (g.pointStrokeColor = o.config.series[l].data[r].strokeColor)), s && (g.pSize = s), (c.x[v] < 0 || c.x[v] > o.globals.gridWidth || c.y[v] < -o.globals.markers.largestSize || c.y[v] > o.globals.gridHeight + o.globals.markers.largestSize) && (g.pSize = 0), p = f.drawMarker(c.x[v], c.y[v], g), p.attr("rel", r), p.attr("j", r), p.attr("index", t), p.node.setAttribute("default-marker-size", g.pSize), new It(this.ctx).setSelectionFilter(p, t, r), this.addEvents(p), d && d.add(p);
        } else
          typeof o.globals.pointsArray[t] > "u" && (o.globals.pointsArray[t] = []), o.globals.pointsArray[t].push([c.x[v], c.y[v]]);
      }
    return d;
  }
  getMarkerConfig({
    cssClass: e,
    seriesIndex: t,
    dataPointIndex: i = null,
    finishRadius: s = null
  }) {
    const n = this.w;
    let o = this.getMarkerStyle(t), l = n.globals.markers.size[t];
    const c = n.config.markers;
    return i !== null && c.discrete.length && c.discrete.map((d) => {
      d.seriesIndex === t && d.dataPointIndex === i && (o.pointStrokeColor = d.strokeColor, o.pointFillColor = d.fillColor, l = d.size, o.pointShape = d.shape);
    }), {
      pSize: s === null ? l : s,
      pRadius: c.radius,
      width: Array.isArray(c.width) ? c.width[t] : c.width,
      height: Array.isArray(c.height) ? c.height[t] : c.height,
      pointStrokeWidth: Array.isArray(c.strokeWidth) ? c.strokeWidth[t] : c.strokeWidth,
      pointStrokeColor: o.pointStrokeColor,
      pointFillColor: o.pointFillColor,
      shape: o.pointShape || (Array.isArray(c.shape) ? c.shape[t] : c.shape),
      class: e,
      pointStrokeOpacity: Array.isArray(c.strokeOpacity) ? c.strokeOpacity[t] : c.strokeOpacity,
      pointStrokeDashArray: Array.isArray(c.strokeDashArray) ? c.strokeDashArray[t] : c.strokeDashArray,
      pointFillOpacity: Array.isArray(c.fillOpacity) ? c.fillOpacity[t] : c.fillOpacity,
      seriesIndex: t
    };
  }
  addEvents(e) {
    const t = this.w, i = new K(this.ctx);
    e.node.addEventListener(
      "mouseenter",
      i.pathMouseEnter.bind(this.ctx, e)
    ), e.node.addEventListener(
      "mouseleave",
      i.pathMouseLeave.bind(this.ctx, e)
    ), e.node.addEventListener(
      "mousedown",
      i.pathMouseDown.bind(this.ctx, e)
    ), e.node.addEventListener("click", t.config.markers.onClick), e.node.addEventListener("dblclick", t.config.markers.onDblClick), e.node.addEventListener(
      "touchstart",
      i.pathMouseDown.bind(this.ctx, e),
      { passive: !0 }
    );
  }
  getMarkerStyle(e) {
    let t = this.w, i = t.globals.markers.colors, s = t.config.markers.strokeColor || t.config.markers.strokeColors, n = Array.isArray(s) ? s[e] : s, o = Array.isArray(i) ? i[e] : i;
    return {
      pointStrokeColor: n,
      pointFillColor: o
    };
  }
}
class Av {
  constructor(e) {
    this.ctx = e, this.w = e.w, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;
  }
  draw(e, t, i) {
    let s = this.w, n = new K(this.ctx), o = i.realIndex, l = i.pointsPos, c = i.zRatio, d = i.elParent, f = n.group({
      class: `apexcharts-series-markers apexcharts-series-${s.config.chart.type}`
    });
    if (f.attr("clip-path", `url(#gridRectMarkerMask${s.globals.cuid})`), Array.isArray(l.x))
      for (let p = 0; p < l.x.length; p++) {
        let m = t + 1, v = !0;
        t === 0 && p === 0 && (m = 0), t === 0 && p === 1 && (m = 1);
        let r = 0, h = s.globals.markers.size[o];
        if (c !== 1 / 0) {
          const b = s.config.plotOptions.bubble;
          h = s.globals.seriesZ[o][m], b.zScaling && (h /= c), b.minBubbleRadius && h < b.minBubbleRadius && (h = b.minBubbleRadius), b.maxBubbleRadius && h > b.maxBubbleRadius && (h = b.maxBubbleRadius);
        }
        s.config.chart.animations.enabled || (r = h);
        let u = l.x[p], g = l.y[p];
        if (r = r || 0, (g === null || typeof s.globals.series[o][m] > "u") && (v = !1), v) {
          const b = this.drawPoint(
            u,
            g,
            r,
            h,
            o,
            m,
            t
          );
          f.add(b);
        }
        d.add(f);
      }
  }
  drawPoint(e, t, i, s, n, o, l) {
    const c = this.w;
    let d = n, f = new cr(this.ctx), p = new It(this.ctx), m = new _i(this.ctx), v = new va(this.ctx);
    const r = new K(this.ctx), h = v.getMarkerConfig({
      cssClass: "apexcharts-marker",
      seriesIndex: d,
      dataPointIndex: o,
      finishRadius: c.config.chart.type === "bubble" || c.globals.comboCharts && c.config.series[n] && c.config.series[n].type === "bubble" ? s : null
    });
    s = h.pSize;
    let u = m.fillPath({
      seriesNumber: n,
      dataPointIndex: o,
      color: h.pointFillColor,
      patternUnits: "objectBoundingBox",
      value: c.globals.series[n][l]
    }), g;
    if (h.shape === "circle" ? g = r.drawCircle(i) : (h.shape === "square" || h.shape === "rect") && (g = r.drawRect(
      0,
      0,
      h.width - h.pointStrokeWidth / 2,
      h.height - h.pointStrokeWidth / 2,
      h.pRadius
    )), c.config.series[d].data[o] && c.config.series[d].data[o].fillColor && (u = c.config.series[d].data[o].fillColor), g.attr({
      x: e - h.width / 2 - h.pointStrokeWidth / 2,
      y: t - h.height / 2 - h.pointStrokeWidth / 2,
      cx: e,
      cy: t,
      fill: u,
      "fill-opacity": h.pointFillOpacity,
      stroke: h.pointStrokeColor,
      r: s,
      "stroke-width": h.pointStrokeWidth,
      "stroke-dasharray": h.pointStrokeDashArray,
      "stroke-opacity": h.pointStrokeOpacity
    }), c.config.chart.dropShadow.enabled) {
      const b = c.config.chart.dropShadow;
      p.dropShadow(g, b, n);
    }
    if (this.initialAnim && !c.globals.dataChanged && !c.globals.resized) {
      let b = c.config.chart.animations.speed;
      f.animateMarker(
        g,
        0,
        h.shape === "circle" ? s : { width: h.width, height: h.height },
        b,
        c.globals.easing,
        () => {
          window.setTimeout(() => {
            f.animationCompleted(g);
          }, 100);
        }
      );
    } else
      c.globals.animationEnded = !0;
    if (c.globals.dataChanged && h.shape === "circle")
      if (this.dynamicAnim) {
        let b = c.config.chart.animations.dynamicAnimation.speed, O, x, S, k = null;
        k = c.globals.previousPaths[n] && c.globals.previousPaths[n][l], typeof k < "u" && k !== null && (O = k.x, x = k.y, S = typeof k.r < "u" ? k.r : s);
        for (let C = 0; C < c.globals.collapsedSeries.length; C++)
          c.globals.collapsedSeries[C].index === n && (b = 1, s = 0);
        e === 0 && t === 0 && (s = 0), f.animateCircle(
          g,
          {
            cx: O,
            cy: x,
            r: S
          },
          {
            cx: e,
            cy: t,
            r: s
          },
          b,
          c.globals.easing
        );
      } else
        g.attr({
          r: s
        });
    return g.attr({
      rel: o,
      j: o,
      index: n,
      "default-marker-size": s
    }), p.setSelectionFilter(g, n, o), v.addEvents(g), g.node.classList.add("apexcharts-marker"), g;
  }
  centerTextInBubble(e) {
    let t = this.w;
    return e = e + parseInt(t.config.dataLabels.style.fontSize, 10) / 4, {
      y: e
    };
  }
}
class Yn {
  constructor(e) {
    this.ctx = e, this.w = e.w;
  }
  // When there are many datalabels to be printed, and some of them overlaps each other in the same series, this method will take care of that
  // Also, when datalabels exceeds the drawable area and get clipped off, we need to adjust and move some pixels to make them visible again
  dataLabelsCorrection(e, t, i, s, n, o, l) {
    let c = this.w, d = new K(this.ctx), f = !1, p = d.getTextRects(i, l), m = p.width, v = p.height;
    t < 0 && (t = 0), t > c.globals.gridHeight + v && (t = c.globals.gridHeight + v / 2), typeof c.globals.dataLabelsRects[s] > "u" && (c.globals.dataLabelsRects[s] = []), c.globals.dataLabelsRects[s].push({ x: e, y: t, width: m, height: v });
    let r = c.globals.dataLabelsRects[s].length - 2, h = typeof c.globals.lastDrawnDataLabelsIndexes[s] < "u" ? c.globals.lastDrawnDataLabelsIndexes[s][c.globals.lastDrawnDataLabelsIndexes[s].length - 1] : 0;
    if (typeof c.globals.dataLabelsRects[s][r] < "u") {
      let u = c.globals.dataLabelsRects[s][h];
      // next label forward and x not intersecting
      (e > u.x + u.width || t > u.y + u.height || t + v < u.y || e + m < u.x) && (f = !0);
    }
    return (n === 0 || o) && (f = !0), {
      x: e,
      y: t,
      textRects: p,
      drawnextLabel: f
    };
  }
  drawDataLabel({ type: e, pos: t, i, j: s, isRangeStart: n, strokeWidth: o = 2 }) {
    let l = this.w;
    const c = new K(this.ctx);
    let d = l.config.dataLabels, f = 0, p = 0, m = s, v = null;
    if (l.globals.collapsedSeriesIndices.indexOf(i) !== -1 || !d.enabled || !Array.isArray(t.x))
      return v;
    v = c.group({
      class: "apexcharts-data-labels"
    });
    for (let h = 0; h < t.x.length; h++)
      if (f = t.x[h] + d.offsetX, p = t.y[h] + d.offsetY + o, !isNaN(f)) {
        s === 1 && h === 0 && (m = 0), s === 1 && h === 1 && (m = 1);
        let u = l.globals.series[i][m];
        e === "rangeArea" && (n ? u = l.globals.seriesRangeStart[i][m] : u = l.globals.seriesRangeEnd[i][m]);
        let g = "";
        const b = (O) => l.config.dataLabels.formatter(O, {
          ctx: this.ctx,
          seriesIndex: i,
          dataPointIndex: m,
          w: l
        });
        l.config.chart.type === "bubble" ? (u = l.globals.seriesZ[i][m], g = b(u), p = t.y[h], p = new Av(this.ctx).centerTextInBubble(
          p,
          i,
          m
        ).y) : typeof u < "u" && (g = b(u)), this.plotDataLabelsText({
          x: f,
          y: p,
          text: g,
          i,
          j: m,
          parent: v,
          offsetCorrection: !0,
          dataLabelsConfig: l.config.dataLabels
        });
      }
    return v;
  }
  plotDataLabelsText(e) {
    let t = this.w, i = new K(this.ctx), {
      x: s,
      y: n,
      i: o,
      j: l,
      text: c,
      textAnchor: d,
      fontSize: f,
      parent: p,
      dataLabelsConfig: m,
      color: v,
      alwaysDrawDataLabel: r,
      offsetCorrection: h
    } = e;
    if (Array.isArray(t.config.dataLabels.enabledOnSeries) && t.config.dataLabels.enabledOnSeries.indexOf(o) < 0)
      return;
    let u = {
      x: s,
      y: n,
      drawnextLabel: !0,
      textRects: null
    };
    h && (u = this.dataLabelsCorrection(
      s,
      n,
      c,
      o,
      l,
      r,
      parseInt(m.style.fontSize, 10)
    )), t.globals.zoomed || (s = u.x, n = u.y), u.textRects && (s < -20 - u.textRects.width || s > t.globals.gridWidth + u.textRects.width + 30) && (c = "");
    let g = t.globals.dataLabels.style.colors[o];
    ((t.config.chart.type === "bar" || t.config.chart.type === "rangeBar") && t.config.plotOptions.bar.distributed || t.config.dataLabels.distributed) && (g = t.globals.dataLabels.style.colors[l]), typeof g == "function" && (g = g({
      series: t.globals.series,
      seriesIndex: o,
      dataPointIndex: l,
      w: t
    })), v && (g = v);
    let b = m.offsetX, O = m.offsetY;
    if ((t.config.chart.type === "bar" || t.config.chart.type === "rangeBar") && (b = 0, O = 0), u.drawnextLabel) {
      let x = i.drawText({
        width: 100,
        height: parseInt(m.style.fontSize, 10),
        x: s + b,
        y: n + O,
        foreColor: g,
        textAnchor: d || m.textAnchor,
        text: c,
        fontSize: f || m.style.fontSize,
        fontFamily: m.style.fontFamily,
        fontWeight: m.style.fontWeight || "normal"
      });
      if (x.attr({
        class: "apexcharts-datalabel",
        cx: s,
        cy: n
      }), m.dropShadow.enabled) {
        const S = m.dropShadow;
        new It(this.ctx).dropShadow(x, S);
      }
      p.add(x), typeof t.globals.lastDrawnDataLabelsIndexes[o] > "u" && (t.globals.lastDrawnDataLabelsIndexes[o] = []), t.globals.lastDrawnDataLabelsIndexes[o].push(l);
    }
  }
  addBackgroundToDataLabel(e, t) {
    const i = this.w, s = i.config.dataLabels.background, n = s.padding, o = s.padding / 2, l = t.width, c = t.height, f = new K(this.ctx).drawRect(
      t.x - n,
      t.y - o / 2,
      l + n * 2,
      c + o,
      s.borderRadius,
      i.config.chart.background === "transparent" ? "#fff" : i.config.chart.background,
      s.opacity,
      s.borderWidth,
      s.borderColor
    );
    return s.dropShadow.enabled && new It(this.ctx).dropShadow(f, s.dropShadow), f;
  }
  dataLabelsBackground() {
    const e = this.w;
    if (e.config.chart.type === "bubble")
      return;
    const t = e.globals.dom.baseEl.querySelectorAll(
      ".apexcharts-datalabels text"
    );
    for (let i = 0; i < t.length; i++) {
      const s = t[i], n = s.getBBox();
      let o = null;
      if (n.width && n.height && (o = this.addBackgroundToDataLabel(s, n)), o) {
        s.parentNode.insertBefore(o.node, s);
        const l = s.getAttribute("fill");
        e.config.chart.animations.enabled && !e.globals.resized && !e.globals.dataChanged ? o.animate().attr({ fill: l }) : o.attr({ fill: l }), s.setAttribute("fill", e.config.dataLabels.background.foreColor);
      }
    }
  }
  bringForward() {
    const e = this.w, t = e.globals.dom.baseEl.querySelectorAll(
      ".apexcharts-datalabels"
    ), i = e.globals.dom.baseEl.querySelector(
      ".apexcharts-plot-series:last-child"
    );
    for (let s = 0; s < t.length; s++)
      i && i.insertBefore(t[s], i.nextSibling);
  }
}
class mi {
  constructor(e) {
    this.ctx = e, this.w = e.w, this.legendInactiveClass = "legend-mouseover-inactive";
  }
  getAllSeriesEls() {
    return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series");
  }
  getSeriesByName(e) {
    return this.w.globals.dom.baseEl.querySelector(
      `.apexcharts-inner .apexcharts-series[seriesName='${N.escapeString(
        e
      )}']`
    );
  }
  isSeriesHidden(e) {
    const t = this.getSeriesByName(e);
    let i = parseInt(t.getAttribute("data:realIndex"), 10);
    return { isHidden: t.classList.contains(
      "apexcharts-series-collapsed"
    ), realIndex: i };
  }
  addCollapsedClassToSeries(e, t) {
    const i = this.w;
    function s(n) {
      for (let o = 0; o < n.length; o++)
        n[o].index === t && e.node.classList.add("apexcharts-series-collapsed");
    }
    s(i.globals.collapsedSeries), s(i.globals.ancillaryCollapsedSeries);
  }
  toggleSeries(e) {
    let t = this.isSeriesHidden(e);
    return this.ctx.legend.legendHelpers.toggleDataSeries(
      t.realIndex,
      t.isHidden
    ), t.isHidden;
  }
  showSeries(e) {
    let t = this.isSeriesHidden(e);
    t.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(
      t.realIndex,
      !0
    );
  }
  hideSeries(e) {
    let t = this.isSeriesHidden(e);
    t.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(
      t.realIndex,
      !1
    );
  }
  resetSeries(e = !0, t = !0, i = !0) {
    const s = this.w;
    let n = N.clone(s.globals.initialSeries);
    s.globals.previousPaths = [], i ? (s.globals.collapsedSeries = [], s.globals.ancillaryCollapsedSeries = [], s.globals.collapsedSeriesIndices = [], s.globals.ancillaryCollapsedSeriesIndices = []) : n = this.emptyCollapsedSeries(n), s.config.series = n, e && (t && (s.globals.zoomed = !1, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(
      n,
      s.config.chart.animations.dynamicAnimation.enabled
    ));
  }
  emptyCollapsedSeries(e) {
    const t = this.w;
    for (let i = 0; i < e.length; i++)
      t.globals.collapsedSeriesIndices.indexOf(i) > -1 && (e[i].data = []);
    return e;
  }
  toggleSeriesOnHover(e, t) {
    const i = this.w;
    t || (t = e.target);
    let s = i.globals.dom.baseEl.querySelectorAll(
      ".apexcharts-series, .apexcharts-datalabels"
    );
    if (e.type === "mousemove") {
      let n = parseInt(t.getAttribute("rel"), 10) - 1, o = null, l = null;
      i.globals.axisCharts || i.config.chart.type === "radialBar" ? i.globals.axisCharts ? (o = i.globals.dom.baseEl.querySelector(
        `.apexcharts-series[data\\:realIndex='${n}']`
      ), l = i.globals.dom.baseEl.querySelector(
        `.apexcharts-datalabels[data\\:realIndex='${n}']`
      )) : o = i.globals.dom.baseEl.querySelector(
        `.apexcharts-series[rel='${n + 1}']`
      ) : o = i.globals.dom.baseEl.querySelector(
        `.apexcharts-series[rel='${n + 1}'] path`
      );
      for (let c = 0; c < s.length; c++)
        s[c].classList.add(this.legendInactiveClass);
      o !== null && (i.globals.axisCharts || o.parentNode.classList.remove(this.legendInactiveClass), o.classList.remove(this.legendInactiveClass), l !== null && l.classList.remove(this.legendInactiveClass));
    } else if (e.type === "mouseout")
      for (let n = 0; n < s.length; n++)
        s[n].classList.remove(this.legendInactiveClass);
  }
  highlightRangeInSeries(e, t) {
    const i = this.w, s = i.globals.dom.baseEl.getElementsByClassName(
      "apexcharts-heatmap-rect"
    ), n = (l) => {
      for (let c = 0; c < s.length; c++)
        s[c].classList[l](this.legendInactiveClass);
    }, o = (l) => {
      for (let c = 0; c < s.length; c++) {
        const d = parseInt(s[c].getAttribute("val"), 10);
        d >= l.from && d <= l.to && s[c].classList.remove(this.legendInactiveClass);
      }
    };
    if (e.type === "mousemove") {
      let l = parseInt(t.getAttribute("rel"), 10) - 1;
      n("add");
      const c = i.config.plotOptions.heatmap.colorScale.ranges[l];
      o(c);
    } else
      e.type === "mouseout" && n("remove");
  }
  getActiveConfigSeriesIndex(e = "asc", t = []) {
    const i = this.w;
    let s = 0;
    if (i.config.series.length > 1) {
      let n = i.config.series.map((o, l) => {
        const c = () => i.globals.comboCharts ? t.length === 0 || t.length && t.indexOf(i.config.series[l].type) > -1 : !0;
        return o.data && o.data.length > 0 && i.globals.collapsedSeriesIndices.indexOf(l) === -1 && c() ? l : -1;
      });
      for (let o = e === "asc" ? 0 : n.length - 1; e === "asc" ? o < n.length : o >= 0; e === "asc" ? o++ : o--)
        if (n[o] !== -1) {
          s = n[o];
          break;
        }
    }
    return s;
  }
  getBarSeriesIndices() {
    return this.w.globals.comboCharts ? this.w.config.series.map((t, i) => t.type === "bar" || t.type === "column" ? i : -1).filter((t) => t !== -1) : this.w.config.series.map((t, i) => i);
  }
  getPreviousPaths() {
    let e = this.w;
    e.globals.previousPaths = [];
    function t(o, l, c) {
      let d = o[l].childNodes, f = {
        type: c,
        paths: [],
        realIndex: o[l].getAttribute("data:realIndex")
      };
      for (let p = 0; p < d.length; p++)
        if (d[p].hasAttribute("pathTo")) {
          let m = d[p].getAttribute("pathTo");
          f.paths.push({
            d: m
          });
        }
      e.globals.previousPaths.push(f);
    }
    const i = (o) => e.globals.dom.baseEl.querySelectorAll(
      `.apexcharts-${o}-series .apexcharts-series`
    );
    [
      "line",
      "area",
      "bar",
      "rangebar",
      "rangeArea",
      "candlestick",
      "radar"
    ].forEach((o) => {
      const l = i(o);
      for (let c = 0; c < l.length; c++)
        t(l, c, o);
    }), this.handlePrevBubbleScatterPaths("bubble"), this.handlePrevBubbleScatterPaths("scatter");
    let n = e.globals.dom.baseEl.querySelectorAll(
      `.apexcharts-${e.config.chart.type} .apexcharts-series`
    );
    if (n.length > 0)
      for (let o = 0; o < n.length; o++) {
        let l = e.globals.dom.baseEl.querySelectorAll(
          `.apexcharts-${e.config.chart.type} .apexcharts-series[data\\:realIndex='${o}'] rect`
        ), c = [];
        for (let d = 0; d < l.length; d++) {
          const f = (m) => l[d].getAttribute(m), p = {
            x: parseFloat(f("x")),
            y: parseFloat(f("y")),
            width: parseFloat(f("width")),
            height: parseFloat(f("height"))
          };
          c.push({
            rect: p,
            color: l[d].getAttribute("color")
          });
        }
        e.globals.previousPaths.push(c);
      }
    e.globals.axisCharts || (e.globals.previousPaths = e.globals.series);
  }
  handlePrevBubbleScatterPaths(e) {
    const t = this.w;
    let i = t.globals.dom.baseEl.querySelectorAll(
      `.apexcharts-${e}-series .apexcharts-series`
    );
    if (i.length > 0)
      for (let s = 0; s < i.length; s++) {
        let n = t.globals.dom.baseEl.querySelectorAll(
          `.apexcharts-${e}-series .apexcharts-series[data\\:realIndex='${s}'] circle`
        ), o = [];
        for (let l = 0; l < n.length; l++)
          o.push({
            x: n[l].getAttribute("cx"),
            y: n[l].getAttribute("cy"),
            r: n[l].getAttribute("r")
          });
        t.globals.previousPaths.push(o);
      }
  }
  clearPreviousPaths() {
    const e = this.w;
    e.globals.previousPaths = [], e.globals.allSeriesCollapsed = !1;
  }
  handleNoData() {
    const e = this.w, t = this, i = e.config.noData, s = new K(t.ctx);
    let n = e.globals.svgWidth / 2, o = e.globals.svgHeight / 2, l = "middle";
    if (e.globals.noData = !0, e.globals.animationEnded = !0, i.align === "left" ? (n = 10, l = "start") : i.align === "right" && (n = e.globals.svgWidth - 10, l = "end"), i.verticalAlign === "top" ? o = 50 : i.verticalAlign === "bottom" && (o = e.globals.svgHeight - 50), n = n + i.offsetX, o = o + parseInt(i.style.fontSize, 10) + 2 + i.offsetY, i.text !== void 0 && i.text !== "") {
      let c = s.drawText({
        x: n,
        y: o,
        text: i.text,
        textAnchor: l,
        fontSize: i.style.fontSize,
        fontFamily: i.style.fontFamily,
        foreColor: i.style.color,
        opacity: 1,
        class: "apexcharts-text-nodata"
      });
      e.globals.dom.Paper.add(c);
    }
  }
  // When user clicks on legends, the collapsed series is filled with [0,0,0,...,0]
  // This is because we don't want to alter the series' length as it is used at many places
  setNullSeriesToZeroValues(e) {
    let t = this.w;
    for (let i = 0; i < e.length; i++)
      if (e[i].length === 0)
        for (let s = 0; s < e[t.globals.maxValsInArrayIndex].length; s++)
          e[i].push(0);
    return e;
  }
  hasAllSeriesEqualX() {
    let e = !0;
    const t = this.w, i = this.filteredSeriesX();
    for (let s = 0; s < i.length - 1; s++)
      if (i[s][0] !== i[s + 1][0]) {
        e = !1;
        break;
      }
    return t.globals.allSeriesHasEqualX = e, e;
  }
  filteredSeriesX() {
    return this.w.globals.seriesX.map(
      (i) => i.length > 0 ? i : []
    );
  }
}
class $v {
  constructor(e) {
    this.ctx = e, this.w = e.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.seriesGoals = [], this.coreUtils = new vt(this.ctx);
  }
  isMultiFormat() {
    return this.isFormatXY() || this.isFormat2DArray();
  }
  // given format is [{x, y}, {x, y}]
  isFormatXY() {
    const e = this.w.config.series.slice(), t = new mi(this.ctx);
    if (this.activeSeriesIndex = t.getActiveConfigSeriesIndex(), typeof e[this.activeSeriesIndex].data < "u" && e[this.activeSeriesIndex].data.length > 0 && e[this.activeSeriesIndex].data[0] !== null && typeof e[this.activeSeriesIndex].data[0].x < "u" && e[this.activeSeriesIndex].data[0] !== null)
      return !0;
  }
  // given format is [[x, y], [x, y]]
  isFormat2DArray() {
    const e = this.w.config.series.slice(), t = new mi(this.ctx);
    if (this.activeSeriesIndex = t.getActiveConfigSeriesIndex(), typeof e[this.activeSeriesIndex].data < "u" && e[this.activeSeriesIndex].data.length > 0 && typeof e[this.activeSeriesIndex].data[0] < "u" && e[this.activeSeriesIndex].data[0] !== null && e[this.activeSeriesIndex].data[0].constructor === Array)
      return !0;
  }
  handleFormat2DArray(e, t) {
    const i = this.w.config, s = this.w.globals, n = i.chart.type === "boxPlot" || i.series[t].type === "boxPlot";
    for (let o = 0; o < e[t].data.length; o++)
      if (typeof e[t].data[o][1] < "u" && (Array.isArray(e[t].data[o][1]) && e[t].data[o][1].length === 4 && !n ? this.twoDSeries.push(N.parseNumber(e[t].data[o][1][3])) : e[t].data[o].length >= 5 ? this.twoDSeries.push(N.parseNumber(e[t].data[o][4])) : this.twoDSeries.push(N.parseNumber(e[t].data[o][1])), s.dataFormatXNumeric = !0), i.xaxis.type === "datetime") {
        let l = new Date(e[t].data[o][0]);
        l = new Date(l).getTime(), this.twoDSeriesX.push(l);
      } else
        this.twoDSeriesX.push(e[t].data[o][0]);
    for (let o = 0; o < e[t].data.length; o++)
      typeof e[t].data[o][2] < "u" && (this.threeDSeries.push(e[t].data[o][2]), s.isDataXYZ = !0);
  }
  handleFormatXY(e, t) {
    const i = this.w.config, s = this.w.globals, n = new Tt(this.ctx);
    let o = t;
    s.collapsedSeriesIndices.indexOf(t) > -1 && (o = this.activeSeriesIndex);
    for (let l = 0; l < e[t].data.length; l++)
      typeof e[t].data[l].y < "u" && (Array.isArray(e[t].data[l].y) ? this.twoDSeries.push(
        N.parseNumber(e[t].data[l].y[e[t].data[l].y.length - 1])
      ) : this.twoDSeries.push(N.parseNumber(e[t].data[l].y))), typeof e[t].data[l].goals < "u" && Array.isArray(e[t].data[l].goals) ? (typeof this.seriesGoals[t] > "u" && (this.seriesGoals[t] = []), this.seriesGoals[t].push(e[t].data[l].goals)) : (typeof this.seriesGoals[t] > "u" && (this.seriesGoals[t] = []), this.seriesGoals[t].push(null));
    for (let l = 0; l < e[o].data.length; l++) {
      const c = typeof e[o].data[l].x == "string", d = Array.isArray(e[o].data[l].x), f = !d && !!n.isValidDate(e[o].data[l].x);
      if (c || f)
        if (c || i.xaxis.convertedCatToNumeric) {
          const p = s.isBarHorizontal && s.isRangeData;
          i.xaxis.type === "datetime" && !p ? this.twoDSeriesX.push(n.parseDate(e[o].data[l].x)) : (this.fallbackToCategory = !0, this.twoDSeriesX.push(e[o].data[l].x), !isNaN(e[o].data[l].x) && this.w.config.xaxis.type !== "category" && typeof e[o].data[l].x != "string" && (s.isXNumeric = !0));
        } else
          i.xaxis.type === "datetime" ? this.twoDSeriesX.push(
            n.parseDate(e[o].data[l].x.toString())
          ) : (s.dataFormatXNumeric = !0, s.isXNumeric = !0, this.twoDSeriesX.push(parseFloat(e[o].data[l].x)));
      else
        d ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(e[o].data[l].x)) : (s.isXNumeric = !0, s.dataFormatXNumeric = !0, this.twoDSeriesX.push(e[o].data[l].x));
    }
    if (e[t].data[0] && typeof e[t].data[0].z < "u") {
      for (let l = 0; l < e[t].data.length; l++)
        this.threeDSeries.push(e[t].data[l].z);
      s.isDataXYZ = !0;
    }
  }
  handleRangeData(e, t) {
    const i = this.w.globals;
    let s = {};
    return this.isFormat2DArray() ? s = this.handleRangeDataFormat("array", e, t) : this.isFormatXY() && (s = this.handleRangeDataFormat("xy", e, t)), i.seriesRangeStart.push(s.start === void 0 ? [] : s.start), i.seriesRangeEnd.push(s.end === void 0 ? [] : s.end), i.seriesRange.push(s.rangeUniques), i.seriesRange.forEach((n, o) => {
      n && n.forEach((l, c) => {
        l.y.forEach((d, f) => {
          for (let p = 0; p < l.y.length; p++)
            if (f !== p) {
              const m = d.y1, v = d.y2, r = l.y[p].y1, h = l.y[p].y2;
              m <= h && r <= v && (l.overlaps.indexOf(d.rangeName) < 0 && l.overlaps.push(d.rangeName), l.overlaps.indexOf(l.y[p].rangeName) < 0 && l.overlaps.push(l.y[p].rangeName));
            }
        });
      });
    }), s;
  }
  handleCandleStickBoxData(e, t) {
    const i = this.w.globals;
    let s = {};
    return this.isFormat2DArray() ? s = this.handleCandleStickBoxDataFormat("array", e, t) : this.isFormatXY() && (s = this.handleCandleStickBoxDataFormat("xy", e, t)), i.seriesCandleO[t] = s.o, i.seriesCandleH[t] = s.h, i.seriesCandleM[t] = s.m, i.seriesCandleL[t] = s.l, i.seriesCandleC[t] = s.c, s;
  }
  handleRangeDataFormat(e, t, i) {
    const s = [], n = [], o = t[i].data.filter(
      (l, c, d) => c === d.findIndex((f) => f.x === l.x)
    ).map((l, c) => ({
      x: l.x,
      overlaps: [],
      y: []
    }));
    if (e === "array")
      for (let l = 0; l < t[i].data.length; l++)
        Array.isArray(t[i].data[l]) ? (s.push(t[i].data[l][1][0]), n.push(t[i].data[l][1][1])) : (s.push(t[i].data[l]), n.push(t[i].data[l]));
    else if (e === "xy")
      for (let l = 0; l < t[i].data.length; l++) {
        let c = Array.isArray(t[i].data[l].y);
        const d = N.randomId(), f = t[i].data[l].x, p = {
          y1: c ? t[i].data[l].y[0] : t[i].data[l].y,
          y2: c ? t[i].data[l].y[1] : t[i].data[l].y,
          rangeName: d
        };
        t[i].data[l].rangeName = d;
        const m = o.findIndex((v) => v.x === f);
        o[m].y.push(p), s.push(p.y1), n.push(p.y2);
      }
    return {
      start: s,
      end: n,
      rangeUniques: o
    };
  }
  handleCandleStickBoxDataFormat(e, t, i) {
    const s = this.w, n = s.config.chart.type === "boxPlot" || s.config.series[i].type === "boxPlot", o = [], l = [], c = [], d = [], f = [];
    if (e === "array")
      if (n && t[i].data[0].length === 6 || !n && t[i].data[0].length === 5)
        for (let p = 0; p < t[i].data.length; p++)
          o.push(t[i].data[p][1]), l.push(t[i].data[p][2]), n ? (c.push(t[i].data[p][3]), d.push(t[i].data[p][4]), f.push(t[i].data[p][5])) : (d.push(t[i].data[p][3]), f.push(t[i].data[p][4]));
      else
        for (let p = 0; p < t[i].data.length; p++)
          Array.isArray(t[i].data[p][1]) && (o.push(t[i].data[p][1][0]), l.push(t[i].data[p][1][1]), n ? (c.push(t[i].data[p][1][2]), d.push(t[i].data[p][1][3]), f.push(t[i].data[p][1][4])) : (d.push(t[i].data[p][1][2]), f.push(t[i].data[p][1][3])));
    else if (e === "xy")
      for (let p = 0; p < t[i].data.length; p++)
        Array.isArray(t[i].data[p].y) && (o.push(t[i].data[p].y[0]), l.push(t[i].data[p].y[1]), n ? (c.push(t[i].data[p].y[2]), d.push(t[i].data[p].y[3]), f.push(t[i].data[p].y[4])) : (d.push(t[i].data[p].y[2]), f.push(t[i].data[p].y[3])));
    return {
      o,
      h: l,
      m: c,
      l: d,
      c: f
    };
  }
  parseDataAxisCharts(e, t = this.ctx) {
    var c;
    const i = this.w.config, s = this.w.globals, n = new Tt(t), o = i.labels.length > 0 ? i.labels.slice() : i.xaxis.categories.slice();
    if (s.isRangeBar = i.chart.type === "rangeBar" && s.isBarHorizontal, s.hasXaxisGroups = i.xaxis.type === "category" && i.xaxis.group.groups.length > 0, s.hasXaxisGroups && (s.groups = i.xaxis.group.groups), s.hasSeriesGroups = (c = e[0]) == null ? void 0 : c.group, s.hasSeriesGroups) {
      let d = [], f = [...new Set(e.map((p) => p.group))];
      e.forEach((p, m) => {
        let v = f.indexOf(p.group);
        d[v] || (d[v] = []), d[v].push(p.name);
      }), s.seriesGroups = d;
    }
    const l = () => {
      for (let d = 0; d < o.length; d++)
        if (typeof o[d] == "string")
          if (n.isValidDate(o[d]))
            this.twoDSeriesX.push(n.parseDate(o[d]));
          else
            throw new Error(
              "You have provided invalid Date format. Please provide a valid JavaScript Date"
            );
        else
          this.twoDSeriesX.push(o[d]);
    };
    for (let d = 0; d < e.length; d++) {
      if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], typeof e[d].data > "u") {
        console.error(
          "It is a possibility that you may have not included 'data' property in series."
        );
        return;
      }
      if ((i.chart.type === "rangeBar" || i.chart.type === "rangeArea" || e[d].type === "rangeBar" || e[d].type === "rangeArea") && (s.isRangeData = !0, (i.chart.type === "rangeBar" || i.chart.type === "rangeArea") && this.handleRangeData(e, d)), this.isMultiFormat())
        this.isFormat2DArray() ? this.handleFormat2DArray(e, d) : this.isFormatXY() && this.handleFormatXY(e, d), (i.chart.type === "candlestick" || e[d].type === "candlestick" || i.chart.type === "boxPlot" || e[d].type === "boxPlot") && this.handleCandleStickBoxData(e, d), s.series.push(this.twoDSeries), s.labels.push(this.twoDSeriesX), s.seriesX.push(this.twoDSeriesX), s.seriesGoals = this.seriesGoals, d === this.activeSeriesIndex && !this.fallbackToCategory && (s.isXNumeric = !0);
      else {
        i.xaxis.type === "datetime" ? (s.isXNumeric = !0, l(), s.seriesX.push(this.twoDSeriesX)) : i.xaxis.type === "numeric" && (s.isXNumeric = !0, o.length > 0 && (this.twoDSeriesX = o, s.seriesX.push(this.twoDSeriesX))), s.labels.push(this.twoDSeriesX);
        const f = e[d].data.map((p) => N.parseNumber(p));
        s.series.push(f);
      }
      s.seriesZ.push(this.threeDSeries), e[d].name !== void 0 ? s.seriesNames.push(e[d].name) : s.seriesNames.push("series-" + parseInt(d + 1, 10)), e[d].color !== void 0 ? s.seriesColors.push(e[d].color) : s.seriesColors.push(void 0);
    }
    return this.w;
  }
  parseDataNonAxisCharts(e) {
    const t = this.w.globals, i = this.w.config;
    t.series = e.slice(), t.seriesNames = i.labels.slice();
    for (let s = 0; s < t.series.length; s++)
      t.seriesNames[s] === void 0 && t.seriesNames.push("series-" + (s + 1));
    return this.w;
  }
  /** User possibly set string categories in xaxis.categories or labels prop
   * Or didn't set xaxis labels at all - in which case we manually do it.
   * If user passed series data as [[3, 2], [4, 5]] or [{ x: 3, y: 55 }],
   * this shouldn't be called
   * @param {array} ser - the series which user passed to the config
   */
  handleExternalLabelsData(e) {
    const t = this.w.config, i = this.w.globals;
    t.xaxis.categories.length > 0 ? i.labels = t.xaxis.categories : t.labels.length > 0 ? i.labels = t.labels.slice() : this.fallbackToCategory ? (i.labels = i.labels[0], i.seriesRange.length && (i.seriesRange.map((s) => {
      s.forEach((n) => {
        i.labels.indexOf(n.x) < 0 && n.x && i.labels.push(n.x);
      });
    }), i.labels = Array.from(
      new Set(i.labels.map(JSON.stringify)),
      JSON.parse
    )), t.xaxis.convertedCatToNumeric && (new jr(t).convertCatToNumericXaxis(t, this.ctx, i.seriesX[0]), this._generateExternalLabels(e))) : this._generateExternalLabels(e);
  }
  _generateExternalLabels(e) {
    const t = this.w.globals, i = this.w.config;
    let s = [];
    if (t.axisCharts) {
      if (t.series.length > 0)
        if (this.isFormatXY()) {
          const n = i.series.map((l, c) => l.data.filter(
            (d, f, p) => p.findIndex((m) => m.x === d.x) === f
          )), o = n.reduce(
            (l, c, d, f) => f[l].length > c.length ? l : d,
            0
          );
          for (let l = 0; l < n[o].length; l++)
            s.push(l + 1);
        } else
          for (let n = 0; n < t.series[t.maxValsInArrayIndex].length; n++)
            s.push(n + 1);
      t.seriesX = [];
      for (let n = 0; n < e.length; n++)
        t.seriesX.push(s);
      this.w.globals.isBarHorizontal || (t.isXNumeric = !0);
    }
    if (s.length === 0) {
      s = t.axisCharts ? [] : t.series.map((n, o) => o + 1);
      for (let n = 0; n < e.length; n++)
        t.seriesX.push(s);
    }
    t.labels = s, i.xaxis.convertedCatToNumeric && (t.categoryLabels = s.map((n) => i.xaxis.labels.formatter(n))), t.noLabelsProvided = !0;
  }
  // Segregate user provided data into appropriate vars
  parseData(e) {
    let t = this.w, i = t.config, s = t.globals;
    if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = !1, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), s.axisCharts ? (this.parseDataAxisCharts(e), this.coreUtils.getLargestSeries()) : this.parseDataNonAxisCharts(e), i.chart.stacked) {
      const o = new mi(this.ctx);
      s.series = o.setNullSeriesToZeroValues(s.series);
    }
    this.coreUtils.getSeriesTotals(), s.axisCharts && (s.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals(), s.stackedSeriesTotalsByGroups = this.coreUtils.getStackedSeriesTotalsByGroups()), this.coreUtils.getPercentSeries(), !s.dataFormatXNumeric && (!s.isXNumeric || i.xaxis.type === "numeric" && i.labels.length === 0 && i.xaxis.categories.length === 0) && this.handleExternalLabelsData(e);
    const n = this.coreUtils.getCategoryLabels(s.labels);
    for (let o = 0; o < n.length; o++)
      if (Array.isArray(n[o])) {
        s.isMultiLineX = !0;
        break;
      }
  }
  excludeCollapsedSeriesInYAxis() {
    const e = this.w;
    let t = [];
    e.globals.seriesYAxisMap.forEach((i, s) => {
      let n = 0;
      i.forEach((o) => {
        e.globals.collapsedSeriesIndices.indexOf(o) !== -1 && n++;
      }), n > 0 && n == i.length && t.push(s);
    }), e.globals.ignoreYAxisIndexes = t.map((i) => i);
  }
}
class Eo {
  constructor(e) {
    this.ctx = e, this.w = e.w;
  }
  scaleSvgNode(e, t) {
    let i = parseFloat(e.getAttributeNS(null, "width")), s = parseFloat(e.getAttributeNS(null, "height"));
    e.setAttributeNS(null, "width", i * t), e.setAttributeNS(null, "height", s * t), e.setAttributeNS(null, "viewBox", "0 0 " + i + " " + s);
  }
  fixSvgStringForIe11(e) {
    if (!N.isIE11())
      return e.replace(/&nbsp;/g, "&#160;");
    let t = 0, i = e.replace(
      /xmlns="http:\/\/www.w3.org\/2000\/svg"/g,
      (s) => (t++, t === 2 ? 'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev"' : s)
    );
    return i = i.replace(/xmlns:NS\d+=""/g, ""), i = i.replace(/NS\d+:(\w+:\w+=")/g, "$1"), i;
  }
  getSvgString(e) {
    e == null && (e = 1);
    let t = this.w.globals.dom.Paper.svg();
    if (e !== 1) {
      const i = this.w.globals.dom.Paper.node.cloneNode(!0);
      this.scaleSvgNode(i, e), t = new XMLSerializer().serializeToString(i);
    }
    return this.fixSvgStringForIe11(t);
  }
  cleanup() {
    const e = this.w, t = e.globals.dom.baseEl.getElementsByClassName(
      "apexcharts-xcrosshairs"
    ), i = e.globals.dom.baseEl.getElementsByClassName(
      "apexcharts-ycrosshairs"
    ), s = e.globals.dom.baseEl.querySelectorAll(
      ".apexcharts-zoom-rect, .apexcharts-selection-rect"
    );
    Array.prototype.forEach.call(s, (n) => {
      n.setAttribute("width", 0);
    }), t && t[0] && (t[0].setAttribute("x", -500), t[0].setAttribute("x1", -500), t[0].setAttribute("x2", -500)), i && i[0] && (i[0].setAttribute("y", -100), i[0].setAttribute("y1", -100), i[0].setAttribute("y2", -100));
  }
  svgUrl() {
    this.cleanup();
    const e = this.getSvgString(), t = new Blob([e], { type: "image/svg+xml;charset=utf-8" });
    return URL.createObjectURL(t);
  }
  dataURI(e) {
    return new Promise((t) => {
      const i = this.w, s = e ? e.scale || e.width / i.globals.svgWidth : 1;
      this.cleanup();
      const n = document.createElement("canvas");
      n.width = i.globals.svgWidth * s, n.height = parseInt(i.globals.dom.elWrap.style.height, 10) * s;
      const o = i.config.chart.background === "transparent" ? "#fff" : i.config.chart.background;
      let l = n.getContext("2d");
      l.fillStyle = o, l.fillRect(0, 0, n.width * s, n.height * s);
      const c = this.getSvgString(s);
      if (window.canvg && N.isIE11()) {
        let d = window.canvg.Canvg.fromString(l, c, {
          ignoreClear: !0,
          ignoreDimensions: !0
        });
        d.start();
        let f = n.msToBlob();
        d.stop(), t({ blob: f });
      } else {
        const d = "data:image/svg+xml," + encodeURIComponent(c);
        let f = new Image();
        f.crossOrigin = "anonymous", f.onload = () => {
          if (l.drawImage(f, 0, 0), n.msToBlob) {
            let p = n.msToBlob();
            t({ blob: p });
          } else {
            let p = n.toDataURL("image/png");
            t({ imgURI: p });
          }
        }, f.src = d;
      }
    });
  }
  exportToSVG() {
    this.triggerDownload(
      this.svgUrl(),
      this.w.config.chart.toolbar.export.svg.filename,
      ".svg"
    );
  }
  exportToPng() {
    this.dataURI().then(({ imgURI: e, blob: t }) => {
      t ? navigator.msSaveOrOpenBlob(t, this.w.globals.chartID + ".png") : this.triggerDownload(
        e,
        this.w.config.chart.toolbar.export.png.filename,
        ".png"
      );
    });
  }
  exportToCSV({
    series: e,
    fileName: t,
    columnDelimiter: i = ",",
    lineDelimiter: s = `
`
  }) {
    const n = this.w;
    e || (e = n.config.series);
    let o = [], l = [], c = "", d = "\uFEFF", f = n.globals.series.map((O, x) => n.globals.collapsedSeriesIndices.indexOf(x) === -1 ? O : []);
    const p = (O) => n.config.xaxis.type === "datetime" && String(O).length >= 10, m = Math.max(
      ...e.map((O) => O.data ? O.data.length : 0)
    ), v = new $v(this.ctx), r = new Es(this.ctx), h = (O) => {
      let x = "";
      if (!n.globals.axisCharts)
        x = n.config.labels[O];
      else {
        if (n.config.xaxis.type === "category" || n.config.xaxis.convertedCatToNumeric)
          if (n.globals.isBarHorizontal) {
            let S = n.globals.yLabelFormatters[0], C = new mi(this.ctx).getActiveConfigSeriesIndex();
            x = S(n.globals.labels[O], {
              seriesIndex: C,
              dataPointIndex: O,
              w: n
            });
          } else
            x = r.getLabel(
              n.globals.labels,
              n.globals.timescaleLabels,
              0,
              O
            ).text;
        n.config.xaxis.type === "datetime" && (n.config.xaxis.categories.length ? x = n.config.xaxis.categories[O] : n.config.labels.length && (x = n.config.labels[O]));
      }
      return Array.isArray(x) && (x = x.join(" ")), N.isNumber(x) ? x : x.split(i).join("");
    }, u = () => [...Array(m)].map(() => ""), g = (O, x) => {
      var S;
      if (o.length && x === 0 && l.push(o.join(i)), O.data) {
        O.data = O.data.length && O.data || u();
        for (let k = 0; k < O.data.length; k++) {
          o = [];
          let C = h(k);
          if (C || (v.isFormatXY() ? C = e[x].data[k].x : v.isFormat2DArray() && (C = e[x].data[k] ? e[x].data[k][0] : "")), x === 0) {
            o.push(
              p(C) ? n.config.chart.toolbar.export.csv.dateFormatter(C) : N.isNumber(C) ? C : C.split(i).join("")
            );
            for (let _ = 0; _ < n.globals.series.length; _++)
              v.isFormatXY() ? o.push((S = e[_].data[k]) == null ? void 0 : S.y) : o.push(f[_][k]);
          }
          (n.config.chart.type === "candlestick" || O.type && O.type === "candlestick") && (o.pop(), o.push(n.globals.seriesCandleO[x][k]), o.push(n.globals.seriesCandleH[x][k]), o.push(n.globals.seriesCandleL[x][k]), o.push(n.globals.seriesCandleC[x][k])), (n.config.chart.type === "boxPlot" || O.type && O.type === "boxPlot") && (o.pop(), o.push(n.globals.seriesCandleO[x][k]), o.push(n.globals.seriesCandleH[x][k]), o.push(n.globals.seriesCandleM[x][k]), o.push(n.globals.seriesCandleL[x][k]), o.push(n.globals.seriesCandleC[x][k])), n.config.chart.type === "rangeBar" && (o.pop(), o.push(n.globals.seriesRangeStart[x][k]), o.push(n.globals.seriesRangeEnd[x][k])), o.length && l.push(o.join(i));
        }
      }
    }, b = () => {
      const O = /* @__PURE__ */ new Set(), x = {};
      e.forEach((S, k) => {
        S == null || S.data.forEach((C) => {
          let _, $;
          if (v.isFormatXY())
            _ = C.x, $ = C.y;
          else if (v.isFormat2DArray())
            _ = C[0], $ = C[1];
          else
            return;
          x[_] || (x[_] = Array(e.length).fill("")), x[_][k] = $, O.add(_);
        });
      }), o.length && l.push(o.join(i)), Array.from(O).sort().forEach((S) => {
        l.push([
          p(S) && n.config.xaxis.type === "datetime" ? n.config.chart.toolbar.export.csv.dateFormatter(S) : N.isNumber(S) ? S : S.split(i).join(""),
          x[S].join(i)
        ]);
      });
    };
    o.push(n.config.chart.toolbar.export.csv.headerCategory), n.config.chart.type === "boxPlot" ? (o.push("minimum"), o.push("q1"), o.push("median"), o.push("q3"), o.push("maximum")) : n.config.chart.type === "candlestick" ? (o.push("open"), o.push("high"), o.push("low"), o.push("close")) : n.config.chart.type === "rangeBar" ? (o.push("minimum"), o.push("maximum")) : e.map((O, x) => {
      const S = (O.name ? O.name : `series-${x}`) + "";
      n.globals.axisCharts && o.push(
        S.split(i).join("") ? S.split(i).join("") : `series-${x}`
      );
    }), n.globals.axisCharts || (o.push(n.config.chart.toolbar.export.csv.headerValue), l.push(o.join(i))), !n.globals.allSeriesHasEqualX && n.globals.axisCharts && !n.config.xaxis.categories.length && !n.config.labels.length ? b() : e.map((O, x) => {
      n.globals.axisCharts ? g(O, x) : (o = [], o.push(n.globals.labels[x].split(i).join("")), o.push(f[x]), l.push(o.join(i)));
    }), c += l.join(s), this.triggerDownload(
      "data:text/csv; charset=utf-8," + encodeURIComponent(d + c),
      t || n.config.chart.toolbar.export.csv.filename,
      ".csv"
    );
  }
  triggerDownload(e, t, i) {
    const s = document.createElement("a");
    s.href = e, s.download = (t || this.w.globals.chartID) + i, document.body.appendChild(s), s.click(), document.body.removeChild(s);
  }
}
class Zr {
  constructor(e, t) {
    this.ctx = e, this.elgrid = t, this.w = e.w;
    const i = this.w;
    this.axesUtils = new Es(e), this.xaxisLabels = i.globals.labels.slice(), i.globals.timescaleLabels.length > 0 && !i.globals.isBarHorizontal && (this.xaxisLabels = i.globals.timescaleLabels.slice()), i.config.xaxis.overwriteCategories && (this.xaxisLabels = i.config.xaxis.overwriteCategories), this.drawnLabels = [], this.drawnLabelsRects = [], i.config.xaxis.position === "top" ? this.offY = 0 : this.offY = i.globals.gridHeight + 1, this.offY = this.offY + i.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = i.config.chart.type === "bar" && i.config.plotOptions.bar.horizontal, this.xaxisFontSize = i.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = i.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i.config.xaxis.labels.style.colors, this.xaxisBorderWidth = i.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = i.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = i.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = i.config.xaxis.axisBorder.height, this.yaxis = i.config.yaxis[0];
  }
  drawXaxis() {
    let e = this.w, t = new K(this.ctx), i = t.group({
      class: "apexcharts-xaxis",
      transform: `translate(${e.config.xaxis.offsetX}, ${e.config.xaxis.offsetY})`
    }), s = t.group({
      class: "apexcharts-xaxis-texts-g",
      transform: `translate(${e.globals.translateXAxisX}, ${e.globals.translateXAxisY})`
    });
    i.add(s);
    let n = [];
    for (let o = 0; o < this.xaxisLabels.length; o++)
      n.push(this.xaxisLabels[o]);
    if (this.drawXAxisLabelAndGroup(
      !0,
      t,
      s,
      n,
      e.globals.isXNumeric,
      (o, l) => l
    ), e.globals.hasXaxisGroups) {
      let o = e.globals.groups;
      n = [];
      for (let c = 0; c < o.length; c++)
        n.push(o[c].title);
      let l = {};
      e.config.xaxis.group.style && (l.xaxisFontSize = e.config.xaxis.group.style.fontSize, l.xaxisFontFamily = e.config.xaxis.group.style.fontFamily, l.xaxisForeColors = e.config.xaxis.group.style.colors, l.fontWeight = e.config.xaxis.group.style.fontWeight, l.cssClass = e.config.xaxis.group.style.cssClass), this.drawXAxisLabelAndGroup(
        !1,
        t,
        s,
        n,
        !1,
        (c, d) => o[c].cols * d,
        l
      );
    }
    if (e.config.xaxis.title.text !== void 0) {
      let o = t.group({
        class: "apexcharts-xaxis-title"
      }), l = t.drawText({
        x: e.globals.gridWidth / 2 + e.config.xaxis.title.offsetX,
        y: this.offY + parseFloat(this.xaxisFontSize) + (e.config.xaxis.position === "bottom" ? e.globals.xAxisLabelsHeight : -e.globals.xAxisLabelsHeight - 10) + e.config.xaxis.title.offsetY,
        text: e.config.xaxis.title.text,
        textAnchor: "middle",
        fontSize: e.config.xaxis.title.style.fontSize,
        fontFamily: e.config.xaxis.title.style.fontFamily,
        fontWeight: e.config.xaxis.title.style.fontWeight,
        foreColor: e.config.xaxis.title.style.color,
        cssClass: "apexcharts-xaxis-title-text " + e.config.xaxis.title.style.cssClass
      });
      o.add(l), i.add(o);
    }
    if (e.config.xaxis.axisBorder.show) {
      const o = e.globals.barPadForNumericAxis;
      let l = t.drawLine(
        e.globals.padHorizontal + e.config.xaxis.axisBorder.offsetX - o,
        this.offY,
        this.xaxisBorderWidth + o,
        this.offY,
        e.config.xaxis.axisBorder.color,
        0,
        this.xaxisBorderHeight
      );
      this.elgrid && this.elgrid.elGridBorders && e.config.grid.show ? this.elgrid.elGridBorders.add(l) : i.add(l);
    }
    return i;
  }
  drawXAxisLabelAndGroup(e, t, i, s, n, o, l = {}) {
    let c = [], d = [], f = this.w;
    const p = l.xaxisFontSize || this.xaxisFontSize, m = l.xaxisFontFamily || this.xaxisFontFamily, v = l.xaxisForeColors || this.xaxisForeColors, r = l.fontWeight || f.config.xaxis.labels.style.fontWeight, h = l.cssClass || f.config.xaxis.labels.style.cssClass;
    let u, g = f.globals.padHorizontal, b = s.length, O = f.config.xaxis.type === "category" ? f.globals.dataPoints : b;
    if (O === 0 && b > O && (O = b), n) {
      let x = O > 1 ? O - 1 : O;
      u = f.globals.gridWidth / Math.min(x, b - 1), g = g + o(0, u) / 2 + f.config.xaxis.labels.offsetX;
    } else
      u = f.globals.gridWidth / O, g = g + o(0, u) + f.config.xaxis.labels.offsetX;
    for (let x = 0; x <= b - 1; x++) {
      let S = g - o(x, u) / 2 + f.config.xaxis.labels.offsetX;
      x === 0 && b === 1 && u / 2 === g && O === 1 && (S = f.globals.gridWidth / 2);
      let k = this.axesUtils.getLabel(
        s,
        f.globals.timescaleLabels,
        S,
        x,
        c,
        p,
        e
      ), C = 28;
      f.globals.rotateXLabels && e && (C = 22), f.config.xaxis.title.text && f.config.xaxis.position === "top" && (C += parseFloat(f.config.xaxis.title.style.fontSize) + 2), e || (C = C + parseFloat(p) + (f.globals.xAxisLabelsHeight - f.globals.xAxisGroupLabelsHeight) + (f.globals.rotateXLabels ? 10 : 0)), typeof f.config.xaxis.tickAmount < "u" && f.config.xaxis.tickAmount !== "dataPoints" && f.config.xaxis.type !== "datetime" ? k = this.axesUtils.checkLabelBasedOnTickamount(x, k, b) : k = this.axesUtils.checkForOverflowingLabels(
        x,
        k,
        b,
        c,
        d
      );
      const $ = () => e && f.config.xaxis.convertedCatToNumeric ? v[f.globals.minX + x - 1] : v[x];
      if (f.config.xaxis.labels.show) {
        let L = t.drawText({
          x: k.x,
          y: this.offY + f.config.xaxis.labels.offsetY + C - (f.config.xaxis.position === "top" ? f.globals.xAxisHeight + f.config.xaxis.axisTicks.height - 2 : 0),
          text: k.text,
          textAnchor: "middle",
          fontWeight: k.isBold ? 600 : r,
          fontSize: p,
          fontFamily: m,
          foreColor: Array.isArray(v) ? $() : v,
          isPlainText: !1,
          cssClass: (e ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + h
        });
        if (i.add(L), L.on("click", (E) => {
          if (typeof f.config.chart.events.xAxisLabelClick == "function") {
            const A = Object.assign({}, f, {
              labelIndex: x
            });
            f.config.chart.events.xAxisLabelClick(E, this.ctx, A);
          }
        }), e) {
          let E = document.createElementNS(
            f.globals.SVGNS,
            "title"
          );
          E.textContent = Array.isArray(k.text) ? k.text.join(" ") : k.text, L.node.appendChild(E), k.text !== "" && (c.push(k.text), d.push(k));
        }
      }
      x < b - 1 && (g = g + o(x + 1, u));
    }
  }
  // this actually becomes the vertical axis (for bar charts)
  drawXaxisInversed(e) {
    let t = this.w, i = new K(this.ctx), s = t.config.yaxis[0].opposite ? t.globals.translateYAxisX[e] : 0, n = i.group({
      class: "apexcharts-yaxis apexcharts-xaxis-inversed",
      rel: e
    }), o = i.group({
      class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g",
      transform: "translate(" + s + ", 0)"
    });
    n.add(o);
    let l, c, d = [];
    if (t.config.yaxis[e].show)
      for (let r = 0; r < this.xaxisLabels.length; r++)
        d.push(this.xaxisLabels[r]);
    l = t.globals.gridHeight / d.length, c = -(l / 2.2);
    let f = t.globals.yLabelFormatters[0];
    const p = t.config.yaxis[0].labels;
    if (p.show)
      for (let r = 0; r <= d.length - 1; r++) {
        let h = typeof d[r] > "u" ? "" : d[r];
        h = f(h, {
          seriesIndex: e,
          dataPointIndex: r,
          w: t
        });
        const u = this.axesUtils.getYAxisForeColor(
          p.style.colors,
          e
        ), g = () => Array.isArray(u) ? u[r] : u;
        let b = 0;
        Array.isArray(h) && (b = h.length / 2 * parseInt(p.style.fontSize, 10));
        let O = p.offsetX - 15, x = "end";
        this.yaxis.opposite && (x = "start"), t.config.yaxis[0].labels.align === "left" ? (O = p.offsetX, x = "start") : t.config.yaxis[0].labels.align === "center" ? (O = p.offsetX, x = "middle") : t.config.yaxis[0].labels.align === "right" && (x = "end");
        let S = i.drawText({
          x: O,
          y: c + l + p.offsetY - b,
          text: h,
          textAnchor: x,
          foreColor: g(),
          fontSize: p.style.fontSize,
          fontFamily: p.style.fontFamily,
          fontWeight: p.style.fontWeight,
          isPlainText: !1,
          cssClass: "apexcharts-yaxis-label " + p.style.cssClass,
          maxWidth: p.maxWidth
        });
        o.add(S), S.on("click", (C) => {
          if (typeof t.config.chart.events.xAxisLabelClick == "function") {
            const _ = Object.assign({}, t, {
              labelIndex: r
            });
            t.config.chart.events.xAxisLabelClick(C, this.ctx, _);
          }
        });
        let k = document.createElementNS(t.globals.SVGNS, "title");
        if (k.textContent = Array.isArray(h) ? h.join(" ") : h, S.node.appendChild(k), t.config.yaxis[e].labels.rotate !== 0) {
          let C = i.rotateAroundCenter(S.node);
          S.node.setAttribute(
            "transform",
            `rotate(${t.config.yaxis[e].labels.rotate} 0 ${C.y})`
          );
        }
        c = c + l;
      }
    if (t.config.yaxis[0].title.text !== void 0) {
      let r = i.group({
        class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed",
        transform: "translate(" + s + ", 0)"
      }), h = i.drawText({
        x: t.config.yaxis[0].title.offsetX,
        y: t.globals.gridHeight / 2 + t.config.yaxis[0].title.offsetY,
        text: t.config.yaxis[0].title.text,
        textAnchor: "middle",
        foreColor: t.config.yaxis[0].title.style.color,
        fontSize: t.config.yaxis[0].title.style.fontSize,
        fontWeight: t.config.yaxis[0].title.style.fontWeight,
        fontFamily: t.config.yaxis[0].title.style.fontFamily,
        cssClass: "apexcharts-yaxis-title-text " + t.config.yaxis[0].title.style.cssClass
      });
      r.add(h), n.add(r);
    }
    let m = 0;
    this.isCategoryBarHorizontal && t.config.yaxis[0].opposite && (m = t.globals.gridWidth);
    const v = t.config.xaxis.axisBorder;
    if (v.show) {
      let r = i.drawLine(
        t.globals.padHorizontal + v.offsetX + m,
        1 + v.offsetY,
        t.globals.padHorizontal + v.offsetX + m,
        t.globals.gridHeight + v.offsetY,
        v.color,
        0
      );
      this.elgrid && this.elgrid.elGridBorders && t.config.grid.show ? this.elgrid.elGridBorders.add(r) : n.add(r);
    }
    return t.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(
      m,
      d.length,
      t.config.yaxis[0].axisBorder,
      t.config.yaxis[0].axisTicks,
      0,
      l,
      n
    ), n;
  }
  drawXaxisTicks(e, t, i) {
    let s = this.w, n = e;
    if (e < 0 || e - 2 > s.globals.gridWidth)
      return;
    let o = this.offY + s.config.xaxis.axisTicks.offsetY;
    if (t = t + o + s.config.xaxis.axisTicks.height, s.config.xaxis.position === "top" && (t = o - s.config.xaxis.axisTicks.height), s.config.xaxis.axisTicks.show) {
      let c = new K(this.ctx).drawLine(
        e + s.config.xaxis.axisTicks.offsetX,
        o + s.config.xaxis.offsetY,
        n + s.config.xaxis.axisTicks.offsetX,
        t + s.config.xaxis.offsetY,
        s.config.xaxis.axisTicks.color
      );
      i.add(c), c.node.classList.add("apexcharts-xaxis-tick");
    }
  }
  getXAxisTicksPositions() {
    const e = this.w;
    let t = [];
    const i = this.xaxisLabels.length;
    let s = e.globals.padHorizontal;
    if (e.globals.timescaleLabels.length > 0)
      for (let n = 0; n < i; n++)
        s = this.xaxisLabels[n].position, t.push(s);
    else {
      let n = i;
      for (let o = 0; o < n; o++) {
        let l = n;
        e.globals.isXNumeric && e.config.chart.type !== "bar" && (l -= 1), s = s + e.globals.gridWidth / l, t.push(s);
      }
    }
    return t;
  }
  // to rotate x-axis labels or to put ... for longer text in xaxis
  xAxisLabelCorrections() {
    let e = this.w, t = new K(this.ctx), i = e.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"), s = e.globals.dom.baseEl.querySelectorAll(
      ".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"
    ), n = e.globals.dom.baseEl.querySelectorAll(
      ".apexcharts-yaxis-inversed text"
    ), o = e.globals.dom.baseEl.querySelectorAll(
      ".apexcharts-xaxis-inversed-texts-g text tspan"
    );
    if (e.globals.rotateXLabels || e.config.xaxis.labels.rotateAlways)
      for (let l = 0; l < s.length; l++) {
        let c = t.rotateAroundCenter(s[l]);
        c.y = c.y - 1, c.x = c.x + 1, s[l].setAttribute(
          "transform",
          `rotate(${e.config.xaxis.labels.rotate} ${c.x} ${c.y})`
        ), s[l].setAttribute("text-anchor", "end");
        let d = 10;
        i.setAttribute("transform", `translate(0, ${-d})`);
        let f = s[l].childNodes;
        e.config.xaxis.labels.trim && Array.prototype.forEach.call(f, (p) => {
          t.placeTextWithEllipsis(
            p,
            p.textContent,
            e.globals.xAxisLabelsHeight - (e.config.legend.position === "bottom" ? 20 : 10)
          );
        });
      }
    else {
      let l = e.globals.gridWidth / (e.globals.labels.length + 1);
      for (let c = 0; c < s.length; c++) {
        let d = s[c].childNodes;
        e.config.xaxis.labels.trim && e.config.xaxis.type !== "datetime" && Array.prototype.forEach.call(d, (f) => {
          t.placeTextWithEllipsis(f, f.textContent, l);
        });
      }
    }
    if (n.length > 0) {
      let l = n[n.length - 1].getBBox(), c = n[0].getBBox();
      l.x < -20 && n[n.length - 1].parentNode.removeChild(
        n[n.length - 1]
      ), c.x + c.width > e.globals.gridWidth && !e.globals.isBarHorizontal && n[0].parentNode.removeChild(n[0]);
      for (let d = 0; d < o.length; d++)
        t.placeTextWithEllipsis(
          o[d],
          o[d].textContent,
          e.config.yaxis[0].labels.maxWidth - (e.config.yaxis[0].title.text ? parseFloat(e.config.yaxis[0].title.style.fontSize) * 2 : 0) - 15
        );
    }
  }
  // renderXAxisBands() {
  //   let w = this.w;
  //   let plotBand = document.createElementNS(w.globals.SVGNS, 'rect')
  //   w.globals.dom.elGraphical.add(plotBand)
  // }
}
class Ev {
  constructor(e) {
    this.ctx = e, this.w = e.w;
    const t = this.w;
    this.xaxisLabels = t.globals.labels.slice(), this.axesUtils = new Es(e), this.isRangeBar = t.globals.seriesRange.length && t.globals.isBarHorizontal, t.globals.timescaleLabels.length > 0 && (this.xaxisLabels = t.globals.timescaleLabels.slice());
  }
  // when using sparklines or when showing no grid, we need to have a grid area which is reused at many places for other calculations as well
  drawGridArea(e = null) {
    let t = this.w, i = new K(this.ctx);
    e === null && (e = i.group({
      class: "apexcharts-grid"
    }));
    let s = i.drawLine(
      t.globals.padHorizontal,
      1,
      t.globals.padHorizontal,
      t.globals.gridHeight,
      "transparent"
    ), n = i.drawLine(
      t.globals.padHorizontal,
      t.globals.gridHeight,
      t.globals.gridWidth,
      t.globals.gridHeight,
      "transparent"
    );
    return e.add(n), e.add(s), e;
  }
  drawGrid() {
    let e = this.w.globals, t = null;
    return e.axisCharts && (t = this.renderGrid(), this.drawGridArea(t.el)), t;
  }
  // This mask will clip off overflowing graphics from the drawable area
  createGridMask() {
    let e = this.w, t = e.globals;
    const i = new K(this.ctx);
    let s = Array.isArray(e.config.stroke.width) ? 0 : e.config.stroke.width;
    if (Array.isArray(e.config.stroke.width)) {
      let p = 0;
      e.config.stroke.width.forEach((m) => {
        p = Math.max(p, m);
      }), s = p;
    }
    t.dom.elGridRectMask = document.createElementNS(t.SVGNS, "clipPath"), t.dom.elGridRectMask.setAttribute("id", `gridRectMask${t.cuid}`), t.dom.elGridRectMarkerMask = document.createElementNS(t.SVGNS, "clipPath"), t.dom.elGridRectMarkerMask.setAttribute(
      "id",
      `gridRectMarkerMask${t.cuid}`
    ), t.dom.elForecastMask = document.createElementNS(t.SVGNS, "clipPath"), t.dom.elForecastMask.setAttribute("id", `forecastMask${t.cuid}`), t.dom.elNonForecastMask = document.createElementNS(t.SVGNS, "clipPath"), t.dom.elNonForecastMask.setAttribute("id", `nonForecastMask${t.cuid}`);
    const n = e.config.chart.type, o = n === "bar" || n === "rangeBar" || n === "candlestick" || n === "boxPlot" || e.globals.comboBarCount > 0;
    let l = 0, c = 0;
    o && e.globals.isXNumeric && !e.globals.isBarHorizontal && (l = e.config.grid.padding.left, c = e.config.grid.padding.right, t.barPadForNumericAxis > l && (l = t.barPadForNumericAxis, c = t.barPadForNumericAxis)), t.dom.elGridRect = i.drawRect(
      -s / 2 - l - 2,
      -s / 2 - 2,
      t.gridWidth + s + c + l + 4,
      t.gridHeight + s + 4,
      0,
      "#fff"
    );
    let d = e.globals.markers.largestSize + 1;
    t.dom.elGridRectMarker = i.drawRect(
      -d * 2,
      -d * 2,
      t.gridWidth + d * 4,
      t.gridHeight + d * 4,
      0,
      "#fff"
    ), t.dom.elGridRectMask.appendChild(t.dom.elGridRect.node), t.dom.elGridRectMarkerMask.appendChild(t.dom.elGridRectMarker.node);
    let f = t.dom.baseEl.querySelector("defs");
    f.appendChild(t.dom.elGridRectMask), f.appendChild(t.dom.elForecastMask), f.appendChild(t.dom.elNonForecastMask), f.appendChild(t.dom.elGridRectMarkerMask);
  }
  _drawGridLines({ i: e, x1: t, y1: i, x2: s, y2: n, xCount: o, parent: l }) {
    const c = this.w;
    if ((() => !(e === 0 && c.globals.skipFirstTimelinelabel || e === o - 1 && c.globals.skipLastTimelinelabel && !c.config.xaxis.labels.formatter || c.config.chart.type === "radar"))()) {
      c.config.grid.xaxis.lines.show && this._drawGridLine({ i: e, x1: t, y1: i, x2: s, y2: n, xCount: o, parent: l });
      let f = 0;
      if (c.globals.hasXaxisGroups && c.config.xaxis.tickPlacement === "between") {
        const m = c.globals.groups;
        if (m) {
          let v = 0;
          for (let r = 0; v < e && r < m.length; r++)
            v += m[r].cols;
          v === e && (f = c.globals.xAxisLabelsHeight * 0.6);
        }
      }
      new Zr(this.ctx).drawXaxisTicks(t, f, c.globals.dom.elGraphical);
    }
  }
  _drawGridLine({ i: e, x1: t, y1: i, x2: s, y2: n, xCount: o, parent: l }) {
    const c = this.w;
    let d = !1;
    const f = l.node.classList.contains(
      "apexcharts-gridlines-horizontal"
    );
    let p = c.config.grid.strokeDashArray;
    const m = c.globals.barPadForNumericAxis;
    (i === 0 && n === 0 || t === 0 && s === 0) && (d = !0), i === c.globals.gridHeight && n === c.globals.gridHeight && (d = !0), c.globals.isBarHorizontal && (e === 0 || e === o - 1) && (d = !0);
    let r = new K(this).drawLine(
      t - (f ? m : 0),
      i,
      s + (f ? m : 0),
      n,
      c.config.grid.borderColor,
      p
    );
    r.node.classList.add("apexcharts-gridline"), d && c.config.grid.show ? this.elGridBorders.add(r) : l.add(r);
  }
  _drawGridBandRect({ c: e, x1: t, y1: i, x2: s, y2: n, type: o }) {
    const l = this.w, c = new K(this.ctx), d = l.globals.barPadForNumericAxis;
    if (o === "column" && l.config.xaxis.type === "datetime")
      return;
    const f = l.config.grid[o].colors[e];
    let p = c.drawRect(
      t - (o === "row" ? d : 0),
      i,
      s + (o === "row" ? d * 2 : 0),
      n,
      0,
      f,
      l.config.grid[o].opacity
    );
    this.elg.add(p), p.attr("clip-path", `url(#gridRectMask${l.globals.cuid})`), p.node.classList.add(`apexcharts-grid-${o}`);
  }
  _drawXYLines({ xCount: e, tickAmount: t }) {
    const i = this.w, s = ({ xC: o, x1: l, y1: c, x2: d, y2: f }) => {
      for (let p = 0; p < o; p++)
        l = this.xaxisLabels[p].position, d = this.xaxisLabels[p].position, this._drawGridLines({
          i: p,
          x1: l,
          y1: c,
          x2: d,
          y2: f,
          xCount: e,
          parent: this.elgridLinesV
        });
    }, n = ({ xC: o, x1: l, y1: c, x2: d, y2: f }) => {
      for (let p = 0; p < o + (i.globals.isXNumeric ? 0 : 1); p++)
        p === 0 && o === 1 && i.globals.dataPoints === 1 && (l = i.globals.gridWidth / 2, d = l), this._drawGridLines({
          i: p,
          x1: l,
          y1: c,
          x2: d,
          y2: f,
          xCount: e,
          parent: this.elgridLinesV
        }), l = l + i.globals.gridWidth / (i.globals.isXNumeric ? o - 1 : o), d = l;
    };
    if (i.config.grid.xaxis.lines.show || i.config.xaxis.axisTicks.show) {
      let o = i.globals.padHorizontal, l = 0, c, d = i.globals.gridHeight;
      i.globals.timescaleLabels.length ? s({ xC: e, x1: o, y1: l, x2: c, y2: d }) : (i.globals.isXNumeric && (e = i.globals.xAxisScale.result.length), n({ xC: e, x1: o, y1: l, x2: c, y2: d }));
    }
    if (i.config.grid.yaxis.lines.show) {
      let o = 0, l = 0, c = 0, d = i.globals.gridWidth, f = t + 1;
      this.isRangeBar && (f = i.globals.labels.length);
      for (let p = 0; p < f + (this.isRangeBar ? 1 : 0); p++)
        this._drawGridLine({
          i: p,
          xCount: f + (this.isRangeBar ? 1 : 0),
          x1: o,
          y1: l,
          x2: d,
          y2: c,
          parent: this.elgridLinesH
        }), l = l + i.globals.gridHeight / (this.isRangeBar ? f : t), c = l;
    }
  }
  _drawInvertedXYLines({ xCount: e }) {
    const t = this.w;
    if (t.config.grid.xaxis.lines.show || t.config.xaxis.axisTicks.show) {
      let i = t.globals.padHorizontal, s = 0, n, o = t.globals.gridHeight;
      for (let l = 0; l < e + 1; l++)
        t.config.grid.xaxis.lines.show && this._drawGridLine({
          i: l,
          xCount: e + 1,
          x1: i,
          y1: s,
          x2: n,
          y2: o,
          parent: this.elgridLinesV
        }), new Zr(this.ctx).drawXaxisTicks(i, 0, t.globals.dom.elGraphical), i = i + t.globals.gridWidth / e, n = i;
    }
    if (t.config.grid.yaxis.lines.show) {
      let i = 0, s = 0, n = 0, o = t.globals.gridWidth;
      for (let l = 0; l < t.globals.dataPoints + 1; l++)
        this._drawGridLine({
          i: l,
          xCount: t.globals.dataPoints + 1,
          x1: i,
          y1: s,
          x2: o,
          y2: n,
          parent: this.elgridLinesH
        }), s = s + t.globals.gridHeight / t.globals.dataPoints, n = s;
    }
  }
  // actual grid rendering
  renderGrid() {
    var o, l, c;
    let e = this.w, t = new K(this.ctx);
    this.elg = t.group({
      class: "apexcharts-grid"
    }), this.elgridLinesH = t.group({
      class: "apexcharts-gridlines-horizontal"
    }), this.elgridLinesV = t.group({
      class: "apexcharts-gridlines-vertical"
    }), this.elGridBorders = t.group({
      class: "apexcharts-grid-borders"
    }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), e.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide(), this.elGridBorders.hide());
    let i = 0;
    for (; i < e.globals.seriesYAxisMap.length && e.globals.ignoreYAxisIndexes.indexOf(i) !== -1; )
      i++;
    i === e.globals.seriesYAxisMap.length && (i = 0);
    let s = e.globals.yAxisScale[i].result.length - 1, n;
    return !e.globals.isBarHorizontal || this.isRangeBar ? (n = this.xaxisLabels.length, this.isRangeBar && (n--, s = e.globals.labels.length, e.config.xaxis.tickAmount && e.config.xaxis.labels.formatter && (n = e.config.xaxis.tickAmount), ((c = (l = (o = e.globals.yAxisScale) == null ? void 0 : o[i]) == null ? void 0 : l.result) == null ? void 0 : c.length) > 0 && e.config.xaxis.type !== "datetime" && (n = e.globals.yAxisScale[i].result.length - 1)), this._drawXYLines({
      xCount: n,
      tickAmount: s
    })) : (n = s, s = e.globals.xTickAmount, this._drawInvertedXYLines({ xCount: n, tickAmount: s })), this.drawGridBands(n, s), {
      el: this.elg,
      elGridBorders: this.elGridBorders,
      xAxisTickWidth: e.globals.gridWidth / n
    };
  }
  drawGridBands(e, t) {
    const i = this.w;
    if (i.config.grid.row.colors !== void 0 && i.config.grid.row.colors.length > 0) {
      let s = 0, n = 0, o = i.globals.gridHeight / t, l = i.globals.gridWidth;
      for (let c = 0, d = 0; c < t; c++, d++)
        d >= i.config.grid.row.colors.length && (d = 0), this._drawGridBandRect({
          c: d,
          x1: s,
          y1: n,
          x2: l,
          y2: o,
          type: "row"
        }), n = n + i.globals.gridHeight / t;
    }
    if (i.config.grid.column.colors !== void 0 && i.config.grid.column.colors.length > 0) {
      const s = !i.globals.isBarHorizontal && i.config.xaxis.tickPlacement === "on" && (i.config.xaxis.type === "category" || i.config.xaxis.convertedCatToNumeric) ? e - 1 : e;
      let n = i.globals.padHorizontal, o = 0, l = i.globals.padHorizontal + i.globals.gridWidth / s, c = i.globals.gridHeight;
      for (let d = 0, f = 0; d < e; d++, f++)
        f >= i.config.grid.column.colors.length && (f = 0), this._drawGridBandRect({
          c: f,
          x1: n,
          y1: o,
          x2: l,
          y2: c,
          type: "column"
        }), n = n + i.globals.gridWidth / s;
    }
  }
}
class Pv {
  constructor(e) {
    this.ctx = e, this.w = e.w;
  }
  // http://stackoverflow.com/questions/326679/choosing-an-attractive-linear-scale-for-a-graphs-y-axis
  // This routine creates the Y axis values for a graph.
  niceScale(e, t, i = 0) {
    const n = this.w, o = n.globals;
    let l, c, d, f;
    o.isBarHorizontal ? (l = n.config.xaxis, c = Math.max((o.svgWidth - 100) / 25, 2)) : (l = n.config.yaxis[i], c = Math.max((o.svgHeight - 100) / 15, 2)), d = l.min !== void 0 && l.min !== null, f = l.max !== void 0 && l.min !== null;
    let p = l.stepSize !== void 0 && l.stepSize !== null, m = l.tickAmount !== void 0 && l.tickAmount !== null, v = m ? l.tickAmount : l.forceNiceScale ? o.niceScaleDefaultTicks[Math.min(
      Math.round(c / 2),
      o.niceScaleDefaultTicks.length - 1
    )] : 10;
    if (o.isMultipleYAxis && !m && o.multiAxisTickAmount > 0 && (v = o.multiAxisTickAmount, m = !0), v === "dataPoints" ? v = o.dataPoints - 1 : v = Math.abs(Math.round(v)), (e === Number.MIN_VALUE && t === 0 || !N.isNumber(e) && !N.isNumber(t) || e === Number.MIN_VALUE && t === -Number.MAX_VALUE) && (e = 0, t = v, o.allSeriesCollapsed = !1), e > t) {
      console.warn(
        "axis.min cannot be greater than axis.max: swapping min and max"
      );
      let E = t;
      t = e, e = E;
    } else
      e === t && (e = e === 0 ? 0 : e - 1, t = t === 0 ? 2 : t + 1);
    let r = [];
    v < 1 && (v = 1);
    let h = v, u = Math.abs(t - e);
    if (l.forceNiceScale) {
      let E = 0.15;
      !d && e > 0 && e / u < E && (e = 0, d = !0), !f && t < 0 && -t / u < E && (t = 0, f = !0), u = Math.abs(t - e);
    }
    let g = u / h, b = g, O = Math.floor(Math.log10(b)), x = Math.pow(10, O), S = Math.ceil(b / x);
    if (S = o.niceScaleAllowedMagMsd[o.yValueDecimal === 0 ? 0 : 1][S], b = S * x, g = b, o.isBarHorizontal && l.stepSize && l.type !== "datetime" ? (g = l.stepSize, p = !0) : p && (g = l.stepSize), p && l.forceNiceScale) {
      let E = Math.floor(Math.log10(g));
      g *= Math.pow(10, O - E);
    }
    if (d && f) {
      let E = u / h;
      if (m)
        if (p)
          if (N.mod(u, g) != 0) {
            let A = N.getGCD(g, E);
            E / A < 10 ? g = A : g = E;
          } else
            N.mod(g, E) == 0 ? g = E : (E = g, m = !1);
        else
          g = E;
      else if (p)
        N.mod(u, g) == 0 ? E = g : g = E;
      else if (N.mod(u, g) == 0)
        E = g;
      else {
        h = Math.ceil(u / g), E = u / h;
        let A = N.getGCD(u, g);
        u / A < c && (E = A), g = E;
      }
      h = Math.round(u / g);
    } else {
      if (!d && !f)
        if (m) {
          let E = g / (t - e > t ? 1 : 2), A = E * Math.floor(e / E);
          Math.abs(A - e) <= E / 2 ? (e = A, t = e + g * h) : (t = E * Math.ceil(t / E), e = t - g * h);
        } else
          e = g * Math.floor(e / g), t = g * Math.ceil(t / g);
      else if (f)
        if (m)
          e = t - g * h;
        else {
          let E = e;
          e = g * Math.floor(e / g), Math.abs(t - e) / N.getGCD(u, g) > c && (e = t - g * v, e += g * Math.floor((E - e) / g));
        }
      else
        d && (m ? t = e + g * h : t = g * Math.ceil(t / g));
      u = Math.abs(t - e), g = N.getGCD(u, g), h = Math.round(u / g);
    }
    if (!m && !(d || f) && (h = Math.ceil((u - 1e-11) / (g + 1e-11)), h > 16 && N.getPrimeFactors(h).length < 2 && h++), !m && l.forceNiceScale && o.yValueDecimal === 0 && h > u && (h = u, g = Math.round(u / h)), o.isMultipleYAxis && o.multiAxisTickAmount == 0 && (o.multiAxisTickAmount = h), h > c && (!(m || p) || l.forceNiceScale)) {
      let E = N.getPrimeFactors(h), A = E.length - 1, y = h;
      e:
        for (var k = 0; k < A; k++)
          for (var C = 0; C <= A - k; C++) {
            let w = Math.min(C + k, A), T = y, P = 1;
            for (var _ = C; _ <= w; _++)
              P *= E[_];
            if (T /= P, T < c) {
              y = T;
              break e;
            }
          }
      y === h ? g = u : g = u / y;
    }
    let $ = e - g, L = g * 1e-11;
    do
      $ += g, r.push(N.stripNumber($, 7));
    while (t - $ > L);
    return {
      result: r,
      niceMin: r[0],
      niceMax: r[r.length - 1]
    };
  }
  linearScale(e, t, i = 10, s = 0, n = void 0) {
    let o = Math.abs(t - e);
    i = this._adjustTicksForSmallRange(i, s, o), i === "dataPoints" && (i = this.w.globals.dataPoints - 1), n || (n = o / i), i === Number.MAX_VALUE && (i = 5, n = 1);
    let l = [], c = e;
    for (; i >= 0; )
      l.push(c), c = c + n, i -= 1;
    return {
      result: l,
      niceMin: l[0],
      niceMax: l[l.length - 1]
    };
  }
  logarithmicScaleNice(e, t, i) {
    t <= 0 && (t = Math.max(e, i)), e <= 0 && (e = Math.min(t, i));
    const s = [], n = Math.ceil(Math.log(t) / Math.log(i) + 1), o = Math.floor(Math.log(e) / Math.log(i));
    for (let l = o; l < n; l++)
      s.push(Math.pow(i, l));
    return {
      result: s,
      niceMin: s[0],
      niceMax: s[s.length - 1]
    };
  }
  logarithmicScale(e, t, i) {
    t <= 0 && (t = Math.max(e, i)), e <= 0 && (e = Math.min(t, i));
    const s = [], n = Math.log(t) / Math.log(i), o = Math.log(e) / Math.log(i), l = n - o, c = Math.round(l), d = l / c;
    for (let f = 0, p = o; f < c; f++, p += d)
      s.push(Math.pow(i, p));
    return s.push(Math.pow(i, n)), {
      result: s,
      niceMin: e,
      niceMax: t
    };
  }
  _adjustTicksForSmallRange(e, t, i) {
    let s = e;
    if (typeof t < "u" && this.w.config.yaxis[t].labels.formatter && this.w.config.yaxis[t].tickAmount === void 0) {
      const n = Number(
        this.w.config.yaxis[t].labels.formatter(1)
      );
      N.isNumber(n) && this.w.globals.yValueDecimal === 0 && (s = Math.ceil(i));
    }
    return s < e ? s : e;
  }
  setYScaleForIndex(e, t, i) {
    const s = this.w.globals, n = this.w.config;
    let o = s.isBarHorizontal ? n.xaxis : n.yaxis[e];
    typeof s.yAxisScale[e] > "u" && (s.yAxisScale[e] = []);
    let l = Math.abs(i - t);
    o.logarithmic && l <= 5 && (s.invalidLogScale = !0), o.logarithmic && l > 5 ? (s.allSeriesCollapsed = !1, s.yAxisScale[e] = o.forceNiceScale ? this.logarithmicScaleNice(t, i, o.logBase) : this.logarithmicScale(t, i, o.logBase)) : i === -Number.MAX_VALUE || !N.isNumber(i) ? s.yAxisScale[e] = this.linearScale(
      0,
      10,
      10,
      e,
      n.yaxis[e].stepSize
    ) : (s.allSeriesCollapsed = !1, s.yAxisScale[e] = this.niceScale(t, i, e));
  }
  setXScale(e, t) {
    const i = this.w, s = i.globals;
    let n = Math.abs(t - e);
    return t === -Number.MAX_VALUE || !N.isNumber(t) ? s.xAxisScale = this.linearScale(0, 10, 10) : s.xAxisScale = this.linearScale(
      e,
      t,
      i.config.xaxis.tickAmount ? i.config.xaxis.tickAmount : n < 10 && n > 1 ? n + 1 : 10,
      0,
      i.config.xaxis.stepSize
    ), s.xAxisScale;
  }
  setMultipleYScales() {
    const e = this.w.globals, t = this.w.config, i = e.minYArr, s = e.maxYArr;
    let n = [], o = [], l = [], c = t.yaxis.length !== t.series.length;
    t.series.forEach((p, m) => {
      l.push(m), o.push(null);
    }), t.yaxis.forEach((p, m) => {
      n[m] = [];
    });
    let d = [];
    t.yaxis.forEach((p, m) => {
      let v = !1;
      if (p.seriesName) {
        let r = [];
        Array.isArray(p.seriesName) ? r = p.seriesName : r.push(p.seriesName), r.forEach((h) => {
          t.series.forEach((u, g) => {
            if (u.name === h) {
              m === g || c ? n[m].push(g) : n[g].push(m), v = !0;
              let b = l.indexOf(g);
              b !== -1 && l.splice(b, 1);
            }
          });
        });
      }
      v || d.push(m);
    }), n.forEach((p, m) => {
      p.forEach((v) => {
        o[v] = m;
      });
    });
    let f;
    for (let p = 0; p < d.length && (f = d[p], n[f] = [], l); p++) {
      let m = l[0];
      l.shift(), n[f].push(m), o[m] = f;
    }
    f && l.forEach((p) => {
      n[f].push(p), o[p] = f;
    }), e.seriesYAxisMap = n.map((p) => p), e.seriesYAxisReverseMap = o.map((p) => p), this.sameScaleInMultipleAxes(i, s, n);
  }
  sameScaleInMultipleAxes(e, t, i) {
    const s = this.w.config, n = this.w.globals;
    i.forEach((o, l) => {
      if (o.length > 0) {
        let c = Number.MAX_VALUE, d = -Number.MAX_VALUE;
        if (s.chart.stacked) {
          let f = n.seriesX[o[0]].map((r) => Number.MIN_VALUE), p = n.seriesX[o[0]].map((r) => Number.MIN_VALUE), m = n.seriesX[o[0]].map((r) => Number.MIN_VALUE), v = s.series[o[0]].type;
          for (let r = 0; r < o.length; r++) {
            let h = o[r];
            if (n.collapsedSeriesIndices.indexOf(h) === -1)
              for (let u = 0; u < n.series[h].length; u++) {
                let g = n.series[h][u];
                g >= 0 ? p[u] += g : m[u] += g, f[u] += g;
              }
          }
          v === "bar" ? (c = Math.min.apply(null, m), d = Math.max.apply(null, p)) : (c = Math.min.apply(null, f), d = Math.max.apply(null, f));
        } else {
          for (let f = 0; f < o.length; f++)
            c = Math.min(c, e[o[f]]);
          for (let f = 0; f < o.length; f++)
            d = Math.max(d, t[o[f]]);
        }
        s.yaxis[l].min !== void 0 && (typeof s.yaxis[l].min == "function" ? c = s.yaxis[l].min(c) : c = s.yaxis[l].min), s.yaxis[l].max !== void 0 && (typeof s.yaxis[l].max == "function" ? d = s.yaxis[l].max(d) : d = s.yaxis[l].max), this.setYScaleForIndex(l, c, d), o.forEach((f) => {
          e[f] = n.yAxisScale[l].niceMin, t[f] = n.yAxisScale[l].niceMax;
        });
      }
    });
  }
}
let gh = class {
  constructor(e) {
    this.ctx = e, this.w = e.w, this.scales = new Pv(e);
  }
  init() {
    this.setYRange(), this.setXRange(), this.setZRange();
  }
  getMinYMaxY(e, t = Number.MAX_VALUE, i = -Number.MAX_VALUE, s = null) {
    var h;
    const n = this.w.config, o = this.w.globals;
    let l = -Number.MAX_VALUE, c = Number.MIN_VALUE;
    s === null && (s = e + 1);
    let d = 0, f = 0, p;
    if (o.seriesX.length >= s) {
      p = [...new Set([].concat(...o.seriesX.slice(e, s)))], d = 0, f = p.length - 1;
      let u = (h = o.brushSource) == null ? void 0 : h.w.config.chart.brush;
      if (n.chart.zoom.enabled && n.chart.zoom.autoScaleYaxis || u != null && u.enabled && (u != null && u.autoScaleYaxis)) {
        if (n.xaxis.min)
          for (d = 0; d < f && p[d] < n.xaxis.min; d++)
            ;
        if (n.xaxis.max)
          for (; f > d && p[f] > n.xaxis.max; f--)
            ;
      }
    }
    let m = o.series, v = m, r = m;
    n.chart.type === "candlestick" ? (v = o.seriesCandleL, r = o.seriesCandleH) : n.chart.type === "boxPlot" ? (v = o.seriesCandleO, r = o.seriesCandleC) : o.isRangeData && (v = o.seriesRangeStart, r = o.seriesRangeEnd);
    for (let u = e; u < s; u++) {
      o.dataPoints = Math.max(o.dataPoints, m[u].length);
      const g = n.series[u].type;
      o.categoryLabels.length && (o.dataPoints = o.categoryLabels.filter(
        (b) => typeof b < "u"
      ).length), o.labels.length && n.xaxis.type !== "datetime" && o.series.reduce((b, O) => b + O.length, 0) !== 0 && (o.dataPoints = Math.max(o.dataPoints, o.labels.length)), p || (d = 0, f = o.series[u].length);
      for (let b = d; b <= f && b < o.series[u].length; b++) {
        let O = m[u][b];
        if (O !== null && N.isNumber(O)) {
          switch (typeof r[u][b] < "u" && (l = Math.max(l, r[u][b]), t = Math.min(t, r[u][b])), typeof v[u][b] < "u" && (t = Math.min(t, v[u][b]), i = Math.max(i, v[u][b])), g) {
            case "candlestick":
              typeof o.seriesCandleC[u][b] < "u" && (l = Math.max(l, o.seriesCandleH[u][b]), t = Math.min(t, o.seriesCandleL[u][b]));
            case "boxPlot":
              typeof o.seriesCandleC[u][b] < "u" && (l = Math.max(l, o.seriesCandleC[u][b]), t = Math.min(t, o.seriesCandleO[u][b]));
          }
          g && g !== "candlestick" && g !== "boxPlot" && g !== "rangeArea" && g !== "rangeBar" && (l = Math.max(l, o.series[u][b]), t = Math.min(t, o.series[u][b])), i = l, o.seriesGoals[u] && o.seriesGoals[u][b] && Array.isArray(o.seriesGoals[u][b]) && o.seriesGoals[u][b].forEach((x) => {
            c !== Number.MIN_VALUE && (c = Math.min(c, x.value), t = c), l = Math.max(l, x.value), i = l;
          }), N.isFloat(O) && (O = N.noExponents(O), o.yValueDecimal = Math.max(
            o.yValueDecimal,
            O.toString().split(".")[1].length
          )), c > v[u][b] && v[u][b] < 0 && (c = v[u][b]);
        } else
          o.hasNullValues = !0;
      }
      (g === "bar" || g === "column") && (c < 0 && l < 0 && (l = 0, i = Math.max(i, 0)), c === Number.MIN_VALUE && (c = 0, t = Math.min(t, 0)));
    }
    return n.chart.type === "rangeBar" && o.seriesRangeStart.length && o.isBarHorizontal && (c = t), n.chart.type === "bar" && (c < 0 && l < 0 && (l = 0), c === Number.MIN_VALUE && (c = 0)), {
      minY: c,
      maxY: l,
      lowestY: t,
      highestY: i
    };
  }
  setYRange() {
    let e = this.w.globals, t = this.w.config;
    e.maxY = -Number.MAX_VALUE, e.minY = Number.MIN_VALUE;
    let i = Number.MAX_VALUE, s;
    if (e.isMultipleYAxis) {
      i = Number.MAX_VALUE;
      for (let n = 0; n < e.series.length; n++)
        s = this.getMinYMaxY(n), e.minYArr[n] = s.lowestY, e.maxYArr[n] = s.highestY, i = Math.min(i, s.lowestY);
    }
    return s = this.getMinYMaxY(
      0,
      i,
      null,
      e.series.length
    ), t.chart.type === "bar" ? (e.minY = s.minY, e.maxY = s.maxY) : (e.minY = s.lowestY, e.maxY = s.highestY), i = s.lowestY, t.chart.stacked && this._setStackedMinMax(), t.chart.type === "line" || t.chart.type === "area" || t.chart.type === "scatter" || t.chart.type === "candlestick" || t.chart.type === "boxPlot" || t.chart.type === "rangeBar" && !e.isBarHorizontal ? e.minY === Number.MIN_VALUE && i !== -Number.MAX_VALUE && i !== e.maxY && (e.minY = i) : e.minY = s.minY, t.yaxis.forEach((n, o) => {
      n.max !== void 0 && (typeof n.max == "number" ? e.maxYArr[o] = n.max : typeof n.max == "function" && (e.maxYArr[o] = n.max(
        e.isMultipleYAxis ? e.maxYArr[o] : e.maxY
      )), e.maxY = e.maxYArr[o]), n.min !== void 0 && (typeof n.min == "number" ? e.minYArr[o] = n.min : typeof n.min == "function" && (e.minYArr[o] = n.min(
        e.isMultipleYAxis ? e.minYArr[o] === Number.MIN_VALUE ? 0 : e.minYArr[o] : e.minY
      )), e.minY = e.minYArr[o]);
    }), e.isBarHorizontal && ["min", "max"].forEach((o) => {
      t.xaxis[o] !== void 0 && typeof t.xaxis[o] == "number" && (o === "min" ? e.minY = t.xaxis[o] : e.maxY = t.xaxis[o]);
    }), e.isMultipleYAxis ? (this.scales.setMultipleYScales(), e.minY = i) : (this.scales.setYScaleForIndex(0, e.minY, e.maxY), e.minY = e.yAxisScale[0].niceMin, e.maxY = e.yAxisScale[0].niceMax, e.minYArr[0] = e.yAxisScale[0].niceMin, e.maxYArr[0] = e.yAxisScale[0].niceMax, e.seriesYAxisMap = [e.series.map((n, o) => o)], e.seriesYAxisReverseMap = e.series.map((n, o) => 0)), {
      minY: e.minY,
      maxY: e.maxY,
      minYArr: e.minYArr,
      maxYArr: e.maxYArr,
      yAxisScale: e.yAxisScale
    };
  }
  setXRange() {
    let e = this.w.globals, t = this.w.config;
    const i = t.xaxis.type === "numeric" || t.xaxis.type === "datetime" || t.xaxis.type === "category" && !e.noLabelsProvided || e.noLabelsProvided || e.isXNumeric, s = () => {
      for (let n = 0; n < e.series.length; n++)
        if (e.labels[n])
          for (let o = 0; o < e.labels[n].length; o++)
            e.labels[n][o] !== null && N.isNumber(e.labels[n][o]) && (e.maxX = Math.max(e.maxX, e.labels[n][o]), e.initialMaxX = Math.max(e.maxX, e.labels[n][o]), e.minX = Math.min(e.minX, e.labels[n][o]), e.initialMinX = Math.min(e.minX, e.labels[n][o]));
    };
    if (e.isXNumeric && s(), e.noLabelsProvided && t.xaxis.categories.length === 0 && (e.maxX = e.labels[e.labels.length - 1], e.initialMaxX = e.labels[e.labels.length - 1], e.minX = 1, e.initialMinX = 1), e.isXNumeric || e.noLabelsProvided || e.dataFormatXNumeric) {
      let n;
      if (t.xaxis.tickAmount === void 0 ? (n = Math.round(e.svgWidth / 150), t.xaxis.type === "numeric" && e.dataPoints < 30 && (n = e.dataPoints - 1), n > e.dataPoints && e.dataPoints !== 0 && (n = e.dataPoints - 1)) : t.xaxis.tickAmount === "dataPoints" ? (e.series.length > 1 && (n = e.series[e.maxValsInArrayIndex].length - 1), e.isXNumeric && (n = e.maxX - e.minX - 1)) : n = t.xaxis.tickAmount, e.xTickAmount = n, t.xaxis.max !== void 0 && typeof t.xaxis.max == "number" && (e.maxX = t.xaxis.max), t.xaxis.min !== void 0 && typeof t.xaxis.min == "number" && (e.minX = t.xaxis.min), t.xaxis.range !== void 0 && (e.minX = e.maxX - t.xaxis.range), e.minX !== Number.MAX_VALUE && e.maxX !== -Number.MAX_VALUE)
        if (t.xaxis.convertedCatToNumeric && !e.dataFormatXNumeric) {
          let o = [];
          for (let l = e.minX - 1; l < e.maxX; l++)
            o.push(l + 1);
          e.xAxisScale = {
            result: o,
            niceMin: o[0],
            niceMax: o[o.length - 1]
          };
        } else
          e.xAxisScale = this.scales.setXScale(e.minX, e.maxX);
      else
        e.xAxisScale = this.scales.linearScale(
          0,
          n,
          n,
          0,
          t.xaxis.stepSize
        ), e.noLabelsProvided && e.labels.length > 0 && (e.xAxisScale = this.scales.linearScale(
          1,
          e.labels.length,
          n - 1,
          0,
          t.xaxis.stepSize
        ), e.seriesX = e.labels.slice());
      i && (e.labels = e.xAxisScale.result.slice());
    }
    return e.isBarHorizontal && e.labels.length && (e.xTickAmount = e.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), {
      minX: e.minX,
      maxX: e.maxX
    };
  }
  setZRange() {
    let e = this.w.globals;
    if (e.isDataXYZ) {
      for (let t = 0; t < e.series.length; t++)
        if (typeof e.seriesZ[t] < "u")
          for (let i = 0; i < e.seriesZ[t].length; i++)
            e.seriesZ[t][i] !== null && N.isNumber(e.seriesZ[t][i]) && (e.maxZ = Math.max(e.maxZ, e.seriesZ[t][i]), e.minZ = Math.min(e.minZ, e.seriesZ[t][i]));
    }
  }
  _handleSingleDataPoint() {
    const e = this.w.globals, t = this.w.config;
    if (e.minX === e.maxX) {
      let i = new Tt(this.ctx);
      if (t.xaxis.type === "datetime") {
        const s = i.getDate(e.minX);
        t.xaxis.labels.datetimeUTC ? s.setUTCDate(s.getUTCDate() - 2) : s.setDate(s.getDate() - 2), e.minX = new Date(s).getTime();
        const n = i.getDate(e.maxX);
        t.xaxis.labels.datetimeUTC ? n.setUTCDate(n.getUTCDate() + 2) : n.setDate(n.getDate() + 2), e.maxX = new Date(n).getTime();
      } else
        (t.xaxis.type === "numeric" || t.xaxis.type === "category" && !e.noLabelsProvided) && (e.minX = e.minX - 2, e.initialMinX = e.minX, e.maxX = e.maxX + 2, e.initialMaxX = e.maxX);
    }
  }
  _getMinXDiff() {
    const e = this.w.globals;
    e.isXNumeric && e.seriesX.forEach((t, i) => {
      t.length === 1 && t.push(
        e.seriesX[e.maxValsInArrayIndex][e.seriesX[e.maxValsInArrayIndex].length - 1]
      );
      const s = t.slice();
      s.sort((n, o) => n - o), s.forEach((n, o) => {
        if (o > 0) {
          let l = n - s[o - 1];
          l > 0 && (e.minXDiff = Math.min(l, e.minXDiff));
        }
      }), (e.dataPoints === 1 || e.minXDiff === Number.MAX_VALUE) && (e.minXDiff = 0.5);
    });
  }
  _setStackedMinMax() {
    const e = this.w.globals;
    if (!e.series.length)
      return;
    let t = e.seriesGroups;
    t.length || (t = [this.w.config.series.map((n) => n.name)]);
    let i = {}, s = {};
    t.forEach((n) => {
      i[n] = [], s[n] = [], this.w.config.series.map((l, c) => n.indexOf(l.name) > -1 ? c : null).filter((l) => l !== null).forEach((l) => {
        var c, d;
        for (let f = 0; f < e.series[e.maxValsInArrayIndex].length; f++)
          typeof i[n][f] > "u" && (i[n][f] = 0, s[n][f] = 0), (this.w.config.chart.stacked && !e.comboCharts || this.w.config.chart.stacked && e.comboCharts && (!this.w.config.chart.stackOnlyBar || ((d = (c = this.w.config.series) == null ? void 0 : c[l]) == null ? void 0 : d.type) === "bar")) && e.series[l][f] !== null && N.isNumber(e.series[l][f]) && (e.series[l][f] > 0 ? i[n][f] += parseFloat(e.series[l][f]) + 1e-4 : s[n][f] += parseFloat(e.series[l][f]));
      });
    }), Object.entries(i).forEach(([n]) => {
      i[n].forEach((o, l) => {
        e.maxY = Math.max(e.maxY, i[n][l]), e.minY = Math.min(e.minY, s[n][l]);
      });
    });
  }
};
class Bd {
  constructor(e, t) {
    this.ctx = e, this.elgrid = t, this.w = e.w;
    const i = this.w;
    this.xaxisFontSize = i.config.xaxis.labels.style.fontSize, this.axisFontFamily = i.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = i.config.chart.type === "bar" && i.config.plotOptions.bar.horizontal, this.xAxisoffX = 0, i.config.xaxis.position === "bottom" && (this.xAxisoffX = i.globals.gridHeight), this.drawnLabels = [], this.axesUtils = new Es(e);
  }
  drawYaxis(e) {
    let t = this.w, i = new K(this.ctx);
    const s = t.config.yaxis[e].labels.style;
    let n = s.fontSize, o = s.fontFamily, l = s.fontWeight, c = i.group({
      class: "apexcharts-yaxis",
      rel: e,
      transform: "translate(" + t.globals.translateYAxisX[e] + ", 0)"
    });
    if (this.axesUtils.isYAxisHidden(e))
      return c;
    let d = i.group({
      class: "apexcharts-yaxis-texts-g"
    });
    c.add(d);
    let f = t.globals.yAxisScale[e].result.length - 1, p = t.globals.gridHeight / f, m = t.globals.translateY, v = t.globals.yLabelFormatters[e], r = t.globals.yAxisScale[e].result.slice();
    r = this.axesUtils.checkForReversedLabels(e, r);
    let h = "";
    if (t.config.yaxis[e].labels.show)
      for (let b = f; b >= 0; b--) {
        let O = r[b];
        O = v(O, b, t);
        let x = t.config.yaxis[e].labels.padding;
        t.config.yaxis[e].opposite && t.config.yaxis.length !== 0 && (x = x * -1);
        let S = "end";
        t.config.yaxis[e].opposite && (S = "start"), t.config.yaxis[e].labels.align === "left" ? S = "start" : t.config.yaxis[e].labels.align === "center" ? S = "middle" : t.config.yaxis[e].labels.align === "right" && (S = "end");
        const k = this.axesUtils.getYAxisForeColor(
          s.colors,
          e
        ), C = () => Array.isArray(k) ? k[b] : k;
        let _ = t.config.yaxis[e].labels.offsetY;
        if (t.config.chart.type === "heatmap") {
          const E = t.globals.gridHeight / t.globals.series.length - 1;
          _ = _ - E / 2;
        }
        let $ = i.drawText({
          x,
          y: m + f / 10 + _ + 1,
          text: O,
          textAnchor: S,
          fontSize: n,
          fontFamily: o,
          fontWeight: l,
          maxWidth: t.config.yaxis[e].labels.maxWidth,
          foreColor: C(),
          isPlainText: !1,
          cssClass: "apexcharts-yaxis-label " + s.cssClass
        });
        b === f && (h = $), d.add($);
        let L = document.createElementNS(t.globals.SVGNS, "title");
        if (L.textContent = Array.isArray(O) ? O.join(" ") : O, $.node.appendChild(L), t.config.yaxis[e].labels.rotate !== 0) {
          let E = i.rotateAroundCenter(
            h.node
          ), A = i.rotateAroundCenter($.node);
          $.node.setAttribute(
            "transform",
            `rotate(${t.config.yaxis[e].labels.rotate} ${E.x} ${A.y})`
          );
        }
        m = m + p;
      }
    if (t.config.yaxis[e].title.text !== void 0) {
      let b = i.group({
        class: "apexcharts-yaxis-title"
      }), O = 0;
      t.config.yaxis[e].opposite && (O = t.globals.translateYAxisX[e]);
      let x = i.drawText({
        x: O,
        y: t.globals.gridHeight / 2 + t.globals.translateY + t.config.yaxis[e].title.offsetY,
        text: t.config.yaxis[e].title.text,
        textAnchor: "end",
        foreColor: t.config.yaxis[e].title.style.color,
        fontSize: t.config.yaxis[e].title.style.fontSize,
        fontWeight: t.config.yaxis[e].title.style.fontWeight,
        fontFamily: t.config.yaxis[e].title.style.fontFamily,
        cssClass: "apexcharts-yaxis-title-text " + t.config.yaxis[e].title.style.cssClass
      });
      b.add(x), c.add(b);
    }
    let u = t.config.yaxis[e].axisBorder, g = 31 + u.offsetX;
    if (t.config.yaxis[e].opposite && (g = -31 - u.offsetX), u.show) {
      let b = i.drawLine(
        g,
        t.globals.translateY + u.offsetY - 2,
        g,
        t.globals.gridHeight + t.globals.translateY + u.offsetY + 2,
        u.color,
        0,
        u.width
      );
      c.add(b);
    }
    return t.config.yaxis[e].axisTicks.show && this.axesUtils.drawYAxisTicks(
      g,
      f,
      u,
      t.config.yaxis[e].axisTicks,
      e,
      p,
      c
    ), c;
  }
  // This actually becomes horizontal axis (for bar charts)
  drawYaxisInversed(e) {
    let t = this.w, i = new K(this.ctx), s = i.group({
      class: "apexcharts-xaxis apexcharts-yaxis-inversed"
    }), n = i.group({
      class: "apexcharts-xaxis-texts-g",
      transform: `translate(${t.globals.translateXAxisX}, ${t.globals.translateXAxisY})`
    });
    s.add(n);
    let o = t.globals.yAxisScale[e].result.length - 1, l = t.globals.gridWidth / o + 0.1, c = l + t.config.xaxis.labels.offsetX, d = t.globals.xLabelFormatter, f = t.globals.yAxisScale[e].result.slice(), p = t.globals.timescaleLabels;
    p.length > 0 && (this.xaxisLabels = p.slice(), f = p.slice(), o = f.length), f = this.axesUtils.checkForReversedLabels(e, f);
    const m = p.length;
    if (t.config.xaxis.labels.show)
      for (let v = m ? 0 : o; m ? v < m : v >= 0; m ? v++ : v--) {
        let r = f[v];
        r = d(r, v, t);
        let h = t.globals.gridWidth + t.globals.padHorizontal - (c - l + t.config.xaxis.labels.offsetX);
        if (p.length) {
          let b = this.axesUtils.getLabel(
            f,
            p,
            h,
            v,
            this.drawnLabels,
            this.xaxisFontSize
          );
          h = b.x, r = b.text, this.drawnLabels.push(b.text), v === 0 && t.globals.skipFirstTimelinelabel && (r = ""), v === f.length - 1 && t.globals.skipLastTimelinelabel && (r = "");
        }
        let u = i.drawText({
          x: h,
          y: this.xAxisoffX + t.config.xaxis.labels.offsetY + 30 - (t.config.xaxis.position === "top" ? t.globals.xAxisHeight + t.config.xaxis.axisTicks.height - 2 : 0),
          text: r,
          textAnchor: "middle",
          foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[e] : this.xaxisForeColors,
          fontSize: this.xaxisFontSize,
          fontFamily: this.xaxisFontFamily,
          fontWeight: t.config.xaxis.labels.style.fontWeight,
          isPlainText: !1,
          cssClass: "apexcharts-xaxis-label " + t.config.xaxis.labels.style.cssClass
        });
        n.add(u), u.tspan(r);
        let g = document.createElementNS(t.globals.SVGNS, "title");
        g.textContent = r, u.node.appendChild(g), c = c + l;
      }
    return this.inversedYAxisTitleText(s), this.inversedYAxisBorder(s), s;
  }
  inversedYAxisBorder(e) {
    const t = this.w, i = new K(this.ctx);
    let s = t.config.xaxis.axisBorder;
    if (s.show) {
      let n = 0;
      t.config.chart.type === "bar" && t.globals.isXNumeric && (n = n - 15);
      let o = i.drawLine(
        t.globals.padHorizontal + n + s.offsetX,
        this.xAxisoffX,
        t.globals.gridWidth,
        this.xAxisoffX,
        s.color,
        0,
        s.height
      );
      this.elgrid && this.elgrid.elGridBorders && t.config.grid.show ? this.elgrid.elGridBorders.add(o) : e.add(o);
    }
  }
  inversedYAxisTitleText(e) {
    const t = this.w, i = new K(this.ctx);
    if (t.config.xaxis.title.text !== void 0) {
      let s = i.group({
        class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed"
      }), n = i.drawText({
        x: t.globals.gridWidth / 2 + t.config.xaxis.title.offsetX,
        y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(t.config.xaxis.title.style.fontSize) + t.config.xaxis.title.offsetY + 20,
        text: t.config.xaxis.title.text,
        textAnchor: "middle",
        fontSize: t.config.xaxis.title.style.fontSize,
        fontFamily: t.config.xaxis.title.style.fontFamily,
        fontWeight: t.config.xaxis.title.style.fontWeight,
        foreColor: t.config.xaxis.title.style.color,
        cssClass: "apexcharts-xaxis-title-text " + t.config.xaxis.title.style.cssClass
      });
      s.add(n), e.add(s);
    }
  }
  yAxisTitleRotate(e, t) {
    let i = this.w, s = new K(this.ctx), n = {
      width: 0,
      height: 0
    }, o = {
      width: 0,
      height: 0
    }, l = i.globals.dom.baseEl.querySelector(
      ` .apexcharts-yaxis[rel='${e}'] .apexcharts-yaxis-texts-g`
    );
    l !== null && (n = l.getBoundingClientRect());
    let c = i.globals.dom.baseEl.querySelector(
      `.apexcharts-yaxis[rel='${e}'] .apexcharts-yaxis-title text`
    );
    if (c !== null && (o = c.getBoundingClientRect()), c !== null) {
      let d = this.xPaddingForYAxisTitle(
        e,
        n,
        o,
        t
      );
      c.setAttribute("x", d.xPos - (t ? 10 : 0));
    }
    if (c !== null) {
      let d = s.rotateAroundCenter(c);
      c.setAttribute(
        "transform",
        `rotate(${t ? i.config.yaxis[e].title.rotate * -1 : i.config.yaxis[e].title.rotate} ${d.x} ${d.y})`
      );
    }
  }
  xPaddingForYAxisTitle(e, t, i, s) {
    let n = this.w, o = 0, l = 0, c = 10;
    return n.config.yaxis[e].title.text === void 0 || e < 0 ? {
      xPos: l,
      padd: 0
    } : (s ? (l = t.width + n.config.yaxis[e].title.offsetX + i.width / 2 + c / 2, o += 1, o === 0 && (l = l - c / 2)) : (l = t.width * -1 + n.config.yaxis[e].title.offsetX + c / 2 + i.width / 2, n.globals.isBarHorizontal && (c = 25, l = t.width * -1 - n.config.yaxis[e].title.offsetX - c)), {
      xPos: l,
      padd: c
    });
  }
  // sets the x position of the y-axis by counting the labels width, title width and any offset
  setYAxisXPosition(e, t) {
    let i = this.w, s = 0, n = 0, o = 18, l = 1;
    i.config.yaxis.length > 1 && (this.multipleYs = !0), i.config.yaxis.map((c, d) => {
      let f = i.globals.ignoreYAxisIndexes.indexOf(d) > -1 || !c.show || c.floating || e[d].width === 0, p = e[d].width + t[d].width;
      c.opposite ? i.globals.isBarHorizontal ? (n = i.globals.gridWidth + i.globals.translateX - 1, i.globals.translateYAxisX[d] = n - c.labels.offsetX) : (n = i.globals.gridWidth + i.globals.translateX + l, f || (l = l + p + 20), i.globals.translateYAxisX[d] = n - c.labels.offsetX + 20) : (s = i.globals.translateX - o, f || (o = o + p + 20), i.globals.translateYAxisX[d] = s + c.labels.offsetX);
    });
  }
  setYAxisTextAlignments() {
    const e = this.w;
    let t = e.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");
    t = N.listToArray(t), t.forEach((i, s) => {
      const n = e.config.yaxis[s];
      if (n && !n.floating && n.labels.align !== void 0) {
        const o = e.globals.dom.baseEl.querySelector(
          `.apexcharts-yaxis[rel='${s}'] .apexcharts-yaxis-texts-g`
        );
        let l = e.globals.dom.baseEl.querySelectorAll(
          `.apexcharts-yaxis[rel='${s}'] .apexcharts-yaxis-label`
        );
        l = N.listToArray(l);
        const c = o.getBoundingClientRect();
        n.labels.align === "left" ? (l.forEach((d, f) => {
          d.setAttribute("text-anchor", "start");
        }), n.opposite || o.setAttribute("transform", `translate(-${c.width}, 0)`)) : n.labels.align === "center" ? (l.forEach((d, f) => {
          d.setAttribute("text-anchor", "middle");
        }), o.setAttribute(
          "transform",
          `translate(${c.width / 2 * (n.opposite ? 1 : -1)}, 0)`
        )) : n.labels.align === "right" && (l.forEach((d, f) => {
          d.setAttribute("text-anchor", "end");
        }), n.opposite && o.setAttribute("transform", `translate(${c.width}, 0)`));
      }
    });
  }
}
class nL {
  constructor(e) {
    this.ctx = e, this.w = e.w, this.documentEvent = N.bind(this.documentEvent, this);
  }
  addEventListener(e, t) {
    const i = this.w;
    i.globals.events.hasOwnProperty(e) ? i.globals.events[e].push(t) : i.globals.events[e] = [t];
  }
  removeEventListener(e, t) {
    const i = this.w;
    if (!i.globals.events.hasOwnProperty(e))
      return;
    let s = i.globals.events[e].indexOf(t);
    s !== -1 && i.globals.events[e].splice(s, 1);
  }
  fireEvent(e, t) {
    const i = this.w;
    if (!i.globals.events.hasOwnProperty(e))
      return;
    (!t || !t.length) && (t = []);
    let s = i.globals.events[e], n = s.length;
    for (let o = 0; o < n; o++)
      s[o].apply(null, t);
  }
  setupEventHandlers() {
    const e = this.w, t = this.ctx;
    let i = e.globals.dom.baseEl.querySelector(e.globals.chartClass);
    this.ctx.eventList.forEach((s) => {
      i.addEventListener(
        s,
        (n) => {
          const o = Object.assign({}, e, {
            seriesIndex: e.globals.capturedSeriesIndex,
            dataPointIndex: e.globals.capturedDataPointIndex
          });
          n.type === "mousemove" || n.type === "touchmove" ? typeof e.config.chart.events.mouseMove == "function" && e.config.chart.events.mouseMove(n, t, o) : n.type === "mouseleave" || n.type === "touchleave" ? typeof e.config.chart.events.mouseLeave == "function" && e.config.chart.events.mouseLeave(n, t, o) : (n.type === "mouseup" && n.which === 1 || n.type === "touchend") && (typeof e.config.chart.events.click == "function" && e.config.chart.events.click(n, t, o), t.ctx.events.fireEvent("click", [n, t, o]));
        },
        { capture: !1, passive: !0 }
      );
    }), this.ctx.eventList.forEach((s) => {
      e.globals.dom.baseEl.addEventListener(s, this.documentEvent, {
        passive: !0
      });
    }), this.ctx.core.setupBrushHandler();
  }
  documentEvent(e) {
    const t = this.w, i = e.target.className;
    if (e.type === "click") {
      let s = t.globals.dom.baseEl.querySelector(".apexcharts-menu");
      s && s.classList.contains("apexcharts-menu-open") && i !== "apexcharts-menu-icon" && s.classList.remove("apexcharts-menu-open");
    }
    t.globals.clientX = e.type === "touchmove" ? e.touches[0].clientX : e.clientX, t.globals.clientY = e.type === "touchmove" ? e.touches[0].clientY : e.clientY;
  }
}
class rL {
  constructor(e) {
    this.ctx = e, this.w = e.w;
  }
  setCurrentLocaleValues(e) {
    let t = this.w.config.chart.locales;
    window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (t = this.w.config.chart.locales.concat(window.Apex.chart.locales));
    const i = t.filter((s) => s.name === e)[0];
    if (i) {
      let s = N.extend(Cv, i);
      this.w.globals.locale = s.options;
    } else
      throw new Error(
        "Wrong locale name provided. Please make sure you set the correct locale name in options"
      );
  }
}
class aL {
  constructor(e) {
    this.ctx = e, this.w = e.w;
  }
  drawAxis(e, t) {
    let i = this.w.globals, s = this.w.config, n = new Zr(this.ctx, t), o = new Bd(this.ctx, t);
    if (i.axisCharts && e !== "radar") {
      let l, c;
      i.isBarHorizontal ? (c = o.drawYaxisInversed(0), l = n.drawXaxisInversed(0), i.dom.elGraphical.add(l), i.dom.elGraphical.add(c)) : (l = n.drawXaxis(), i.dom.elGraphical.add(l), s.yaxis.map((d, f) => {
        if (i.ignoreYAxisIndexes.indexOf(f) === -1 && (c = o.drawYaxis(f), i.dom.Paper.add(c), this.w.config.grid.position === "back")) {
          const p = i.dom.Paper.children()[1];
          p.remove(), i.dom.Paper.add(p);
        }
      }));
    }
  }
}
class mh {
  constructor(e) {
    this.ctx = e, this.w = e.w;
  }
  drawXCrosshairs() {
    const e = this.w;
    let t = new K(this.ctx), i = new It(this.ctx), s = e.config.xaxis.crosshairs.fill.gradient, n = e.config.xaxis.crosshairs.dropShadow, o = e.config.xaxis.crosshairs.fill.type, l = s.colorFrom, c = s.colorTo, d = s.opacityFrom, f = s.opacityTo, p = s.stops, m = "none", v = n.enabled, r = n.left, h = n.top, u = n.blur, g = n.color, b = n.opacity, O = e.config.xaxis.crosshairs.fill.color;
    if (e.config.xaxis.crosshairs.show) {
      o === "gradient" && (O = t.drawGradient(
        "vertical",
        l,
        c,
        d,
        f,
        null,
        p,
        null
      ));
      let x = t.drawRect();
      e.config.xaxis.crosshairs.width === 1 && (x = t.drawLine());
      let S = e.globals.gridHeight;
      (!N.isNumber(S) || S < 0) && (S = 0);
      let k = e.config.xaxis.crosshairs.width;
      (!N.isNumber(k) || k < 0) && (k = 0), x.attr({
        class: "apexcharts-xcrosshairs",
        x: 0,
        y: 0,
        y2: S,
        width: k,
        height: S,
        fill: O,
        filter: m,
        "fill-opacity": e.config.xaxis.crosshairs.opacity,
        stroke: e.config.xaxis.crosshairs.stroke.color,
        "stroke-width": e.config.xaxis.crosshairs.stroke.width,
        "stroke-dasharray": e.config.xaxis.crosshairs.stroke.dashArray
      }), v && (x = i.dropShadow(x, {
        left: r,
        top: h,
        blur: u,
        color: g,
        opacity: b
      })), e.globals.dom.elGraphical.add(x);
    }
  }
  drawYCrosshairs() {
    const e = this.w;
    let t = new K(this.ctx), i = e.config.yaxis[0].crosshairs;
    const s = e.globals.barPadForNumericAxis;
    if (e.config.yaxis[0].crosshairs.show) {
      let o = t.drawLine(
        -s,
        0,
        e.globals.gridWidth + s,
        0,
        i.stroke.color,
        i.stroke.dashArray,
        i.stroke.width
      );
      o.attr({
        class: "apexcharts-ycrosshairs"
      }), e.globals.dom.elGraphical.add(o);
    }
    let n = t.drawLine(
      -s,
      0,
      e.globals.gridWidth + s,
      0,
      i.stroke.color,
      0,
      0
    );
    n.attr({
      class: "apexcharts-ycrosshairs-hidden"
    }), e.globals.dom.elGraphical.add(n);
  }
}
class oL {
  constructor(e) {
    this.ctx = e, this.w = e.w;
  }
  // the opts parameter if not null has to be set overriding everything
  // as the opts is set by user externally
  checkResponsiveConfig(e) {
    const t = this.w, i = t.config;
    if (i.responsive.length === 0)
      return;
    let s = i.responsive.slice();
    s.sort(
      (l, c) => l.breakpoint > c.breakpoint ? 1 : c.breakpoint > l.breakpoint ? -1 : 0
    ).reverse();
    let n = new Ur({});
    const o = (l = {}) => {
      let c = s[0].breakpoint;
      const d = window.innerWidth > 0 ? window.innerWidth : screen.width;
      if (d > c) {
        let f = vt.extendArrayProps(
          n,
          t.globals.initialConfig,
          t
        );
        l = N.extend(f, l), l = N.extend(t.config, l), this.overrideResponsiveOptions(l);
      } else
        for (let f = 0; f < s.length; f++)
          d < s[f].breakpoint && (l = vt.extendArrayProps(n, s[f].options, t), l = N.extend(t.config, l), this.overrideResponsiveOptions(l));
    };
    if (e) {
      let l = vt.extendArrayProps(n, e, t);
      l = N.extend(t.config, l), l = N.extend(l, e), o(l);
    } else
      o({});
  }
  overrideResponsiveOptions(e) {
    let t = new Ur(e).init({ responsiveOverride: !0 });
    this.w.config = t;
  }
}
class lL {
  constructor(e) {
    this.ctx = e, this.colors = [], this.w = e.w;
    const t = this.w;
    this.isColorFn = !1, this.isHeatmapDistributed = t.config.chart.type === "treemap" && t.config.plotOptions.treemap.distributed || t.config.chart.type === "heatmap" && t.config.plotOptions.heatmap.distributed, this.isBarDistributed = t.config.plotOptions.bar.distributed && (t.config.chart.type === "bar" || t.config.chart.type === "rangeBar");
  }
  init() {
    this.setDefaultColors();
  }
  setDefaultColors() {
    var n;
    let e = this.w, t = new N();
    if (e.globals.dom.elWrap.classList.add(
      `apexcharts-theme-${e.config.theme.mode}`
    ), e.config.colors === void 0 || ((n = e.config.colors) == null ? void 0 : n.length) === 0 ? e.globals.colors = this.predefined() : (e.globals.colors = e.config.colors, Array.isArray(e.config.colors) && e.config.colors.length > 0 && typeof e.config.colors[0] == "function" && (e.globals.colors = e.config.series.map((o, l) => {
      let c = e.config.colors[l];
      return c || (c = e.config.colors[0]), typeof c == "function" ? (this.isColorFn = !0, c({
        value: e.globals.axisCharts ? e.globals.series[l][0] ? e.globals.series[l][0] : 0 : e.globals.series[l],
        seriesIndex: l,
        dataPointIndex: l,
        w: e
      })) : c;
    }))), e.globals.seriesColors.map((o, l) => {
      o && (e.globals.colors[l] = o);
    }), e.config.theme.monochrome.enabled) {
      let o = [], l = e.globals.series.length;
      (this.isBarDistributed || this.isHeatmapDistributed) && (l = e.globals.series[0].length * e.globals.series.length);
      let c = e.config.theme.monochrome.color, d = 1 / (l / e.config.theme.monochrome.shadeIntensity), f = e.config.theme.monochrome.shadeTo, p = 0;
      for (let m = 0; m < l; m++) {
        let v;
        f === "dark" ? (v = t.shadeColor(p * -1, c), p = p + d) : (v = t.shadeColor(p, c), p = p + d), o.push(v);
      }
      e.globals.colors = o.slice();
    }
    const i = e.globals.colors.slice();
    this.pushExtraColors(e.globals.colors), ["fill", "stroke"].forEach((o) => {
      e.config[o].colors === void 0 ? e.globals[o].colors = this.isColorFn ? e.config.colors : i : e.globals[o].colors = e.config[o].colors.slice(), this.pushExtraColors(e.globals[o].colors);
    }), e.config.dataLabels.style.colors === void 0 ? e.globals.dataLabels.style.colors = i : e.globals.dataLabels.style.colors = e.config.dataLabels.style.colors.slice(), this.pushExtraColors(e.globals.dataLabels.style.colors, 50), e.config.plotOptions.radar.polygons.fill.colors === void 0 ? e.globals.radarPolygons.fill.colors = [
      e.config.theme.mode === "dark" ? "#424242" : "none"
    ] : e.globals.radarPolygons.fill.colors = e.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(e.globals.radarPolygons.fill.colors, 20), e.config.markers.colors === void 0 ? e.globals.markers.colors = i : e.globals.markers.colors = e.config.markers.colors.slice(), this.pushExtraColors(e.globals.markers.colors);
  }
  // When the number of colors provided is less than the number of series, this method
  // will push same colors to the list
  // params:
  // distributed is only valid for distributed column/bar charts
  pushExtraColors(e, t, i = null) {
    let s = this.w, n = t || s.globals.series.length;
    if (i === null && (i = this.isBarDistributed || this.isHeatmapDistributed || s.config.chart.type === "heatmap" && s.config.plotOptions.heatmap.colorScale.inverse), i && s.globals.series.length && (n = s.globals.series[s.globals.maxValsInArrayIndex].length * s.globals.series.length), e.length < n) {
      let o = n - e.length;
      for (let l = 0; l < o; l++)
        e.push(e[l]);
    }
  }
  updateThemeOptions(e) {
    e.chart = e.chart || {}, e.tooltip = e.tooltip || {};
    const t = e.theme.mode || "light", i = e.theme.palette ? e.theme.palette : t === "dark" ? "palette4" : "palette1", s = e.chart.foreColor ? e.chart.foreColor : t === "dark" ? "#f6f7f8" : "#373d3f";
    return e.tooltip.theme = t, e.chart.foreColor = s, e.theme.palette = i, e;
  }
  predefined() {
    switch (this.w.config.theme.palette) {
      case "palette1":
        this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
        break;
      case "palette2":
        this.colors = ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"];
        break;
      case "palette3":
        this.colors = ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"];
        break;
      case "palette4":
        this.colors = ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"];
        break;
      case "palette5":
        this.colors = ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"];
        break;
      case "palette6":
        this.colors = ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"];
        break;
      case "palette7":
        this.colors = ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"];
        break;
      case "palette8":
        this.colors = ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"];
        break;
      case "palette9":
        this.colors = ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"];
        break;
      case "palette10":
        this.colors = ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"];
        break;
      default:
        this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
        break;
    }
    return this.colors;
  }
}
class cL {
  constructor(e) {
    this.ctx = e, this.w = e.w;
  }
  draw() {
    this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle");
  }
  drawTitleSubtitle(e) {
    let t = this.w;
    const i = e === "title" ? t.config.title : t.config.subtitle;
    let s = t.globals.svgWidth / 2, n = i.offsetY, o = "middle";
    if (i.align === "left" ? (s = 10, o = "start") : i.align === "right" && (s = t.globals.svgWidth - 10, o = "end"), s = s + i.offsetX, n = n + parseInt(i.style.fontSize, 10) + i.margin / 2, i.text !== void 0) {
      let c = new K(this.ctx).drawText({
        x: s,
        y: n,
        text: i.text,
        textAnchor: o,
        fontSize: i.style.fontSize,
        fontFamily: i.style.fontFamily,
        fontWeight: i.style.fontWeight,
        foreColor: i.style.color,
        opacity: 1
      });
      c.node.setAttribute("class", `apexcharts-${e}-text`), t.globals.dom.Paper.add(c);
    }
  }
}
let hL = class {
  constructor(e) {
    this.w = e.w, this.dCtx = e;
  }
  /**
   * Get Chart Title/Subtitle Dimensions
   * @memberof Dimensions
   * @return {{width, height}}
   **/
  getTitleSubtitleCoords(e) {
    let t = this.w, i = 0, s = 0;
    const n = e === "title" ? t.config.title.floating : t.config.subtitle.floating;
    let o = t.globals.dom.baseEl.querySelector(`.apexcharts-${e}-text`);
    if (o !== null && !n) {
      let l = o.getBoundingClientRect();
      i = l.width, s = t.globals.axisCharts ? l.height + 5 : l.height;
    }
    return {
      width: i,
      height: s
    };
  }
  getLegendsRect() {
    let e = this.w, t = e.globals.dom.elLegendWrap;
    !e.config.legend.height && (e.config.legend.position === "top" || e.config.legend.position === "bottom") && (t.style.maxHeight = e.globals.svgHeight / 2 + "px");
    let i = Object.assign({}, N.getBoundingClientRect(t));
    return t !== null && !e.config.legend.floating && e.config.legend.show ? this.dCtx.lgRect = {
      x: i.x,
      y: i.y,
      height: i.height,
      width: i.height === 0 ? 0 : i.width
    } : this.dCtx.lgRect = {
      x: 0,
      y: 0,
      height: 0,
      width: 0
    }, (e.config.legend.position === "left" || e.config.legend.position === "right") && this.dCtx.lgRect.width * 1.5 > e.globals.svgWidth && (this.dCtx.lgRect.width = e.globals.svgWidth / 1.5), this.dCtx.lgRect;
  }
  getLargestStringFromMultiArr(e, t) {
    const i = this.w;
    let s = e;
    if (i.globals.isMultiLineX) {
      let n = t.map((c, d) => Array.isArray(c) ? c.length : 1), o = Math.max(...n), l = n.indexOf(o);
      s = t[l];
    }
    return s;
  }
};
class dL {
  constructor(e) {
    this.w = e.w, this.dCtx = e;
  }
  /**
   * Get X Axis Dimensions
   * @memberof Dimensions
   * @return {{width, height}}
   **/
  getxAxisLabelsCoords() {
    let e = this.w, t = e.globals.labels.slice();
    e.config.xaxis.convertedCatToNumeric && t.length === 0 && (t = e.globals.categoryLabels);
    let i;
    if (e.globals.timescaleLabels.length > 0) {
      const s = this.getxAxisTimeScaleLabelsCoords();
      i = {
        width: s.width,
        height: s.height
      }, e.globals.rotateXLabels = !1;
    } else {
      this.dCtx.lgWidthForSideLegends = (e.config.legend.position === "left" || e.config.legend.position === "right") && !e.config.legend.floating ? this.dCtx.lgRect.width : 0;
      let s = e.globals.xLabelFormatter, n = N.getLargestStringFromArr(t), o = this.dCtx.dimHelpers.getLargestStringFromMultiArr(
        n,
        t
      );
      e.globals.isBarHorizontal && (n = e.globals.yAxisScale[0].result.reduce(
        (m, v) => m.length > v.length ? m : v,
        0
      ), o = n);
      let l = new ba(this.dCtx.ctx), c = n;
      n = l.xLabelFormat(s, n, c, {
        i: void 0,
        dateFormatter: new Tt(this.dCtx.ctx).formatDate,
        w: e
      }), o = l.xLabelFormat(s, o, c, {
        i: void 0,
        dateFormatter: new Tt(this.dCtx.ctx).formatDate,
        w: e
      }), (e.config.xaxis.convertedCatToNumeric && typeof n > "u" || String(n).trim() === "") && (n = "1", o = n);
      let d = new K(this.dCtx.ctx), f = d.getTextRects(
        n,
        e.config.xaxis.labels.style.fontSize
      ), p = f;
      if (n !== o && (p = d.getTextRects(
        o,
        e.config.xaxis.labels.style.fontSize
      )), i = {
        width: f.width >= p.width ? f.width : p.width,
        height: f.height >= p.height ? f.height : p.height
      }, i.width * t.length > e.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && e.config.xaxis.labels.rotate !== 0 || e.config.xaxis.labels.rotateAlways) {
        if (!e.globals.isBarHorizontal) {
          e.globals.rotateXLabels = !0;
          const m = (v) => d.getTextRects(
            v,
            e.config.xaxis.labels.style.fontSize,
            e.config.xaxis.labels.style.fontFamily,
            `rotate(${e.config.xaxis.labels.rotate} 0 0)`,
            !1
          );
          f = m(n), n !== o && (p = m(o)), i.height = (f.height > p.height ? f.height : p.height) / 1.5, i.width = f.width > p.width ? f.width : p.width;
        }
      } else
        e.globals.rotateXLabels = !1;
    }
    return e.config.xaxis.labels.show || (i = {
      width: 0,
      height: 0
    }), {
      width: i.width,
      height: i.height
    };
  }
  /**
   * Get X Axis Label Group height
   * @memberof Dimensions
   * @return {{width, height}}
   */
  getxAxisGroupLabelsCoords() {
    var f;
    let e = this.w;
    if (!e.globals.hasXaxisGroups)
      return { width: 0, height: 0 };
    const t = ((f = e.config.xaxis.group.style) == null ? void 0 : f.fontSize) || e.config.xaxis.labels.style.fontSize;
    let i = e.globals.groups.map((p) => p.title), s, n = N.getLargestStringFromArr(i), o = this.dCtx.dimHelpers.getLargestStringFromMultiArr(
      n,
      i
    ), l = new K(this.dCtx.ctx), c = l.getTextRects(n, t), d = c;
    return n !== o && (d = l.getTextRects(o, t)), s = {
      width: c.width >= d.width ? c.width : d.width,
      height: c.height >= d.height ? c.height : d.height
    }, e.config.xaxis.labels.show || (s = {
      width: 0,
      height: 0
    }), {
      width: s.width,
      height: s.height
    };
  }
  /**
   * Get X Axis Title Dimensions
   * @memberof Dimensions
   * @return {{width, height}}
   **/
  getxAxisTitleCoords() {
    let e = this.w, t = 0, i = 0;
    if (e.config.xaxis.title.text !== void 0) {
      let n = new K(this.dCtx.ctx).getTextRects(
        e.config.xaxis.title.text,
        e.config.xaxis.title.style.fontSize
      );
      t = n.width, i = n.height;
    }
    return {
      width: t,
      height: i
    };
  }
  getxAxisTimeScaleLabelsCoords() {
    let e = this.w, t;
    this.dCtx.timescaleLabels = e.globals.timescaleLabels.slice();
    let i = this.dCtx.timescaleLabels.map((l) => l.value), s = i.reduce((l, c) => typeof l > "u" ? (console.error(
      "You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"
    ), 0) : l.length > c.length ? l : c, 0);
    return t = new K(this.dCtx.ctx).getTextRects(s, e.config.xaxis.labels.style.fontSize), t.width * 1.05 * i.length > e.globals.gridWidth && e.config.xaxis.labels.rotate !== 0 && (e.globals.overlappingXLabels = !0), t;
  }
  // In certain cases, the last labels gets cropped in xaxis.
  // Hence, we add some additional padding based on the label length to avoid the last label being cropped or we don't draw it at all
  additionalPaddingXLabels(e) {
    const t = this.w, i = t.globals, s = t.config, n = s.xaxis.type;
    let o = e.width;
    i.skipLastTimelinelabel = !1, i.skipFirstTimelinelabel = !1;
    const l = t.config.yaxis[0].opposite && t.globals.isBarHorizontal, c = (p) => i.collapsedSeriesIndices.indexOf(p) !== -1, d = (p) => {
      if (this.dCtx.timescaleLabels && this.dCtx.timescaleLabels.length) {
        const m = this.dCtx.timescaleLabels[0], r = this.dCtx.timescaleLabels[this.dCtx.timescaleLabels.length - 1].position + o / 1.75 - this.dCtx.yAxisWidthRight, h = m.position - o / 1.75 + this.dCtx.yAxisWidthLeft;
        let u = t.config.legend.position === "right" && this.dCtx.lgRect.width > 0 ? this.dCtx.lgRect.width : 0;
        r > i.svgWidth - i.translateX - u && (i.skipLastTimelinelabel = !0), h < -((!p.show || p.floating) && (s.chart.type === "bar" || s.chart.type === "candlestick" || s.chart.type === "rangeBar" || s.chart.type === "boxPlot") ? o / 1.75 : 10) && (i.skipFirstTimelinelabel = !0);
      } else
        n === "datetime" ? this.dCtx.gridPad.right < o && !i.rotateXLabels && (i.skipLastTimelinelabel = !0) : n !== "datetime" && this.dCtx.gridPad.right < o / 2 - this.dCtx.yAxisWidthRight && !i.rotateXLabels && !t.config.xaxis.labels.trim && (t.config.xaxis.tickPlacement !== "between" || t.globals.isBarHorizontal) && (this.dCtx.xPadRight = o / 2 + 1);
    }, f = (p, m) => {
      s.yaxis.length > 1 && c(m) || d(p);
    };
    s.yaxis.forEach((p, m) => {
      l ? (this.dCtx.gridPad.left < o && (this.dCtx.xPadLeft = o / 2 + 1), this.dCtx.xPadRight = o / 2 + 1) : f(p, m);
    });
  }
}
class uL {
  constructor(e) {
    this.w = e.w, this.dCtx = e;
  }
  /**
   * Get Y Axis Dimensions
   * @memberof Dimensions
   * @return {{width, height}}
   **/
  getyAxisLabelsCoords() {
    let e = this.w, t = 0, i = 0, s = [], n = 10;
    const o = new Es(this.dCtx.ctx);
    return e.config.yaxis.map((l, c) => {
      const d = {
        seriesIndex: c,
        dataPointIndex: -1,
        w: e
      }, f = e.globals.yAxisScale[c];
      let p = 0;
      if (!o.isYAxisHidden(c) && l.labels.show && l.labels.minWidth !== void 0 && (p = l.labels.minWidth), !o.isYAxisHidden(c) && l.labels.show && f.result.length) {
        let m = e.globals.yLabelFormatters[c], v = f.niceMin === Number.MIN_VALUE ? 0 : f.niceMin, r = f.result.reduce((x, S) => {
          var k, C;
          return ((k = String(m(x, d))) == null ? void 0 : k.length) > ((C = String(m(S, d))) == null ? void 0 : C.length) ? x : S;
        }, v);
        r = m(r, d);
        let h = r;
        if ((typeof r > "u" || r.length === 0) && (r = f.niceMax), e.globals.isBarHorizontal) {
          n = 0;
          let x = e.globals.labels.slice();
          r = N.getLargestStringFromArr(x), r = m(r, { seriesIndex: c, dataPointIndex: -1, w: e }), h = this.dCtx.dimHelpers.getLargestStringFromMultiArr(
            r,
            x
          );
        }
        let u = new K(this.dCtx.ctx), g = "rotate(".concat(l.labels.rotate, " 0 0)"), b = u.getTextRects(
          r,
          l.labels.style.fontSize,
          l.labels.style.fontFamily,
          g,
          !1
        ), O = b;
        r !== h && (O = u.getTextRects(
          h,
          l.labels.style.fontSize,
          l.labels.style.fontFamily,
          g,
          !1
        )), s.push({
          width: (p > O.width || p > b.width ? p : O.width > b.width ? O.width : b.width) + n,
          height: O.height > b.height ? O.height : b.height
        });
      } else
        s.push({
          width: t,
          height: i
        });
    }), s;
  }
  /**
   * Get Y Axis Dimensions
   * @memberof Dimensions
   * @return {{width, height}}
   **/
  getyAxisTitleCoords() {
    let e = this.w, t = [];
    return e.config.yaxis.map((i, s) => {
      if (i.show && i.title.text !== void 0) {
        let n = new K(this.dCtx.ctx), o = "rotate(".concat(i.title.rotate, " 0 0)"), l = n.getTextRects(
          i.title.text,
          i.title.style.fontSize,
          i.title.style.fontFamily,
          o,
          !1
        );
        t.push({
          width: l.width,
          height: l.height
        });
      } else
        t.push({
          width: 0,
          height: 0
        });
    }), t;
  }
  getTotalYAxisWidth() {
    let e = this.w, t = 0, i = 0, s = 0, n = e.globals.yAxisScale.length > 1 ? 10 : 0;
    const o = new Es(this.dCtx.ctx), l = function(d) {
      return e.globals.ignoreYAxisIndexes.indexOf(d) > -1;
    }, c = (d, f) => {
      let p = e.config.yaxis[f].floating, m = 0;
      d.width > 0 && !p ? (m = d.width + n, l(f) && (m = m - d.width - n)) : m = p || o.isYAxisHidden(f) ? 0 : 5, e.config.yaxis[f].opposite ? s = s + m : i = i + m, t = t + m;
    };
    return e.globals.yLabelsCoords.map((d, f) => {
      c(d, f);
    }), e.globals.yTitleCoords.map((d, f) => {
      c(d, f);
    }), e.globals.isBarHorizontal && !e.config.yaxis[0].floating && (t = e.globals.yLabelsCoords[0].width + e.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i, this.dCtx.yAxisWidthRight = s, t;
  }
}
class fL {
  constructor(e) {
    this.w = e.w, this.dCtx = e;
  }
  gridPadForColumnsInNumericAxis(e) {
    const t = this.w;
    if (t.globals.noData || t.globals.allSeriesCollapsed)
      return 0;
    const i = (c) => c === "bar" || c === "rangeBar" || c === "candlestick" || c === "boxPlot", s = t.config.chart.type;
    let n = 0, o = i(s) ? t.config.series.length : 1;
    if (t.globals.comboBarCount > 0 && (o = t.globals.comboBarCount), t.globals.collapsedSeries.forEach((c) => {
      i(c.type) && (o = o - 1);
    }), t.config.chart.stacked && (o = 1), (i(s) || t.globals.comboBarCount > 0) && t.globals.isXNumeric && !t.globals.isBarHorizontal && o > 0) {
      let c = 0, d = Math.abs(t.globals.initialMaxX - t.globals.initialMinX);
      d <= 3 && (d = t.globals.dataPoints), c = d / e;
      let f;
      t.globals.minXDiff && t.globals.minXDiff / c > 0 && (f = t.globals.minXDiff / c), f > e / 2 && (f = f / 2), n = f * parseInt(t.config.plotOptions.bar.columnWidth, 10) / 100, n < 1 && (n = 1), t.globals.barPadForNumericAxis = n;
    }
    return n;
  }
  gridPadFortitleSubtitle() {
    const e = this.w, t = e.globals;
    let i = this.dCtx.isSparkline || !e.globals.axisCharts ? 0 : 10;
    ["title", "subtitle"].forEach((l) => {
      e.config[l].text !== void 0 ? i += e.config[l].margin : i += this.dCtx.isSparkline || !e.globals.axisCharts ? 0 : 5;
    }), e.config.legend.show && e.config.legend.position === "bottom" && !e.config.legend.floating && !e.globals.axisCharts && (i += 10);
    let n = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"), o = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
    t.gridHeight = t.gridHeight - n.height - o.height - i, t.translateY = t.translateY + n.height + o.height + i;
  }
  setGridXPosForDualYAxis(e, t) {
    let i = this.w;
    const s = new Es(this.dCtx.ctx);
    i.config.yaxis.map((n, o) => {
      i.globals.ignoreYAxisIndexes.indexOf(o) === -1 && !n.floating && !s.isYAxisHidden(o) && (n.opposite && (i.globals.translateX = i.globals.translateX - (t[o].width + e[o].width) - parseInt(i.config.yaxis[o].labels.style.fontSize, 10) / 1.2 - 12), i.globals.translateX < 2 && (i.globals.translateX = 2));
    });
  }
}
class Po {
  constructor(e) {
    this.ctx = e, this.w = e.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new hL(this), this.dimYAxis = new uL(this), this.dimXAxis = new dL(this), this.dimGrid = new fL(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0;
  }
  /**
   * @memberof Dimensions
   * @param {object} w - chart context
   **/
  plotCoords() {
    let e = this.w, t = e.globals;
    this.lgRect = this.dimHelpers.getLegendsRect(), this.isSparkline && ((e.config.markers.discrete.length > 0 || e.config.markers.size > 0) && Object.entries(this.gridPad).forEach(([s, n]) => {
      this.gridPad[s] = Math.max(
        n,
        this.w.globals.markers.largestSize / 1.5
      );
    }), this.gridPad.top = Math.max(e.config.stroke.width / 2, this.gridPad.top), this.gridPad.bottom = Math.max(
      e.config.stroke.width / 2,
      this.gridPad.bottom
    )), t.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), t.gridHeight = t.gridHeight - this.gridPad.top - this.gridPad.bottom, t.gridWidth = t.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
    let i = this.dimGrid.gridPadForColumnsInNumericAxis(t.gridWidth);
    t.gridWidth = t.gridWidth - i * 2, t.translateX = t.translateX + this.gridPad.left + this.xPadLeft + (i > 0 ? i + 4 : 0), t.translateY = t.translateY + this.gridPad.top;
  }
  setDimensionsForAxisCharts() {
    let e = this.w, t = e.globals, i = this.dimYAxis.getyAxisLabelsCoords(), s = this.dimYAxis.getyAxisTitleCoords();
    e.globals.yLabelsCoords = [], e.globals.yTitleCoords = [], e.config.yaxis.map((v, r) => {
      e.globals.yLabelsCoords.push({
        width: i[r].width,
        index: r
      }), e.globals.yTitleCoords.push({
        width: s[r].width,
        index: r
      });
    }), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
    let n = this.dimXAxis.getxAxisLabelsCoords(), o = this.dimXAxis.getxAxisGroupLabelsCoords(), l = this.dimXAxis.getxAxisTitleCoords();
    this.conditionalChecksForAxisCoords(
      n,
      l,
      o
    ), t.translateXAxisY = e.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, t.translateXAxisX = e.globals.rotateXLabels && e.globals.isXNumeric && e.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, e.globals.isBarHorizontal && (t.rotateXLabels = !1, t.translateXAxisY = -1 * (parseInt(e.config.xaxis.labels.style.fontSize, 10) / 1.5)), t.translateXAxisY = t.translateXAxisY + e.config.xaxis.labels.offsetY, t.translateXAxisX = t.translateXAxisX + e.config.xaxis.labels.offsetX;
    let c = this.yAxisWidth, d = this.xAxisHeight;
    t.xAxisLabelsHeight = this.xAxisHeight - l.height, t.xAxisGroupLabelsHeight = t.xAxisLabelsHeight - n.height, t.xAxisLabelsWidth = this.xAxisWidth, t.xAxisHeight = this.xAxisHeight;
    let f = 10;
    (e.config.chart.type === "radar" || this.isSparkline) && (c = 0, d = t.goldenPadding), this.isSparkline && (this.lgRect = {
      height: 0,
      width: 0
    }), (this.isSparkline || e.config.chart.type === "treemap") && (c = 0, d = 0, f = 0), this.isSparkline || this.dimXAxis.additionalPaddingXLabels(n);
    const p = () => {
      t.translateX = c, t.gridHeight = t.svgHeight - this.lgRect.height - d - (!this.isSparkline && e.config.chart.type !== "treemap" ? e.globals.rotateXLabels ? 10 : 15 : 0), t.gridWidth = t.svgWidth - c;
    };
    switch (e.config.xaxis.position === "top" && (f = t.xAxisHeight - e.config.xaxis.axisTicks.height - 5), e.config.legend.position) {
      case "bottom":
        t.translateY = f, p();
        break;
      case "top":
        t.translateY = this.lgRect.height + f, p();
        break;
      case "left":
        t.translateY = f, t.translateX = this.lgRect.width + c, t.gridHeight = t.svgHeight - d - 12, t.gridWidth = t.svgWidth - this.lgRect.width - c;
        break;
      case "right":
        t.translateY = f, t.translateX = c, t.gridHeight = t.svgHeight - d - 12, t.gridWidth = t.svgWidth - this.lgRect.width - c - 5;
        break;
      default:
        throw new Error("Legend position not supported");
    }
    this.dimGrid.setGridXPosForDualYAxis(s, i), new Bd(this.ctx).setYAxisXPosition(i, s);
  }
  setDimensionsForNonAxisCharts() {
    let e = this.w, t = e.globals, i = e.config, s = 0;
    e.config.legend.show && !e.config.legend.floating && (s = 20);
    const n = i.chart.type === "pie" || i.chart.type === "polarArea" || i.chart.type === "donut" ? "pie" : "radialBar";
    let o = i.plotOptions[n].offsetY, l = i.plotOptions[n].offsetX;
    if (!i.legend.show || i.legend.floating) {
      t.gridHeight = t.svgHeight - i.grid.padding.left + i.grid.padding.right, t.gridWidth = t.gridHeight, t.translateY = o, t.translateX = l + (t.svgWidth - t.gridWidth) / 2;
      return;
    }
    switch (i.legend.position) {
      case "bottom":
        t.gridHeight = t.svgHeight - this.lgRect.height - t.goldenPadding, t.gridWidth = t.svgWidth, t.translateY = o - 10, t.translateX = l + (t.svgWidth - t.gridWidth) / 2;
        break;
      case "top":
        t.gridHeight = t.svgHeight - this.lgRect.height - t.goldenPadding, t.gridWidth = t.svgWidth, t.translateY = this.lgRect.height + o + 10, t.translateX = l + (t.svgWidth - t.gridWidth) / 2;
        break;
      case "left":
        t.gridWidth = t.svgWidth - this.lgRect.width - s, t.gridHeight = i.chart.height !== "auto" ? t.svgHeight : t.gridWidth, t.translateY = o, t.translateX = l + this.lgRect.width + s;
        break;
      case "right":
        t.gridWidth = t.svgWidth - this.lgRect.width - s - 5, t.gridHeight = i.chart.height !== "auto" ? t.svgHeight : t.gridWidth, t.translateY = o, t.translateX = l + 10;
        break;
      default:
        throw new Error("Legend position not supported");
    }
  }
  conditionalChecksForAxisCoords(e, t, i) {
    const s = this.w, n = s.globals.hasXaxisGroups ? 2 : 1, o = i.height + e.height + t.height, l = s.globals.isMultiLineX ? 1.2 : s.globals.LINE_HEIGHT_RATIO, c = s.globals.rotateXLabels ? 22 : 10, f = s.globals.rotateXLabels && s.config.legend.position === "bottom" ? 10 : 0;
    this.xAxisHeight = o * l + n * c + f, this.xAxisWidth = e.width, this.xAxisHeight - t.height > s.config.xaxis.labels.maxHeight && (this.xAxisHeight = s.config.xaxis.labels.maxHeight), s.config.xaxis.labels.minHeight && this.xAxisHeight < s.config.xaxis.labels.minHeight && (this.xAxisHeight = s.config.xaxis.labels.minHeight), s.config.xaxis.floating && (this.xAxisHeight = 0);
    let p = 0, m = 0;
    s.config.yaxis.forEach((v) => {
      p += v.labels.minWidth, m += v.labels.maxWidth;
    }), this.yAxisWidth < p && (this.yAxisWidth = p), this.yAxisWidth > m && (this.yAxisWidth = m);
  }
}
let pL = class {
  constructor(e) {
    this.w = e.w, this.lgCtx = e;
  }
  getLegendStyles() {
    var n, o, l;
    let e = document.createElement("style");
    e.setAttribute("type", "text/css");
    const t = ((l = (o = (n = this.lgCtx.ctx) == null ? void 0 : n.opts) == null ? void 0 : o.chart) == null ? void 0 : l.nonce) || this.w.config.chart.nonce;
    t && e.setAttribute("nonce", t);
    const i = `
      .apexcharts-legend {
        display: flex;
        overflow: auto;
        padding: 0 10px;
      }
      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {
        flex-wrap: wrap
      }
      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {
        flex-direction: column;
        bottom: 0;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {
        justify-content: flex-start;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {
        justify-content: center;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {
        justify-content: flex-end;
      }
      .apexcharts-legend-series {
        cursor: pointer;
        line-height: normal;
      }
      .apexcharts-legend.apx-legend-position-bottom .apexcharts-legend-series, .apexcharts-legend.apx-legend-position-top .apexcharts-legend-series{
        display: flex;
        align-items: center;
      }
      .apexcharts-legend-text {
        position: relative;
        font-size: 14px;
      }
      .apexcharts-legend-text *, .apexcharts-legend-marker * {
        pointer-events: none;
      }
      .apexcharts-legend-marker {
        position: relative;
        display: inline-block;
        cursor: pointer;
        margin-right: 3px;
        border-style: solid;
      }

      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{
        display: inline-block;
      }
      .apexcharts-legend-series.apexcharts-no-click {
        cursor: auto;
      }
      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {
        display: none !important;
      }
      .apexcharts-inactive-legend {
        opacity: 0.45;
      }`;
    let s = document.createTextNode(i);
    return e.appendChild(s), e;
  }
  getLegendBBox() {
    let i = this.w.globals.dom.baseEl.querySelector(
      ".apexcharts-legend"
    ).getBoundingClientRect(), s = i.width;
    return {
      clwh: i.height,
      clww: s
    };
  }
  appendToForeignObject() {
    this.w.globals.dom.elLegendForeign.appendChild(this.getLegendStyles());
  }
  toggleDataSeries(e, t) {
    const i = this.w;
    if (i.globals.axisCharts || i.config.chart.type === "radialBar") {
      i.globals.resized = !0;
      let s = null, n = null;
      i.globals.risingSeries = [], i.globals.axisCharts ? (s = i.globals.dom.baseEl.querySelector(
        `.apexcharts-series[data\\:realIndex='${e}']`
      ), n = parseInt(s.getAttribute("data:realIndex"), 10)) : (s = i.globals.dom.baseEl.querySelector(
        `.apexcharts-series[rel='${e + 1}']`
      ), n = parseInt(s.getAttribute("rel"), 10) - 1), t ? [
        {
          cs: i.globals.collapsedSeries,
          csi: i.globals.collapsedSeriesIndices
        },
        {
          cs: i.globals.ancillaryCollapsedSeries,
          csi: i.globals.ancillaryCollapsedSeriesIndices
        }
      ].forEach((l) => {
        this.riseCollapsedSeries(l.cs, l.csi, n);
      }) : this.hideSeries({ seriesEl: s, realIndex: n });
    } else {
      let s = i.globals.dom.Paper.select(
        ` .apexcharts-series[rel='${e + 1}'] path`
      );
      const n = i.config.chart.type;
      if (n === "pie" || n === "polarArea" || n === "donut") {
        let o = i.config.plotOptions.pie.donut.labels;
        new K(this.lgCtx.ctx).pathMouseDown(s.members[0], null), this.lgCtx.ctx.pie.printDataLabelsInner(
          s.members[0].node,
          o
        );
      }
      s.fire("click");
    }
  }
  hideSeries({ seriesEl: e, realIndex: t }) {
    const i = this.w;
    let s = N.clone(i.config.series);
    if (i.globals.axisCharts) {
      let o = i.config.yaxis[i.globals.seriesYAxisReverseMap[t]];
      if (o && o.show && o.showAlways)
        i.globals.ancillaryCollapsedSeriesIndices.indexOf(t) < 0 && (i.globals.ancillaryCollapsedSeries.push({
          index: t,
          data: s[t].data.slice(),
          type: e.parentNode.className.baseVal.split("-")[1]
        }), i.globals.ancillaryCollapsedSeriesIndices.push(t));
      else if (i.globals.collapsedSeriesIndices.indexOf(t) < 0) {
        i.globals.collapsedSeries.push({
          index: t,
          data: s[t].data.slice(),
          type: e.parentNode.className.baseVal.split("-")[1]
        }), i.globals.collapsedSeriesIndices.push(t);
        let l = i.globals.risingSeries.indexOf(t);
        i.globals.risingSeries.splice(l, 1);
      }
    } else
      i.globals.collapsedSeries.push({
        index: t,
        data: s[t]
      }), i.globals.collapsedSeriesIndices.push(t);
    let n = e.childNodes;
    for (let o = 0; o < n.length; o++)
      n[o].classList.contains("apexcharts-series-markers-wrap") && (n[o].classList.contains("apexcharts-hide") ? n[o].classList.remove("apexcharts-hide") : n[o].classList.add("apexcharts-hide"));
    i.globals.allSeriesCollapsed = i.globals.collapsedSeries.length === i.config.series.length, s = this._getSeriesBasedOnCollapsedState(s), this.lgCtx.ctx.updateHelpers._updateSeries(
      s,
      i.config.chart.animations.dynamicAnimation.enabled
    );
  }
  riseCollapsedSeries(e, t, i) {
    const s = this.w;
    let n = N.clone(s.config.series);
    if (e.length > 0) {
      for (let o = 0; o < e.length; o++)
        e[o].index === i && (s.globals.axisCharts ? (n[i].data = e[o].data.slice(), e.splice(o, 1), t.splice(o, 1), s.globals.risingSeries.push(i)) : (n[i] = e[o].data, e.splice(o, 1), t.splice(o, 1), s.globals.risingSeries.push(i)));
      n = this._getSeriesBasedOnCollapsedState(n), this.lgCtx.ctx.updateHelpers._updateSeries(
        n,
        s.config.chart.animations.dynamicAnimation.enabled
      );
    }
  }
  _getSeriesBasedOnCollapsedState(e) {
    const t = this.w;
    return t.globals.axisCharts ? e.forEach((i, s) => {
      t.globals.collapsedSeriesIndices.indexOf(s) > -1 && (e[s].data = []);
    }) : e.forEach((i, s) => {
      t.globals.collapsedSeriesIndices.indexOf(s) > -1 && (e[s] = 0);
    }), e;
  }
};
class Lv {
  constructor(e) {
    this.ctx = e, this.w = e.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = this.w.config.chart.type === "bar" && this.w.config.plotOptions.bar.distributed && this.w.config.series.length === 1, this.legendHelpers = new pL(this);
  }
  init() {
    const e = this.w, t = e.globals, i = e.config;
    if ((i.legend.showForSingleSeries && t.series.length === 1 || this.isBarsDistributed || t.series.length > 1 || !t.axisCharts) && i.legend.show) {
      for (; t.dom.elLegendWrap.firstChild; )
        t.dom.elLegendWrap.removeChild(t.dom.elLegendWrap.firstChild);
      this.drawLegends(), N.isIE11() ? document.getElementsByTagName("head")[0].appendChild(this.legendHelpers.getLegendStyles()) : this.legendHelpers.appendToForeignObject(), i.legend.position === "bottom" || i.legend.position === "top" ? this.legendAlignHorizontal() : (i.legend.position === "right" || i.legend.position === "left") && this.legendAlignVertical();
    }
  }
  drawLegends() {
    var c;
    let e = this, t = this.w, i = t.config.legend.fontFamily, s = t.globals.seriesNames, n = t.globals.colors.slice();
    if (t.config.chart.type === "heatmap") {
      const d = t.config.plotOptions.heatmap.colorScale.ranges;
      s = d.map((f) => f.name ? f.name : f.from + " - " + f.to), n = d.map((f) => f.color);
    } else
      this.isBarsDistributed && (s = t.globals.labels.slice());
    t.config.legend.customLegendItems.length && (s = t.config.legend.customLegendItems);
    let o = t.globals.legendFormatter, l = t.config.legend.inverseOrder;
    for (let d = l ? s.length - 1 : 0; l ? d >= 0 : d <= s.length - 1; l ? d-- : d++) {
      let f = o(s[d], { seriesIndex: d, w: t }), p = !1, m = !1;
      if (t.globals.collapsedSeries.length > 0)
        for (let L = 0; L < t.globals.collapsedSeries.length; L++)
          t.globals.collapsedSeries[L].index === d && (p = !0);
      if (t.globals.ancillaryCollapsedSeriesIndices.length > 0)
        for (let L = 0; L < t.globals.ancillaryCollapsedSeriesIndices.length; L++)
          t.globals.ancillaryCollapsedSeriesIndices[L] === d && (m = !0);
      let v = document.createElement("span");
      v.classList.add("apexcharts-legend-marker");
      let r = t.config.legend.markers.offsetX, h = t.config.legend.markers.offsetY, u = t.config.legend.markers.height, g = t.config.legend.markers.width, b = t.config.legend.markers.strokeWidth, O = t.config.legend.markers.strokeColor, x = t.config.legend.markers.radius, S = v.style;
      S.background = n[d], S.color = n[d], S.setProperty("background", n[d], "important"), t.config.legend.markers.fillColors && t.config.legend.markers.fillColors[d] && (S.background = t.config.legend.markers.fillColors[d]), t.globals.seriesColors[d] !== void 0 && (S.background = t.globals.seriesColors[d], S.color = t.globals.seriesColors[d]), S.height = Array.isArray(u) ? parseFloat(u[d]) + "px" : parseFloat(u) + "px", S.width = Array.isArray(g) ? parseFloat(g[d]) + "px" : parseFloat(g) + "px", S.left = (Array.isArray(r) ? parseFloat(r[d]) : parseFloat(r)) + "px", S.top = (Array.isArray(h) ? parseFloat(h[d]) : parseFloat(h)) + "px", S.borderWidth = Array.isArray(b) ? b[d] : b, S.borderColor = Array.isArray(O) ? O[d] : O, S.borderRadius = Array.isArray(x) ? parseFloat(x[d]) + "px" : parseFloat(x) + "px", t.config.legend.markers.customHTML && (Array.isArray(t.config.legend.markers.customHTML) ? t.config.legend.markers.customHTML[d] && (v.innerHTML = t.config.legend.markers.customHTML[d]()) : v.innerHTML = t.config.legend.markers.customHTML()), K.setAttrs(v, {
        rel: d + 1,
        "data:collapsed": p || m
      }), (p || m) && v.classList.add("apexcharts-inactive-legend");
      let k = document.createElement("div"), C = document.createElement("span");
      C.classList.add("apexcharts-legend-text"), C.innerHTML = Array.isArray(f) ? f.join(" ") : f;
      let _ = t.config.legend.labels.useSeriesColors ? t.globals.colors[d] : Array.isArray(t.config.legend.labels.colors) ? (c = t.config.legend.labels.colors) == null ? void 0 : c[d] : t.config.legend.labels.colors;
      _ || (_ = t.config.chart.foreColor), C.style.color = _, C.style.fontSize = parseFloat(t.config.legend.fontSize) + "px", C.style.fontWeight = t.config.legend.fontWeight, C.style.fontFamily = i || t.config.chart.fontFamily, K.setAttrs(C, {
        rel: d + 1,
        i: d,
        "data:default-text": encodeURIComponent(f),
        "data:collapsed": p || m
      }), k.appendChild(v), k.appendChild(C);
      const $ = new vt(this.ctx);
      t.config.legend.showForZeroSeries || $.getSeriesTotalByIndex(d) === 0 && $.seriesHaveSameValues(d) && !$.isSeriesNull(d) && t.globals.collapsedSeriesIndices.indexOf(d) === -1 && t.globals.ancillaryCollapsedSeriesIndices.indexOf(d) === -1 && k.classList.add("apexcharts-hidden-zero-series"), t.config.legend.showForNullSeries || $.isSeriesNull(d) && t.globals.collapsedSeriesIndices.indexOf(d) === -1 && t.globals.ancillaryCollapsedSeriesIndices.indexOf(d) === -1 && k.classList.add("apexcharts-hidden-null-series"), t.globals.dom.elLegendWrap.appendChild(k), t.globals.dom.elLegendWrap.classList.add(
        `apexcharts-align-${t.config.legend.horizontalAlign}`
      ), t.globals.dom.elLegendWrap.classList.add(
        "apx-legend-position-" + t.config.legend.position
      ), k.classList.add("apexcharts-legend-series"), k.style.margin = `${t.config.legend.itemMargin.vertical}px ${t.config.legend.itemMargin.horizontal}px`, t.globals.dom.elLegendWrap.style.width = t.config.legend.width ? t.config.legend.width + "px" : "", t.globals.dom.elLegendWrap.style.height = t.config.legend.height ? t.config.legend.height + "px" : "", K.setAttrs(k, {
        rel: d + 1,
        seriesName: N.escapeString(s[d]),
        "data:collapsed": p || m
      }), (p || m) && k.classList.add("apexcharts-inactive-legend"), t.config.legend.onItemClick.toggleDataSeries || k.classList.add("apexcharts-no-click");
    }
    t.globals.dom.elWrap.addEventListener("click", e.onLegendClick, !0), t.config.legend.onItemHover.highlightDataSeries && t.config.legend.customLegendItems.length === 0 && (t.globals.dom.elWrap.addEventListener(
      "mousemove",
      e.onLegendHovered,
      !0
    ), t.globals.dom.elWrap.addEventListener(
      "mouseout",
      e.onLegendHovered,
      !0
    ));
  }
  setLegendWrapXY(e, t) {
    let i = this.w, s = i.globals.dom.elLegendWrap;
    const n = s.getBoundingClientRect();
    let o = 0, l = 0;
    if (i.config.legend.position === "bottom")
      l = l + (i.globals.svgHeight - n.height / 2);
    else if (i.config.legend.position === "top") {
      const d = new Po(this.ctx), f = d.dimHelpers.getTitleSubtitleCoords("title").height, p = d.dimHelpers.getTitleSubtitleCoords("subtitle").height;
      l = l + (f > 0 ? f - 10 : 0) + (p > 0 ? p - 10 : 0);
    }
    s.style.position = "absolute", o = o + e + i.config.legend.offsetX, l = l + t + i.config.legend.offsetY, s.style.left = o + "px", s.style.top = l + "px", i.config.legend.position === "bottom" ? (s.style.top = "auto", s.style.bottom = 5 - i.config.legend.offsetY + "px") : i.config.legend.position === "right" && (s.style.left = "auto", s.style.right = 25 + i.config.legend.offsetX + "px"), ["width", "height"].forEach((d) => {
      s.style[d] && (s.style[d] = parseInt(i.config.legend[d], 10) + "px");
    });
  }
  legendAlignHorizontal() {
    let e = this.w, t = e.globals.dom.elLegendWrap;
    t.style.right = 0;
    let i = this.legendHelpers.getLegendBBox(), s = new Po(this.ctx), n = s.dimHelpers.getTitleSubtitleCoords("title"), o = s.dimHelpers.getTitleSubtitleCoords("subtitle"), l = 20, c = 0;
    e.config.legend.position === "bottom" ? c = -i.clwh / 1.8 : e.config.legend.position === "top" && (c = n.height + o.height + e.config.title.margin + e.config.subtitle.margin - 10), this.setLegendWrapXY(l, c);
  }
  legendAlignVertical() {
    let e = this.w, t = this.legendHelpers.getLegendBBox(), i = 20, s = 0;
    e.config.legend.position === "left" && (s = 20), e.config.legend.position === "right" && (s = e.globals.svgWidth - t.clww - 10), this.setLegendWrapXY(s, i);
  }
  onLegendHovered(e) {
    const t = this.w, i = e.target.classList.contains("apexcharts-legend-series") || e.target.classList.contains("apexcharts-legend-text") || e.target.classList.contains("apexcharts-legend-marker");
    if (t.config.chart.type !== "heatmap" && !this.isBarsDistributed)
      !e.target.classList.contains("apexcharts-inactive-legend") && i && new mi(this.ctx).toggleSeriesOnHover(e, e.target);
    else if (i) {
      let s = parseInt(e.target.getAttribute("rel"), 10) - 1;
      this.ctx.events.fireEvent("legendHover", [this.ctx, s, this.w]), new mi(this.ctx).highlightRangeInSeries(e, e.target);
    }
  }
  onLegendClick(e) {
    const t = this.w;
    if (!t.config.legend.customLegendItems.length && (e.target.classList.contains("apexcharts-legend-series") || e.target.classList.contains("apexcharts-legend-text") || e.target.classList.contains("apexcharts-legend-marker"))) {
      let i = parseInt(e.target.getAttribute("rel"), 10) - 1, s = e.target.getAttribute("data:collapsed") === "true";
      const n = this.w.config.chart.events.legendClick;
      typeof n == "function" && n(this.ctx, i, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, i, this.w]);
      const o = this.w.config.legend.markers.onClick;
      typeof o == "function" && e.target.classList.contains("apexcharts-legend-marker") && (o(this.ctx, i, this.w), this.ctx.events.fireEvent("legendMarkerClick", [
        this.ctx,
        i,
        this.w
      ])), t.config.chart.type !== "treemap" && t.config.chart.type !== "heatmap" && !this.isBarsDistributed && t.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(i, s);
    }
  }
}
const gL = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBmaWxsPSIjMDAwMDAwIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCI+CiAgICA8ZGVmcz4KICAgICAgICA8cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBpZD0iYSIvPgogICAgPC9kZWZzPgogICAgPGNsaXBQYXRoIGlkPSJiIj4KICAgICAgICA8dXNlIG92ZXJmbG93PSJ2aXNpYmxlIiB4bGluazpocmVmPSIjYSIvPgogICAgPC9jbGlwUGF0aD4KICAgIDxwYXRoIGNsaXAtcGF0aD0idXJsKCNiKSIgZD0iTTIzIDUuNVYyMGMwIDIuMi0xLjggNC00IDRoLTcuM2MtMS4wOCAwLTIuMS0uNDMtMi44NS0xLjE5TDEgMTQuODNzMS4yNi0xLjIzIDEuMy0xLjI1Yy4yMi0uMTkuNDktLjI5Ljc5LS4yOS4yMiAwIC40Mi4wNi42LjE2LjA0LjAxIDQuMzEgMi40NiA0LjMxIDIuNDZWNGMwLS44My42Ny0xLjUgMS41LTEuNVMxMSAzLjE3IDExIDR2N2gxVjEuNWMwLS44My42Ny0xLjUgMS41LTEuNVMxNSAuNjcgMTUgMS41VjExaDFWMi41YzAtLjgzLjY3LTEuNSAxLjUtMS41czEuNS42NyAxLjUgMS41VjExaDFWNS41YzAtLjgzLjY3LTEuNSAxLjUtMS41czEuNS42NyAxLjUgMS41eiIvPgo8L3N2Zz4=", mL = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9IiMwMDAwMDAiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij4KICAgIDxwYXRoIGQ9Ik0xNS41IDE0aC0uNzlsLS4yOC0uMjdDMTUuNDEgMTIuNTkgMTYgMTEuMTEgMTYgOS41IDE2IDUuOTEgMTMuMDkgMyA5LjUgM1MzIDUuOTEgMyA5LjUgNS45MSAxNiA5LjUgMTZjMS42MSAwIDMuMDktLjU5IDQuMjMtMS41N2wuMjcuMjh2Ljc5bDUgNC45OUwyMC40OSAxOWwtNC45OS01em0tNiAwQzcuMDEgMTQgNSAxMS45OSA1IDkuNVM3LjAxIDUgOS41IDUgMTQgNy4wMSAxNCA5LjUgMTEuOTkgMTQgOS41IDE0eiIvPgogICAgPHBhdGggZD0iTTAgMGgyNHYyNEgwVjB6IiBmaWxsPSJub25lIi8+CiAgICA8cGF0aCBkPSJNMTIgMTBoLTJ2Mkg5di0ySDdWOWgyVjdoMXYyaDJ2MXoiLz4KPC9zdmc+", bL = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjMDAwMDAwIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxwYXRoIGQ9Ik0xMCAyMHYtNmg0djZoNXYtOGgzTDEyIDMgMiAxMmgzdjh6Ii8+CiAgICA8cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+Cjwvc3ZnPg==", vL = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxwYXRoIGQ9Ik0wIDBoMjR2MjRIMHoiIGZpbGw9Im5vbmUiLz4KICAgIDxwYXRoIGQ9Ik0xMyA3aC0ydjRIN3YyaDR2NGgydi00aDR2LTJoLTRWN3ptLTEtNUM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptMCAxOGMtNC40MSAwLTgtMy41OS04LThzMy41OS04IDgtOCA4IDMuNTkgOCA4LTMuNTkgOC04IDh6Ii8+Cjwvc3ZnPgo=", yL = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxwYXRoIGQ9Ik0wIDBoMjR2MjRIMHoiIGZpbGw9Im5vbmUiLz4KICAgIDxwYXRoIGQ9Ik03IDExdjJoMTB2LTJIN3ptNS05QzYuNDggMiAyIDYuNDggMiAxMnM0LjQ4IDEwIDEwIDEwIDEwLTQuNDggMTAtMTBTMTcuNTIgMiAxMiAyem0wIDE4Yy00LjQxIDAtOC0zLjU5LTgtOHMzLjU5LTggOC04IDggMy41OSA4IDgtMy41OSA4LTggOHoiLz4KPC9zdmc+Cg==", OL = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjNkU4MTkyIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxwYXRoIGQ9Ik0wIDBoMjR2MjRIMHoiIGZpbGw9Im5vbmUiLz4KICAgIDxwYXRoIGQ9Ik0zIDVoMlYzYy0xLjEgMC0yIC45LTIgMnptMCA4aDJ2LTJIM3Yyem00IDhoMnYtMkg3djJ6TTMgOWgyVjdIM3Yyem0xMC02aC0ydjJoMlYzem02IDB2MmgyYzAtMS4xLS45LTItMi0yek01IDIxdi0ySDNjMCAxLjEuOSAyIDIgMnptLTItNGgydi0ySDN2MnpNOSAzSDd2MmgyVjN6bTIgMThoMnYtMmgtMnYyem04LThoMnYtMmgtMnYyem0wIDhjMS4xIDAgMi0uOSAyLTJoLTJ2MnptMC0xMmgyVjdoLTJ2MnptMCA4aDJ2LTJoLTJ2MnptLTQgNGgydi0yaC0ydjJ6bTAtMTZoMlYzaC0ydjJ6Ii8+Cjwvc3ZnPg==", xL = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBmaWxsPSJub25lIiBkPSJNMCAwaDI0djI0SDBWMHoiLz48cGF0aCBkPSJNMyAxOGgxOHYtMkgzdjJ6bTAtNWgxOHYtMkgzdjJ6bTAtN3YyaDE4VjZIM3oiLz48L3N2Zz4=";
class Mv {
  constructor(e) {
    this.ctx = e, this.w = e.w;
    const t = this.w;
    this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = t.globals.minX, this.maxX = t.globals.maxX;
  }
  createToolbar() {
    let e = this.w;
    const t = () => document.createElement("div"), i = t();
    if (i.setAttribute("class", "apexcharts-toolbar"), i.style.top = e.config.chart.toolbar.offsetY + "px", i.style.right = -e.config.chart.toolbar.offsetX + 3 + "px", e.globals.dom.elWrap.appendChild(i), this.elZoom = t(), this.elZoomIn = t(), this.elZoomOut = t(), this.elPan = t(), this.elSelection = t(), this.elZoomReset = t(), this.elMenuIcon = t(), this.elMenu = t(), this.elCustomIcons = [], this.t = e.config.chart.toolbar.tools, Array.isArray(this.t.customIcons))
      for (let l = 0; l < this.t.customIcons.length; l++)
        this.elCustomIcons.push(t());
    let s = [];
    const n = (l, c, d) => {
      const f = l.toLowerCase();
      this.t[f] && e.config.chart.zoom.enabled && s.push({
        el: c,
        icon: typeof this.t[f] == "string" ? this.t[f] : d,
        title: this.localeValues[l],
        class: `apexcharts-${f}-icon`
      });
    };
    n("zoomIn", this.elZoomIn, vL), n("zoomOut", this.elZoomOut, yL);
    const o = (l) => {
      this.t[l] && e.config.chart[l].enabled && s.push({
        el: l === "zoom" ? this.elZoom : this.elSelection,
        icon: typeof this.t[l] == "string" ? this.t[l] : l === "zoom" ? mL : OL,
        title: this.localeValues[l === "zoom" ? "selectionZoom" : "selection"],
        class: e.globals.isTouchDevice ? "apexcharts-element-hidden" : `apexcharts-${l}-icon`
      });
    };
    o("zoom"), o("selection"), this.t.pan && e.config.chart.zoom.enabled && s.push({
      el: this.elPan,
      icon: typeof this.t.pan == "string" ? this.t.pan : gL,
      title: this.localeValues.pan,
      class: e.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon"
    }), n("reset", this.elZoomReset, bL), this.t.download && s.push({
      el: this.elMenuIcon,
      icon: typeof this.t.download == "string" ? this.t.download : xL,
      title: this.localeValues.menu,
      class: "apexcharts-menu-icon"
    });
    for (let l = 0; l < this.elCustomIcons.length; l++)
      s.push({
        el: this.elCustomIcons[l],
        icon: this.t.customIcons[l].icon,
        title: this.t.customIcons[l].title,
        index: this.t.customIcons[l].index,
        class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[l].class
      });
    s.forEach((l, c) => {
      l.index && N.moveIndexInArray(s, c, l.index);
    });
    for (let l = 0; l < s.length; l++)
      K.setAttrs(s[l].el, {
        class: s[l].class,
        title: s[l].title
      }), s[l].el.innerHTML = s[l].icon, i.appendChild(s[l].el);
    this._createHamburgerMenu(i), e.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : e.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : e.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners();
  }
  _createHamburgerMenu(e) {
    this.elMenuItems = [], e.appendChild(this.elMenu), K.setAttrs(this.elMenu, {
      class: "apexcharts-menu"
    });
    const t = [
      {
        name: "exportSVG",
        title: this.localeValues.exportToSVG
      },
      {
        name: "exportPNG",
        title: this.localeValues.exportToPNG
      },
      {
        name: "exportCSV",
        title: this.localeValues.exportToCSV
      }
    ];
    for (let i = 0; i < t.length; i++)
      this.elMenuItems.push(document.createElement("div")), this.elMenuItems[i].innerHTML = t[i].title, K.setAttrs(this.elMenuItems[i], {
        class: `apexcharts-menu-item ${t[i].name}`,
        title: t[i].title
      }), this.elMenu.appendChild(this.elMenuItems[i]);
  }
  addToolbarEventListeners() {
    this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener(
      "click",
      this.toggleZoomSelection.bind(this, "selection")
    ), this.elZoom.addEventListener(
      "click",
      this.toggleZoomSelection.bind(this, "zoom")
    ), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach((e) => {
      e.classList.contains("exportSVG") ? e.addEventListener("click", this.handleDownload.bind(this, "svg")) : e.classList.contains("exportPNG") ? e.addEventListener("click", this.handleDownload.bind(this, "png")) : e.classList.contains("exportCSV") && e.addEventListener("click", this.handleDownload.bind(this, "csv"));
    });
    for (let e = 0; e < this.t.customIcons.length; e++)
      this.elCustomIcons[e].addEventListener(
        "click",
        this.t.customIcons[e].click.bind(this, this.ctx, this.ctx.w)
      );
  }
  toggleZoomSelection(e) {
    this.ctx.getSyncedCharts().forEach((i) => {
      i.ctx.toolbar.toggleOtherControls();
      let s = e === "selection" ? i.ctx.toolbar.elSelection : i.ctx.toolbar.elZoom, n = e === "selection" ? "selectionEnabled" : "zoomEnabled";
      i.w.globals[n] = !i.w.globals[n], s.classList.contains(i.ctx.toolbar.selectedClass) ? s.classList.remove(i.ctx.toolbar.selectedClass) : s.classList.add(i.ctx.toolbar.selectedClass);
    });
  }
  getToolbarIconsReference() {
    const e = this.w;
    this.elZoom || (this.elZoom = e.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = e.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = e.globals.dom.baseEl.querySelector(
      ".apexcharts-selection-icon"
    ));
  }
  enableZoomPanFromToolbar(e) {
    this.toggleOtherControls(), e === "pan" ? this.w.globals.panEnabled = !0 : this.w.globals.zoomEnabled = !0;
    const t = e === "pan" ? this.elPan : this.elZoom, i = e === "pan" ? this.elZoom : this.elPan;
    t && t.classList.add(this.selectedClass), i && i.classList.remove(this.selectedClass);
  }
  togglePanning() {
    this.ctx.getSyncedCharts().forEach((t) => {
      t.ctx.toolbar.toggleOtherControls(), t.w.globals.panEnabled = !t.w.globals.panEnabled, t.ctx.toolbar.elPan.classList.contains(t.ctx.toolbar.selectedClass) ? t.ctx.toolbar.elPan.classList.remove(t.ctx.toolbar.selectedClass) : t.ctx.toolbar.elPan.classList.add(t.ctx.toolbar.selectedClass);
    });
  }
  toggleOtherControls() {
    const e = this.w;
    e.globals.panEnabled = !1, e.globals.zoomEnabled = !1, e.globals.selectionEnabled = !1, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach((i) => {
      i && i.classList.remove(this.selectedClass);
    });
  }
  handleZoomIn() {
    const e = this.w;
    e.globals.isRangeBar && (this.minX = e.globals.minY, this.maxX = e.globals.maxY);
    const t = (this.minX + this.maxX) / 2;
    let i = (this.minX + t) / 2, s = (this.maxX + t) / 2;
    const n = this._getNewMinXMaxX(i, s);
    e.globals.disableZoomIn || this.zoomUpdateOptions(n.minX, n.maxX);
  }
  handleZoomOut() {
    const e = this.w;
    if (e.globals.isRangeBar && (this.minX = e.globals.minY, this.maxX = e.globals.maxY), e.config.xaxis.type === "datetime" && new Date(this.minX).getUTCFullYear() < 1e3)
      return;
    const t = (this.minX + this.maxX) / 2;
    let i = this.minX - (t - this.minX), s = this.maxX - (t - this.maxX);
    const n = this._getNewMinXMaxX(i, s);
    e.globals.disableZoomOut || this.zoomUpdateOptions(n.minX, n.maxX);
  }
  _getNewMinXMaxX(e, t) {
    const i = this.w.config.xaxis.convertedCatToNumeric;
    return {
      minX: i ? Math.floor(e) : e,
      maxX: i ? Math.floor(t) : t
    };
  }
  zoomUpdateOptions(e, t) {
    const i = this.w;
    if (e === void 0 && t === void 0) {
      this.handleZoomReset();
      return;
    }
    if (i.config.xaxis.convertedCatToNumeric && (e < 1 && (e = 1, t = i.globals.dataPoints), t - e < 2))
      return;
    let s = {
      min: e,
      max: t
    };
    const n = this.getBeforeZoomRange(s);
    n && (s = n.xaxis);
    let o = {
      xaxis: s
    }, l = N.clone(i.globals.initialConfig.yaxis);
    i.config.chart.group || (o.yaxis = l), this.w.globals.zoomed = !0, this.ctx.updateHelpers._updateOptions(
      o,
      !1,
      this.w.config.chart.animations.dynamicAnimation.enabled
    ), this.zoomCallback(s, l);
  }
  zoomCallback(e, t) {
    typeof this.ev.zoomed == "function" && this.ev.zoomed(this.ctx, { xaxis: e, yaxis: t });
  }
  getBeforeZoomRange(e, t) {
    let i = null;
    return typeof this.ev.beforeZoom == "function" && (i = this.ev.beforeZoom(this, { xaxis: e, yaxis: t })), i;
  }
  toggleMenu() {
    window.setTimeout(() => {
      this.elMenu.classList.contains("apexcharts-menu-open") ? this.elMenu.classList.remove("apexcharts-menu-open") : this.elMenu.classList.add("apexcharts-menu-open");
    }, 0);
  }
  handleDownload(e) {
    const t = this.w, i = new Eo(this.ctx);
    switch (e) {
      case "svg":
        i.exportToSVG(this.ctx);
        break;
      case "png":
        i.exportToPng(this.ctx);
        break;
      case "csv":
        i.exportToCSV({
          series: t.config.series,
          columnDelimiter: t.config.chart.toolbar.export.csv.columnDelimiter
        });
        break;
    }
  }
  handleZoomReset(e) {
    this.ctx.getSyncedCharts().forEach((i) => {
      let s = i.w;
      if (s.globals.lastXAxis.min = s.globals.initialConfig.xaxis.min, s.globals.lastXAxis.max = s.globals.initialConfig.xaxis.max, i.updateHelpers.revertDefaultAxisMinMax(), typeof s.config.chart.events.beforeResetZoom == "function") {
        const o = s.config.chart.events.beforeResetZoom(i, s);
        o && i.updateHelpers.revertDefaultAxisMinMax(o);
      }
      typeof s.config.chart.events.zoomed == "function" && i.ctx.toolbar.zoomCallback({
        min: s.config.xaxis.min,
        max: s.config.xaxis.max
      }), s.globals.zoomed = !1;
      let n = i.ctx.series.emptyCollapsedSeries(
        N.clone(s.globals.initialSeries)
      );
      i.updateHelpers._updateSeries(
        n,
        s.config.chart.animations.dynamicAnimation.enabled
      );
    });
  }
  destroy() {
    this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null;
  }
}
class wL extends Mv {
  constructor(e) {
    super(e), this.ctx = e, this.w = e.w, this.dragged = !1, this.graphics = new K(this.ctx), this.eventList = [
      "mousedown",
      "mouseleave",
      "mousemove",
      "touchstart",
      "touchmove",
      "mouseup",
      "touchend"
    ], this.clientX = 0, this.clientY = 0, this.startX = 0, this.endX = 0, this.dragX = 0, this.startY = 0, this.endY = 0, this.dragY = 0, this.moveDirection = "none";
  }
  init({ xyRatios: e }) {
    let t = this.w, i = this;
    this.xyRatios = e, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = t.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), t.globals.dom.elGraphical.add(this.zoomRect), t.globals.dom.elGraphical.add(this.selectionRect), t.config.chart.selection.type === "x" ? this.slDraggableRect = this.selectionRect.draggable({
      minX: 0,
      minY: 0,
      maxX: t.globals.gridWidth,
      maxY: t.globals.gridHeight
    }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : t.config.chart.selection.type === "y" ? this.slDraggableRect = this.selectionRect.draggable({
      minX: 0,
      maxX: t.globals.gridWidth
    }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = t.globals.dom.baseEl.querySelector(
      `${t.globals.chartClass} .apexcharts-svg`
    ), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach((s) => {
      this.hoverArea.addEventListener(
        s,
        i.svgMouseEvents.bind(i, e),
        {
          capture: !1,
          passive: !0
        }
      );
    });
  }
  // remove the event listeners which were previously added on hover area
  destroy() {
    this.slDraggableRect && (this.slDraggableRect.draggable(!1), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null;
  }
  svgMouseEvents(e, t) {
    let i = this.w, s = this;
    const n = this.ctx.toolbar;
    let o = i.globals.zoomEnabled ? i.config.chart.zoom.type : i.config.chart.selection.type;
    const l = i.config.chart.toolbar.autoSelected;
    if (t.shiftKey ? (this.shiftWasPressed = !0, n.enableZoomPanFromToolbar(l === "pan" ? "zoom" : "pan")) : this.shiftWasPressed && (n.enableZoomPanFromToolbar(l), this.shiftWasPressed = !1), !t.target)
      return;
    const c = t.target.classList;
    let d;
    if (t.target.parentNode && t.target.parentNode !== null && (d = t.target.parentNode.classList), !(c.contains("apexcharts-selection-rect") || c.contains("apexcharts-legend-marker") || c.contains("apexcharts-legend-text") || d && d.contains("apexcharts-toolbar"))) {
      if (s.clientX = t.type === "touchmove" || t.type === "touchstart" ? t.touches[0].clientX : t.type === "touchend" ? t.changedTouches[0].clientX : t.clientX, s.clientY = t.type === "touchmove" || t.type === "touchstart" ? t.touches[0].clientY : t.type === "touchend" ? t.changedTouches[0].clientY : t.clientY, (t.type === "mousedown" || t.type === "touchmove") && t.which === 1) {
        let p = s.gridRect.getBoundingClientRect();
        s.startX = s.clientX - p.left, s.startY = s.clientY - p.top, s.dragged = !1, s.w.globals.mousedown = !0;
      }
      if (t.type === "mousemove" && t.which === 1 || t.type === "touchmove")
        if (s.dragged = !0, i.globals.panEnabled) {
          if (i.globals.selection = null, s.w.globals.mousedown || t.type === "touchmove") {
            if (t.type === "touchmove" && !s.w.globals.mousedown) {
              console.warn("me.w.globals.mousedown ", s.w.globals.mousedown);
              let p = s.gridRect.getBoundingClientRect();
              s.startX = s.clientX - p.left, s.startY = s.clientY - p.top, s.w.globals.mousedown = !0;
            }
            s.panDragging({
              context: s,
              zoomtype: o,
              xyRatios: e
            });
          }
        } else {
          if (t.type === "touchmove") {
            if (!s.w.globals.mousedown) {
              let p = s.gridRect.getBoundingClientRect();
              s.startX = s.clientX - p.left, s.startY = s.clientY - p.top;
            }
            s.w.globals.mousedown = !0;
          }
          (s.w.globals.mousedown && i.globals.zoomEnabled || s.w.globals.mousedown && i.globals.selectionEnabled) && (s.selection = s.selectionDrawing({
            context: s,
            zoomtype: o
          }));
        }
      if (t.type === "mouseup" || t.type === "touchend" || t.type === "mouseleave") {
        let p = s.gridRect.getBoundingClientRect();
        s.w.globals.mousedown && (s.endX = s.clientX - p.left, s.endY = s.clientY - p.top, s.dragX = Math.abs(s.endX - s.startX), s.dragY = Math.abs(s.endY - s.startY), (i.globals.zoomEnabled || i.globals.selectionEnabled) && s.selectionDrawn({
          context: s,
          zoomtype: o
        }), i.globals.panEnabled && i.config.xaxis.convertedCatToNumeric && s.delayedPanScrolled()), i.globals.zoomEnabled && s.hideSelectionRect(this.selectionRect), s.dragged = !1, s.w.globals.mousedown = !1;
      }
      this.makeSelectionRectDraggable();
    }
  }
  makeSelectionRectDraggable() {
    const e = this.w;
    if (!this.selectionRect)
      return;
    const t = this.selectionRect.node.getBoundingClientRect();
    t.width > 0 && t.height > 0 && this.slDraggableRect.selectize({
      points: "l, r",
      pointSize: 8,
      pointType: "rect"
    }).resize({
      constraint: {
        minX: 0,
        minY: 0,
        maxX: e.globals.gridWidth,
        maxY: e.globals.gridHeight
      }
    }).on("resizing", this.selectionDragging.bind(this, "resizing"));
  }
  preselectedSelection() {
    const e = this.w, t = this.xyRatios;
    if (!e.globals.zoomEnabled) {
      if (typeof e.globals.selection < "u" && e.globals.selection !== null)
        this.drawSelectionRect(e.globals.selection);
      else if (e.config.chart.selection.xaxis.min !== void 0 && e.config.chart.selection.xaxis.max !== void 0) {
        let i = (e.config.chart.selection.xaxis.min - e.globals.minX) / t.xRatio, s = e.globals.gridWidth - (e.globals.maxX - e.config.chart.selection.xaxis.max) / t.xRatio - i;
        e.globals.isRangeBar && (i = // calculation: (selection left time - chart left time) / milliseconds per pixel = selection X value in pixels
        (e.config.chart.selection.xaxis.min - e.globals.yAxisScale[0].niceMin) / t.invertedYRatio, s = (e.config.chart.selection.xaxis.max - e.config.chart.selection.xaxis.min) / t.invertedYRatio);
        let n = {
          x: i,
          y: 0,
          width: s,
          height: e.globals.gridHeight,
          translateX: 0,
          translateY: 0,
          selectionEnabled: !0
        };
        this.drawSelectionRect(n), this.makeSelectionRectDraggable(), typeof e.config.chart.events.selection == "function" && e.config.chart.events.selection(this.ctx, {
          xaxis: {
            min: e.config.chart.selection.xaxis.min,
            max: e.config.chart.selection.xaxis.max
          },
          yaxis: {}
        });
      }
    }
  }
  drawSelectionRect({ x: e, y: t, width: i, height: s, translateX: n = 0, translateY: o = 0 }) {
    const l = this.w, c = this.zoomRect, d = this.selectionRect;
    if (this.dragged || l.globals.selection !== null) {
      let f = {
        transform: "translate(" + n + ", " + o + ")"
      };
      l.globals.zoomEnabled && this.dragged && (i < 0 && (i = 1), c.attr({
        x: e,
        y: t,
        width: i,
        height: s,
        fill: l.config.chart.zoom.zoomedArea.fill.color,
        "fill-opacity": l.config.chart.zoom.zoomedArea.fill.opacity,
        stroke: l.config.chart.zoom.zoomedArea.stroke.color,
        "stroke-width": l.config.chart.zoom.zoomedArea.stroke.width,
        "stroke-opacity": l.config.chart.zoom.zoomedArea.stroke.opacity
      }), K.setAttrs(c.node, f)), l.globals.selectionEnabled && (d.attr({
        x: e,
        y: t,
        width: i > 0 ? i : 0,
        height: s > 0 ? s : 0,
        fill: l.config.chart.selection.fill.color,
        "fill-opacity": l.config.chart.selection.fill.opacity,
        stroke: l.config.chart.selection.stroke.color,
        "stroke-width": l.config.chart.selection.stroke.width,
        "stroke-dasharray": l.config.chart.selection.stroke.dashArray,
        "stroke-opacity": l.config.chart.selection.stroke.opacity
      }), K.setAttrs(d.node, f));
    }
  }
  hideSelectionRect(e) {
    e && e.attr({
      x: 0,
      y: 0,
      width: 0,
      height: 0
    });
  }
  selectionDrawing({ context: e, zoomtype: t }) {
    const i = this.w;
    let s = e, n = this.gridRect.getBoundingClientRect(), o = s.startX - 1, l = s.startY, c = !1, d = !1, f = s.clientX - n.left - o, p = s.clientY - n.top - l, m = {};
    return Math.abs(f + o) > i.globals.gridWidth ? f = i.globals.gridWidth - o : s.clientX - n.left < 0 && (f = o), o > s.clientX - n.left && (c = !0, f = Math.abs(f)), l > s.clientY - n.top && (d = !0, p = Math.abs(p)), t === "x" ? m = {
      x: c ? o - f : o,
      y: 0,
      width: f,
      height: i.globals.gridHeight
    } : t === "y" ? m = {
      x: 0,
      y: d ? l - p : l,
      width: i.globals.gridWidth,
      height: p
    } : m = {
      x: c ? o - f : o,
      y: d ? l - p : l,
      width: f,
      height: p
    }, s.drawSelectionRect(m), s.selectionDragging("resizing"), m;
  }
  selectionDragging(e, t) {
    const i = this.w, s = this.xyRatios, n = this.selectionRect;
    let o = 0;
    e === "resizing" && (o = 30);
    const l = (d) => parseFloat(n.node.getAttribute(d)), c = {
      x: l("x"),
      y: l("y"),
      width: l("width"),
      height: l("height")
    };
    i.globals.selection = c, typeof i.config.chart.events.selection == "function" && i.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout(() => {
      const d = this.gridRect.getBoundingClientRect(), f = n.node.getBoundingClientRect();
      let p, m, v, r;
      i.globals.isRangeBar ? (p = i.globals.yAxisScale[0].niceMin + (f.left - d.left) * s.invertedYRatio, m = i.globals.yAxisScale[0].niceMin + (f.right - d.left) * s.invertedYRatio, v = 0, r = 1) : (p = i.globals.xAxisScale.niceMin + (f.left - d.left) * s.xRatio, m = i.globals.xAxisScale.niceMin + (f.right - d.left) * s.xRatio, v = i.globals.yAxisScale[0].niceMin + (d.bottom - f.bottom) * s.yRatio[0], r = i.globals.yAxisScale[0].niceMax - (f.top - d.top) * s.yRatio[0]);
      const h = {
        xaxis: {
          min: p,
          max: m
        },
        yaxis: {
          min: v,
          max: r
        }
      };
      i.config.chart.events.selection(this.ctx, h), i.config.chart.brush.enabled && i.config.chart.events.brushScrolled !== void 0 && i.config.chart.events.brushScrolled(this.ctx, h);
    }, o));
  }
  selectionDrawn({ context: e, zoomtype: t }) {
    const i = this.w, s = e, n = this.xyRatios, o = this.ctx.toolbar;
    if (s.startX > s.endX) {
      let p = s.startX;
      s.startX = s.endX, s.endX = p;
    }
    if (s.startY > s.endY) {
      let p = s.startY;
      s.startY = s.endY, s.endY = p;
    }
    let l, c;
    i.globals.isRangeBar ? (l = i.globals.yAxisScale[0].niceMin + s.startX * n.invertedYRatio, c = i.globals.yAxisScale[0].niceMin + s.endX * n.invertedYRatio) : (l = i.globals.xAxisScale.niceMin + s.startX * n.xRatio, c = i.globals.xAxisScale.niceMin + s.endX * n.xRatio);
    let d = [], f = [];
    if (i.config.yaxis.forEach((p, m) => {
      let v = i.globals.seriesYAxisMap[m][0];
      d.push(
        i.globals.yAxisScale[m].niceMax - n.yRatio[v] * s.startY
      ), f.push(
        i.globals.yAxisScale[m].niceMax - n.yRatio[v] * s.endY
      );
    }), s.dragged && (s.dragX > 10 || s.dragY > 10) && l !== c) {
      if (i.globals.zoomEnabled) {
        let p = N.clone(i.globals.initialConfig.yaxis), m = N.clone(i.globals.initialConfig.xaxis);
        if (i.globals.zoomed = !0, i.config.xaxis.convertedCatToNumeric && (l = Math.floor(l), c = Math.floor(c), l < 1 && (l = 1, c = i.globals.dataPoints), c - l < 2 && (c = l + 1)), (t === "xy" || t === "x") && (m = {
          min: l,
          max: c
        }), (t === "xy" || t === "y") && p.forEach((r, h) => {
          p[h].min = f[h], p[h].max = d[h];
        }), o) {
          let r = o.getBeforeZoomRange(m, p);
          r && (m = r.xaxis ? r.xaxis : m, p = r.yaxis ? r.yaxis : p);
        }
        let v = {
          xaxis: m
        };
        i.config.chart.group || (v.yaxis = p), s.ctx.updateHelpers._updateOptions(
          v,
          !1,
          s.w.config.chart.animations.dynamicAnimation.enabled
        ), typeof i.config.chart.events.zoomed == "function" && o.zoomCallback(m, p);
      } else if (i.globals.selectionEnabled) {
        let p = null, m = null;
        m = {
          min: l,
          max: c
        }, (t === "xy" || t === "y") && (p = N.clone(i.config.yaxis), p.forEach((v, r) => {
          p[r].min = f[r], p[r].max = d[r];
        })), i.globals.selection = s.selection, typeof i.config.chart.events.selection == "function" && i.config.chart.events.selection(s.ctx, {
          xaxis: m,
          yaxis: p
        });
      }
    }
  }
  panDragging({ context: e }) {
    const t = this.w;
    let i = e;
    if (typeof t.globals.lastClientPosition.x < "u") {
      const o = t.globals.lastClientPosition.x - i.clientX, l = t.globals.lastClientPosition.y - i.clientY;
      Math.abs(o) > Math.abs(l) && o > 0 ? this.moveDirection = "left" : Math.abs(o) > Math.abs(l) && o < 0 ? this.moveDirection = "right" : Math.abs(l) > Math.abs(o) && l > 0 ? this.moveDirection = "up" : Math.abs(l) > Math.abs(o) && l < 0 && (this.moveDirection = "down");
    }
    t.globals.lastClientPosition = {
      x: i.clientX,
      y: i.clientY
    };
    let s = t.globals.isRangeBar ? t.globals.minY : t.globals.minX, n = t.globals.isRangeBar ? t.globals.maxY : t.globals.maxX;
    t.config.xaxis.convertedCatToNumeric || i.panScrolled(s, n);
  }
  delayedPanScrolled() {
    const e = this.w;
    let t = e.globals.minX, i = e.globals.maxX;
    const s = (e.globals.maxX - e.globals.minX) / 2;
    this.moveDirection === "left" ? (t = e.globals.minX + s, i = e.globals.maxX + s) : this.moveDirection === "right" && (t = e.globals.minX - s, i = e.globals.maxX - s), t = Math.floor(t), i = Math.floor(i), this.updateScrolledChart(
      { xaxis: { min: t, max: i } },
      t,
      i
    );
  }
  panScrolled(e, t) {
    const i = this.w, s = this.xyRatios;
    let n = N.clone(i.globals.initialConfig.yaxis), o = s.xRatio, l = i.globals.minX, c = i.globals.maxX;
    i.globals.isRangeBar && (o = s.invertedYRatio, l = i.globals.minY, c = i.globals.maxY), this.moveDirection === "left" ? (e = l + i.globals.gridWidth / 15 * o, t = c + i.globals.gridWidth / 15 * o) : this.moveDirection === "right" && (e = l - i.globals.gridWidth / 15 * o, t = c - i.globals.gridWidth / 15 * o), i.globals.isRangeBar || (e < i.globals.initialMinX || t > i.globals.initialMaxX) && (e = l, t = c);
    let d = {
      xaxis: {
        min: e,
        max: t
      }
    };
    i.config.chart.group || (d.yaxis = n), this.updateScrolledChart(d, e, t);
  }
  updateScrolledChart(e, t, i) {
    const s = this.w;
    this.ctx.updateHelpers._updateOptions(e, !1, !1), typeof s.config.chart.events.scrolled == "function" && s.config.chart.events.scrolled(this.ctx, {
      xaxis: {
        min: t,
        max: i
      }
    });
  }
}
class Dv {
  constructor(e) {
    this.w = e.w, this.ttCtx = e, this.ctx = e.ctx;
  }
  /**
   ** When hovering over series, you need to capture which series is being hovered on.
   ** This function will return both capturedseries index as well as inner index of that series
   * @memberof Utils
   * @param {object}
   * - hoverArea = the rect on which user hovers
   * - elGrid = dimensions of the hover rect (it can be different than hoverarea)
   */
  getNearestValues({ hoverArea: e, elGrid: t, clientX: i, clientY: s }) {
    let n = this.w;
    const o = t.getBoundingClientRect(), l = o.width, c = o.height;
    let d = l / (n.globals.dataPoints - 1), f = c / n.globals.dataPoints;
    const p = this.hasBars();
    (n.globals.comboCharts || p) && !n.config.xaxis.convertedCatToNumeric && (d = l / n.globals.dataPoints);
    let m = i - o.left - n.globals.barPadForNumericAxis, v = s - o.top;
    m < 0 || v < 0 || m > l || v > c ? (e.classList.remove("hovering-zoom"), e.classList.remove("hovering-pan")) : n.globals.zoomEnabled ? (e.classList.remove("hovering-pan"), e.classList.add("hovering-zoom")) : n.globals.panEnabled && (e.classList.remove("hovering-zoom"), e.classList.add("hovering-pan"));
    let h = Math.round(m / d), u = Math.floor(v / f);
    p && !n.config.xaxis.convertedCatToNumeric && (h = Math.ceil(m / d), h = h - 1);
    let g = null, b = null, O = n.globals.seriesXvalues.map((S) => S.filter((k) => N.isNumber(k))), x = n.globals.seriesYvalues.map((S) => S.filter((k) => N.isNumber(k)));
    if (n.globals.isXNumeric) {
      const k = this.ttCtx.getElGrid().getBoundingClientRect(), C = m * (k.width / l), _ = v * (k.height / c);
      b = this.closestInMultiArray(
        C,
        _,
        O,
        x
      ), g = b.index, h = b.j, g !== null && (O = n.globals.seriesXvalues[g], b = this.closestInArray(C, O), h = b.index);
    }
    return n.globals.capturedSeriesIndex = g === null ? -1 : g, (!h || h < 1) && (h = 0), n.globals.isBarHorizontal ? n.globals.capturedDataPointIndex = u : n.globals.capturedDataPointIndex = h, {
      capturedSeries: g,
      j: n.globals.isBarHorizontal ? u : h,
      hoverX: m,
      hoverY: v
    };
  }
  closestInMultiArray(e, t, i, s) {
    let n = this.w, o = 0, l = null, c = -1;
    n.globals.series.length > 1 ? o = this.getFirstActiveXArray(i) : l = 0;
    let d = i[o][0], f = Math.abs(e - d);
    if (i.forEach((p) => {
      p.forEach((m, v) => {
        const r = Math.abs(e - m);
        r <= f && (f = r, c = v);
      });
    }), c !== -1) {
      let p = s[o][c], m = Math.abs(t - p);
      l = o, s.forEach((v, r) => {
        const h = Math.abs(t - v[c]);
        h <= m && (m = h, l = r);
      });
    }
    return {
      index: l,
      j: c
    };
  }
  getFirstActiveXArray(e) {
    const t = this.w;
    let i = 0, s = e.map((n, o) => n.length > 0 ? o : -1);
    for (let n = 0; n < s.length; n++)
      if (s[n] !== -1 && t.globals.collapsedSeriesIndices.indexOf(n) === -1 && t.globals.ancillaryCollapsedSeriesIndices.indexOf(n) === -1) {
        i = s[n];
        break;
      }
    return i;
  }
  closestInArray(e, t) {
    let i = t[0], s = null, n = Math.abs(e - i);
    for (let o = 0; o < t.length; o++) {
      let l = Math.abs(e - t[o]);
      l < n && (n = l, s = o);
    }
    return {
      index: s
    };
  }
  /**
   * When there are multiple series, it is possible to have different x values for each series.
   * But it may be possible in those multiple series, that there is same x value for 2 or more
   * series.
   * @memberof Utils
   * @param {int}
   * - j = is the inner index of series -> (series[i][j])
   * @return {bool}
   */
  isXoverlap(e) {
    let t = this.w, i = [];
    const s = t.globals.seriesX.filter((n) => typeof n[0] < "u");
    if (s.length > 0)
      for (let n = 0; n < s.length - 1; n++)
        typeof s[n][e] < "u" && typeof s[n + 1][e] < "u" && s[n][e] !== s[n + 1][e] && i.push("unEqual");
    return i.length === 0;
  }
  isInitialSeriesSameLen() {
    let e = !0;
    const t = this.w.globals.initialSeries;
    for (let i = 0; i < t.length - 1; i++)
      if (t[i].data.length !== t[i + 1].data.length) {
        e = !1;
        break;
      }
    return e;
  }
  getBarsHeight(e) {
    return [...e].reduce((s, n) => s + n.getBBox().height, 0);
  }
  getElMarkers(e) {
    return typeof e == "number" ? this.w.globals.dom.baseEl.querySelectorAll(
      `.apexcharts-series[data\\:realIndex='${e}'] .apexcharts-series-markers-wrap > *`
    ) : this.w.globals.dom.baseEl.querySelectorAll(
      ".apexcharts-series-markers-wrap > *"
    );
  }
  getAllMarkers() {
    let e = this.w.globals.dom.baseEl.querySelectorAll(
      ".apexcharts-series-markers-wrap"
    );
    e = [...e], e.sort((i, s) => {
      var n = Number(i.getAttribute("data:realIndex")), o = Number(s.getAttribute("data:realIndex"));
      return o < n ? 1 : o > n ? -1 : 0;
    });
    let t = [];
    return e.forEach((i) => {
      t.push(i.querySelector(".apexcharts-marker"));
    }), t;
  }
  hasMarkers(e) {
    return this.getElMarkers(e).length > 0;
  }
  getElBars() {
    return this.w.globals.dom.baseEl.querySelectorAll(
      ".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series"
    );
  }
  hasBars() {
    return this.getElBars().length > 0;
  }
  getHoverMarkerSize(e) {
    const t = this.w;
    let i = t.config.markers.hover.size;
    return i === void 0 && (i = t.globals.markers.size[e] + t.config.markers.hover.sizeOffset), i;
  }
  toggleAllTooltipSeriesGroups(e) {
    let t = this.w;
    const i = this.ttCtx;
    i.allTooltipSeriesGroups.length === 0 && (i.allTooltipSeriesGroups = t.globals.dom.baseEl.querySelectorAll(
      ".apexcharts-tooltip-series-group"
    ));
    let s = i.allTooltipSeriesGroups;
    for (let n = 0; n < s.length; n++)
      e === "enable" ? (s[n].classList.add("apexcharts-active"), s[n].style.display = t.config.tooltip.items.display) : (s[n].classList.remove("apexcharts-active"), s[n].style.display = "none");
  }
}
class SL {
  constructor(e) {
    this.w = e.w, this.ctx = e.ctx, this.ttCtx = e, this.tooltipUtil = new Dv(e);
  }
  drawSeriesTexts({ shared: e = !0, ttItems: t, i = 0, j: s = null, y1: n, y2: o, e: l }) {
    let c = this.w;
    c.config.tooltip.custom !== void 0 ? this.handleCustomTooltip({ i, j: s, y1: n, y2: o, w: c }) : this.toggleActiveInactiveSeries(e);
    let d = this.getValuesToPrint({
      i,
      j: s
    });
    this.printLabels({
      i,
      j: s,
      values: d,
      ttItems: t,
      shared: e,
      e: l
    });
    const f = this.ttCtx.getElTooltip();
    this.ttCtx.tooltipRect.ttWidth = f.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = f.getBoundingClientRect().height;
  }
  printLabels({ i: e, j: t, values: i, ttItems: s, shared: n, e: o }) {
    var u;
    const l = this.w;
    let c, d = [];
    const f = (g) => l.globals.seriesGoals[g] && l.globals.seriesGoals[g][t] && Array.isArray(l.globals.seriesGoals[g][t]), { xVal: p, zVal: m, xAxisTTVal: v } = i;
    let r = "", h = l.globals.colors[e];
    t !== null && l.config.plotOptions.bar.distributed && (h = l.globals.colors[t]);
    for (let g = 0, b = l.globals.series.length - 1; g < l.globals.series.length; g++, b--) {
      let O = this.getFormatters(e);
      r = this.getSeriesName({
        fn: O.yLbTitleFormatter,
        index: e,
        seriesIndex: e,
        j: t
      }), l.config.chart.type === "treemap" && (r = O.yLbTitleFormatter(String(l.config.series[e].data[t].x), {
        series: l.globals.series,
        seriesIndex: e,
        dataPointIndex: t,
        w: l
      }));
      const x = l.config.tooltip.inverseOrder ? b : g;
      if (l.globals.axisCharts) {
        const S = (k) => {
          var C, _, $, L;
          return l.globals.isRangeData ? O.yLbFormatter((_ = (C = l.globals.seriesRangeStart) == null ? void 0 : C[k]) == null ? void 0 : _[t], {
            series: l.globals.seriesRangeStart,
            seriesIndex: k,
            dataPointIndex: t,
            w: l
          }) + " - " + O.yLbFormatter((L = ($ = l.globals.seriesRangeEnd) == null ? void 0 : $[k]) == null ? void 0 : L[t], {
            series: l.globals.seriesRangeEnd,
            seriesIndex: k,
            dataPointIndex: t,
            w: l
          }) : O.yLbFormatter(l.globals.series[k][t], {
            series: l.globals.series,
            seriesIndex: k,
            dataPointIndex: t,
            w: l
          });
        };
        if (n)
          O = this.getFormatters(x), r = this.getSeriesName({
            fn: O.yLbTitleFormatter,
            index: x,
            seriesIndex: e,
            j: t
          }), h = l.globals.colors[x], c = S(x), f(x) && (d = l.globals.seriesGoals[x][t].map((k) => ({
            attrs: k,
            val: O.yLbFormatter(k.value, {
              seriesIndex: x,
              dataPointIndex: t,
              w: l
            })
          })));
        else {
          const k = (u = o == null ? void 0 : o.target) == null ? void 0 : u.getAttribute("fill");
          k && (h = k.indexOf("url") !== -1 ? document.querySelector(k.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke") : k), c = S(e), f(e) && Array.isArray(l.globals.seriesGoals[e][t]) && (d = l.globals.seriesGoals[e][t].map((C) => ({
            attrs: C,
            val: O.yLbFormatter(C.value, {
              seriesIndex: e,
              dataPointIndex: t,
              w: l
            })
          })));
        }
      }
      t === null && (c = O.yLbFormatter(l.globals.series[e], {
        ...l,
        seriesIndex: e,
        dataPointIndex: e
      })), this.DOMHandling({
        i: e,
        t: x,
        j: t,
        ttItems: s,
        values: {
          val: c,
          goalVals: d,
          xVal: p,
          xAxisTTVal: v,
          zVal: m
        },
        seriesName: r,
        shared: n,
        pColor: h
      });
    }
  }
  getFormatters(e) {
    const t = this.w;
    let i = t.globals.yLabelFormatters[e], s;
    return t.globals.ttVal !== void 0 ? Array.isArray(t.globals.ttVal) ? (i = t.globals.ttVal[e] && t.globals.ttVal[e].formatter, s = t.globals.ttVal[e] && t.globals.ttVal[e].title && t.globals.ttVal[e].title.formatter) : (i = t.globals.ttVal.formatter, typeof t.globals.ttVal.title.formatter == "function" && (s = t.globals.ttVal.title.formatter)) : s = t.config.tooltip.y.title.formatter, typeof i != "function" && (t.globals.yLabelFormatters[0] ? i = t.globals.yLabelFormatters[0] : i = function(n) {
      return n;
    }), typeof s != "function" && (s = function(n) {
      return n;
    }), {
      yLbFormatter: i,
      yLbTitleFormatter: s
    };
  }
  getSeriesName({ fn: e, index: t, seriesIndex: i, j: s }) {
    const n = this.w;
    return e(String(n.globals.seriesNames[t]), {
      series: n.globals.series,
      seriesIndex: i,
      dataPointIndex: s,
      w: n
    });
  }
  DOMHandling({ i: e, t, j: i, ttItems: s, values: n, seriesName: o, shared: l, pColor: c }) {
    const d = this.w, f = this.ttCtx, { val: p, goalVals: m, xVal: v, xAxisTTVal: r, zVal: h } = n;
    let u = null;
    u = s[t].children, d.config.tooltip.fillSeriesColor && (s[t].style.backgroundColor = c, u[0].style.display = "none"), f.showTooltipTitle && (f.tooltipTitle === null && (f.tooltipTitle = d.globals.dom.baseEl.querySelector(
      ".apexcharts-tooltip-title"
    )), f.tooltipTitle.innerHTML = v), f.isXAxisTooltipEnabled && (f.xaxisTooltipText.innerHTML = r !== "" ? r : v);
    const g = s[t].querySelector(
      ".apexcharts-tooltip-text-y-label"
    );
    g && (g.innerHTML = o || "");
    const b = s[t].querySelector(".apexcharts-tooltip-text-y-value");
    b && (b.innerHTML = typeof p < "u" ? p : ""), u[0] && u[0].classList.contains("apexcharts-tooltip-marker") && (d.config.tooltip.marker.fillColors && Array.isArray(d.config.tooltip.marker.fillColors) && (c = d.config.tooltip.marker.fillColors[t]), u[0].style.backgroundColor = c), d.config.tooltip.marker.show || (u[0].style.display = "none");
    const O = s[t].querySelector(
      ".apexcharts-tooltip-text-goals-label"
    ), x = s[t].querySelector(
      ".apexcharts-tooltip-text-goals-value"
    );
    if (m.length && d.globals.seriesGoals[t]) {
      const S = () => {
        let k = "<div >", C = "<div>";
        m.forEach((_, $) => {
          k += ` <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: ${_.attrs.strokeColor}; height: 3px; border-radius: 0; top: 5px;"></span> ${_.attrs.name}</div>`, C += `<div>${_.val}</div>`;
        }), O.innerHTML = k + "</div>", x.innerHTML = C + "</div>";
      };
      l ? d.globals.seriesGoals[t][i] && Array.isArray(d.globals.seriesGoals[t][i]) ? S() : (O.innerHTML = "", x.innerHTML = "") : S();
    } else
      O.innerHTML = "", x.innerHTML = "";
    if (h !== null) {
      const S = s[t].querySelector(
        ".apexcharts-tooltip-text-z-label"
      );
      S.innerHTML = d.config.tooltip.z.title;
      const k = s[t].querySelector(
        ".apexcharts-tooltip-text-z-value"
      );
      k.innerHTML = typeof h < "u" ? h : "";
    }
    if (l && u[0]) {
      if (d.config.tooltip.hideEmptySeries) {
        let S = s[t].querySelector(
          ".apexcharts-tooltip-marker"
        ), k = s[t].querySelector(".apexcharts-tooltip-text");
        parseFloat(p) == 0 ? (S.style.display = "none", k.style.display = "none") : (S.style.display = "block", k.style.display = "block");
      }
      typeof p > "u" || p === null || d.globals.ancillaryCollapsedSeriesIndices.indexOf(t) > -1 || d.globals.collapsedSeriesIndices.indexOf(t) > -1 ? u[0].parentNode.style.display = "none" : u[0].parentNode.style.display = d.config.tooltip.items.display;
    }
  }
  toggleActiveInactiveSeries(e) {
    const t = this.w;
    if (e)
      this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
    else {
      this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
      let i = t.globals.dom.baseEl.querySelector(
        ".apexcharts-tooltip-series-group"
      );
      i && (i.classList.add("apexcharts-active"), i.style.display = t.config.tooltip.items.display);
    }
  }
  getValuesToPrint({ i: e, j: t }) {
    const i = this.w, s = this.ctx.series.filteredSeriesX();
    let n = "", o = "", l = null, c = null;
    const d = {
      series: i.globals.series,
      seriesIndex: e,
      dataPointIndex: t,
      w: i
    };
    let f = i.globals.ttZFormatter;
    if (t === null)
      c = i.globals.series[e];
    else if (i.globals.isXNumeric && i.config.chart.type !== "treemap") {
      if (n = s[e][t], s[e].length === 0) {
        const m = this.tooltipUtil.getFirstActiveXArray(s);
        n = s[m][t];
      }
    } else
      n = typeof i.globals.labels[t] < "u" ? i.globals.labels[t] : "";
    let p = n;
    return i.globals.isXNumeric && i.config.xaxis.type === "datetime" ? n = new ba(this.ctx).xLabelFormat(
      i.globals.ttKeyFormatter,
      p,
      p,
      {
        i: void 0,
        dateFormatter: new Tt(this.ctx).formatDate,
        w: this.w
      }
    ) : i.globals.isBarHorizontal ? n = i.globals.yLabelFormatters[0](p, d) : n = i.globals.xLabelFormatter(p, d), i.config.tooltip.x.formatter !== void 0 && (n = i.globals.ttKeyFormatter(p, d)), i.globals.seriesZ.length > 0 && i.globals.seriesZ[e].length > 0 && (l = f(i.globals.seriesZ[e][t], i)), typeof i.config.xaxis.tooltip.formatter == "function" ? o = i.globals.xaxisTooltipFormatter(
      p,
      d
    ) : o = n, {
      val: Array.isArray(c) ? c.join(" ") : c,
      xVal: Array.isArray(n) ? n.join(" ") : n,
      xAxisTTVal: Array.isArray(o) ? o.join(" ") : o,
      zVal: l
    };
  }
  handleCustomTooltip({ i: e, j: t, y1: i, y2: s, w: n }) {
    const o = this.ttCtx.getElTooltip();
    let l = n.config.tooltip.custom;
    Array.isArray(l) && l[e] && (l = l[e]), o.innerHTML = l({
      ctx: this.ctx,
      series: n.globals.series,
      seriesIndex: e,
      dataPointIndex: t,
      y1: i,
      y2: s,
      w: n
    });
  }
}
class Rv {
  constructor(e) {
    this.ttCtx = e, this.ctx = e.ctx, this.w = e.w;
  }
  /**
   * This will move the crosshair (the vertical/horz line that moves along with mouse)
   * Along with this, this function also calls the xaxisMove function
   * @memberof Position
   * @param {int} - cx = point's x position, wherever point's x is, you need to move crosshair
   */
  moveXCrosshairs(e, t = null) {
    const i = this.ttCtx;
    let s = this.w;
    const n = i.getElXCrosshairs();
    let o = e - i.xcrosshairsWidth / 2, l = s.globals.labels.slice().length;
    if (t !== null && (o = s.globals.gridWidth / l * t), n !== null && !s.globals.isBarHorizontal && (n.setAttribute("x", o), n.setAttribute("x1", o), n.setAttribute("x2", o), n.setAttribute("y2", s.globals.gridHeight), n.classList.add("apexcharts-active")), o < 0 && (o = 0), o > s.globals.gridWidth && (o = s.globals.gridWidth), i.isXAxisTooltipEnabled) {
      let c = o;
      (s.config.xaxis.crosshairs.width === "tickWidth" || s.config.xaxis.crosshairs.width === "barWidth") && (c = o + i.xcrosshairsWidth / 2), this.moveXAxisTooltip(c);
    }
  }
  /**
   * This will move the crosshair (the vertical/horz line that moves along with mouse)
   * Along with this, this function also calls the xaxisMove function
   * @memberof Position
   * @param {int} - cx = point's x position, wherever point's x is, you need to move crosshair
   */
  moveYCrosshairs(e) {
    const t = this.ttCtx;
    t.ycrosshairs !== null && K.setAttrs(t.ycrosshairs, {
      y1: e,
      y2: e
    }), t.ycrosshairsHidden !== null && K.setAttrs(t.ycrosshairsHidden, {
      y1: e,
      y2: e
    });
  }
  /**
   ** AxisTooltip is the small rectangle which appears on x axis with x value, when user moves
   * @memberof Position
   * @param {int} - cx = point's x position, wherever point's x is, you need to move
   */
  moveXAxisTooltip(e) {
    let t = this.w;
    const i = this.ttCtx;
    if (i.xaxisTooltip !== null && i.xcrosshairsWidth !== 0) {
      i.xaxisTooltip.classList.add("apexcharts-active");
      let s = i.xaxisOffY + t.config.xaxis.tooltip.offsetY + t.globals.translateY + 1 + t.config.xaxis.offsetY, o = i.xaxisTooltip.getBoundingClientRect().width;
      if (e = e - o / 2, !isNaN(e)) {
        e = e + t.globals.translateX;
        let l = 0;
        l = new K(this.ctx).getTextRects(i.xaxisTooltipText.innerHTML), i.xaxisTooltipText.style.minWidth = l.width + "px", i.xaxisTooltip.style.left = e + "px", i.xaxisTooltip.style.top = s + "px";
      }
    }
  }
  moveYAxisTooltip(e) {
    const t = this.w, i = this.ttCtx;
    i.yaxisTTEls === null && (i.yaxisTTEls = t.globals.dom.baseEl.querySelectorAll(
      ".apexcharts-yaxistooltip"
    ));
    const s = parseInt(
      i.ycrosshairsHidden.getAttribute("y1"),
      10
    );
    let n = t.globals.translateY + s;
    const l = i.yaxisTTEls[e].getBoundingClientRect().height;
    let c = t.globals.translateYAxisX[e] - 2;
    t.config.yaxis[e].opposite && (c = c - 26), n = n - l / 2, t.globals.ignoreYAxisIndexes.indexOf(e) === -1 ? (i.yaxisTTEls[e].classList.add("apexcharts-active"), i.yaxisTTEls[e].style.top = n + "px", i.yaxisTTEls[e].style.left = c + t.config.yaxis[e].tooltip.offsetX + "px") : i.yaxisTTEls[e].classList.remove("apexcharts-active");
  }
  /**
   ** moves the whole tooltip by changing x, y attrs
   * @memberof Position
   * @param {int} - cx = point's x position, wherever point's x is, you need to move tooltip
   * @param {int} - cy = point's y position, wherever point's y is, you need to move tooltip
   * @param {int} - r = point's radius
   */
  moveTooltip(e, t, i = null) {
    let s = this.w, n = this.ttCtx;
    const o = n.getElTooltip();
    let l = n.tooltipRect, c = i !== null ? parseFloat(i) : 1, d = parseFloat(e) + c + 5, f = parseFloat(t) + c / 2;
    if (d > s.globals.gridWidth / 2 && (d = d - l.ttWidth - c - 10), d > s.globals.gridWidth - l.ttWidth - 10 && (d = s.globals.gridWidth - l.ttWidth), d < -20 && (d = -20), s.config.tooltip.followCursor) {
      const m = n.getElGrid().getBoundingClientRect();
      d = n.e.clientX - m.left, d > s.globals.gridWidth / 2 && (d = d - n.tooltipRect.ttWidth), f = n.e.clientY + s.globals.translateY - m.top, f > s.globals.gridHeight / 2 && (f = f - n.tooltipRect.ttHeight);
    } else
      s.globals.isBarHorizontal || l.ttHeight / 2 + f > s.globals.gridHeight && (f = s.globals.gridHeight - l.ttHeight + s.globals.translateY);
    isNaN(d) || (d = d + s.globals.translateX, o.style.left = d + "px", o.style.top = f + "px");
  }
  moveMarkers(e, t) {
    let i = this.w, s = this.ttCtx;
    if (i.globals.markers.size[e] > 0) {
      let n = i.globals.dom.baseEl.querySelectorAll(
        ` .apexcharts-series[data\\:realIndex='${e}'] .apexcharts-marker`
      );
      for (let o = 0; o < n.length; o++)
        parseInt(n[o].getAttribute("rel"), 10) === t && (s.marker.resetPointsSize(), s.marker.enlargeCurrentPoint(t, n[o]));
    } else
      s.marker.resetPointsSize(), this.moveDynamicPointOnHover(t, e);
  }
  // This function is used when you need to show markers/points only on hover -
  // DIFFERENT X VALUES in multiple series
  moveDynamicPointOnHover(e, t) {
    let i = this.w, s = this.ttCtx, n = 0, o = 0, l = i.globals.pointsArray, c = s.tooltipUtil.getHoverMarkerSize(t);
    const d = i.config.series[t].type;
    if (d && (d === "column" || d === "candlestick" || d === "boxPlot"))
      return;
    n = l[t][e][0], o = l[t][e][1] ? l[t][e][1] : 0;
    let f = i.globals.dom.baseEl.querySelector(
      `.apexcharts-series[data\\:realIndex='${t}'] .apexcharts-series-markers circle`
    );
    f && o < i.globals.gridHeight && o > 0 && (f.setAttribute("r", c), f.setAttribute("cx", n), f.setAttribute("cy", o)), this.moveXCrosshairs(n), s.fixedTooltip || this.moveTooltip(n, o, c);
  }
  // This function is used when you need to show markers/points only on hover -
  // SAME X VALUES in multiple series
  moveDynamicPointsOnHover(e) {
    const t = this.ttCtx;
    let i = t.w, s = 0, n = 0, o = 0, l = i.globals.pointsArray;
    o = new mi(this.ctx).getActiveConfigSeriesIndex("asc", [
      "line",
      "area",
      "scatter",
      "bubble"
    ]);
    let d = t.tooltipUtil.getHoverMarkerSize(o);
    l[o] && (s = l[o][e][0], n = l[o][e][1]);
    let f = t.tooltipUtil.getAllMarkers();
    if (f !== null)
      for (let p = 0; p < i.globals.series.length; p++) {
        let m = l[p];
        if (i.globals.comboCharts && typeof m > "u" && f.splice(p, 0, null), m && m.length) {
          let v = l[p][e][1], r;
          if (f[p].setAttribute("cx", s), i.config.chart.type === "rangeArea" && !i.globals.comboCharts) {
            const h = e + i.globals.series[p].length;
            r = l[p][h][1];
            const u = Math.abs(v - r) / 2;
            v = v - u;
          }
          v !== null && !isNaN(v) && v < i.globals.gridHeight + d && v + d > 0 ? (f[p] && f[p].setAttribute("r", d), f[p] && f[p].setAttribute("cy", v)) : f[p] && f[p].setAttribute("r", 0);
        }
      }
    this.moveXCrosshairs(s), t.fixedTooltip || this.moveTooltip(s, n || i.globals.gridHeight, d);
  }
  moveStickyTooltipOverBars(e, t) {
    const i = this.w, s = this.ttCtx;
    let n = i.globals.columnSeries ? i.globals.columnSeries.length : i.globals.series.length, o = n >= 2 && n % 2 === 0 ? Math.floor(n / 2) : Math.floor(n / 2) + 1;
    i.globals.isBarHorizontal && (o = new mi(this.ctx).getActiveConfigSeriesIndex("desc") + 1);
    let l = i.globals.dom.baseEl.querySelector(
      `.apexcharts-bar-series .apexcharts-series[rel='${o}'] path[j='${e}'], .apexcharts-candlestick-series .apexcharts-series[rel='${o}'] path[j='${e}'], .apexcharts-boxPlot-series .apexcharts-series[rel='${o}'] path[j='${e}'], .apexcharts-rangebar-series .apexcharts-series[rel='${o}'] path[j='${e}']`
    );
    !l && typeof t == "number" && (l = i.globals.dom.baseEl.querySelector(
      `.apexcharts-bar-series .apexcharts-series[data\\:realIndex='${t}'] path[j='${e}'],
        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='${t}'] path[j='${e}'],
        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='${t}'] path[j='${e}'],
        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='${t}'] path[j='${e}']`
    ));
    let c = l ? parseFloat(l.getAttribute("cx")) : 0, d = l ? parseFloat(l.getAttribute("cy")) : 0, f = l ? parseFloat(l.getAttribute("barWidth")) : 0, m = s.getElGrid().getBoundingClientRect();
    const v = l && (l.classList.contains("apexcharts-candlestick-area") || l.classList.contains("apexcharts-boxPlot-area"));
    i.globals.isXNumeric ? (l && !v && (c = c - (n % 2 !== 0 ? f / 2 : 0)), l && // fixes apexcharts.js#2354
    v && i.globals.comboCharts && (c = c - f / 2)) : i.globals.isBarHorizontal || (c = s.xAxisTicksPositions[e - 1] + s.dataPointsDividedWidth / 2, isNaN(c) && (c = s.xAxisTicksPositions[e] - s.dataPointsDividedWidth / 2)), i.globals.isBarHorizontal ? d = d - s.tooltipRect.ttHeight : i.config.tooltip.followCursor ? d = s.e.clientY - m.top - s.tooltipRect.ttHeight / 2 : d + s.tooltipRect.ttHeight + 15 > i.globals.gridHeight && (d = i.globals.gridHeight), i.globals.isBarHorizontal || this.moveXCrosshairs(c), s.fixedTooltip || this.moveTooltip(c, d || i.globals.gridHeight);
  }
}
class kL {
  constructor(e) {
    this.w = e.w, this.ttCtx = e, this.ctx = e.ctx, this.tooltipPosition = new Rv(e);
  }
  drawDynamicPoints() {
    let e = this.w, t = new K(this.ctx), i = new va(this.ctx), s = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
    s = [...s], e.config.chart.stacked && s.sort((n, o) => parseFloat(n.getAttribute("data:realIndex")) - parseFloat(o.getAttribute("data:realIndex")));
    for (let n = 0; n < s.length; n++) {
      let o = s[n].querySelector(
        ".apexcharts-series-markers-wrap"
      );
      if (o !== null) {
        let l, c = `apexcharts-marker w${(Math.random() + 1).toString(36).substring(4)}`;
        (e.config.chart.type === "line" || e.config.chart.type === "area") && !e.globals.comboCharts && !e.config.tooltip.intersect && (c += " no-pointer-events");
        let d = i.getMarkerConfig({
          cssClass: c,
          seriesIndex: Number(o.getAttribute("data:realIndex"))
          // fixes apexcharts/apexcharts.js #1427
        });
        l = t.drawMarker(0, 0, d), l.node.setAttribute("default-marker-size", 0);
        let f = document.createElementNS(e.globals.SVGNS, "g");
        f.classList.add("apexcharts-series-markers"), f.appendChild(l.node), o.appendChild(f);
      }
    }
  }
  enlargeCurrentPoint(e, t, i = null, s = null) {
    let n = this.w;
    n.config.chart.type !== "bubble" && this.newPointSize(e, t);
    let o = t.getAttribute("cx"), l = t.getAttribute("cy");
    if (i !== null && s !== null && (o = i, l = s), this.tooltipPosition.moveXCrosshairs(o), !this.fixedTooltip) {
      if (n.config.chart.type === "radar") {
        const d = this.ttCtx.getElGrid().getBoundingClientRect();
        o = this.ttCtx.e.clientX - d.left;
      }
      this.tooltipPosition.moveTooltip(o, l, n.config.markers.hover.size);
    }
  }
  enlargePoints(e) {
    let t = this.w, i = this;
    const s = this.ttCtx;
    let n = e, o = t.globals.dom.baseEl.querySelectorAll(
      ".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"
    ), l = t.config.markers.hover.size;
    for (let c = 0; c < o.length; c++) {
      let d = o[c].getAttribute("rel"), f = o[c].getAttribute("index");
      if (l === void 0 && (l = t.globals.markers.size[f] + t.config.markers.hover.sizeOffset), n === parseInt(d, 10)) {
        i.newPointSize(n, o[c]);
        let p = o[c].getAttribute("cx"), m = o[c].getAttribute("cy");
        i.tooltipPosition.moveXCrosshairs(p), s.fixedTooltip || i.tooltipPosition.moveTooltip(p, m, l);
      } else
        i.oldPointSize(o[c]);
    }
  }
  newPointSize(e, t) {
    let i = this.w, s = i.config.markers.hover.size, n = e === 0 ? t.parentNode.firstChild : t.parentNode.lastChild;
    if (n.getAttribute("default-marker-size") !== "0") {
      const o = parseInt(n.getAttribute("index"), 10);
      s === void 0 && (s = i.globals.markers.size[o] + i.config.markers.hover.sizeOffset), s < 0 && (s = 0), n.setAttribute("r", s);
    }
  }
  oldPointSize(e) {
    const t = parseFloat(e.getAttribute("default-marker-size"));
    e.setAttribute("r", t);
  }
  resetPointsSize() {
    let t = this.w.globals.dom.baseEl.querySelectorAll(
      ".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"
    );
    for (let i = 0; i < t.length; i++) {
      const s = parseFloat(t[i].getAttribute("default-marker-size"));
      N.isNumber(s) && s >= 0 ? t[i].setAttribute("r", s) : t[i].setAttribute("r", 0);
    }
  }
}
class _L {
  constructor(e) {
    this.w = e.w;
    const t = this.w;
    this.ttCtx = e, this.isVerticalGroupedRangeBar = !t.globals.isBarHorizontal && t.config.chart.type === "rangeBar" && t.config.plotOptions.bar.rangeBarGroupRows;
  }
  // a helper function to get an element's attribute value
  getAttr(e, t) {
    return parseFloat(e.target.getAttribute(t));
  }
  // handle tooltip for heatmaps and treemaps
  handleHeatTreeTooltip({ e, opt: t, x: i, y: s, type: n }) {
    const o = this.ttCtx, l = this.w;
    if (e.target.classList.contains(`apexcharts-${n}-rect`)) {
      let c = this.getAttr(e, "i"), d = this.getAttr(e, "j"), f = this.getAttr(e, "cx"), p = this.getAttr(e, "cy"), m = this.getAttr(e, "width"), v = this.getAttr(e, "height");
      if (o.tooltipLabels.drawSeriesTexts({
        ttItems: t.ttItems,
        i: c,
        j: d,
        shared: !1,
        e
      }), l.globals.capturedSeriesIndex = c, l.globals.capturedDataPointIndex = d, i = f + o.tooltipRect.ttWidth / 2 + m, s = p + o.tooltipRect.ttHeight / 2 - v / 2, o.tooltipPosition.moveXCrosshairs(f + m / 2), i > l.globals.gridWidth / 2 && (i = f - o.tooltipRect.ttWidth / 2 + m), o.w.config.tooltip.followCursor) {
        let r = l.globals.dom.elWrap.getBoundingClientRect();
        i = l.globals.clientX - r.left - (i > l.globals.gridWidth / 2 ? o.tooltipRect.ttWidth : 0), s = l.globals.clientY - r.top - (s > l.globals.gridHeight / 2 ? o.tooltipRect.ttHeight : 0);
      }
    }
    return {
      x: i,
      y: s
    };
  }
  /**
   * handle tooltips for line/area/scatter charts where tooltip.intersect is true
   * when user hovers over the marker directly, this function is executed
   */
  handleMarkerTooltip({ e, opt: t, x: i, y: s }) {
    let n = this.w;
    const o = this.ttCtx;
    let l, c;
    if (e.target.classList.contains("apexcharts-marker")) {
      let d = parseInt(t.paths.getAttribute("cx"), 10), f = parseInt(t.paths.getAttribute("cy"), 10), p = parseFloat(t.paths.getAttribute("val"));
      if (c = parseInt(t.paths.getAttribute("rel"), 10), l = parseInt(
        t.paths.parentNode.parentNode.parentNode.getAttribute("rel"),
        10
      ) - 1, o.intersect) {
        const m = N.findAncestor(t.paths, "apexcharts-series");
        m && (l = parseInt(m.getAttribute("data:realIndex"), 10));
      }
      if (o.tooltipLabels.drawSeriesTexts({
        ttItems: t.ttItems,
        i: l,
        j: c,
        shared: o.showOnIntersect ? !1 : n.config.tooltip.shared,
        e
      }), e.type === "mouseup" && o.markerClick(e, l, c), n.globals.capturedSeriesIndex = l, n.globals.capturedDataPointIndex = c, i = d, s = f + n.globals.translateY - o.tooltipRect.ttHeight * 1.4, o.w.config.tooltip.followCursor) {
        const v = o.getElGrid().getBoundingClientRect();
        s = o.e.clientY + n.globals.translateY - v.top;
      }
      p < 0 && (s = f), o.marker.enlargeCurrentPoint(c, t.paths, i, s);
    }
    return {
      x: i,
      y: s
    };
  }
  /**
   * handle tooltips for bar/column charts
   */
  handleBarTooltip({ e, opt: t }) {
    const i = this.w, s = this.ttCtx, n = s.getElTooltip();
    let o = 0, l = 0, c = 0, d = 0, f, p = this.getBarTooltipXY({
      e,
      opt: t
    });
    d = p.i;
    let m = p.barHeight, v = p.j;
    i.globals.capturedSeriesIndex = d, i.globals.capturedDataPointIndex = v, i.globals.isBarHorizontal && s.tooltipUtil.hasBars() || !i.config.tooltip.shared ? (l = p.x, c = p.y, f = Array.isArray(i.config.stroke.width) ? i.config.stroke.width[d] : i.config.stroke.width, o = l) : !i.globals.comboCharts && !i.config.tooltip.shared && (o = o / 2), isNaN(c) && (c = i.globals.svgHeight - s.tooltipRect.ttHeight);
    const r = parseInt(
      t.paths.parentNode.getAttribute("data:realIndex"),
      10
    ), h = i.globals.isMultipleYAxis ? i.config.yaxis[r] && i.config.yaxis[r].reversed : i.config.yaxis[0].reversed;
    if (l + s.tooltipRect.ttWidth > i.globals.gridWidth && !h ? l = l - s.tooltipRect.ttWidth : l < 0 && (l = 0), s.w.config.tooltip.followCursor) {
      const g = s.getElGrid().getBoundingClientRect();
      c = s.e.clientY - g.top;
    }
    s.tooltip === null && (s.tooltip = i.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), i.config.tooltip.shared || (i.globals.comboBarCount > 0 ? s.tooltipPosition.moveXCrosshairs(o + f / 2) : s.tooltipPosition.moveXCrosshairs(o)), !s.fixedTooltip && (!i.config.tooltip.shared || i.globals.isBarHorizontal && s.tooltipUtil.hasBars()) && (h && (l = l - s.tooltipRect.ttWidth, l < 0 && (l = 0)), h && !(i.globals.isBarHorizontal && s.tooltipUtil.hasBars()) && (c = c + m - (i.globals.series[d][v] < 0 ? m : 0) * 2), c = c + i.globals.translateY - s.tooltipRect.ttHeight / 2, n.style.left = l + i.globals.translateX + "px", n.style.top = c + "px");
  }
  getBarTooltipXY({ e, opt: t }) {
    let i = this.w, s = null;
    const n = this.ttCtx;
    let o = 0, l = 0, c = 0, d = 0, f = 0;
    const p = e.target.classList;
    if (p.contains("apexcharts-bar-area") || p.contains("apexcharts-candlestick-area") || p.contains("apexcharts-boxPlot-area") || p.contains("apexcharts-rangebar-area")) {
      let m = e.target, v = m.getBoundingClientRect(), r = t.elGrid.getBoundingClientRect(), h = v.height;
      f = v.height;
      let u = v.width, g = parseInt(m.getAttribute("cx"), 10), b = parseInt(m.getAttribute("cy"), 10);
      d = parseFloat(m.getAttribute("barWidth"));
      const O = e.type === "touchmove" ? e.touches[0].clientX : e.clientX;
      s = parseInt(m.getAttribute("j"), 10), o = parseInt(m.parentNode.getAttribute("rel"), 10) - 1;
      let x = m.getAttribute("data-range-y1"), S = m.getAttribute("data-range-y2");
      i.globals.comboCharts && (o = parseInt(m.parentNode.getAttribute("data:realIndex"), 10));
      const k = (_) => (i.globals.isXNumeric ? _ = g - u / 2 : this.isVerticalGroupedRangeBar ? _ = g + u / 2 : _ = g - n.dataPointsDividedWidth + u / 2, _), C = () => b - n.dataPointsDividedHeight + h / 2 - n.tooltipRect.ttHeight / 2;
      n.tooltipLabels.drawSeriesTexts({
        ttItems: t.ttItems,
        i: o,
        j: s,
        y1: x ? parseInt(x, 10) : null,
        y2: S ? parseInt(S, 10) : null,
        shared: n.showOnIntersect ? !1 : i.config.tooltip.shared,
        e
      }), i.config.tooltip.followCursor ? i.globals.isBarHorizontal ? (l = O - r.left + 15, c = C()) : (l = k(l), c = e.clientY - r.top - n.tooltipRect.ttHeight / 2 - 15) : i.globals.isBarHorizontal ? (l = g, l < n.xyRatios.baseLineInvertedY && (l = g - n.tooltipRect.ttWidth), c = C()) : (l = k(l), c = b);
    }
    return {
      x: l,
      y: c,
      barHeight: f,
      barWidth: d,
      i: o,
      j: s
    };
  }
}
class CL {
  constructor(e) {
    this.w = e.w, this.ttCtx = e;
  }
  /**
   * This method adds the secondary tooltip which appears below x axis
   * @memberof Tooltip
   **/
  drawXaxisTooltip() {
    let e = this.w;
    const t = this.ttCtx, i = e.config.xaxis.position === "bottom";
    t.xaxisOffY = i ? e.globals.gridHeight + 1 : -e.globals.xAxisHeight - e.config.xaxis.axisTicks.height + 3;
    const s = i ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top";
    let n = e.globals.dom.elWrap;
    t.isXAxisTooltipEnabled && e.globals.dom.baseEl.querySelector(
      ".apexcharts-xaxistooltip"
    ) === null && (t.xaxisTooltip = document.createElement("div"), t.xaxisTooltip.setAttribute(
      "class",
      s + " apexcharts-theme-" + e.config.tooltip.theme
    ), n.appendChild(t.xaxisTooltip), t.xaxisTooltipText = document.createElement("div"), t.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), t.xaxisTooltipText.style.fontFamily = e.config.xaxis.tooltip.style.fontFamily || e.config.chart.fontFamily, t.xaxisTooltipText.style.fontSize = e.config.xaxis.tooltip.style.fontSize, t.xaxisTooltip.appendChild(t.xaxisTooltipText));
  }
  /**
   * This method adds the secondary tooltip which appears below x axis
   * @memberof Tooltip
   **/
  drawYaxisTooltip() {
    let e = this.w;
    const t = this.ttCtx;
    for (let i = 0; i < e.config.yaxis.length; i++) {
      const s = e.config.yaxis[i].opposite || e.config.yaxis[i].crosshairs.opposite;
      t.yaxisOffX = s ? e.globals.gridWidth + 1 : 1;
      let n = s ? `apexcharts-yaxistooltip apexcharts-yaxistooltip-${i} apexcharts-yaxistooltip-right` : `apexcharts-yaxistooltip apexcharts-yaxistooltip-${i} apexcharts-yaxistooltip-left`, o = e.globals.dom.elWrap;
      e.globals.dom.baseEl.querySelector(
        `.apexcharts-yaxistooltip apexcharts-yaxistooltip-${i}`
      ) === null && (t.yaxisTooltip = document.createElement("div"), t.yaxisTooltip.setAttribute(
        "class",
        n + " apexcharts-theme-" + e.config.tooltip.theme
      ), o.appendChild(t.yaxisTooltip), i === 0 && (t.yaxisTooltipText = []), t.yaxisTooltipText[i] = document.createElement("div"), t.yaxisTooltipText[i].classList.add("apexcharts-yaxistooltip-text"), t.yaxisTooltip.appendChild(t.yaxisTooltipText[i]));
    }
  }
  /**
   * @memberof Tooltip
   **/
  setXCrosshairWidth() {
    let e = this.w;
    const t = this.ttCtx, i = t.getElXCrosshairs();
    if (t.xcrosshairsWidth = parseInt(e.config.xaxis.crosshairs.width, 10), e.globals.comboCharts) {
      let s = e.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
      if (s !== null && e.config.xaxis.crosshairs.width === "barWidth") {
        let n = parseFloat(s.getAttribute("barWidth"));
        t.xcrosshairsWidth = n;
      } else if (e.config.xaxis.crosshairs.width === "tickWidth") {
        let n = e.globals.labels.length;
        t.xcrosshairsWidth = e.globals.gridWidth / n;
      }
    } else if (e.config.xaxis.crosshairs.width === "tickWidth") {
      let s = e.globals.labels.length;
      t.xcrosshairsWidth = e.globals.gridWidth / s;
    } else if (e.config.xaxis.crosshairs.width === "barWidth") {
      let s = e.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
      if (s !== null) {
        let n = parseFloat(s.getAttribute("barWidth"));
        t.xcrosshairsWidth = n;
      } else
        t.xcrosshairsWidth = 1;
    }
    e.globals.isBarHorizontal && (t.xcrosshairsWidth = 0), i !== null && t.xcrosshairsWidth > 0 && i.setAttribute("width", t.xcrosshairsWidth);
  }
  handleYCrosshair() {
    let e = this.w;
    const t = this.ttCtx;
    t.ycrosshairs = e.globals.dom.baseEl.querySelector(
      ".apexcharts-ycrosshairs"
    ), t.ycrosshairsHidden = e.globals.dom.baseEl.querySelector(
      ".apexcharts-ycrosshairs-hidden"
    );
  }
  drawYaxisTooltipText(e, t, i) {
    const s = this.ttCtx, n = this.w;
    let o = n.globals.yLabelFormatters[e];
    if (s.yaxisTooltips[e]) {
      const c = s.getElGrid().getBoundingClientRect();
      let d = n.globals.seriesYAxisMap[anno.yAxisIndex][0];
      const f = (t - c.top) * i.yRatio[d], p = n.globals.maxYArr[d] - n.globals.minYArr[d], m = n.globals.minYArr[d] + (p - f);
      s.tooltipPosition.moveYCrosshairs(t - c.top), s.yaxisTooltipText[e].innerHTML = o(m), s.tooltipPosition.moveYAxisTooltip(e);
    }
  }
}
class Uf {
  constructor(e) {
    this.ctx = e, this.w = e.w;
    const t = this.w;
    this.tConfig = t.config.tooltip, this.tooltipUtil = new Dv(this), this.tooltipLabels = new SL(this), this.tooltipPosition = new Rv(this), this.marker = new kL(this), this.intersect = new _L(this), this.axesTooltip = new CL(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !t.globals.isBarHorizontal && this.tConfig.shared, this.lastHoverTime = Date.now();
  }
  getElTooltip(e) {
    return e || (e = this), e.w.globals.dom.baseEl ? e.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null;
  }
  getElXCrosshairs() {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs");
  }
  getElGrid() {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid");
  }
  drawTooltip(e) {
    let t = this.w;
    this.xyRatios = e, this.isXAxisTooltipEnabled = t.config.xaxis.tooltip.enabled && t.globals.axisCharts, this.yaxisTooltips = t.config.yaxis.map((n, o) => !!(n.show && n.tooltip.enabled && t.globals.axisCharts)), this.allTooltipSeriesGroups = [], t.globals.axisCharts || (this.showTooltipTitle = !1);
    const i = document.createElement("div");
    if (i.classList.add("apexcharts-tooltip"), t.config.tooltip.cssClass && i.classList.add(t.config.tooltip.cssClass), i.classList.add(`apexcharts-theme-${this.tConfig.theme}`), t.globals.dom.elWrap.appendChild(i), t.globals.axisCharts) {
      this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
      let n = new Zr(this.ctx);
      this.xAxisTicksPositions = n.getXAxisTicksPositions();
    }
    if ((t.globals.comboCharts || this.tConfig.intersect || t.config.chart.type === "rangeBar") && !this.tConfig.shared && (this.showOnIntersect = !0), (t.config.markers.size === 0 || t.globals.markers.largestSize === 0) && this.marker.drawDynamicPoints(this), t.globals.collapsedSeries.length === t.globals.series.length)
      return;
    this.dataPointsDividedHeight = t.globals.gridHeight / t.globals.dataPoints, this.dataPointsDividedWidth = t.globals.gridWidth / t.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || t.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i.appendChild(this.tooltipTitle));
    let s = t.globals.series.length;
    (t.globals.xyCharts || t.globals.comboCharts) && this.tConfig.shared && (this.showOnIntersect ? s = 1 : s = t.globals.series.length), this.legendLabels = t.globals.dom.baseEl.querySelectorAll(
      ".apexcharts-legend-text"
    ), this.ttItems = this.createTTElements(s), this.addSVGEvents();
  }
  createTTElements(e) {
    const t = this.w;
    let i = [];
    const s = this.getElTooltip();
    for (let n = 0; n < e; n++) {
      let o = document.createElement("div");
      o.classList.add("apexcharts-tooltip-series-group"), o.style.order = t.config.tooltip.inverseOrder ? e - n : n + 1, this.tConfig.shared && this.tConfig.enabledOnSeries && Array.isArray(this.tConfig.enabledOnSeries) && this.tConfig.enabledOnSeries.indexOf(n) < 0 && o.classList.add("apexcharts-tooltip-series-group-hidden");
      let l = document.createElement("span");
      l.classList.add("apexcharts-tooltip-marker"), l.style.backgroundColor = t.globals.colors[n], o.appendChild(l);
      const c = document.createElement("div");
      c.classList.add("apexcharts-tooltip-text"), c.style.fontFamily = this.tConfig.style.fontFamily || t.config.chart.fontFamily, c.style.fontSize = this.tConfig.style.fontSize, ["y", "goals", "z"].forEach((d) => {
        const f = document.createElement("div");
        f.classList.add(`apexcharts-tooltip-${d}-group`);
        let p = document.createElement("span");
        p.classList.add(`apexcharts-tooltip-text-${d}-label`), f.appendChild(p);
        let m = document.createElement("span");
        m.classList.add(`apexcharts-tooltip-text-${d}-value`), f.appendChild(m), c.appendChild(f);
      }), o.appendChild(c), s.appendChild(o), i.push(o);
    }
    return i;
  }
  addSVGEvents() {
    const e = this.w;
    let t = e.config.chart.type;
    const i = this.getElTooltip(), s = t === "bar" || t === "candlestick" || t === "boxPlot" || t === "rangeBar", n = t === "area" || t === "line" || t === "scatter" || t === "bubble" || t === "radar";
    let o = e.globals.dom.Paper.node;
    const l = this.getElGrid();
    l && (this.seriesBound = l.getBoundingClientRect());
    let c = [], d = [], f = {
      hoverArea: o,
      elGrid: l,
      tooltipEl: i,
      tooltipY: c,
      tooltipX: d,
      ttItems: this.ttItems
    }, p;
    if (e.globals.axisCharts && (n ? p = e.globals.dom.baseEl.querySelectorAll(
      ".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker"
    ) : s ? p = e.globals.dom.baseEl.querySelectorAll(
      ".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area"
    ) : (t === "heatmap" || t === "treemap") && (p = e.globals.dom.baseEl.querySelectorAll(
      ".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap"
    )), p && p.length))
      for (let v = 0; v < p.length; v++)
        c.push(p[v].getAttribute("cy")), d.push(p[v].getAttribute("cx"));
    if (e.globals.xyCharts && !this.showOnIntersect || e.globals.comboCharts && !this.showOnIntersect || s && this.tooltipUtil.hasBars() && this.tConfig.shared)
      this.addPathsEventListeners([o], f);
    else if (s && !e.globals.comboCharts || n && this.showOnIntersect)
      this.addDatapointEventsListeners(f);
    else if (!e.globals.axisCharts || t === "heatmap" || t === "treemap") {
      let v = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
      this.addPathsEventListeners(v, f);
    }
    if (this.showOnIntersect) {
      let v = e.globals.dom.baseEl.querySelectorAll(
        ".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker"
      );
      v.length > 0 && this.addPathsEventListeners(v, f), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(f);
    }
  }
  drawFixedTooltipRect() {
    let e = this.w;
    const t = this.getElTooltip();
    let i = t.getBoundingClientRect(), s = i.width + 10, n = i.height + 10, o = this.tConfig.fixed.offsetX, l = this.tConfig.fixed.offsetY;
    const c = this.tConfig.fixed.position.toLowerCase();
    return c.indexOf("right") > -1 && (o = o + e.globals.svgWidth - s + 10), c.indexOf("bottom") > -1 && (l = l + e.globals.svgHeight - n - 10), t.style.left = o + "px", t.style.top = l + "px", {
      x: o,
      y: l,
      ttWidth: s,
      ttHeight: n
    };
  }
  addDatapointEventsListeners(e) {
    let i = this.w.globals.dom.baseEl.querySelectorAll(
      ".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area"
    );
    this.addPathsEventListeners(i, e);
  }
  addPathsEventListeners(e, t) {
    let i = this;
    for (let s = 0; s < e.length; s++) {
      let n = {
        paths: e[s],
        tooltipEl: t.tooltipEl,
        tooltipY: t.tooltipY,
        tooltipX: t.tooltipX,
        elGrid: t.elGrid,
        hoverArea: t.hoverArea,
        ttItems: t.ttItems
      };
      ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map((l) => e[s].addEventListener(
        l,
        i.onSeriesHover.bind(i, n),
        { capture: !1, passive: !0 }
      ));
    }
  }
  /*
   ** Check to see if the tooltips should be updated based on a mouse / touch event
   */
  onSeriesHover(e, t) {
    const s = Date.now() - this.lastHoverTime;
    s >= 100 ? this.seriesHover(e, t) : (clearTimeout(this.seriesHoverTimeout), this.seriesHoverTimeout = setTimeout(() => {
      this.seriesHover(e, t);
    }, 100 - s));
  }
  /*
   ** The actual series hover function
   */
  seriesHover(e, t) {
    this.lastHoverTime = Date.now();
    let i = [];
    const s = this.w;
    s.config.chart.group && (i = this.ctx.getGroupedCharts()), !(s.globals.axisCharts && (s.globals.minX === -1 / 0 && s.globals.maxX === 1 / 0 || s.globals.dataPoints === 0)) && (i.length ? i.forEach((n) => {
      const o = this.getElTooltip(n), l = {
        paths: e.paths,
        tooltipEl: o,
        tooltipY: e.tooltipY,
        tooltipX: e.tooltipX,
        elGrid: e.elGrid,
        hoverArea: e.hoverArea,
        ttItems: n.w.globals.tooltip.ttItems
      };
      n.w.globals.minX === this.w.globals.minX && n.w.globals.maxX === this.w.globals.maxX && n.w.globals.tooltip.seriesHoverByContext({
        chartCtx: n,
        ttCtx: n.w.globals.tooltip,
        opt: l,
        e: t
      });
    }) : this.seriesHoverByContext({
      chartCtx: this.ctx,
      ttCtx: this.w.globals.tooltip,
      opt: e,
      e: t
    }));
  }
  seriesHoverByContext({ chartCtx: e, ttCtx: t, opt: i, e: s }) {
    let n = e.w;
    const o = this.getElTooltip();
    o && (t.tooltipRect = {
      x: 0,
      y: 0,
      ttWidth: o.getBoundingClientRect().width,
      ttHeight: o.getBoundingClientRect().height
    }, t.e = s, t.tooltipUtil.hasBars() && !n.globals.comboCharts && !t.isBarShared && this.tConfig.onDatasetHover.highlightDataSeries && new mi(e).toggleSeriesOnHover(s, s.target.parentNode), t.fixedTooltip && t.drawFixedTooltipRect(), n.globals.axisCharts ? t.axisChartsTooltips({
      e: s,
      opt: i,
      tooltipRect: t.tooltipRect
    }) : t.nonAxisChartsTooltips({
      e: s,
      opt: i,
      tooltipRect: t.tooltipRect
    }));
  }
  // tooltip handling for line/area/bar/columns/scatter
  axisChartsTooltips({ e, opt: t }) {
    let i = this.w, s, n, o = t.elGrid.getBoundingClientRect();
    const l = e.type === "touchmove" ? e.touches[0].clientX : e.clientX, c = e.type === "touchmove" ? e.touches[0].clientY : e.clientY;
    if (this.clientY = c, this.clientX = l, i.globals.capturedSeriesIndex = -1, i.globals.capturedDataPointIndex = -1, c < o.top || c > o.top + o.height) {
      this.handleMouseOut(t);
      return;
    }
    if (Array.isArray(this.tConfig.enabledOnSeries) && !i.config.tooltip.shared) {
      const m = parseInt(t.paths.getAttribute("index"), 10);
      if (this.tConfig.enabledOnSeries.indexOf(m) < 0) {
        this.handleMouseOut(t);
        return;
      }
    }
    const d = this.getElTooltip(), f = this.getElXCrosshairs();
    let p = i.globals.xyCharts || i.config.chart.type === "bar" && !i.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || i.globals.comboCharts && this.tooltipUtil.hasBars();
    if (e.type === "mousemove" || e.type === "touchmove" || e.type === "mouseup") {
      if (i.globals.collapsedSeries.length + i.globals.ancillaryCollapsedSeries.length === i.globals.series.length)
        return;
      f !== null && f.classList.add("apexcharts-active");
      const m = this.yaxisTooltips.filter((v) => v === !0);
      if (this.ycrosshairs !== null && m.length && this.ycrosshairs.classList.add("apexcharts-active"), p && !this.showOnIntersect)
        this.handleStickyTooltip(e, l, c, t);
      else if (i.config.chart.type === "heatmap" || i.config.chart.type === "treemap") {
        let v = this.intersect.handleHeatTreeTooltip({
          e,
          opt: t,
          x: s,
          y: n,
          type: i.config.chart.type
        });
        s = v.x, n = v.y, d.style.left = s + "px", d.style.top = n + "px";
      } else
        this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({
          e,
          opt: t
        }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({
          e,
          opt: t,
          x: s,
          y: n
        });
      if (this.yaxisTooltips.length)
        for (let v = 0; v < i.config.yaxis.length; v++)
          this.axesTooltip.drawYaxisTooltipText(v, c, this.xyRatios);
      t.tooltipEl.classList.add("apexcharts-active");
    } else
      (e.type === "mouseout" || e.type === "touchend") && this.handleMouseOut(t);
  }
  // tooltip handling for pie/donuts
  nonAxisChartsTooltips({ e, opt: t, tooltipRect: i }) {
    let s = this.w, n = t.paths.getAttribute("rel");
    const o = this.getElTooltip();
    let l = s.globals.dom.elWrap.getBoundingClientRect();
    if (e.type === "mousemove" || e.type === "touchmove") {
      o.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({
        ttItems: t.ttItems,
        i: parseInt(n, 10) - 1,
        shared: !1
      });
      let c = s.globals.clientX - l.left - i.ttWidth / 2, d = s.globals.clientY - l.top - i.ttHeight - 10;
      if (o.style.left = c + "px", o.style.top = d + "px", s.config.legend.tooltipHoverFormatter) {
        let f = s.config.legend.tooltipHoverFormatter;
        const p = n - 1, m = this.legendLabels[p].getAttribute("data:default-text");
        let v = f(m, {
          seriesIndex: p,
          dataPointIndex: p,
          w: s
        });
        this.legendLabels[p].innerHTML = v;
      }
    } else
      (e.type === "mouseout" || e.type === "touchend") && (o.classList.remove("apexcharts-active"), s.config.legend.tooltipHoverFormatter && this.legendLabels.forEach((c) => {
        const d = c.getAttribute("data:default-text");
        c.innerHTML = decodeURIComponent(d);
      }));
  }
  handleStickyTooltip(e, t, i, s) {
    const n = this.w;
    let o = this.tooltipUtil.getNearestValues({
      context: this,
      hoverArea: s.hoverArea,
      elGrid: s.elGrid,
      clientX: t,
      clientY: i
    }), l = o.j, c = o.capturedSeries;
    n.globals.collapsedSeriesIndices.includes(c) && (c = null);
    const d = s.elGrid.getBoundingClientRect();
    if (o.hoverX < 0 || o.hoverX > d.width) {
      this.handleMouseOut(s);
      return;
    }
    if (c !== null)
      this.handleStickyCapturedSeries(e, c, s, l);
    else if (this.tooltipUtil.isXoverlap(l) || n.globals.isBarHorizontal) {
      const f = n.globals.series.findIndex(
        (p, m) => !n.globals.collapsedSeriesIndices.includes(m)
      );
      this.create(e, this, f, l, s.ttItems);
    }
  }
  handleStickyCapturedSeries(e, t, i, s) {
    const n = this.w;
    if (!this.tConfig.shared && n.globals.series[t][s] === null) {
      this.handleMouseOut(i);
      return;
    }
    if (typeof n.globals.series[t][s] < "u")
      this.tConfig.shared && this.tooltipUtil.isXoverlap(s) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(e, this, t, s, i.ttItems) : this.create(e, this, t, s, i.ttItems, !1);
    else if (this.tooltipUtil.isXoverlap(s)) {
      const o = n.globals.series.findIndex(
        (l, c) => !n.globals.collapsedSeriesIndices.includes(c)
      );
      this.create(e, this, o, s, i.ttItems);
    }
  }
  deactivateHoverFilter() {
    let e = this.w, t = new K(this.ctx), i = e.globals.dom.Paper.select(".apexcharts-bar-area");
    for (let s = 0; s < i.length; s++)
      t.pathMouseLeave(i[s]);
  }
  handleMouseOut(e) {
    const t = this.w, i = this.getElXCrosshairs();
    if (e.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), t.config.chart.type !== "bubble" && this.marker.resetPointsSize(), i !== null && i.classList.remove("apexcharts-active"), this.ycrosshairs !== null && this.ycrosshairs.classList.remove("apexcharts-active"), this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
      this.yaxisTTEls === null && (this.yaxisTTEls = t.globals.dom.baseEl.querySelectorAll(
        ".apexcharts-yaxistooltip"
      ));
      for (let s = 0; s < this.yaxisTTEls.length; s++)
        this.yaxisTTEls[s].classList.remove("apexcharts-active");
    }
    t.config.legend.tooltipHoverFormatter && this.legendLabels.forEach((s) => {
      const n = s.getAttribute("data:default-text");
      s.innerHTML = decodeURIComponent(n);
    });
  }
  markerClick(e, t, i) {
    const s = this.w;
    typeof s.config.chart.events.markerClick == "function" && s.config.chart.events.markerClick(e, this.ctx, {
      seriesIndex: t,
      dataPointIndex: i,
      w: s
    }), this.ctx.events.fireEvent("markerClick", [
      e,
      this.ctx,
      { seriesIndex: t, dataPointIndex: i, w: s }
    ]);
  }
  create(e, t, i, s, n, o = null) {
    var m, v, r, h, u, g, b, O, x, S, k, C, _, $, L, E;
    let l = this.w, c = t;
    e.type === "mouseup" && this.markerClick(e, i, s), o === null && (o = this.tConfig.shared);
    const d = this.tooltipUtil.hasMarkers(i), f = this.tooltipUtil.getElBars();
    if (l.config.legend.tooltipHoverFormatter) {
      let A = l.config.legend.tooltipHoverFormatter, y = Array.from(this.legendLabels);
      y.forEach((w) => {
        const T = w.getAttribute("data:default-text");
        w.innerHTML = decodeURIComponent(T);
      });
      for (let w = 0; w < y.length; w++) {
        const T = y[w], P = parseInt(T.getAttribute("i"), 10), R = decodeURIComponent(
          T.getAttribute("data:default-text")
        );
        let Q = A(R, {
          seriesIndex: o ? P : i,
          dataPointIndex: s,
          w: l
        });
        if (o)
          T.innerHTML = l.globals.collapsedSeriesIndices.indexOf(P) < 0 ? Q : R;
        else if (T.innerHTML = P === i ? Q : R, i === P)
          break;
      }
    }
    const p = {
      ttItems: n,
      i,
      j: s,
      ...typeof ((h = (r = (v = (m = l.globals.seriesRange) == null ? void 0 : m[i]) == null ? void 0 : v[s]) == null ? void 0 : r.y[0]) == null ? void 0 : h.y1) < "u" && {
        y1: (O = (b = (g = (u = l.globals.seriesRange) == null ? void 0 : u[i]) == null ? void 0 : g[s]) == null ? void 0 : b.y[0]) == null ? void 0 : O.y1
      },
      ...typeof ((C = (k = (S = (x = l.globals.seriesRange) == null ? void 0 : x[i]) == null ? void 0 : S[s]) == null ? void 0 : k.y[0]) == null ? void 0 : C.y2) < "u" && {
        y2: (E = (L = ($ = (_ = l.globals.seriesRange) == null ? void 0 : _[i]) == null ? void 0 : $[s]) == null ? void 0 : L.y[0]) == null ? void 0 : E.y2
      }
    };
    if (o) {
      if (c.tooltipLabels.drawSeriesTexts({
        ...p,
        shared: this.showOnIntersect ? !1 : this.tConfig.shared
      }), d)
        l.globals.markers.largestSize > 0 ? c.marker.enlargePoints(s) : c.tooltipPosition.moveDynamicPointsOnHover(s);
      else if (this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(f), this.barSeriesHeight > 0)) {
        let A = new K(this.ctx), y = l.globals.dom.Paper.select(
          `.apexcharts-bar-area[j='${s}']`
        );
        this.deactivateHoverFilter(), this.tooltipPosition.moveStickyTooltipOverBars(s, i);
        for (let w = 0; w < y.length; w++)
          A.pathMouseEnter(y[w]);
      }
    } else
      c.tooltipLabels.drawSeriesTexts({
        shared: !1,
        ...p
      }), this.tooltipUtil.hasBars() && c.tooltipPosition.moveStickyTooltipOverBars(s, i), d && c.tooltipPosition.moveMarkers(i, s);
  }
}
class TL {
  constructor(e) {
    this.w = e.w, this.barCtx = e, this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter, this.totalFormatter || (this.totalFormatter = this.w.config.dataLabels.formatter);
  }
  /** handleBarDataLabels is used to calculate the positions for the data-labels
   * It also sets the element's data attr for bars and calls drawCalculatedBarDataLabels()
   * After calculating, it also calls the function to draw data labels
   * @memberof Bar
   * @param {object} {barProps} most of the bar properties used throughout the bar
   * drawing function
   * @return {object} dataLabels node-element which you can append later
   **/
  handleBarDataLabels(e) {
    let {
      x: t,
      y: i,
      y1: s,
      y2: n,
      i: o,
      j: l,
      realIndex: c,
      groupIndex: d,
      series: f,
      barHeight: p,
      barWidth: m,
      barXPosition: v,
      barYPosition: r,
      visibleSeries: h,
      renderedPath: u
    } = e, g = this.w, b = new K(this.barCtx.ctx), O = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[c] : this.barCtx.strokeWidth, x = t + parseFloat(m * h), S = i + parseFloat(p * h);
    g.globals.isXNumeric && !g.globals.isBarHorizontal && (x = t + parseFloat(m * (h + 1)), S = i + parseFloat(p * (h + 1)) - O);
    let k = null, C = null, _ = t, $ = i, L = {}, E = g.config.dataLabels, A = this.barCtx.barOptions.dataLabels, y = this.barCtx.barOptions.dataLabels.total;
    typeof r < "u" && this.barCtx.isRangeBar && (S = r, $ = r), typeof v < "u" && this.barCtx.isVerticalGroupedRangeBar && (x = v, _ = v);
    const w = E.offsetX, T = E.offsetY;
    let P = {
      width: 0,
      height: 0
    };
    if (g.config.dataLabels.enabled) {
      const Q = this.barCtx.series[o][l];
      P = b.getTextRects(
        g.globals.yLabelFormatters[0](Q),
        parseFloat(E.style.fontSize)
      );
    }
    const R = {
      x: t,
      y: i,
      i: o,
      j: l,
      realIndex: c,
      groupIndex: d || -1,
      renderedPath: u,
      bcx: x,
      bcy: S,
      barHeight: p,
      barWidth: m,
      textRects: P,
      strokeWidth: O,
      dataLabelsX: _,
      dataLabelsY: $,
      dataLabelsConfig: E,
      barDataLabelsConfig: A,
      barTotalDataLabelsConfig: y,
      offX: w,
      offY: T
    };
    return this.barCtx.isHorizontal ? L = this.calculateBarsDataLabelsPosition(R) : L = this.calculateColumnsDataLabelsPosition(R), u.attr({
      cy: L.bcy,
      cx: L.bcx,
      j: l,
      val: f[o][l],
      barHeight: p,
      barWidth: m
    }), k = this.drawCalculatedDataLabels({
      x: L.dataLabelsX,
      y: L.dataLabelsY,
      val: this.barCtx.isRangeBar ? [s, n] : f[o][l],
      i: c,
      j: l,
      barWidth: m,
      barHeight: p,
      textRects: P,
      dataLabelsConfig: E
    }), g.config.chart.stacked && y.enabled && (C = this.drawTotalDataLabels({
      x: L.totalDataLabelsX,
      y: L.totalDataLabelsY,
      barWidth: m,
      barHeight: p,
      realIndex: c,
      textAnchor: L.totalDataLabelsAnchor,
      val: this.getStackedTotalDataLabel({ realIndex: c, j: l }),
      dataLabelsConfig: E,
      barTotalDataLabelsConfig: y
    })), {
      dataLabels: k,
      totalDataLabels: C
    };
  }
  getStackedTotalDataLabel({ realIndex: e, j: t }) {
    const i = this.w;
    let s = this.barCtx.stackedSeriesTotals[t];
    return this.totalFormatter && (s = this.totalFormatter(s, {
      ...i,
      seriesIndex: e,
      dataPointIndex: t,
      w: i
    })), s;
  }
  calculateColumnsDataLabelsPosition(e) {
    const t = this.w;
    let {
      i,
      j: s,
      realIndex: n,
      groupIndex: o,
      y: l,
      bcx: c,
      barWidth: d,
      barHeight: f,
      textRects: p,
      dataLabelsX: m,
      dataLabelsY: v,
      dataLabelsConfig: r,
      barDataLabelsConfig: h,
      barTotalDataLabelsConfig: u,
      strokeWidth: g,
      offX: b,
      offY: O
    } = e, x, S, k = "middle";
    f = Math.abs(f);
    let C = t.config.plotOptions.bar.dataLabels.orientation === "vertical";
    const { zeroEncounters: _ } = this.barCtx.barHelpers.getZeroValueEncounters({
      i,
      j: s
    });
    c = c - g / 2 + (o !== -1 ? o * d : 0);
    let $ = t.globals.gridWidth / t.globals.dataPoints;
    this.barCtx.isVerticalGroupedRangeBar ? m = m + d / 2 : (t.globals.isXNumeric ? m = c - d / 2 + b : m = c - $ + d / 2 + b, _ > 0 && t.config.plotOptions.bar.hideZeroBarsWhenGrouped && (m = m - d * _)), C && (m = m + p.height / 2 - g / 2 - 2);
    let L = this.barCtx.series[i][s] < 0, E = l;
    switch (this.barCtx.isReversed && (E = l - f + (L ? f * 2 : 0), l = l - f), h.position) {
      case "center":
        C ? L ? v = E - f / 2 + O : v = E + f / 2 - O : L ? v = E - f / 2 + p.height / 2 + O : v = E + f / 2 + p.height / 2 - O;
        break;
      case "bottom":
        C ? L ? v = E - f + O : v = E + f - O : L ? v = E - f + p.height + g + O : v = E + f - p.height / 2 + g - O;
        break;
      case "top":
        C ? L ? v = E + O : v = E - O : L ? v = E - p.height / 2 - O : v = E + p.height + O;
        break;
    }
    if (this.barCtx.lastActiveBarSerieIndex === n && u.enabled) {
      const w = new K(this.barCtx.ctx).getTextRects(
        this.getStackedTotalDataLabel({ realIndex: n, j: s }),
        r.fontSize
      );
      L ? x = E - w.height / 2 - O - u.offsetY + 18 : x = E + w.height + O + u.offsetY - 18, S = m + u.offsetX;
    }
    return t.config.chart.stacked || (v < 0 ? v = 0 + g : v + p.height / 3 > t.globals.gridHeight && (v = t.globals.gridHeight - g)), {
      bcx: c,
      bcy: l,
      dataLabelsX: m,
      dataLabelsY: v,
      totalDataLabelsX: S,
      totalDataLabelsY: x,
      totalDataLabelsAnchor: k
    };
  }
  calculateBarsDataLabelsPosition(e) {
    const t = this.w;
    let {
      x: i,
      i: s,
      j: n,
      realIndex: o,
      groupIndex: l,
      bcy: c,
      barHeight: d,
      barWidth: f,
      textRects: p,
      dataLabelsX: m,
      strokeWidth: v,
      dataLabelsConfig: r,
      barDataLabelsConfig: h,
      barTotalDataLabelsConfig: u,
      offX: g,
      offY: b
    } = e, O = t.globals.gridHeight / t.globals.dataPoints;
    f = Math.abs(f), c = c + (l !== -1 ? l * d : 0);
    let x = c - (this.barCtx.isRangeBar ? 0 : O) + d / 2 + p.height / 2 + b - 3, S, k, C = "start", _ = this.barCtx.series[s][n] < 0, $ = i;
    switch (this.barCtx.isReversed && ($ = i + f - (_ ? f * 2 : 0), i = t.globals.gridWidth - f), h.position) {
      case "center":
        _ ? m = $ + f / 2 - g : m = Math.max(p.width / 2, $ - f / 2) + g;
        break;
      case "bottom":
        _ ? m = $ + f - v - Math.round(p.width / 2) - g : m = $ - f + v + Math.round(p.width / 2) + g;
        break;
      case "top":
        _ ? m = $ - v + Math.round(p.width / 2) - g : m = $ - v - Math.round(p.width / 2) + g;
        break;
    }
    if (this.barCtx.lastActiveBarSerieIndex === o && u.enabled) {
      const A = new K(this.barCtx.ctx).getTextRects(
        this.getStackedTotalDataLabel({ realIndex: o, j: n }),
        r.fontSize
      );
      _ ? (S = $ - v + Math.round(A.width / 2) - g - u.offsetX - 15, C = "end") : S = $ - v - Math.round(A.width / 2) + g + u.offsetX + 15, k = x + u.offsetY;
    }
    return t.config.chart.stacked || (m < 0 ? m = m + p.width + v : m + p.width / 2 > t.globals.gridWidth && (m = t.globals.gridWidth - p.width - v)), {
      bcx: i,
      bcy: c,
      dataLabelsX: m,
      dataLabelsY: x,
      totalDataLabelsX: S,
      totalDataLabelsY: k,
      totalDataLabelsAnchor: C
    };
  }
  drawCalculatedDataLabels({
    x: e,
    y: t,
    val: i,
    i: s,
    // = realIndex
    j: n,
    textRects: o,
    barHeight: l,
    barWidth: c,
    dataLabelsConfig: d
  }) {
    const f = this.w;
    let p = "rotate(0)";
    f.config.plotOptions.bar.dataLabels.orientation === "vertical" && (p = `rotate(-90, ${e}, ${t})`);
    const m = new Yn(this.barCtx.ctx), v = new K(this.barCtx.ctx), r = d.formatter;
    let h = null;
    const u = f.globals.collapsedSeriesIndices.indexOf(s) > -1;
    if (d.enabled && !u) {
      h = v.group({
        class: "apexcharts-data-labels",
        transform: p
      });
      let g = "";
      typeof i < "u" && (g = r(i, {
        ...f,
        seriesIndex: s,
        dataPointIndex: n,
        w: f
      })), !i && f.config.plotOptions.bar.hideZeroBarsWhenGrouped && (g = "");
      let b = f.globals.series[s][n] < 0, O = f.config.plotOptions.bar.dataLabels.position;
      if (f.config.plotOptions.bar.dataLabels.orientation === "vertical" && (O === "top" && (b ? d.textAnchor = "end" : d.textAnchor = "start"), O === "center" && (d.textAnchor = "middle"), O === "bottom" && (b ? d.textAnchor = "end" : d.textAnchor = "start")), this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels) {
        const S = v.getTextRects(
          g,
          parseFloat(d.style.fontSize)
        );
        c < S.width && (g = "");
      }
      f.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? o.width / 1.6 > Math.abs(c) && (g = "") : o.height / 1.6 > Math.abs(l) && (g = ""));
      let x = {
        ...d
      };
      this.barCtx.isHorizontal && i < 0 && (d.textAnchor === "start" ? x.textAnchor = "end" : d.textAnchor === "end" && (x.textAnchor = "start")), m.plotDataLabelsText({
        x: e,
        y: t,
        text: g,
        i: s,
        j: n,
        parent: h,
        dataLabelsConfig: x,
        alwaysDrawDataLabel: !0,
        offsetCorrection: !0
      });
    }
    return h;
  }
  drawTotalDataLabels({
    x: e,
    y: t,
    val: i,
    barWidth: s,
    barHeight: n,
    realIndex: o,
    textAnchor: l,
    barTotalDataLabelsConfig: c
  }) {
    const d = this.w, f = new K(this.barCtx.ctx);
    let p;
    return c.enabled && typeof e < "u" && typeof t < "u" && this.barCtx.lastActiveBarSerieIndex === o && (p = f.drawText({
      x: e - (!d.globals.isBarHorizontal && d.globals.seriesGroups.length ? s / d.globals.seriesGroups.length : 0),
      y: t - (d.globals.isBarHorizontal && d.globals.seriesGroups.length ? n / d.globals.seriesGroups.length : 0),
      foreColor: c.style.color,
      text: i,
      textAnchor: l,
      fontFamily: c.style.fontFamily,
      fontSize: c.style.fontSize,
      fontWeight: c.style.fontWeight
    })), p;
  }
}
let AL = class {
  constructor(e) {
    this.w = e.w, this.barCtx = e;
  }
  initVariables(e) {
    const t = this.w;
    this.barCtx.series = e, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
    for (let i = 0; i < e.length; i++)
      if (e[i].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += e[i].length), t.globals.isXNumeric)
        for (let s = 0; s < e[i].length; s++)
          t.globals.seriesX[i][s] > t.globals.minX && t.globals.seriesX[i][s] < t.globals.maxX && this.barCtx.visibleItems++;
      else
        this.barCtx.visibleItems = t.globals.dataPoints;
    this.barCtx.seriesLen === 0 && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], t.globals.comboCharts || this.checkZeroSeries({ series: e });
  }
  initialPositions() {
    let e = this.w, t, i, s, n, o, l, c, d, f = e.globals.dataPoints;
    this.barCtx.isRangeBar && (f = e.globals.labels.length);
    let p = this.barCtx.seriesLen;
    if (e.config.plotOptions.bar.rangeBarGroupRows && (p = 1), this.barCtx.isHorizontal)
      s = e.globals.gridHeight / f, o = s / p, e.globals.isXNumeric && (s = e.globals.gridHeight / this.barCtx.totalItems, o = s / this.barCtx.seriesLen), o = o * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, String(this.barCtx.barOptions.barHeight).indexOf("%") === -1 && (o = parseInt(this.barCtx.barOptions.barHeight, 10)), d = this.barCtx.baseLineInvertedY + e.globals.padHorizontal + (this.barCtx.isReversed ? e.globals.gridWidth : 0) - (this.barCtx.isReversed ? this.barCtx.baseLineInvertedY * 2 : 0), this.barCtx.isFunnel && (d = e.globals.gridWidth / 2), i = (s - o * this.barCtx.seriesLen) / 2;
    else {
      if (n = e.globals.gridWidth / this.barCtx.visibleItems, e.config.xaxis.convertedCatToNumeric && (n = e.globals.gridWidth / e.globals.dataPoints), l = n / p * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, e.globals.isXNumeric) {
        let m = this.barCtx.xRatio;
        e.globals.minXDiff && e.globals.minXDiff !== 0.5 && e.globals.minXDiff / m > 0 && (n = e.globals.minXDiff / m), l = n / p * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, l < 1 && (l = 1);
      }
      String(this.barCtx.barOptions.columnWidth).indexOf("%") === -1 && (l = parseInt(this.barCtx.barOptions.columnWidth, 10)), c = e.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.translationsIndex] - (this.barCtx.isReversed ? e.globals.gridHeight : 0) + (this.barCtx.isReversed ? this.barCtx.baseLineY[this.barCtx.translationsIndex] * 2 : 0), t = e.globals.padHorizontal + (n - l * this.barCtx.seriesLen) / 2;
    }
    return e.globals.barHeight = o, e.globals.barWidth = l, {
      x: t,
      y: i,
      yDivision: s,
      xDivision: n,
      barHeight: o,
      barWidth: l,
      zeroH: c,
      zeroW: d
    };
  }
  initializeStackedPrevVars(e) {
    const t = e.w;
    t.globals.hasSeriesGroups ? t.globals.seriesGroups.forEach((i) => {
      e[i] || (e[i] = {}), e[i].prevY = [], e[i].prevX = [], e[i].prevYF = [], e[i].prevXF = [], e[i].prevYVal = [], e[i].prevXVal = [];
    }) : (e.prevY = [], e.prevX = [], e.prevYF = [], e.prevXF = [], e.prevYVal = [], e.prevXVal = []);
  }
  initializeStackedXYVars(e) {
    const t = e.w;
    t.globals.hasSeriesGroups ? t.globals.seriesGroups.forEach((i) => {
      e[i] || (e[i] = {}), e[i].xArrj = [], e[i].xArrjF = [], e[i].xArrjVal = [], e[i].yArrj = [], e[i].yArrjF = [], e[i].yArrjVal = [];
    }) : (e.xArrj = [], e.xArrjF = [], e.xArrjVal = [], e.yArrj = [], e.yArrjF = [], e.yArrjVal = []);
  }
  getPathFillColor(e, t, i, s) {
    var f, p, m, v;
    const n = this.w;
    let o = new _i(this.barCtx.ctx), l = null, c = this.barCtx.barOptions.distributed ? i : t;
    return this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map((h) => {
      e[t][i] >= h.from && e[t][i] <= h.to && (l = h.color);
    }), n.config.series[t].data[i] && n.config.series[t].data[i].fillColor && (l = n.config.series[t].data[i].fillColor), o.fillPath({
      seriesNumber: this.barCtx.barOptions.distributed ? c : s,
      dataPointIndex: i,
      color: l,
      value: e[t][i],
      fillConfig: (f = n.config.series[t].data[i]) == null ? void 0 : f.fill,
      fillType: (m = (p = n.config.series[t].data[i]) == null ? void 0 : p.fill) != null && m.type ? (v = n.config.series[t].data[i]) == null ? void 0 : v.fill.type : Array.isArray(n.config.fill.type) ? n.config.fill.type[t] : n.config.fill.type
    });
  }
  getStrokeWidth(e, t, i) {
    let s = 0;
    const n = this.w;
    return typeof this.barCtx.series[e][t] > "u" || this.barCtx.series[e][t] === null ? this.barCtx.isNullValue = !0 : this.barCtx.isNullValue = !1, n.config.stroke.show && (this.barCtx.isNullValue || (s = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i] : this.barCtx.strokeWidth)), s;
  }
  shouldApplyRadius(e) {
    const t = this.w;
    let i = !1;
    return t.config.plotOptions.bar.borderRadius > 0 && (t.config.chart.stacked && t.config.plotOptions.bar.borderRadiusWhenStacked === "last" ? this.barCtx.lastActiveBarSerieIndex === e && (i = !0) : i = !0), i;
  }
  barBackground({ j: e, i: t, x1: i, x2: s, y1: n, y2: o, elSeries: l }) {
    const c = this.w, d = new K(this.barCtx.ctx);
    let p = new mi(this.barCtx.ctx).getActiveConfigSeriesIndex();
    if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && p === t) {
      e >= this.barCtx.barOptions.colors.backgroundBarColors.length && (e %= this.barCtx.barOptions.colors.backgroundBarColors.length);
      let m = this.barCtx.barOptions.colors.backgroundBarColors[e], v = d.drawRect(
        typeof i < "u" ? i : 0,
        typeof n < "u" ? n : 0,
        typeof s < "u" ? s : c.globals.gridWidth,
        typeof o < "u" ? o : c.globals.gridHeight,
        this.barCtx.barOptions.colors.backgroundBarRadius,
        m,
        this.barCtx.barOptions.colors.backgroundBarOpacity
      );
      l.add(v), v.node.classList.add("apexcharts-backgroundBar");
    }
  }
  getColumnPaths({
    barWidth: e,
    barXPosition: t,
    y1: i,
    y2: s,
    strokeWidth: n,
    seriesGroup: o,
    realIndex: l,
    i: c,
    j: d,
    w: f
  }) {
    var O;
    const p = new K(this.barCtx.ctx);
    n = Array.isArray(n) ? n[l] : n, n || (n = 0);
    let m = e, v = t;
    (O = f.config.series[l].data[d]) != null && O.columnWidthOffset && (v = t - f.config.series[l].data[d].columnWidthOffset / 2, m = e + f.config.series[l].data[d].columnWidthOffset);
    const r = v, h = v + m;
    i += 1e-3, s += 1e-3;
    let u = p.move(r, i), g = p.move(r, i);
    const b = p.line(h - n, i);
    if (f.globals.previousPaths.length > 0 && (g = this.barCtx.getPreviousPath(l, d, !1)), u = u + p.line(r, s) + p.line(h - n, s) + p.line(h - n, i) + (f.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z"), g = g + p.line(r, i) + b + b + b + b + b + p.line(r, i) + (f.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z"), this.shouldApplyRadius(l) && (u = p.roundPathCorners(
      u,
      f.config.plotOptions.bar.borderRadius
    )), f.config.chart.stacked) {
      let x = this.barCtx;
      f.globals.hasSeriesGroups && o && (x = this.barCtx[o]), x.yArrj.push(s), x.yArrjF.push(Math.abs(i - s)), x.yArrjVal.push(this.barCtx.series[c][d]);
    }
    return {
      pathTo: u,
      pathFrom: g
    };
  }
  getBarpaths({
    barYPosition: e,
    barHeight: t,
    x1: i,
    x2: s,
    strokeWidth: n,
    seriesGroup: o,
    realIndex: l,
    i: c,
    j: d,
    w: f
  }) {
    var O;
    const p = new K(this.barCtx.ctx);
    n = Array.isArray(n) ? n[l] : n, n || (n = 0);
    let m = e, v = t;
    (O = f.config.series[l].data[d]) != null && O.barHeightOffset && (m = e - f.config.series[l].data[d].barHeightOffset / 2, v = t + f.config.series[l].data[d].barHeightOffset);
    const r = m, h = m + v;
    i += 1e-3, s += 1e-3;
    let u = p.move(i, r), g = p.move(i, r);
    f.globals.previousPaths.length > 0 && (g = this.barCtx.getPreviousPath(l, d, !1));
    const b = p.line(i, h - n);
    if (u = u + p.line(s, r) + p.line(s, h - n) + b + (f.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z"), g = g + p.line(i, r) + b + b + b + b + b + p.line(i, r) + (f.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z"), this.shouldApplyRadius(l) && (u = p.roundPathCorners(
      u,
      f.config.plotOptions.bar.borderRadius
    )), f.config.chart.stacked) {
      let x = this.barCtx;
      f.globals.hasSeriesGroups && o && (x = this.barCtx[o]), x.xArrj.push(s), x.xArrjF.push(Math.abs(i - s)), x.xArrjVal.push(this.barCtx.series[c][d]);
    }
    return {
      pathTo: u,
      pathFrom: g
    };
  }
  checkZeroSeries({ series: e }) {
    let t = this.w;
    for (let i = 0; i < e.length; i++) {
      let s = 0;
      for (let n = 0; n < e[t.globals.maxValsInArrayIndex].length; n++)
        s += e[i][n];
      s === 0 && this.barCtx.zeroSerieses.push(i);
    }
  }
  getXForValue(e, t, i = !0) {
    let s = i ? t : null;
    return typeof e < "u" && e !== null && (s = t + e / this.barCtx.invertedYRatio - (this.barCtx.isReversed ? e / this.barCtx.invertedYRatio : 0) * 2), s;
  }
  getYForValue(e, t, i, s = !0) {
    let n = s ? t : null;
    return typeof e < "u" && e !== null && (n = t - e / this.barCtx.yRatio[i] + (this.barCtx.isReversed ? e / this.barCtx.yRatio[i] : 0) * 2), n;
  }
  getGoalValues(e, t, i, s, n, o) {
    const l = this.w;
    let c = [];
    const d = (f, p) => {
      c.push({
        [e]: e === "x" ? this.getXForValue(f, t, !1) : this.getYForValue(f, i, o, !1),
        attrs: p
      });
    };
    if (l.globals.seriesGoals[s] && l.globals.seriesGoals[s][n] && Array.isArray(l.globals.seriesGoals[s][n]) && l.globals.seriesGoals[s][n].forEach((f) => {
      d(f.value, f);
    }), this.barCtx.barOptions.isDumbbell && l.globals.seriesRange.length) {
      let f = this.barCtx.barOptions.dumbbellColors ? this.barCtx.barOptions.dumbbellColors : l.globals.colors;
      const p = {
        strokeHeight: e === "x" ? 0 : l.globals.markers.size[s],
        strokeWidth: e === "x" ? l.globals.markers.size[s] : 0,
        strokeDashArray: 0,
        strokeLineCap: "round",
        strokeColor: Array.isArray(f[s]) ? f[s][0] : f[s]
      };
      d(l.globals.seriesRangeStart[s][n], p), d(l.globals.seriesRangeEnd[s][n], {
        ...p,
        strokeColor: Array.isArray(f[s]) ? f[s][1] : f[s]
      });
    }
    return c;
  }
  drawGoalLine({
    barXPosition: e,
    barYPosition: t,
    goalX: i,
    goalY: s,
    barWidth: n,
    barHeight: o
  }) {
    let l = new K(this.barCtx.ctx);
    const c = l.group({
      className: "apexcharts-bar-goals-groups"
    });
    c.node.classList.add("apexcharts-element-hidden"), this.barCtx.w.globals.delayedElements.push({
      el: c.node
    }), c.attr(
      "clip-path",
      `url(#gridRectMarkerMask${this.barCtx.w.globals.cuid})`
    );
    let d = null;
    return this.barCtx.isHorizontal ? Array.isArray(i) && i.forEach((f) => {
      if (f.x >= -1 && f.x <= l.w.globals.gridWidth + 1) {
        let p = typeof f.attrs.strokeHeight < "u" ? f.attrs.strokeHeight : o / 2, m = t + p + o / 2;
        d = l.drawLine(
          f.x,
          m - p * 2,
          f.x,
          m,
          f.attrs.strokeColor ? f.attrs.strokeColor : void 0,
          f.attrs.strokeDashArray,
          f.attrs.strokeWidth ? f.attrs.strokeWidth : 2,
          f.attrs.strokeLineCap
        ), c.add(d);
      }
    }) : Array.isArray(s) && s.forEach((f) => {
      if (f.y >= -1 && f.y <= l.w.globals.gridHeight + 1) {
        let p = typeof f.attrs.strokeWidth < "u" ? f.attrs.strokeWidth : n / 2, m = e + p + n / 2;
        d = l.drawLine(
          m - p * 2,
          f.y,
          m,
          f.y,
          f.attrs.strokeColor ? f.attrs.strokeColor : void 0,
          f.attrs.strokeDashArray,
          f.attrs.strokeHeight ? f.attrs.strokeHeight : 2,
          f.attrs.strokeLineCap
        ), c.add(d);
      }
    }), c;
  }
  drawBarShadow({ prevPaths: e, currPaths: t, color: i }) {
    const s = this.w, { x: n, x1: o, barYPosition: l } = e, { x: c, x1: d, barYPosition: f } = t, p = l + t.barHeight, m = new K(this.barCtx.ctx), v = new N(), r = m.move(o, p) + m.line(n, p) + m.line(c, f) + m.line(d, f) + m.line(o, p) + (s.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z");
    return m.drawPath({
      d: r,
      fill: v.shadeColor(0.5, N.rgb2hex(i)),
      stroke: "none",
      strokeWidth: 0,
      fillOpacity: 1,
      classes: "apexcharts-bar-shadows"
    });
  }
  getZeroValueEncounters({ i: e, j: t }) {
    const i = this.w;
    let s = 0, n = 0;
    return i.globals.seriesPercent.forEach((o, l) => {
      o[t] && s++, l < e && o[t] === 0 && n++;
    }), {
      nonZeroColumns: s,
      zeroEncounters: n
    };
  }
};
class Vn {
  constructor(e, t) {
    this.ctx = e, this.w = e.w;
    const i = this.w;
    this.barOptions = i.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = i.config.stroke.width, this.isNullValue = !1, this.isRangeBar = i.globals.seriesRange.length && this.isHorizontal, this.isVerticalGroupedRangeBar = !i.globals.isBarHorizontal && i.globals.seriesRange.length && i.config.plotOptions.bar.rangeBarGroupRows, this.isFunnel = this.barOptions.isFunnel, this.xyRatios = t, this.xyRatios !== null && (this.xRatio = t.xRatio, this.yRatio = t.yRatio, this.invertedXRatio = t.invertedXRatio, this.invertedYRatio = t.invertedYRatio, this.baseLineY = t.baseLineY, this.baseLineInvertedY = t.baseLineInvertedY), this.yaxisIndex = 0, this.translationsIndex = 0, this.seriesLen = 0, this.pathArr = [];
    const s = new mi(this.ctx);
    this.lastActiveBarSerieIndex = s.getActiveConfigSeriesIndex("desc", [
      "bar",
      "column"
    ]);
    const n = s.getBarSeriesIndices(), o = new vt(this.ctx);
    this.stackedSeriesTotals = o.getStackedSeriesTotals(
      this.w.config.series.map((l, c) => n.indexOf(c) === -1 ? c : -1).filter((l) => l !== -1)
    ), this.barHelpers = new AL(this);
  }
  /** primary draw method which is called on bar object
   * @memberof Bar
   * @param {array} series - user supplied series values
   * @param {int} seriesIndex - the index by which series will be drawn on the svg
   * @return {node} element which is supplied to parent chart draw method for appending
   **/
  draw(e, t) {
    let i = this.w, s = new K(this.ctx);
    const n = new vt(this.ctx, i);
    e = n.getLogSeries(e), this.series = e, this.yRatio = n.getLogYRatios(this.yRatio), this.barHelpers.initVariables(e);
    let o = s.group({
      class: "apexcharts-bar-series apexcharts-plot-series"
    });
    i.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn(
      "WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering - ApexCharts"
    );
    for (let l = 0, c = 0; l < e.length; l++, c++) {
      let d, f, p, m, v, r, h = [], u = [], g = i.globals.comboCharts ? t[l] : l, b = s.group({
        class: "apexcharts-series",
        rel: l + 1,
        seriesName: N.escapeString(i.globals.seriesNames[g]),
        "data:realIndex": g
      });
      this.ctx.series.addCollapsedClassToSeries(b, g), e[l].length > 0 && (this.visibleI = this.visibleI + 1);
      let O = 0, x = 0;
      this.yRatio.length > 1 && (this.yaxisIndex = i.globals.seriesYAxisReverseMap[g], this.translationsIndex = g);
      let S = this.translationsIndex;
      this.isReversed = i.config.yaxis[this.yaxisIndex] && i.config.yaxis[this.yaxisIndex].reversed;
      let k = this.barHelpers.initialPositions();
      f = k.y, O = k.barHeight, m = k.yDivision, r = k.zeroW, d = k.x, x = k.barWidth, p = k.xDivision, v = k.zeroH, this.horizontal || u.push(d + x / 2);
      let C = s.group({
        class: "apexcharts-datalabels",
        "data:realIndex": g
      });
      i.globals.delayedElements.push({
        el: C.node
      }), C.node.classList.add("apexcharts-element-hidden");
      let _ = s.group({
        class: "apexcharts-bar-goals-markers"
      }), $ = s.group({
        class: "apexcharts-bar-shadows"
      });
      i.globals.delayedElements.push({
        el: $.node
      }), $.node.classList.add("apexcharts-element-hidden");
      for (let L = 0; L < e[l].length; L++) {
        const E = this.barHelpers.getStrokeWidth(l, L, g);
        let A = null;
        const y = {
          indexes: {
            i: l,
            j: L,
            realIndex: g,
            translationsIndex: S,
            bc: c
          },
          x: d,
          y: f,
          strokeWidth: E,
          elSeries: b
        };
        this.isHorizontal ? (A = this.drawBarPaths({
          ...y,
          barHeight: O,
          zeroW: r,
          yDivision: m
        }), x = this.series[l][L] / this.invertedYRatio) : (A = this.drawColumnPaths({
          ...y,
          xDivision: p,
          barWidth: x,
          zeroH: v
        }), O = this.series[l][L] / this.yRatio[S]);
        let w = this.barHelpers.getPathFillColor(e, l, L, g);
        if (this.isFunnel && this.barOptions.isFunnel3d && this.pathArr.length && L > 0) {
          const P = this.barHelpers.drawBarShadow({
            color: typeof w == "string" && (w == null ? void 0 : w.indexOf("url")) === -1 ? w : N.hexToRgba(i.globals.colors[l]),
            prevPaths: this.pathArr[this.pathArr.length - 1],
            currPaths: A
          });
          P && $.add(P);
        }
        this.pathArr.push(A);
        const T = this.barHelpers.drawGoalLine({
          barXPosition: A.barXPosition,
          barYPosition: A.barYPosition,
          goalX: A.goalX,
          goalY: A.goalY,
          barHeight: O,
          barWidth: x
        });
        T && _.add(T), f = A.y, d = A.x, L > 0 && u.push(d + x / 2), h.push(f), this.renderSeries({
          realIndex: g,
          pathFill: w,
          j: L,
          i: l,
          pathFrom: A.pathFrom,
          pathTo: A.pathTo,
          strokeWidth: E,
          elSeries: b,
          x: d,
          y: f,
          series: e,
          barHeight: A.barHeight ? A.barHeight : O,
          barWidth: A.barWidth ? A.barWidth : x,
          elDataLabelsWrap: C,
          elGoalsMarkers: _,
          elBarShadows: $,
          visibleSeries: this.visibleI,
          type: "bar"
        });
      }
      i.globals.seriesXvalues[g] = u, i.globals.seriesYvalues[g] = h, o.add(b);
    }
    return o;
  }
  renderSeries({
    realIndex: e,
    pathFill: t,
    lineFill: i,
    j: s,
    i: n,
    groupIndex: o,
    // required in grouped-stacked bars
    pathFrom: l,
    pathTo: c,
    strokeWidth: d,
    elSeries: f,
    x: p,
    // x pos
    y: m,
    // y pos
    y1: v,
    // absolute value
    y2: r,
    // absolute value
    series: h,
    barHeight: u,
    barWidth: g,
    barXPosition: b,
    barYPosition: O,
    elDataLabelsWrap: x,
    elGoalsMarkers: S,
    elBarShadows: k,
    visibleSeries: C,
    type: _
  }) {
    const $ = this.w, L = new K(this.ctx);
    i || (i = this.barOptions.distributed ? $.globals.stroke.colors[s] : $.globals.stroke.colors[e]), $.config.series[n].data[s] && $.config.series[n].data[s].strokeColor && (i = $.config.series[n].data[s].strokeColor), this.isNullValue && (t = "none");
    let E = s / $.config.chart.animations.animateGradually.delay * ($.config.chart.animations.speed / $.globals.dataPoints) / 2.4, A = L.renderPaths({
      i: n,
      j: s,
      realIndex: e,
      pathFrom: l,
      pathTo: c,
      stroke: i,
      strokeWidth: d,
      strokeLineCap: $.config.stroke.lineCap,
      fill: t,
      animationDelay: E,
      initialSpeed: $.config.chart.animations.speed,
      dataChangeSpeed: $.config.chart.animations.dynamicAnimation.speed,
      className: `apexcharts-${_}-area`
    });
    A.attr("clip-path", `url(#gridRectMask${$.globals.cuid})`);
    const y = $.config.forecastDataPoints;
    y.count > 0 && s >= $.globals.dataPoints - y.count && (A.node.setAttribute("stroke-dasharray", y.dashArray), A.node.setAttribute("stroke-width", y.strokeWidth), A.node.setAttribute("fill-opacity", y.fillOpacity)), typeof v < "u" && typeof r < "u" && (A.attr("data-range-y1", v), A.attr("data-range-y2", r)), new It(this.ctx).setSelectionFilter(A, e, s), f.add(A);
    let P = new TL(this).handleBarDataLabels({
      x: p,
      y: m,
      y1: v,
      y2: r,
      i: n,
      j: s,
      series: h,
      realIndex: e,
      groupIndex: o,
      barHeight: u,
      barWidth: g,
      barXPosition: b,
      barYPosition: O,
      renderedPath: A,
      visibleSeries: C
    });
    return P.dataLabels !== null && x.add(P.dataLabels), P.totalDataLabels && x.add(P.totalDataLabels), f.add(x), S && f.add(S), k && f.add(k), f;
  }
  drawBarPaths({
    indexes: e,
    barHeight: t,
    strokeWidth: i,
    zeroW: s,
    x: n,
    y: o,
    yDivision: l,
    elSeries: c
  }) {
    let d = this.w, f = e.i, p = e.j, m;
    if (d.globals.isXNumeric)
      o = (d.globals.seriesX[f][p] - d.globals.minX) / this.invertedXRatio - t, m = o + t * this.visibleI;
    else if (d.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
      let r = 0, h = 0;
      d.globals.seriesPercent.forEach((u, g) => {
        u[p] && r++, g < f && u[p] === 0 && h++;
      }), r > 0 && (t = this.seriesLen * t / r), m = o + t * this.visibleI, m -= t * h;
    } else
      m = o + t * this.visibleI;
    this.isFunnel && (s = s - (this.barHelpers.getXForValue(this.series[f][p], s) - s) / 2), n = this.barHelpers.getXForValue(this.series[f][p], s);
    const v = this.barHelpers.getBarpaths({
      barYPosition: m,
      barHeight: t,
      x1: s,
      x2: n,
      strokeWidth: i,
      series: this.series,
      realIndex: e.realIndex,
      i: f,
      j: p,
      w: d
    });
    return d.globals.isXNumeric || (o = o + l), this.barHelpers.barBackground({
      j: p,
      i: f,
      y1: m - t * this.visibleI,
      y2: t * this.seriesLen,
      elSeries: c
    }), {
      pathTo: v.pathTo,
      pathFrom: v.pathFrom,
      x1: s,
      x: n,
      y: o,
      goalX: this.barHelpers.getGoalValues("x", s, null, f, p),
      barYPosition: m,
      barHeight: t
    };
  }
  drawColumnPaths({
    indexes: e,
    x: t,
    y: i,
    xDivision: s,
    barWidth: n,
    zeroH: o,
    strokeWidth: l,
    elSeries: c
  }) {
    let d = this.w, f = e.realIndex, p = e.translationsIndex, m = e.i, v = e.j, r = e.bc, h;
    if (d.globals.isXNumeric) {
      const g = this.getBarXForNumericXAxis({
        x: t,
        j: v,
        realIndex: f,
        barWidth: n
      });
      t = g.x, h = g.barXPosition;
    } else if (d.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
      const { nonZeroColumns: g, zeroEncounters: b } = this.barHelpers.getZeroValueEncounters({ i: m, j: v });
      g > 0 && (n = this.seriesLen * n / g), h = t + n * this.visibleI, h -= n * b;
    } else
      h = t + n * this.visibleI;
    i = this.barHelpers.getYForValue(this.series[m][v], o, p);
    const u = this.barHelpers.getColumnPaths({
      barXPosition: h,
      barWidth: n,
      y1: o,
      y2: i,
      strokeWidth: l,
      series: this.series,
      realIndex: f,
      i: m,
      j: v,
      w: d
    });
    return d.globals.isXNumeric || (t = t + s), this.barHelpers.barBackground({
      bc: r,
      j: v,
      i: m,
      x1: h - l / 2 - n * this.visibleI,
      x2: n * this.seriesLen + l / 2,
      elSeries: c
    }), {
      pathTo: u.pathTo,
      pathFrom: u.pathFrom,
      x: t,
      y: i,
      goalY: this.barHelpers.getGoalValues("y", null, o, m, v, p),
      barXPosition: h,
      barWidth: n
    };
  }
  getBarXForNumericXAxis({ x: e, barWidth: t, realIndex: i, j: s }) {
    const n = this.w;
    let o = i;
    return n.globals.seriesX[i].length || (o = n.globals.maxValsInArrayIndex), n.globals.seriesX[o][s] && (e = (n.globals.seriesX[o][s] - n.globals.minX) / this.xRatio - t * this.seriesLen / 2), {
      barXPosition: e + t * this.visibleI,
      x: e
    };
  }
  /** getPreviousPath is a common function for bars/columns which is used to get previous paths when data changes.
   * @memberof Bar
   * @param {int} realIndex - current iterating i
   * @param {int} j - current iterating series's j index
   * @return {string} pathFrom is the string which will be appended in animations
   **/
  getPreviousPath(e, t) {
    let i = this.w, s;
    for (let n = 0; n < i.globals.previousPaths.length; n++) {
      let o = i.globals.previousPaths[n];
      o.paths && o.paths.length > 0 && parseInt(o.realIndex, 10) === parseInt(e, 10) && typeof i.globals.previousPaths[n].paths[t] < "u" && (s = i.globals.previousPaths[n].paths[t].d);
    }
    return s;
  }
}
class Zf extends Vn {
  draw(e, t) {
    let i = this.w;
    this.graphics = new K(this.ctx), this.bar = new Vn(this.ctx, this.xyRatios);
    const s = new vt(this.ctx, i);
    e = s.getLogSeries(e), this.yRatio = s.getLogYRatios(this.yRatio), this.barHelpers.initVariables(e), i.config.chart.stackType === "100%" && (e = i.globals.seriesPercent.slice()), this.series = e, this.barHelpers.initializeStackedPrevVars(this);
    let n = this.graphics.group({
      class: "apexcharts-bar-series apexcharts-plot-series"
    }), o = 0, l = 0;
    for (let c = 0, d = 0; c < e.length; c++, d++) {
      let f, p, m, v, r = -1;
      this.groupCtx = this, i.globals.seriesGroups.forEach(($, L) => {
        $.indexOf(i.config.series[c].name) > -1 && (r = L);
      }), r !== -1 && (this.groupCtx = this[i.globals.seriesGroups[r]]);
      let h = [], u = [], g = i.globals.comboCharts ? t[c] : c, b = 0;
      this.yRatio.length > 1 && (this.yaxisIndex = i.globals.seriesYAxisReverseMap[g][0], b = g), this.isReversed = i.config.yaxis[this.yaxisIndex] && i.config.yaxis[this.yaxisIndex].reversed;
      let O = this.graphics.group({
        class: "apexcharts-series",
        seriesName: N.escapeString(i.globals.seriesNames[g]),
        rel: c + 1,
        "data:realIndex": g
      });
      this.ctx.series.addCollapsedClassToSeries(O, g);
      let x = this.graphics.group({
        class: "apexcharts-datalabels",
        "data:realIndex": g
      }), S = this.graphics.group({
        class: "apexcharts-bar-goals-markers"
      }), k = 0, C = 0, _ = this.initialPositions(
        o,
        l,
        f,
        p,
        m,
        v,
        b
      );
      l = _.y, k = _.barHeight, p = _.yDivision, v = _.zeroW, o = _.x, C = _.barWidth, f = _.xDivision, m = _.zeroH, i.globals.barHeight = k, i.globals.barWidth = C, this.barHelpers.initializeStackedXYVars(this), this.groupCtx.prevY.length === 1 && this.groupCtx.prevY[0].every(($) => isNaN($)) && (this.groupCtx.prevY[0] = this.groupCtx.prevY[0].map(($) => m), this.groupCtx.prevYF[0] = this.groupCtx.prevYF[0].map(($) => 0));
      for (let $ = 0; $ < i.globals.dataPoints; $++) {
        const L = this.barHelpers.getStrokeWidth(c, $, g), E = {
          indexes: { i: c, j: $, realIndex: g, translationsIndex: b, bc: d },
          strokeWidth: L,
          x: o,
          y: l,
          elSeries: O,
          groupIndex: r,
          seriesGroup: i.globals.seriesGroups[r]
        };
        let A = null;
        this.isHorizontal ? (A = this.drawStackedBarPaths({
          ...E,
          zeroW: v,
          barHeight: k,
          yDivision: p
        }), C = this.series[c][$] / this.invertedYRatio) : (A = this.drawStackedColumnPaths({
          ...E,
          xDivision: f,
          barWidth: C,
          zeroH: m
        }), k = this.series[c][$] / this.yRatio[b]);
        const y = this.barHelpers.drawGoalLine({
          barXPosition: A.barXPosition,
          barYPosition: A.barYPosition,
          goalX: A.goalX,
          goalY: A.goalY,
          barHeight: k,
          barWidth: C
        });
        y && S.add(y), l = A.y, o = A.x, h.push(o), u.push(l);
        let w = this.barHelpers.getPathFillColor(e, c, $, g);
        O = this.renderSeries({
          realIndex: g,
          pathFill: w,
          j: $,
          i: c,
          groupIndex: r,
          pathFrom: A.pathFrom,
          pathTo: A.pathTo,
          strokeWidth: L,
          elSeries: O,
          x: o,
          y: l,
          series: e,
          barHeight: k,
          barWidth: C,
          elDataLabelsWrap: x,
          elGoalsMarkers: S,
          type: "bar",
          visibleSeries: 0
        });
      }
      i.globals.seriesXvalues[g] = h, i.globals.seriesYvalues[g] = u, this.groupCtx.prevY.push(this.groupCtx.yArrj), this.groupCtx.prevYF.push(this.groupCtx.yArrjF), this.groupCtx.prevYVal.push(this.groupCtx.yArrjVal), this.groupCtx.prevX.push(this.groupCtx.xArrj), this.groupCtx.prevXF.push(this.groupCtx.xArrjF), this.groupCtx.prevXVal.push(this.groupCtx.xArrjVal), n.add(O);
    }
    return n;
  }
  initialPositions(e, t, i, s, n, o, l) {
    var p, m;
    let c = this.w, d, f;
    return this.isHorizontal ? (s = c.globals.gridHeight / c.globals.dataPoints, d = s, d = d * parseInt(c.config.plotOptions.bar.barHeight, 10) / 100, String(c.config.plotOptions.bar.barHeight).indexOf("%") === -1 && (d = parseInt(c.config.plotOptions.bar.barHeight, 10)), o = this.baseLineInvertedY + c.globals.padHorizontal + (this.isReversed ? c.globals.gridWidth : 0) - (this.isReversed ? this.baseLineInvertedY * 2 : 0), t = (s - d) / 2) : (i = c.globals.gridWidth / c.globals.dataPoints, f = i, c.globals.isXNumeric && c.globals.dataPoints > 1 ? (i = c.globals.minXDiff / this.xRatio, f = i * parseInt(this.barOptions.columnWidth, 10) / 100) : f = f * parseInt(c.config.plotOptions.bar.columnWidth, 10) / 100, String(c.config.plotOptions.bar.columnWidth).indexOf("%") === -1 && (f = parseInt(c.config.plotOptions.bar.columnWidth, 10)), n = c.globals.gridHeight - this.baseLineY[l] - (this.isReversed ? c.globals.gridHeight : 0) + (this.isReversed ? this.baseLineY[l] * 2 : 0), e = c.globals.padHorizontal + (i - f) / 2), {
      x: e,
      y: t,
      yDivision: s,
      xDivision: i,
      barHeight: (p = c.globals.seriesGroups) != null && p.length ? d / c.globals.seriesGroups.length : d,
      barWidth: (m = c.globals.seriesGroups) != null && m.length ? f / c.globals.seriesGroups.length : f,
      zeroH: n,
      zeroW: o
    };
  }
  drawStackedBarPaths({
    indexes: e,
    barHeight: t,
    strokeWidth: i,
    zeroW: s,
    x: n,
    y: o,
    groupIndex: l,
    seriesGroup: c,
    yDivision: d,
    elSeries: f
  }) {
    let p = this.w, m = o + (l !== -1 ? l * t : 0), v, r = e.i, h = e.j, u = e.translationsIndex, g = 0;
    for (let x = 0; x < this.groupCtx.prevXF.length; x++)
      g = g + this.groupCtx.prevXF[x][h];
    let b = r;
    if (c && (b = c.indexOf(p.config.series[r].name)), b > 0) {
      let x = s;
      this.groupCtx.prevXVal[b - 1][h] < 0 ? x = this.series[r][h] >= 0 ? this.groupCtx.prevX[b - 1][h] + g - (this.isReversed ? g : 0) * 2 : this.groupCtx.prevX[b - 1][h] : this.groupCtx.prevXVal[b - 1][h] >= 0 && (x = this.series[r][h] >= 0 ? this.groupCtx.prevX[b - 1][h] : this.groupCtx.prevX[b - 1][h] - g + (this.isReversed ? g : 0) * 2), v = x;
    } else
      v = s;
    this.series[r][h] === null ? n = v : n = v + this.series[r][h] / this.invertedYRatio - (this.isReversed ? this.series[r][h] / this.invertedYRatio : 0) * 2;
    const O = this.barHelpers.getBarpaths({
      barYPosition: m,
      barHeight: t,
      x1: v,
      x2: n,
      strokeWidth: i,
      series: this.series,
      realIndex: e.realIndex,
      seriesGroup: c,
      i: r,
      j: h,
      w: p
    });
    return this.barHelpers.barBackground({
      j: h,
      i: r,
      y1: m,
      y2: t,
      elSeries: f
    }), o = o + d, {
      pathTo: O.pathTo,
      pathFrom: O.pathFrom,
      goalX: this.barHelpers.getGoalValues("x", s, null, r, h, u),
      barYPosition: m,
      x: n,
      y: o
    };
  }
  drawStackedColumnPaths({
    indexes: e,
    x: t,
    y: i,
    xDivision: s,
    barWidth: n,
    zeroH: o,
    groupIndex: l,
    seriesGroup: c,
    elSeries: d
  }) {
    var x, S, k, C;
    let f = this.w, p = e.i, m = e.j, v = e.bc, r = e.translationsIndex;
    if (f.globals.isXNumeric) {
      let _ = f.globals.seriesX[p][m];
      _ || (_ = 0), t = (_ - f.globals.minX) / this.xRatio - n / 2, f.globals.seriesGroups.length && (t = (_ - f.globals.minX) / this.xRatio - n / 2 * f.globals.seriesGroups.length);
    }
    let h = t + (l !== -1 ? l * n : 0), u, g = 0;
    for (let _ = 0; _ < this.groupCtx.prevYF.length; _++)
      g = g + (isNaN(this.groupCtx.prevYF[_][m]) ? 0 : this.groupCtx.prevYF[_][m]);
    let b = p;
    if (c && (b = c.indexOf(f.config.series[p].name)), b > 0 && !f.globals.isXNumeric || b > 0 && f.globals.isXNumeric && f.globals.seriesX[p - 1][m] === f.globals.seriesX[p][m]) {
      let _, $;
      const L = Math.min(this.yRatio.length + 1, p + 1);
      if (this.groupCtx.prevY[b - 1] !== void 0 && this.groupCtx.prevY[b - 1].length) {
        for (let E = 1; E < L; E++)
          if (!isNaN((x = this.groupCtx.prevY[b - E]) == null ? void 0 : x[m])) {
            $ = this.groupCtx.prevY[b - E][m];
            break;
          }
      }
      for (let E = 1; E < L; E++)
        if (((S = this.groupCtx.prevYVal[b - E]) == null ? void 0 : S[m]) < 0) {
          _ = this.series[p][m] >= 0 ? $ - g + (this.isReversed ? g : 0) * 2 : $;
          break;
        } else if (((k = this.groupCtx.prevYVal[b - E]) == null ? void 0 : k[m]) >= 0) {
          _ = this.series[p][m] >= 0 ? $ : $ + g - (this.isReversed ? g : 0) * 2;
          break;
        }
      typeof _ > "u" && (_ = f.globals.gridHeight), (C = this.groupCtx.prevYF[0]) != null && C.every((E) => E === 0) && this.groupCtx.prevYF.slice(1, b).every((E) => E.every((A) => isNaN(A))) ? u = o : u = _;
    } else
      u = o;
    this.series[p][m] ? i = u - this.series[p][m] / this.yRatio[r] + (this.isReversed ? this.series[p][m] / this.yRatio[r] : 0) * 2 : i = u;
    const O = this.barHelpers.getColumnPaths({
      barXPosition: h,
      barWidth: n,
      y1: u,
      y2: i,
      yRatio: this.yRatio[r],
      strokeWidth: this.strokeWidth,
      series: this.series,
      seriesGroup: c,
      realIndex: e.realIndex,
      i: p,
      j: m,
      w: f
    });
    return this.barHelpers.barBackground({
      bc: v,
      j: m,
      i: p,
      x1: h,
      x2: n,
      elSeries: d
    }), t = t + s, {
      pathTo: O.pathTo,
      pathFrom: O.pathFrom,
      goalY: this.barHelpers.getGoalValues("y", null, o, p, m),
      barXPosition: h,
      x: f.globals.isXNumeric ? t - s : t,
      y: i
    };
  }
}
class bc extends Vn {
  draw(e, t, i) {
    let s = this.w, n = new K(this.ctx), o = s.globals.comboCharts ? t : s.config.chart.type, l = new _i(this.ctx);
    this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot, this.isHorizontal = s.config.plotOptions.bar.horizontal;
    const c = new vt(this.ctx, s);
    e = c.getLogSeries(e), this.series = e, this.yRatio = c.getLogYRatios(this.yRatio), this.barHelpers.initVariables(e);
    let d = n.group({
      class: `apexcharts-${o}-series apexcharts-plot-series`
    });
    for (let f = 0; f < e.length; f++) {
      this.isBoxPlot = s.config.chart.type === "boxPlot" || s.config.series[f].type === "boxPlot";
      let p, m, v, r, h, u, g = [], b = [], O = s.globals.comboCharts ? i[f] : f, x = n.group({
        class: "apexcharts-series",
        seriesName: N.escapeString(s.globals.seriesNames[O]),
        rel: f + 1,
        "data:realIndex": O
      });
      this.ctx.series.addCollapsedClassToSeries(x, O), e[f].length > 0 && (this.visibleI = this.visibleI + 1);
      let S = 0, k = 0, C = 0;
      this.yRatio.length > 1 && (this.yaxisIndex = s.globals.seriesYAxisReverseMap[O][0], C = O);
      let _ = this.barHelpers.initialPositions();
      m = _.y, S = _.barHeight, r = _.yDivision, u = _.zeroW, p = _.x, k = _.barWidth, v = _.xDivision, h = _.zeroH, b.push(p + k / 2);
      let $ = n.group({
        class: "apexcharts-datalabels",
        "data:realIndex": O
      });
      for (let L = 0; L < s.globals.dataPoints; L++) {
        const E = this.barHelpers.getStrokeWidth(f, L, O);
        let A = null;
        const y = {
          indexes: {
            i: f,
            j: L,
            realIndex: O,
            translationsIndex: C
          },
          x: p,
          y: m,
          strokeWidth: E,
          elSeries: x
        };
        this.isHorizontal ? A = this.drawHorizontalBoxPaths({
          ...y,
          yDivision: r,
          barHeight: S,
          zeroW: u
        }) : A = this.drawVerticalBoxPaths({
          ...y,
          xDivision: v,
          barWidth: k,
          zeroH: h
        }), m = A.y, p = A.x, L > 0 && b.push(p + k / 2), g.push(m), A.pathTo.forEach((w, T) => {
          let P = !this.isBoxPlot && this.candlestickOptions.wick.useFillColor ? A.color[T] : s.globals.stroke.colors[f], R = l.fillPath({
            seriesNumber: O,
            dataPointIndex: L,
            color: A.color[T],
            value: e[f][L]
          });
          this.renderSeries({
            realIndex: O,
            pathFill: R,
            lineFill: P,
            j: L,
            i: f,
            pathFrom: A.pathFrom,
            pathTo: w,
            strokeWidth: E,
            elSeries: x,
            x: p,
            y: m,
            series: e,
            barHeight: S,
            barWidth: k,
            elDataLabelsWrap: $,
            visibleSeries: this.visibleI,
            type: s.config.chart.type
          });
        });
      }
      s.globals.seriesXvalues[O] = b, s.globals.seriesYvalues[O] = g, d.add(x);
    }
    return d;
  }
  drawVerticalBoxPaths({
    indexes: e,
    x: t,
    y: i,
    xDivision: s,
    barWidth: n,
    zeroH: o,
    strokeWidth: l
  }) {
    let c = this.w, d = new K(this.ctx), f = e.i, p = e.j, m = !0, v = c.config.plotOptions.candlestick.colors.upward, r = c.config.plotOptions.candlestick.colors.downward, h = "";
    this.isBoxPlot && (h = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
    const u = this.yRatio[e.translationsIndex];
    let g = e.realIndex;
    const b = this.getOHLCValue(g, p);
    let O = o, x = o;
    b.o > b.c && (m = !1);
    let S = Math.min(b.o, b.c), k = Math.max(b.o, b.c), C = b.m;
    c.globals.isXNumeric && (t = (c.globals.seriesX[g][p] - c.globals.minX) / this.xRatio - n / 2);
    let _ = t + n * this.visibleI;
    typeof this.series[f][p] > "u" || this.series[f][p] === null ? (S = o, k = o) : (S = o - S / u, k = o - k / u, O = o - b.h / u, x = o - b.l / u, C = o - b.m / u);
    let $ = d.move(_, o), L = d.move(_ + n / 2, S);
    return c.globals.previousPaths.length > 0 && (L = this.getPreviousPath(g, p, !0)), this.isBoxPlot ? $ = [
      d.move(_, S) + d.line(_ + n / 2, S) + d.line(_ + n / 2, O) + d.line(_ + n / 4, O) + d.line(_ + n - n / 4, O) + d.line(_ + n / 2, O) + d.line(_ + n / 2, S) + d.line(_ + n, S) + d.line(_ + n, C) + d.line(_, C) + d.line(_, S + l / 2),
      d.move(_, C) + d.line(_ + n, C) + d.line(_ + n, k) + d.line(_ + n / 2, k) + d.line(_ + n / 2, x) + d.line(_ + n - n / 4, x) + d.line(_ + n / 4, x) + d.line(_ + n / 2, x) + d.line(_ + n / 2, k) + d.line(_, k) + d.line(_, C) + "z"
    ] : $ = [
      d.move(_, k) + d.line(_ + n / 2, k) + d.line(_ + n / 2, O) + d.line(_ + n / 2, k) + d.line(_ + n, k) + d.line(_ + n, S) + d.line(_ + n / 2, S) + d.line(_ + n / 2, x) + d.line(_ + n / 2, S) + d.line(_, S) + d.line(_, k - l / 2)
    ], L = L + d.move(_, S), c.globals.isXNumeric || (t = t + s), {
      pathTo: $,
      pathFrom: L,
      x: t,
      y: k,
      barXPosition: _,
      color: this.isBoxPlot ? h : m ? [v] : [r]
    };
  }
  drawHorizontalBoxPaths({
    indexes: e,
    x: t,
    y: i,
    yDivision: s,
    barHeight: n,
    zeroW: o,
    strokeWidth: l
  }) {
    let c = this.w, d = new K(this.ctx), f = e.i, p = e.j, m = this.boxOptions.colors.lower;
    this.isBoxPlot && (m = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
    const v = this.invertedYRatio;
    let r = e.realIndex;
    const h = this.getOHLCValue(r, p);
    let u = o, g = o, b = Math.min(h.o, h.c), O = Math.max(h.o, h.c), x = h.m;
    c.globals.isXNumeric && (i = (c.globals.seriesX[r][p] - c.globals.minX) / this.invertedXRatio - n / 2);
    let S = i + n * this.visibleI;
    typeof this.series[f][p] > "u" || this.series[f][p] === null ? (b = o, O = o) : (b = o + b / v, O = o + O / v, u = o + h.h / v, g = o + h.l / v, x = o + h.m / v);
    let k = d.move(o, S), C = d.move(b, S + n / 2);
    return c.globals.previousPaths.length > 0 && (C = this.getPreviousPath(r, p, !0)), k = [
      d.move(b, S) + d.line(b, S + n / 2) + d.line(u, S + n / 2) + d.line(u, S + n / 2 - n / 4) + d.line(u, S + n / 2 + n / 4) + d.line(u, S + n / 2) + d.line(b, S + n / 2) + d.line(b, S + n) + d.line(x, S + n) + d.line(x, S) + d.line(b + l / 2, S),
      d.move(x, S) + d.line(x, S + n) + d.line(O, S + n) + d.line(O, S + n / 2) + d.line(g, S + n / 2) + d.line(g, S + n - n / 4) + d.line(g, S + n / 4) + d.line(g, S + n / 2) + d.line(O, S + n / 2) + d.line(O, S) + d.line(x, S) + "z"
    ], C = C + d.move(b, S), c.globals.isXNumeric || (i = i + s), {
      pathTo: k,
      pathFrom: C,
      x: O,
      y: i,
      barYPosition: S,
      color: m
    };
  }
  getOHLCValue(e, t) {
    const i = this.w;
    return {
      o: this.isBoxPlot ? i.globals.seriesCandleH[e][t] : i.globals.seriesCandleO[e][t],
      h: this.isBoxPlot ? i.globals.seriesCandleO[e][t] : i.globals.seriesCandleH[e][t],
      m: i.globals.seriesCandleM[e][t],
      l: this.isBoxPlot ? i.globals.seriesCandleC[e][t] : i.globals.seriesCandleL[e][t],
      c: this.isBoxPlot ? i.globals.seriesCandleL[e][t] : i.globals.seriesCandleC[e][t]
    };
  }
}
class Iv {
  constructor(e) {
    this.ctx = e, this.w = e.w;
  }
  checkColorRange() {
    const e = this.w;
    let t = !1, i = e.config.plotOptions[e.config.chart.type];
    return i.colorScale.ranges.length > 0 && i.colorScale.ranges.map((s, n) => {
      s.from <= 0 && (t = !0);
    }), t;
  }
  getShadeColor(e, t, i, s) {
    const n = this.w;
    let o = 1, l = n.config.plotOptions[e].shadeIntensity;
    const c = this.determineColor(e, t, i);
    n.globals.hasNegs || s ? n.config.plotOptions[e].reverseNegativeShade ? c.percent < 0 ? o = c.percent / 100 * (l * 1.25) : o = (1 - c.percent / 100) * (l * 1.25) : c.percent <= 0 ? o = 1 - (1 + c.percent / 100) * l : o = (1 - c.percent / 100) * l : (o = 1 - c.percent / 100, e === "treemap" && (o = (1 - c.percent / 100) * (l * 1.25)));
    let d = c.color, f = new N();
    return n.config.plotOptions[e].enableShades && (this.w.config.theme.mode === "dark" ? d = N.hexToRgba(
      f.shadeColor(o * -1, c.color),
      n.config.fill.opacity
    ) : d = N.hexToRgba(
      f.shadeColor(o, c.color),
      n.config.fill.opacity
    )), { color: d, colorProps: c };
  }
  determineColor(e, t, i) {
    const s = this.w;
    let n = s.globals.series[t][i], o = s.config.plotOptions[e], l = o.colorScale.inverse ? i : t;
    o.distributed && s.config.chart.type === "treemap" && (l = i);
    let c = s.globals.colors[l], d = null, f = Math.min(...s.globals.series[t]), p = Math.max(...s.globals.series[t]);
    !o.distributed && e === "heatmap" && (f = s.globals.minY, p = s.globals.maxY), typeof o.colorScale.min < "u" && (f = o.colorScale.min < s.globals.minY ? o.colorScale.min : s.globals.minY, p = o.colorScale.max > s.globals.maxY ? o.colorScale.max : s.globals.maxY);
    let m = Math.abs(p) + Math.abs(f), v = 100 * n / (m === 0 ? m - 1e-6 : m);
    return o.colorScale.ranges.length > 0 && o.colorScale.ranges.map((h, u) => {
      if (n >= h.from && n <= h.to) {
        c = h.color, d = h.foreColor ? h.foreColor : null, f = h.from, p = h.to;
        let g = Math.abs(p) + Math.abs(f);
        v = 100 * n / (g === 0 ? g - 1e-6 : g);
      }
    }), {
      color: c,
      foreColor: d,
      percent: v
    };
  }
  calculateDataLabels({ text: e, x: t, y: i, i: s, j: n, colorProps: o, fontSize: l }) {
    let d = this.w.config.dataLabels;
    const f = new K(this.ctx);
    let p = new Yn(this.ctx), m = null;
    if (d.enabled) {
      m = f.group({
        class: "apexcharts-data-labels"
      });
      const v = d.offsetX, r = d.offsetY;
      let h = t + v, u = i + parseFloat(d.style.fontSize) / 3 + r;
      p.plotDataLabelsText({
        x: h,
        y: u,
        text: e,
        i: s,
        j: n,
        color: o.foreColor,
        parent: m,
        fontSize: l,
        dataLabelsConfig: d
      });
    }
    return m;
  }
  addListeners(e) {
    const t = new K(this.ctx);
    e.node.addEventListener(
      "mouseenter",
      t.pathMouseEnter.bind(this, e)
    ), e.node.addEventListener(
      "mouseleave",
      t.pathMouseLeave.bind(this, e)
    ), e.node.addEventListener(
      "mousedown",
      t.pathMouseDown.bind(this, e)
    );
  }
}
class $L {
  constructor(e, t) {
    this.ctx = e, this.w = e.w, this.xRatio = t.xRatio, this.yRatio = t.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new Iv(e), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0;
  }
  draw(e) {
    let t = this.w;
    const i = new K(this.ctx);
    let s = i.group({
      class: "apexcharts-heatmap"
    });
    s.attr("clip-path", `url(#gridRectMask${t.globals.cuid})`);
    let n = t.globals.gridWidth / t.globals.dataPoints, o = t.globals.gridHeight / t.globals.series.length, l = 0, c = !1;
    this.negRange = this.helpers.checkColorRange();
    let d = e.slice();
    t.config.yaxis[0].reversed && (c = !0, d.reverse());
    for (let p = c ? 0 : d.length - 1; c ? p < d.length : p >= 0; c ? p++ : p--) {
      let m = i.group({
        class: "apexcharts-series apexcharts-heatmap-series",
        seriesName: N.escapeString(t.globals.seriesNames[p]),
        rel: p + 1,
        "data:realIndex": p
      });
      if (this.ctx.series.addCollapsedClassToSeries(m, p), t.config.chart.dropShadow.enabled) {
        const h = t.config.chart.dropShadow;
        new It(this.ctx).dropShadow(m, h, p);
      }
      let v = 0, r = t.config.plotOptions.heatmap.shadeIntensity;
      for (let h = 0; h < d[p].length; h++) {
        let u = this.helpers.getShadeColor(
          t.config.chart.type,
          p,
          h,
          this.negRange
        ), g = u.color, b = u.colorProps;
        t.config.fill.type === "image" && (g = new _i(this.ctx).fillPath({
          seriesNumber: p,
          dataPointIndex: h,
          opacity: t.globals.hasNegs ? b.percent < 0 ? 1 - (1 + b.percent / 100) : r + b.percent / 100 : b.percent / 100,
          patternID: N.randomId(),
          width: t.config.fill.image.width ? t.config.fill.image.width : n,
          height: t.config.fill.image.height ? t.config.fill.image.height : o
        }));
        let O = this.rectRadius, x = i.drawRect(v, l, n, o, O);
        if (x.attr({
          cx: v,
          cy: l
        }), x.node.classList.add("apexcharts-heatmap-rect"), m.add(x), x.attr({
          fill: g,
          i: p,
          index: p,
          j: h,
          val: e[p][h],
          "stroke-width": this.strokeWidth,
          stroke: t.config.plotOptions.heatmap.useFillColorAsStroke ? g : t.globals.stroke.colors[0],
          color: g
        }), this.helpers.addListeners(x), t.config.chart.animations.enabled && !t.globals.dataChanged) {
          let _ = 1;
          t.globals.resized || (_ = t.config.chart.animations.speed), this.animateHeatMap(x, v, l, n, o, _);
        }
        if (t.globals.dataChanged) {
          let _ = 1;
          if (this.dynamicAnim.enabled && t.globals.shouldAnimate) {
            _ = this.dynamicAnim.speed;
            let $ = t.globals.previousPaths[p] && t.globals.previousPaths[p][h] && t.globals.previousPaths[p][h].color;
            $ || ($ = "rgba(255, 255, 255, 0)"), this.animateHeatColor(
              x,
              N.isColorHex($) ? $ : N.rgb2hex($),
              N.isColorHex(g) ? g : N.rgb2hex(g),
              _
            );
          }
        }
        let S = t.config.dataLabels.formatter, k = S(t.globals.series[p][h], {
          value: t.globals.series[p][h],
          seriesIndex: p,
          dataPointIndex: h,
          w: t
        }), C = this.helpers.calculateDataLabels({
          text: k,
          x: v + n / 2,
          y: l + o / 2,
          i: p,
          j: h,
          colorProps: b,
          series: d
        });
        C !== null && m.add(C), v = v + n;
      }
      l = l + o, s.add(m);
    }
    let f = t.globals.yAxisScale[0].result.slice();
    return t.config.yaxis[0].reversed ? f.unshift("") : f.push(""), t.globals.yAxisScale[0].result = f, s;
  }
  animateHeatMap(e, t, i, s, n, o) {
    const l = new cr(this.ctx);
    l.animateRect(
      e,
      {
        x: t + s / 2,
        y: i + n / 2,
        width: 0,
        height: 0
      },
      {
        x: t,
        y: i,
        width: s,
        height: n
      },
      o,
      () => {
        l.animationCompleted(e);
      }
    );
  }
  animateHeatColor(e, t, i, s) {
    e.attr({
      fill: t
    }).animate(s).attr({
      fill: i
    });
  }
}
class Qv {
  constructor(e) {
    this.ctx = e, this.w = e.w;
  }
  drawYAxisTexts(e, t, i, s) {
    const n = this.w, o = n.config.yaxis[0], l = n.globals.yLabelFormatters[0];
    return new K(this.ctx).drawText({
      x: e + o.labels.offsetX,
      y: t + o.labels.offsetY,
      text: l(s, i),
      textAnchor: "middle",
      fontSize: o.labels.style.fontSize,
      fontFamily: o.labels.style.fontFamily,
      foreColor: Array.isArray(o.labels.style.colors) ? o.labels.style.colors[i] : o.labels.style.colors
    });
  }
}
class Nv {
  constructor(e) {
    this.ctx = e, this.w = e.w;
    const t = this.w;
    this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = t.globals.stroke.colors !== void 0 ? t.globals.stroke.colors : t.globals.colors, this.defaultSize = Math.min(t.globals.gridWidth, t.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = t.globals.gridWidth / 2, t.config.chart.type === "radialBar" ? this.fullAngle = 360 : this.fullAngle = Math.abs(
      t.config.plotOptions.pie.endAngle - t.config.plotOptions.pie.startAngle
    ), this.initialAngle = t.config.plotOptions.pie.startAngle % this.fullAngle, t.globals.radialSize = this.defaultSize / 2.05 - t.config.stroke.width - (t.config.chart.sparkline.enabled ? 0 : t.config.chart.dropShadow.blur), this.donutSize = t.globals.radialSize * parseInt(t.config.plotOptions.pie.donut.size, 10) / 100, this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = [];
  }
  draw(e) {
    let t = this, i = this.w;
    const s = new K(this.ctx);
    if (this.ret = s.group({
      class: "apexcharts-pie"
    }), i.globals.noData)
      return this.ret;
    let n = 0;
    for (let r = 0; r < e.length; r++)
      n += N.negToZero(e[r]);
    let o = [], l = s.group();
    n === 0 && (n = 1e-5), e.forEach((r) => {
      this.maxY = Math.max(this.maxY, r);
    }), i.config.yaxis[0].max && (this.maxY = i.config.yaxis[0].max), i.config.grid.position === "back" && this.chartType === "polarArea" && this.drawPolarElements(this.ret);
    for (let r = 0; r < e.length; r++) {
      let h = this.fullAngle * N.negToZero(e[r]) / n;
      o.push(h), this.chartType === "polarArea" ? (o[r] = this.fullAngle / e.length, this.sliceSizes.push(i.globals.radialSize * e[r] / this.maxY)) : this.sliceSizes.push(i.globals.radialSize);
    }
    if (i.globals.dataChanged) {
      let r = 0;
      for (let u = 0; u < i.globals.previousPaths.length; u++)
        r += N.negToZero(i.globals.previousPaths[u]);
      let h;
      for (let u = 0; u < i.globals.previousPaths.length; u++)
        h = this.fullAngle * N.negToZero(i.globals.previousPaths[u]) / r, this.prevSectorAngleArr.push(h);
    }
    this.donutSize < 0 && (this.donutSize = 0);
    let c = i.config.plotOptions.pie.customScale, d = i.globals.gridWidth / 2, f = i.globals.gridHeight / 2, p = d - i.globals.gridWidth / 2 * c, m = f - i.globals.gridHeight / 2 * c;
    if (this.chartType === "donut") {
      const r = s.drawCircle(this.donutSize);
      r.attr({
        cx: this.centerX,
        cy: this.centerY,
        fill: i.config.plotOptions.pie.donut.background ? i.config.plotOptions.pie.donut.background : "transparent"
      }), l.add(r);
    }
    let v = t.drawArcs(o, e);
    if (this.sliceLabels.forEach((r) => {
      v.add(r);
    }), l.attr({
      transform: `translate(${p}, ${m}) scale(${c})`
    }), l.add(v), this.ret.add(l), this.donutDataLabels.show) {
      let r = this.renderInnerDataLabels(this.donutDataLabels, {
        hollowSize: this.donutSize,
        centerX: this.centerX,
        centerY: this.centerY,
        opacity: this.donutDataLabels.show,
        translateX: p,
        translateY: m
      });
      this.ret.add(r);
    }
    return i.config.grid.position === "front" && this.chartType === "polarArea" && this.drawPolarElements(this.ret), this.ret;
  }
  // core function for drawing pie arcs
  drawArcs(e, t) {
    let i = this.w;
    const s = new It(this.ctx);
    let n = new K(this.ctx), o = new _i(this.ctx), l = n.group({
      class: "apexcharts-slices"
    }), c = this.initialAngle, d = this.initialAngle, f = this.initialAngle, p = this.initialAngle;
    this.strokeWidth = i.config.stroke.show ? i.config.stroke.width : 0;
    for (let m = 0; m < e.length; m++) {
      let v = n.group({
        class: "apexcharts-series apexcharts-pie-series",
        seriesName: N.escapeString(i.globals.seriesNames[m]),
        rel: m + 1,
        "data:realIndex": m
      });
      l.add(v), c = f, d = p, f = c + e[m], p = d + this.prevSectorAngleArr[m];
      const r = f < c ? this.fullAngle + f - c : f - c;
      let h = o.fillPath({
        seriesNumber: m,
        size: this.sliceSizes[m],
        value: t[m]
      }), u = this.getChangedPath(d, p), g = n.drawPath({
        d: u,
        stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[m] : this.lineColorArr,
        strokeWidth: 0,
        fill: h,
        fillOpacity: i.config.fill.opacity,
        classes: `apexcharts-pie-area apexcharts-${this.chartType.toLowerCase()}-slice-${m}`
      });
      if (g.attr({
        index: 0,
        j: m
      }), s.setSelectionFilter(g, 0, m), i.config.chart.dropShadow.enabled) {
        const x = i.config.chart.dropShadow;
        s.dropShadow(g, x, m);
      }
      this.addListeners(g, this.donutDataLabels), K.setAttrs(g.node, {
        "data:angle": r,
        "data:startAngle": c,
        "data:strokeWidth": this.strokeWidth,
        "data:value": t[m]
      });
      let b = {
        x: 0,
        y: 0
      };
      this.chartType === "pie" || this.chartType === "polarArea" ? b = N.polarToCartesian(
        this.centerX,
        this.centerY,
        i.globals.radialSize / 1.25 + i.config.plotOptions.pie.dataLabels.offset,
        (c + r / 2) % this.fullAngle
      ) : this.chartType === "donut" && (b = N.polarToCartesian(
        this.centerX,
        this.centerY,
        (i.globals.radialSize + this.donutSize) / 2 + i.config.plotOptions.pie.dataLabels.offset,
        (c + r / 2) % this.fullAngle
      )), v.add(g);
      let O = 0;
      if (this.initialAnim && !i.globals.resized && !i.globals.dataChanged ? (O = r / this.fullAngle * i.config.chart.animations.speed, O === 0 && (O = 1), this.animDur = O + this.animDur, this.animBeginArr.push(this.animDur)) : this.animBeginArr.push(0), this.dynamicAnim && i.globals.dataChanged ? this.animatePaths(g, {
        size: this.sliceSizes[m],
        endAngle: f,
        startAngle: c,
        prevStartAngle: d,
        prevEndAngle: p,
        animateStartingPos: !0,
        i: m,
        animBeginArr: this.animBeginArr,
        shouldSetPrevPaths: !0,
        dur: i.config.chart.animations.dynamicAnimation.speed
      }) : this.animatePaths(g, {
        size: this.sliceSizes[m],
        endAngle: f,
        startAngle: c,
        i: m,
        totalItems: e.length - 1,
        animBeginArr: this.animBeginArr,
        dur: O
      }), i.config.plotOptions.pie.expandOnClick && this.chartType !== "polarArea" && g.click(this.pieClicked.bind(this, m)), typeof i.globals.selectedDataPoints[0] < "u" && i.globals.selectedDataPoints[0].indexOf(m) > -1 && this.pieClicked(m), i.config.dataLabels.enabled) {
        let x = b.x, S = b.y, k = 100 * r / this.fullAngle + "%";
        if (r !== 0 && i.config.plotOptions.pie.dataLabels.minAngleToShowLabel < e[m]) {
          let C = i.config.dataLabels.formatter;
          C !== void 0 && (k = C(i.globals.seriesPercent[m][0], {
            seriesIndex: m,
            w: i
          }));
          let _ = i.globals.dataLabels.style.colors[m];
          const $ = n.group({
            class: "apexcharts-datalabels"
          });
          let L = n.drawText({
            x,
            y: S,
            text: k,
            textAnchor: "middle",
            fontSize: i.config.dataLabels.style.fontSize,
            fontFamily: i.config.dataLabels.style.fontFamily,
            fontWeight: i.config.dataLabels.style.fontWeight,
            foreColor: _
          });
          if ($.add(L), i.config.dataLabels.dropShadow.enabled) {
            const E = i.config.dataLabels.dropShadow;
            s.dropShadow(L, E);
          }
          L.node.classList.add("apexcharts-pie-label"), i.config.chart.animations.animate && i.globals.resized === !1 && (L.node.classList.add("apexcharts-pie-label-delay"), L.node.style.animationDelay = i.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push($);
        }
      }
    }
    return l;
  }
  addListeners(e, t) {
    const i = new K(this.ctx);
    e.node.addEventListener(
      "mouseenter",
      i.pathMouseEnter.bind(this, e)
    ), e.node.addEventListener(
      "mouseleave",
      i.pathMouseLeave.bind(this, e)
    ), e.node.addEventListener(
      "mouseleave",
      this.revertDataLabelsInner.bind(this, e.node, t)
    ), e.node.addEventListener(
      "mousedown",
      i.pathMouseDown.bind(this, e)
    ), this.donutDataLabels.total.showAlways || (e.node.addEventListener(
      "mouseenter",
      this.printDataLabelsInner.bind(this, e.node, t)
    ), e.node.addEventListener(
      "mousedown",
      this.printDataLabelsInner.bind(this, e.node, t)
    ));
  }
  // This function can be used for other circle charts too
  animatePaths(e, t) {
    let i = this.w, s = this, n = t.endAngle < t.startAngle ? this.fullAngle + t.endAngle - t.startAngle : t.endAngle - t.startAngle, o = n, l = t.startAngle, c = t.startAngle;
    t.prevStartAngle !== void 0 && t.prevEndAngle !== void 0 && (l = t.prevEndAngle, o = t.prevEndAngle < t.prevStartAngle ? this.fullAngle + t.prevEndAngle - t.prevStartAngle : t.prevEndAngle - t.prevStartAngle), t.i === i.config.series.length - 1 && (n + c > this.fullAngle ? t.endAngle = t.endAngle - (n + c) : n + c < this.fullAngle && (t.endAngle = t.endAngle + (this.fullAngle - (n + c)))), n === this.fullAngle && (n = this.fullAngle - 0.01), s.animateArc(e, l, c, n, o, t);
  }
  animateArc(e, t, i, s, n, o) {
    let l = this;
    const c = this.w, d = new cr(this.ctx);
    let f = o.size, p;
    (isNaN(t) || isNaN(n)) && (t = i, n = s, o.dur = 0);
    let m = s, v = i, r = t < i ? this.fullAngle + t - i : t - i;
    c.globals.dataChanged && o.shouldSetPrevPaths && o.prevEndAngle && (p = l.getPiePath({
      me: l,
      startAngle: o.prevStartAngle,
      angle: o.prevEndAngle < o.prevStartAngle ? this.fullAngle + o.prevEndAngle - o.prevStartAngle : o.prevEndAngle - o.prevStartAngle,
      size: f
    }), e.attr({ d: p })), o.dur !== 0 ? e.animate(o.dur, c.globals.easing, o.animBeginArr[o.i]).afterAll(function() {
      (l.chartType === "pie" || l.chartType === "donut" || l.chartType === "polarArea") && this.animate(c.config.chart.animations.dynamicAnimation.speed).attr(
        {
          "stroke-width": l.strokeWidth
        }
      ), o.i === c.config.series.length - 1 && d.animationCompleted(e);
    }).during((h) => {
      m = r + (s - r) * h, o.animateStartingPos && (m = n + (s - n) * h, v = t - n + (i - (t - n)) * h), p = l.getPiePath({
        me: l,
        startAngle: v,
        angle: m,
        size: f
      }), e.node.setAttribute("data:pathOrig", p), e.attr({
        d: p
      });
    }) : (p = l.getPiePath({
      me: l,
      startAngle: v,
      angle: s,
      size: f
    }), o.isTrack || (c.globals.animationEnded = !0), e.node.setAttribute("data:pathOrig", p), e.attr({
      d: p,
      "stroke-width": l.strokeWidth
    }));
  }
  pieClicked(e) {
    let t = this.w, i = this, s, n = i.sliceSizes[e] + (t.config.plotOptions.pie.expandOnClick ? 4 : 0), o = t.globals.dom.Paper.select(
      `.apexcharts-${i.chartType.toLowerCase()}-slice-${e}`
    ).members[0];
    if (o.attr("data:pieClicked") === "true") {
      o.attr({
        "data:pieClicked": "false"
      }), this.revertDataLabelsInner(o.node, this.donutDataLabels);
      let d = o.attr("data:pathOrig");
      o.attr({
        d
      });
      return;
    } else {
      let d = t.globals.dom.baseEl.getElementsByClassName(
        "apexcharts-pie-area"
      );
      Array.prototype.forEach.call(d, (f) => {
        f.setAttribute("data:pieClicked", "false");
        let p = f.getAttribute("data:pathOrig");
        p && f.setAttribute("d", p);
      }), o.attr("data:pieClicked", "true");
    }
    let l = parseInt(o.attr("data:startAngle"), 10), c = parseInt(o.attr("data:angle"), 10);
    s = i.getPiePath({
      me: i,
      startAngle: l,
      angle: c,
      size: n
    }), c !== 360 && o.plot(s);
  }
  getChangedPath(e, t) {
    let i = "";
    return this.dynamicAnim && this.w.globals.dataChanged && (i = this.getPiePath({
      me: this,
      startAngle: e,
      angle: t - e,
      size: this.size
    })), i;
  }
  getPiePath({ me: e, startAngle: t, angle: i, size: s }) {
    let n;
    const o = new K(this.ctx);
    let l = t, c = Math.PI * (l - 90) / 180, d = i + t;
    Math.ceil(d) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (d = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - 0.01), Math.ceil(d) > this.fullAngle && (d -= this.fullAngle);
    let f = Math.PI * (d - 90) / 180, p = e.centerX + s * Math.cos(c), m = e.centerY + s * Math.sin(c), v = e.centerX + s * Math.cos(f), r = e.centerY + s * Math.sin(f), h = N.polarToCartesian(
      e.centerX,
      e.centerY,
      e.donutSize,
      d
    ), u = N.polarToCartesian(
      e.centerX,
      e.centerY,
      e.donutSize,
      l
    ), g = i > 180 ? 1 : 0;
    const b = ["M", p, m, "A", s, s, 0, g, 1, v, r];
    return e.chartType === "donut" ? n = [
      ...b,
      "L",
      h.x,
      h.y,
      "A",
      e.donutSize,
      e.donutSize,
      0,
      g,
      0,
      u.x,
      u.y,
      "L",
      p,
      m,
      "z"
    ].join(" ") : e.chartType === "pie" || e.chartType === "polarArea" ? n = [...b, "L", e.centerX, e.centerY, "L", p, m].join(
      " "
    ) : n = [...b].join(" "), o.roundPathCorners(n, this.strokeWidth * 2);
  }
  drawPolarElements(e) {
    const t = this.w, i = new Pv(this.ctx), s = new K(this.ctx), n = new Qv(this.ctx), o = s.group(), l = s.group(), c = i.niceScale(
      0,
      Math.ceil(this.maxY),
      0
    ), d = c.result.reverse();
    let f = c.result.length;
    this.maxY = c.niceMax;
    let p = t.globals.radialSize, m = p / (f - 1);
    for (let v = 0; v < f - 1; v++) {
      const r = s.drawCircle(p);
      if (r.attr({
        cx: this.centerX,
        cy: this.centerY,
        fill: "none",
        "stroke-width": t.config.plotOptions.polarArea.rings.strokeWidth,
        stroke: t.config.plotOptions.polarArea.rings.strokeColor
      }), t.config.yaxis[0].show) {
        const h = n.drawYAxisTexts(
          this.centerX,
          this.centerY - p + parseInt(t.config.yaxis[0].labels.style.fontSize, 10) / 2,
          v,
          d[v]
        );
        l.add(h);
      }
      o.add(r), p = p - m;
    }
    this.drawSpokes(e), e.add(o), e.add(l);
  }
  renderInnerDataLabels(e, t) {
    let i = this.w;
    const s = new K(this.ctx);
    let n = s.group({
      class: "apexcharts-datalabels-group",
      transform: `translate(${t.translateX ? t.translateX : 0}, ${t.translateY ? t.translateY : 0}) scale(${i.config.plotOptions.pie.customScale})`
    });
    const o = e.total.show;
    n.node.style.opacity = t.opacity;
    let l = t.centerX, c = t.centerY, d, f;
    e.name.color === void 0 ? d = i.globals.colors[0] : d = e.name.color;
    let p = e.name.fontSize, m = e.name.fontFamily, v = e.name.fontWeight;
    e.value.color === void 0 ? f = i.config.chart.foreColor : f = e.value.color;
    let r = e.value.formatter, h = "", u = "";
    if (o ? (d = e.total.color, p = e.total.fontSize, m = e.total.fontFamily, v = e.total.fontWeight, u = e.total.label, h = e.total.formatter(i)) : i.globals.series.length === 1 && (h = r(i.globals.series[0], i), u = i.globals.seriesNames[0]), u && (u = e.name.formatter(
      u,
      e.total.show,
      i
    )), e.name.show) {
      let g = s.drawText({
        x: l,
        y: c + parseFloat(e.name.offsetY),
        text: u,
        textAnchor: "middle",
        foreColor: d,
        fontSize: p,
        fontWeight: v,
        fontFamily: m
      });
      g.node.classList.add("apexcharts-datalabel-label"), n.add(g);
    }
    if (e.value.show) {
      let g = e.name.show ? parseFloat(e.value.offsetY) + 16 : e.value.offsetY, b = s.drawText({
        x: l,
        y: c + g,
        text: h,
        textAnchor: "middle",
        foreColor: f,
        fontWeight: e.value.fontWeight,
        fontSize: e.value.fontSize,
        fontFamily: e.value.fontFamily
      });
      b.node.classList.add("apexcharts-datalabel-value"), n.add(b);
    }
    return n;
  }
  /**
   *
   * @param {string} name - The name of the series
   * @param {string} val - The value of that series
   * @param {object} el - Optional el (indicates which series was hovered/clicked). If this param is not present, means we need to show total
   */
  printInnerLabels(e, t, i, s) {
    const n = this.w;
    let o;
    s ? e.name.color === void 0 ? o = n.globals.colors[parseInt(s.parentNode.getAttribute("rel"), 10) - 1] : o = e.name.color : n.globals.series.length > 1 && e.total.show && (o = e.total.color);
    let l = n.globals.dom.baseEl.querySelector(
      ".apexcharts-datalabel-label"
    ), c = n.globals.dom.baseEl.querySelector(
      ".apexcharts-datalabel-value"
    ), d = e.value.formatter;
    i = d(i, n), !s && typeof e.total.formatter == "function" && (i = e.total.formatter(n));
    const f = t === e.total.label;
    t = e.name.formatter(t, f, n), l !== null && (l.textContent = t), c !== null && (c.textContent = i), l !== null && (l.style.fill = o);
  }
  printDataLabelsInner(e, t) {
    let i = this.w, s = e.getAttribute("data:value"), n = i.globals.seriesNames[parseInt(e.parentNode.getAttribute("rel"), 10) - 1];
    i.globals.series.length > 1 && this.printInnerLabels(t, n, s, e);
    let o = i.globals.dom.baseEl.querySelector(
      ".apexcharts-datalabels-group"
    );
    o !== null && (o.style.opacity = 1);
  }
  drawSpokes(e) {
    const t = this.w, i = new K(this.ctx), s = t.config.plotOptions.polarArea.spokes;
    if (s.strokeWidth === 0)
      return;
    let n = [], o = 360 / t.globals.series.length;
    for (let l = 0; l < t.globals.series.length; l++)
      n.push(
        N.polarToCartesian(
          this.centerX,
          this.centerY,
          t.globals.radialSize,
          t.config.plotOptions.pie.startAngle + o * l
        )
      );
    n.forEach((l, c) => {
      const d = i.drawLine(
        l.x,
        l.y,
        this.centerX,
        this.centerY,
        Array.isArray(s.connectorColors) ? s.connectorColors[c] : s.connectorColors
      );
      e.add(d);
    });
  }
  revertDataLabelsInner(e, t, i) {
    let s = this.w, n = s.globals.dom.baseEl.querySelector(
      ".apexcharts-datalabels-group"
    ), o = !1;
    const l = s.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area"), c = ({ makeSliceOut: d, printLabel: f }) => {
      Array.prototype.forEach.call(l, (p) => {
        p.getAttribute("data:pieClicked") === "true" && (d && (o = !0), f && this.printDataLabelsInner(p, t));
      });
    };
    if (c({ makeSliceOut: !0, printLabel: !1 }), t.total.show && s.globals.series.length > 1)
      o && !t.total.showAlways ? c({ makeSliceOut: !1, printLabel: !0 }) : this.printInnerLabels(
        t,
        t.total.label,
        t.total.formatter(s)
      );
    else if (c({ makeSliceOut: !1, printLabel: !0 }), !o)
      if (s.globals.selectedDataPoints.length && s.globals.series.length > 1)
        if (s.globals.selectedDataPoints[0].length > 0) {
          const d = s.globals.selectedDataPoints[0], f = s.globals.dom.baseEl.querySelector(
            `.apexcharts-${this.chartType.toLowerCase()}-slice-${d}`
          );
          this.printDataLabelsInner(f, t);
        } else
          n && s.globals.selectedDataPoints.length && s.globals.selectedDataPoints[0].length === 0 && (n.style.opacity = 0);
      else
        n && s.globals.series.length > 1 && (n.style.opacity = 0);
  }
}
class EL {
  constructor(e) {
    this.ctx = e, this.w = e.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
    const t = this.w;
    this.graphics = new K(this.ctx), this.lineColorArr = t.globals.stroke.colors !== void 0 ? t.globals.stroke.colors : t.globals.colors, this.defaultSize = t.globals.svgHeight < t.globals.svgWidth ? t.globals.gridHeight + t.globals.goldenPadding * 1.5 : t.globals.gridWidth, this.isLog = t.config.yaxis[0].logarithmic, this.logBase = t.config.yaxis[0].logBase, this.coreUtils = new vt(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, t.globals.maxY, 0) : t.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, this.w.globals.minY, 0) : t.globals.minY, this.polygons = t.config.plotOptions.radar.polygons, this.strokeWidth = t.config.stroke.show ? t.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - t.config.chart.dropShadow.blur, t.config.xaxis.labels.show && (this.size = this.size - t.globals.xAxisLabelsWidth / 1.75), t.config.plotOptions.radar.size !== void 0 && (this.size = t.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = [];
  }
  draw(e) {
    let t = this.w;
    const i = new _i(this.ctx), s = [], n = new Yn(this.ctx);
    e.length && (this.dataPointsLen = e[t.globals.maxValsInArrayIndex].length), this.disAngle = Math.PI * 2 / this.dataPointsLen;
    let o = t.globals.gridWidth / 2, l = t.globals.gridHeight / 2, c = o + t.config.plotOptions.radar.offsetX, d = l + t.config.plotOptions.radar.offsetY, f = this.graphics.group({
      class: "apexcharts-radar-series apexcharts-plot-series",
      transform: `translate(${c || 0}, ${d || 0})`
    }), p = [], m = null, v = null;
    if (this.yaxisLabels = this.graphics.group({
      class: "apexcharts-yaxis"
    }), e.forEach((r, h) => {
      let u = r.length === t.globals.dataPoints, g = this.graphics.group().attr({
        class: "apexcharts-series",
        "data:longestSeries": u,
        seriesName: N.escapeString(t.globals.seriesNames[h]),
        rel: h + 1,
        "data:realIndex": h
      });
      this.dataRadiusOfPercent[h] = [], this.dataRadius[h] = [], this.angleArr[h] = [], r.forEach((S, k) => {
        const C = Math.abs(this.maxValue - this.minValue);
        S = S + Math.abs(this.minValue), this.isLog && (S = this.coreUtils.getLogVal(this.logBase, S, 0)), this.dataRadiusOfPercent[h][k] = S / C, this.dataRadius[h][k] = this.dataRadiusOfPercent[h][k] * this.size, this.angleArr[h][k] = k * this.disAngle;
      }), p = this.getDataPointsPos(
        this.dataRadius[h],
        this.angleArr[h]
      );
      const b = this.createPaths(p, {
        x: 0,
        y: 0
      });
      m = this.graphics.group({
        class: "apexcharts-series-markers-wrap apexcharts-element-hidden"
      }), v = this.graphics.group({
        class: "apexcharts-datalabels",
        "data:realIndex": h
      }), t.globals.delayedElements.push({
        el: m.node,
        index: h
      });
      const O = {
        i: h,
        realIndex: h,
        animationDelay: h,
        initialSpeed: t.config.chart.animations.speed,
        dataChangeSpeed: t.config.chart.animations.dynamicAnimation.speed,
        className: "apexcharts-radar",
        shouldClipToGrid: !1,
        bindEventsOnPaths: !1,
        stroke: t.globals.stroke.colors[h],
        strokeLineCap: t.config.stroke.lineCap
      };
      let x = null;
      t.globals.previousPaths.length > 0 && (x = this.getPreviousPath(h));
      for (let S = 0; S < b.linePathsTo.length; S++) {
        let k = this.graphics.renderPaths({
          ...O,
          pathFrom: x === null ? b.linePathsFrom[S] : x,
          pathTo: b.linePathsTo[S],
          strokeWidth: Array.isArray(this.strokeWidth) ? this.strokeWidth[h] : this.strokeWidth,
          fill: "none",
          drawShadow: !1
        });
        g.add(k);
        let C = i.fillPath({
          seriesNumber: h
        }), _ = this.graphics.renderPaths({
          ...O,
          pathFrom: x === null ? b.areaPathsFrom[S] : x,
          pathTo: b.areaPathsTo[S],
          strokeWidth: 0,
          fill: C,
          drawShadow: !1
        });
        if (t.config.chart.dropShadow.enabled) {
          const $ = new It(this.ctx), L = t.config.chart.dropShadow;
          $.dropShadow(
            _,
            Object.assign({}, L, { noUserSpaceOnUse: !0 }),
            h
          );
        }
        g.add(_);
      }
      r.forEach((S, k) => {
        let _ = new va(this.ctx).getMarkerConfig({
          cssClass: "apexcharts-marker",
          seriesIndex: h,
          dataPointIndex: k
        }), $ = this.graphics.drawMarker(
          p[k].x,
          p[k].y,
          _
        );
        $.attr("rel", k), $.attr("j", k), $.attr("index", h), $.node.setAttribute("default-marker-size", _.pSize);
        let L = this.graphics.group({
          class: "apexcharts-series-markers"
        });
        L && L.add($), m.add(L), g.add(m);
        const E = t.config.dataLabels;
        if (E.enabled) {
          let A = E.formatter(t.globals.series[h][k], {
            seriesIndex: h,
            dataPointIndex: k,
            w: t
          });
          n.plotDataLabelsText({
            x: p[k].x,
            y: p[k].y,
            text: A,
            textAnchor: "middle",
            i: h,
            j: h,
            parent: v,
            offsetCorrection: !1,
            dataLabelsConfig: {
              ...E
            }
          });
        }
        g.add(v);
      }), s.push(g);
    }), this.drawPolygons({
      parent: f
    }), t.config.xaxis.labels.show) {
      const r = this.drawXAxisTexts();
      f.add(r);
    }
    return s.forEach((r) => {
      f.add(r);
    }), f.add(this.yaxisLabels), f;
  }
  drawPolygons(e) {
    const t = this.w, { parent: i } = e, s = new Qv(this.ctx), n = t.globals.yAxisScale[0].result.reverse(), o = n.length;
    let l = [], c = this.size / (o - 1);
    for (let p = 0; p < o; p++)
      l[p] = c * p;
    l.reverse();
    let d = [], f = [];
    l.forEach((p, m) => {
      const v = N.getPolygonPos(p, this.dataPointsLen);
      let r = "";
      v.forEach((h, u) => {
        if (m === 0) {
          const g = this.graphics.drawLine(
            h.x,
            h.y,
            0,
            0,
            Array.isArray(this.polygons.connectorColors) ? this.polygons.connectorColors[u] : this.polygons.connectorColors
          );
          f.push(g);
        }
        u === 0 && this.yaxisLabelsTextsPos.push({
          x: h.x,
          y: h.y
        }), r += h.x + "," + h.y + " ";
      }), d.push(r);
    }), d.forEach((p, m) => {
      const v = this.polygons.strokeColors, r = this.polygons.strokeWidth, h = this.graphics.drawPolygon(
        p,
        Array.isArray(v) ? v[m] : v,
        Array.isArray(r) ? r[m] : r,
        t.globals.radarPolygons.fill.colors[m]
      );
      i.add(h);
    }), f.forEach((p) => {
      i.add(p);
    }), t.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach((p, m) => {
      const v = s.drawYAxisTexts(p.x, p.y, m, n[m]);
      this.yaxisLabels.add(v);
    });
  }
  drawXAxisTexts() {
    const e = this.w, t = e.config.xaxis.labels;
    let i = this.graphics.group({
      class: "apexcharts-xaxis"
    }), s = N.getPolygonPos(this.size, this.dataPointsLen);
    return e.globals.labels.forEach((n, o) => {
      let l = e.config.xaxis.labels.formatter, c = new Yn(this.ctx);
      if (s[o]) {
        let d = this.getTextPos(s[o], this.size), f = l(n, {
          seriesIndex: -1,
          dataPointIndex: o,
          w: e
        });
        c.plotDataLabelsText({
          x: d.newX,
          y: d.newY,
          text: f,
          textAnchor: d.textAnchor,
          i: o,
          j: o,
          parent: i,
          color: Array.isArray(t.style.colors) && t.style.colors[o] ? t.style.colors[o] : "#a8a8a8",
          dataLabelsConfig: {
            textAnchor: d.textAnchor,
            dropShadow: { enabled: !1 },
            ...t
          },
          offsetCorrection: !1
        });
      }
    }), i;
  }
  createPaths(e, t) {
    let i = [], s = [], n = [], o = [];
    if (e.length) {
      s = [this.graphics.move(t.x, t.y)], o = [this.graphics.move(t.x, t.y)];
      let l = this.graphics.move(e[0].x, e[0].y), c = this.graphics.move(e[0].x, e[0].y);
      e.forEach((d, f) => {
        l += this.graphics.line(d.x, d.y), c += this.graphics.line(d.x, d.y), f === e.length - 1 && (l += "Z", c += "Z");
      }), i.push(l), n.push(c);
    }
    return {
      linePathsFrom: s,
      linePathsTo: i,
      areaPathsFrom: o,
      areaPathsTo: n
    };
  }
  getTextPos(e, t) {
    let i = 10, s = "middle", n = e.x, o = e.y;
    return Math.abs(e.x) >= i ? e.x > 0 ? (s = "start", n += 10) : e.x < 0 && (s = "end", n -= 10) : s = "middle", Math.abs(e.y) >= t - i && (e.y < 0 ? o -= 10 : e.y > 0 && (o += 10)), {
      textAnchor: s,
      newX: n,
      newY: o
    };
  }
  getPreviousPath(e) {
    let t = this.w, i = null;
    for (let s = 0; s < t.globals.previousPaths.length; s++) {
      let n = t.globals.previousPaths[s];
      n.paths.length > 0 && parseInt(n.realIndex, 10) === parseInt(e, 10) && typeof t.globals.previousPaths[s].paths[0] < "u" && (i = t.globals.previousPaths[s].paths[0].d);
    }
    return i;
  }
  getDataPointsPos(e, t, i = this.dataPointsLen) {
    e = e || [], t = t || [];
    let s = [];
    for (let n = 0; n < i; n++) {
      let o = {};
      o.x = e[n] * Math.sin(t[n]), o.y = -e[n] * Math.cos(t[n]), s.push(o);
    }
    return s;
  }
}
class PL extends Nv {
  constructor(e) {
    super(e), this.ctx = e, this.w = e.w, this.animBeginArr = [0], this.animDur = 0;
    const t = this.w;
    this.startAngle = t.config.plotOptions.radialBar.startAngle, this.endAngle = t.config.plotOptions.radialBar.endAngle, this.totalAngle = Math.abs(
      t.config.plotOptions.radialBar.endAngle - t.config.plotOptions.radialBar.startAngle
    ), this.trackStartAngle = t.config.plotOptions.radialBar.track.startAngle, this.trackEndAngle = t.config.plotOptions.radialBar.track.endAngle, this.barLabels = this.w.config.plotOptions.radialBar.barLabels, this.donutDataLabels = this.w.config.plotOptions.radialBar.dataLabels, this.radialDataLabels = this.donutDataLabels, this.trackStartAngle || (this.trackStartAngle = this.startAngle), this.trackEndAngle || (this.trackEndAngle = this.endAngle), this.endAngle === 360 && (this.endAngle = 359.99), this.margin = parseInt(t.config.plotOptions.radialBar.track.margin, 10), this.onBarLabelClick = this.onBarLabelClick.bind(this);
  }
  draw(e) {
    let t = this.w;
    const i = new K(this.ctx);
    let s = i.group({
      class: "apexcharts-radialbar"
    });
    if (t.globals.noData)
      return s;
    let n = i.group(), o = this.defaultSize / 2, l = t.globals.gridWidth / 2, c = this.defaultSize / 2.05;
    t.config.chart.sparkline.enabled || (c = c - t.config.stroke.width - t.config.chart.dropShadow.blur);
    let d = t.globals.fill.colors;
    if (t.config.plotOptions.radialBar.track.show) {
      let v = this.drawTracks({
        size: c,
        centerX: l,
        centerY: o,
        colorArr: d,
        series: e
      });
      n.add(v);
    }
    let f = this.drawArcs({
      size: c,
      centerX: l,
      centerY: o,
      colorArr: d,
      series: e
    }), p = 360;
    t.config.plotOptions.radialBar.startAngle < 0 && (p = this.totalAngle);
    let m = (360 - p) / 360;
    if (t.globals.radialSize = c - c * m, this.radialDataLabels.value.show) {
      let v = Math.max(
        this.radialDataLabels.value.offsetY,
        this.radialDataLabels.name.offsetY
      );
      t.globals.radialSize += v * m;
    }
    return n.add(f.g), t.config.plotOptions.radialBar.hollow.position === "front" && (f.g.add(f.elHollow), f.dataLabels && f.g.add(f.dataLabels)), s.add(n), s;
  }
  drawTracks(e) {
    let t = this.w;
    const i = new K(this.ctx);
    let s = i.group({
      class: "apexcharts-tracks"
    }), n = new It(this.ctx), o = new _i(this.ctx), l = this.getStrokeWidth(e);
    e.size = e.size - l / 2;
    for (let c = 0; c < e.series.length; c++) {
      let d = i.group({
        class: "apexcharts-radialbar-track apexcharts-track"
      });
      s.add(d), d.attr({
        rel: c + 1
      }), e.size = e.size - l - this.margin;
      const f = t.config.plotOptions.radialBar.track;
      let p = o.fillPath({
        seriesNumber: 0,
        size: e.size,
        fillColors: Array.isArray(f.background) ? f.background[c] : f.background,
        solid: !0
      }), m = this.trackStartAngle, v = this.trackEndAngle;
      Math.abs(v) + Math.abs(m) >= 360 && (v = 360 - Math.abs(this.startAngle) - 0.1);
      let r = i.drawPath({
        d: "",
        stroke: p,
        strokeWidth: l * parseInt(f.strokeWidth, 10) / 100,
        fill: "none",
        strokeOpacity: f.opacity,
        classes: "apexcharts-radialbar-area"
      });
      if (f.dropShadow.enabled) {
        const h = f.dropShadow;
        n.dropShadow(r, h);
      }
      d.add(r), r.attr("id", "apexcharts-radialbarTrack-" + c), this.animatePaths(r, {
        centerX: e.centerX,
        centerY: e.centerY,
        endAngle: v,
        startAngle: m,
        size: e.size,
        i: c,
        totalItems: 2,
        animBeginArr: 0,
        dur: 0,
        isTrack: !0,
        easing: t.globals.easing
      });
    }
    return s;
  }
  drawArcs(e) {
    let t = this.w, i = new K(this.ctx), s = new _i(this.ctx), n = new It(this.ctx), o = i.group(), l = this.getStrokeWidth(e);
    e.size = e.size - l / 2;
    let c = t.config.plotOptions.radialBar.hollow.background, d = e.size - l * e.series.length - this.margin * e.series.length - l * parseInt(t.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2, f = d - t.config.plotOptions.radialBar.hollow.margin;
    t.config.plotOptions.radialBar.hollow.image !== void 0 && (c = this.drawHollowImage(e, o, d, c));
    let p = this.drawHollow({
      size: f,
      centerX: e.centerX,
      centerY: e.centerY,
      fill: c || "transparent"
    });
    if (t.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
      const h = t.config.plotOptions.radialBar.hollow.dropShadow;
      n.dropShadow(p, h);
    }
    let m = 1;
    !this.radialDataLabels.total.show && t.globals.series.length > 1 && (m = 0);
    let v = null;
    this.radialDataLabels.show && (v = this.renderInnerDataLabels(this.radialDataLabels, {
      hollowSize: d,
      centerX: e.centerX,
      centerY: e.centerY,
      opacity: m
    })), t.config.plotOptions.radialBar.hollow.position === "back" && (o.add(p), v && o.add(v));
    let r = !1;
    t.config.plotOptions.radialBar.inverseOrder && (r = !0);
    for (let h = r ? e.series.length - 1 : 0; r ? h >= 0 : h < e.series.length; r ? h-- : h++) {
      let u = i.group({
        class: "apexcharts-series apexcharts-radial-series",
        seriesName: N.escapeString(t.globals.seriesNames[h])
      });
      o.add(u), u.attr({
        rel: h + 1,
        "data:realIndex": h
      }), this.ctx.series.addCollapsedClassToSeries(u, h), e.size = e.size - l - this.margin;
      let g = s.fillPath({
        seriesNumber: h,
        size: e.size,
        value: e.series[h]
      }), b = this.startAngle, O;
      const x = N.negToZero(e.series[h] > 100 ? 100 : e.series[h]) / 100;
      let S = Math.round(this.totalAngle * x) + this.startAngle, k;
      t.globals.dataChanged && (O = this.startAngle, k = Math.round(
        this.totalAngle * N.negToZero(t.globals.previousPaths[h]) / 100
      ) + O), Math.abs(S) + Math.abs(b) >= 360 && (S = S - 0.01), Math.abs(k) + Math.abs(O) >= 360 && (k = k - 0.01);
      let $ = S - b;
      const L = Array.isArray(t.config.stroke.dashArray) ? t.config.stroke.dashArray[h] : t.config.stroke.dashArray;
      let E = i.drawPath({
        d: "",
        stroke: g,
        strokeWidth: l,
        fill: "none",
        fillOpacity: t.config.fill.opacity,
        classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + h,
        strokeDashArray: L
      });
      if (K.setAttrs(E.node, {
        "data:angle": $,
        "data:value": e.series[h]
      }), t.config.chart.dropShadow.enabled) {
        const y = t.config.chart.dropShadow;
        n.dropShadow(E, y, h);
      }
      if (n.setSelectionFilter(E, 0, h), this.addListeners(E, this.radialDataLabels), u.add(E), E.attr({
        index: 0,
        j: h
      }), this.barLabels.enabled) {
        let y = N.polarToCartesian(
          e.centerX,
          e.centerY,
          e.size,
          b
        ), w = this.barLabels.formatter(t.globals.seriesNames[h], {
          seriesIndex: h,
          w: t
        }), T = ["apexcharts-radialbar-label"];
        this.barLabels.onClick || T.push("apexcharts-no-click");
        let P = this.barLabels.useSeriesColors ? t.globals.colors[h] : t.config.chart.foreColor;
        P || (P = t.config.chart.foreColor);
        const R = y.x - this.barLabels.margin, Q = y.y;
        let z = i.drawText({
          x: R,
          y: Q,
          text: w,
          textAnchor: "end",
          dominantBaseline: "middle",
          fontFamily: this.barLabels.fontFamily,
          fontWeight: this.barLabels.fontWeight,
          fontSize: this.barLabels.fontSize,
          foreColor: P,
          cssClass: T.join(" ")
        });
        z.on("click", this.onBarLabelClick), z.attr({
          rel: h + 1
        }), b !== 0 && z.attr({
          "transform-origin": `${R} ${Q}`,
          transform: `rotate(${b} 0 0)`
        }), u.add(z);
      }
      let A = 0;
      this.initialAnim && !t.globals.resized && !t.globals.dataChanged && (A = t.config.chart.animations.speed), t.globals.dataChanged && (A = t.config.chart.animations.dynamicAnimation.speed), this.animDur = A / (e.series.length * 1.2) + this.animDur, this.animBeginArr.push(this.animDur), this.animatePaths(E, {
        centerX: e.centerX,
        centerY: e.centerY,
        endAngle: S,
        startAngle: b,
        prevEndAngle: k,
        prevStartAngle: O,
        size: e.size,
        i: h,
        totalItems: 2,
        animBeginArr: this.animBeginArr,
        dur: A,
        shouldSetPrevPaths: !0,
        easing: t.globals.easing
      });
    }
    return {
      g: o,
      elHollow: p,
      dataLabels: v
    };
  }
  drawHollow(e) {
    let i = new K(this.ctx).drawCircle(e.size * 2);
    return i.attr({
      class: "apexcharts-radialbar-hollow",
      cx: e.centerX,
      cy: e.centerY,
      r: e.size,
      fill: e.fill
    }), i;
  }
  drawHollowImage(e, t, i, s) {
    const n = this.w;
    let o = new _i(this.ctx), l = N.randomId(), c = n.config.plotOptions.radialBar.hollow.image;
    if (n.config.plotOptions.radialBar.hollow.imageClipped)
      o.clippedImgArea({
        width: i,
        height: i,
        image: c,
        patternID: `pattern${n.globals.cuid}${l}`
      }), s = `url(#pattern${n.globals.cuid}${l})`;
    else {
      const d = n.config.plotOptions.radialBar.hollow.imageWidth, f = n.config.plotOptions.radialBar.hollow.imageHeight;
      if (d === void 0 && f === void 0) {
        let p = n.globals.dom.Paper.image(c).loaded(function(m) {
          this.move(
            e.centerX - m.width / 2 + n.config.plotOptions.radialBar.hollow.imageOffsetX,
            e.centerY - m.height / 2 + n.config.plotOptions.radialBar.hollow.imageOffsetY
          );
        });
        t.add(p);
      } else {
        let p = n.globals.dom.Paper.image(c).loaded(function(m) {
          this.move(
            e.centerX - d / 2 + n.config.plotOptions.radialBar.hollow.imageOffsetX,
            e.centerY - f / 2 + n.config.plotOptions.radialBar.hollow.imageOffsetY
          ), this.size(d, f);
        });
        t.add(p);
      }
    }
    return s;
  }
  getStrokeWidth(e) {
    const t = this.w;
    return e.size * (100 - parseInt(t.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (e.series.length + 1) - this.margin;
  }
  onBarLabelClick(e) {
    let t = parseInt(e.target.getAttribute("rel"), 10) - 1;
    const i = this.barLabels.onClick, s = this.w;
    i && i(s.globals.seriesNames[t], { w: s, seriesIndex: t });
  }
}
class LL extends Vn {
  draw(e, t) {
    let i = this.w, s = new K(this.ctx);
    this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = e, this.seriesRangeStart = i.globals.seriesRangeStart, this.seriesRangeEnd = i.globals.seriesRangeEnd, this.barHelpers.initVariables(e);
    let n = s.group({
      class: "apexcharts-rangebar-series apexcharts-plot-series"
    });
    for (let o = 0; o < e.length; o++) {
      let l, c, d, f, p, m, v = i.globals.comboCharts ? t[o] : o, r = s.group({
        class: "apexcharts-series",
        seriesName: N.escapeString(i.globals.seriesNames[v]),
        rel: o + 1,
        "data:realIndex": v
      });
      this.ctx.series.addCollapsedClassToSeries(r, v), e[o].length > 0 && (this.visibleI = this.visibleI + 1);
      let h = 0, u = 0, g = 0;
      this.yRatio.length > 1 && (this.yaxisIndex = i.globals.seriesYAxisReverseMap[v][0], g = v);
      let b = this.barHelpers.initialPositions();
      c = b.y, m = b.zeroW, l = b.x, u = b.barWidth, h = b.barHeight, d = b.xDivision, f = b.yDivision, p = b.zeroH;
      let O = s.group({
        class: "apexcharts-datalabels",
        "data:realIndex": v
      }), x = s.group({
        class: "apexcharts-rangebar-goals-markers"
      });
      for (let S = 0; S < i.globals.dataPoints; S++) {
        const k = this.barHelpers.getStrokeWidth(o, S, v), C = this.seriesRangeStart[o][S], _ = this.seriesRangeEnd[o][S];
        let $ = null, L = null, E = null;
        const A = { x: l, y: c, strokeWidth: k, elSeries: r };
        let y = this.seriesLen;
        if (i.config.plotOptions.bar.rangeBarGroupRows && (y = 1), typeof i.config.series[o].data[S] > "u")
          break;
        if (this.isHorizontal) {
          E = c + h * this.visibleI;
          let R = (f - h * y) / 2;
          if (i.config.series[o].data[S].x) {
            let Q = this.detectOverlappingBars({
              i: o,
              j: S,
              barYPosition: E,
              srty: R,
              barHeight: h,
              yDivision: f,
              initPositions: b
            });
            h = Q.barHeight, E = Q.barYPosition;
          }
          $ = this.drawRangeBarPaths({
            indexes: { i: o, j: S, realIndex: v },
            barHeight: h,
            barYPosition: E,
            zeroW: m,
            yDivision: f,
            y1: C,
            y2: _,
            ...A
          }), u = $.barWidth;
        } else {
          i.globals.isXNumeric && (l = (i.globals.seriesX[o][S] - i.globals.minX) / this.xRatio - u / 2), L = l + u * this.visibleI;
          let R = (d - u * y) / 2;
          if (i.config.series[o].data[S].x) {
            let Q = this.detectOverlappingBars({
              i: o,
              j: S,
              barXPosition: L,
              srtx: R,
              barWidth: u,
              xDivision: d,
              initPositions: b
            });
            u = Q.barWidth, L = Q.barXPosition;
          }
          $ = this.drawRangeColumnPaths({
            indexes: { i: o, j: S, realIndex: v, translationsIndex: g },
            barWidth: u,
            barXPosition: L,
            zeroH: p,
            xDivision: d,
            ...A
          }), h = $.barHeight;
        }
        const w = this.barHelpers.drawGoalLine({
          barXPosition: $.barXPosition,
          barYPosition: E,
          goalX: $.goalX,
          goalY: $.goalY,
          barHeight: h,
          barWidth: u
        });
        w && x.add(w), c = $.y, l = $.x;
        let T = this.barHelpers.getPathFillColor(e, o, S, v), P = i.globals.stroke.colors[v];
        this.renderSeries({
          realIndex: v,
          pathFill: T,
          lineFill: P,
          j: S,
          i: o,
          x: l,
          y: c,
          y1: C,
          y2: _,
          pathFrom: $.pathFrom,
          pathTo: $.pathTo,
          strokeWidth: k,
          elSeries: r,
          series: e,
          barHeight: h,
          barWidth: u,
          barXPosition: L,
          barYPosition: E,
          barWidth: u,
          elDataLabelsWrap: O,
          elGoalsMarkers: x,
          visibleSeries: this.visibleI,
          type: "rangebar"
        });
      }
      n.add(r);
    }
    return n;
  }
  detectOverlappingBars({
    i: e,
    j: t,
    barYPosition: i,
    barXPosition: s,
    srty: n,
    srtx: o,
    barHeight: l,
    barWidth: c,
    yDivision: d,
    xDivision: f,
    initPositions: p
  }) {
    const m = this.w;
    let v = [], r = m.config.series[e].data[t].rangeName;
    const h = m.config.series[e].data[t].x, u = Array.isArray(h) ? h.join(" ") : h, g = m.globals.labels.map((O) => Array.isArray(O) ? O.join(" ") : O).indexOf(u), b = m.globals.seriesRange[e].findIndex(
      (O) => O.x === u && O.overlaps.length > 0
    );
    return this.isHorizontal ? (m.config.plotOptions.bar.rangeBarGroupRows ? i = n + d * g : i = n + l * this.visibleI + d * g, b > -1 && !m.config.plotOptions.bar.rangeBarOverlap && (v = m.globals.seriesRange[e][b].overlaps, v.indexOf(r) > -1 && (l = p.barHeight / v.length, i = l * this.visibleI + d * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + l * (this.visibleI + v.indexOf(r)) + d * g))) : (g > -1 && (m.config.plotOptions.bar.rangeBarGroupRows ? s = o + f * g : s = o + c * this.visibleI + f * g), b > -1 && !m.config.plotOptions.bar.rangeBarOverlap && (v = m.globals.seriesRange[e][b].overlaps, v.indexOf(r) > -1 && (c = p.barWidth / v.length, s = c * this.visibleI + f * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + c * (this.visibleI + v.indexOf(r)) + f * g))), {
      barYPosition: i,
      barXPosition: s,
      barHeight: l,
      barWidth: c
    };
  }
  drawRangeColumnPaths({
    indexes: e,
    x: t,
    xDivision: i,
    barWidth: s,
    barXPosition: n,
    zeroH: o
  }) {
    let l = this.w, c = e.i, d = e.j;
    const f = this.yRatio[e.translationsIndex];
    let p = e.realIndex;
    const m = this.getRangeValue(p, d);
    let v = Math.min(m.start, m.end), r = Math.max(m.start, m.end);
    typeof this.series[c][d] > "u" || this.series[c][d] === null ? v = o : (v = o - v / f, r = o - r / f);
    const h = Math.abs(r - v), u = this.barHelpers.getColumnPaths({
      barXPosition: n,
      barWidth: s,
      y1: v,
      y2: r,
      strokeWidth: this.strokeWidth,
      series: this.seriesRangeEnd,
      realIndex: e.realIndex,
      i: p,
      j: d,
      w: l
    });
    if (!l.globals.isXNumeric)
      t = t + i;
    else {
      const g = this.getBarXForNumericXAxis({
        x: t,
        j: d,
        realIndex: p,
        barWidth: s
      });
      t = g.x, n = g.barXPosition;
    }
    return {
      pathTo: u.pathTo,
      pathFrom: u.pathFrom,
      barHeight: h,
      x: t,
      y: r,
      goalY: this.barHelpers.getGoalValues(
        "y",
        null,
        o,
        c,
        d,
        e.translationsIndex
      ),
      barXPosition: n
    };
  }
  drawRangeBarPaths({
    indexes: e,
    y: t,
    y1: i,
    y2: s,
    yDivision: n,
    barHeight: o,
    barYPosition: l,
    zeroW: c
  }) {
    let d = this.w;
    const f = c + i / this.invertedYRatio, p = c + s / this.invertedYRatio, m = Math.abs(p - f), v = this.barHelpers.getBarpaths({
      barYPosition: l,
      barHeight: o,
      x1: f,
      x2: p,
      strokeWidth: this.strokeWidth,
      series: this.seriesRangeEnd,
      i: e.realIndex,
      realIndex: e.realIndex,
      j: e.j,
      w: d
    });
    return d.globals.isXNumeric || (t = t + n), {
      pathTo: v.pathTo,
      pathFrom: v.pathFrom,
      barWidth: m,
      x: p,
      goalX: this.barHelpers.getGoalValues(
        "x",
        c,
        null,
        e.realIndex,
        e.j
      ),
      y: t
    };
  }
  getRangeValue(e, t) {
    const i = this.w;
    return {
      start: i.globals.seriesRangeStart[e][t],
      end: i.globals.seriesRangeEnd[e][t]
    };
  }
}
class ML {
  constructor(e) {
    this.w = e.w, this.lineCtx = e;
  }
  sameValueSeriesFix(e, t) {
    const i = this.w;
    if ((i.config.fill.type === "gradient" || i.config.fill.type[e] === "gradient") && new vt(this.lineCtx.ctx, i).seriesHaveSameValues(e)) {
      let n = t[e].slice();
      n[n.length - 1] = n[n.length - 1] + 1e-6, t[e] = n;
    }
    return t;
  }
  calculatePoints({ series: e, realIndex: t, x: i, y: s, i: n, j: o, prevY: l }) {
    let c = this.w, d = [], f = [];
    if (o === 0) {
      let m = this.lineCtx.categoryAxisCorrection + c.config.markers.offsetX;
      c.globals.isXNumeric && (m = (c.globals.seriesX[t][0] - c.globals.minX) / this.lineCtx.xRatio + c.config.markers.offsetX), d.push(m), f.push(
        N.isNumber(e[n][0]) ? l + c.config.markers.offsetY : null
      ), d.push(i + c.config.markers.offsetX), f.push(
        N.isNumber(e[n][o + 1]) ? s + c.config.markers.offsetY : null
      );
    } else
      d.push(i + c.config.markers.offsetX), f.push(
        N.isNumber(e[n][o + 1]) ? s + c.config.markers.offsetY : null
      );
    return {
      x: d,
      y: f
    };
  }
  checkPreviousPaths({ pathFromLine: e, pathFromArea: t, realIndex: i }) {
    let s = this.w;
    for (let n = 0; n < s.globals.previousPaths.length; n++) {
      let o = s.globals.previousPaths[n];
      (o.type === "line" || o.type === "area") && o.paths.length > 0 && parseInt(o.realIndex, 10) === parseInt(i, 10) && (o.type === "line" ? (this.lineCtx.appendPathFrom = !1, e = s.globals.previousPaths[n].paths[0].d) : o.type === "area" && (this.lineCtx.appendPathFrom = !1, t = s.globals.previousPaths[n].paths[0].d, s.config.stroke.show && s.globals.previousPaths[n].paths[1] && (e = s.globals.previousPaths[n].paths[1].d)));
    }
    return {
      pathFromLine: e,
      pathFromArea: t
    };
  }
  determineFirstPrevY({ i: e, series: t, prevY: i, lineYPosition: s, translationsIndex: n }) {
    var c, d;
    let o = this.w, l = o.config.chart.stacked && !o.globals.comboCharts || o.config.chart.stacked && o.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || ((c = this.w.config.series[e]) == null ? void 0 : c.type) === "bar");
    if (typeof ((d = t[e]) == null ? void 0 : d[0]) < "u")
      l ? e > 0 ? s = this.lineCtx.prevSeriesY[e - 1][0] : s = this.lineCtx.zeroY : s = this.lineCtx.zeroY, i = s - t[e][0] / this.lineCtx.yRatio[n] + (this.lineCtx.isReversed ? t[e][0] / this.lineCtx.yRatio[n] : 0) * 2;
    else if (l && e > 0 && typeof t[e][0] > "u") {
      for (let f = e - 1; f >= 0; f--)
        if (t[f][0] !== null && typeof t[f][0] < "u") {
          s = this.lineCtx.prevSeriesY[f][0], i = s;
          break;
        }
    }
    return {
      prevY: i,
      lineYPosition: s
    };
  }
}
const DL = (a) => {
  const e = RL(a), t = a.length - 1, i = 1e-6, s = [];
  let n, o, l, c;
  for (let d = 0; d < t; d++)
    l = bh(a[d], a[d + 1]), Math.abs(l) < i ? e[d] = e[d + 1] = 0 : (n = e[d] / l, o = e[d + 1] / l, c = n * n + o * o, c > 9 && (c = l * 3 / Math.sqrt(c), e[d] = c * n, e[d + 1] = c * o));
  for (let d = 0; d <= t; d++)
    c = (a[Math.min(t, d + 1)][0] - a[Math.max(0, d - 1)][0]) / (6 * (1 + e[d] * e[d])), s.push([c || 0, e[d] * c || 0]);
  return s;
}, vc = (a) => {
  let e = "";
  for (let t = 0; t < a.length; t++) {
    const i = a[t], s = i.length;
    s > 4 ? (e += `C${i[0]}, ${i[1]}`, e += `, ${i[2]}, ${i[3]}`, e += `, ${i[4]}, ${i[5]}`) : s > 2 && (e += `S${i[0]}, ${i[1]}`, e += `, ${i[2]}, ${i[3]}`);
  }
  return e;
}, qf = {
  /**
   * Convert 'points' to bezier
   * @param {Array} points
   * @returns {Array}
   */
  points(a) {
    const e = DL(a), t = a[1], i = a[0], s = [], n = e[1], o = e[0];
    s.push(i, [
      i[0] + o[0],
      i[1] + o[1],
      t[0] - n[0],
      t[1] - n[1],
      t[0],
      t[1]
    ]);
    for (let l = 2, c = e.length; l < c; l++) {
      const d = a[l], f = e[l];
      s.push([d[0] - f[0], d[1] - f[1], d[0], d[1]]);
    }
    return s;
  },
  /**
   * Slice out a segment of 'points'
   * @param {Array} points
   * @param {Number} start
   * @param {Number} end
   * @returns {Array}
   */
  slice(a, e, t) {
    const i = a.slice(e, t);
    if (e) {
      if (i[1].length < 6) {
        const s = i[0].length;
        i[1] = [
          i[0][s - 2] * 2 - i[0][s - 4],
          i[0][s - 1] * 2 - i[0][s - 3]
        ].concat(i[1]);
      }
      i[0] = i[0].slice(-2);
    }
    return i;
  }
};
function bh(a, e) {
  return (e[1] - a[1]) / (e[0] - a[0]);
}
function RL(a) {
  const e = [];
  let t = a[0], i = a[1], s = e[0] = bh(t, i), n = 1;
  for (let o = a.length - 1; n < o; n++)
    t = i, i = a[n + 1], e[n] = (s + (s = bh(t, i))) * 0.5;
  return e[n] = s, e;
}
let yc = class {
  constructor(e, t, i) {
    this.ctx = e, this.w = e.w, this.xyRatios = t, this.pointsChart = !(this.w.config.chart.type !== "bubble" && this.w.config.chart.type !== "scatter") || i, this.scatter = new Av(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new ML(this), this.markers = new va(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0;
  }
  draw(e, t, i, s) {
    var p;
    let n = this.w, o = new K(this.ctx), l = n.globals.comboCharts ? t : n.config.chart.type, c = o.group({
      class: `apexcharts-${l}-series apexcharts-plot-series`
    });
    const d = new vt(this.ctx, n);
    this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, e = d.getLogSeries(e), this.yRatio = d.getLogYRatios(this.yRatio);
    let f = [];
    for (let m = 0; m < e.length; m++) {
      e = this.lineHelpers.sameValueSeriesFix(m, e);
      let v = n.globals.comboCharts ? i[m] : m, r = this.yRatio.length > 1 ? v : 0;
      this._initSerieVariables(e, m, v);
      let h = [], u = [], g = [], b = n.globals.padHorizontal + this.categoryAxisCorrection, O = 1, x = [], S = [];
      this.ctx.series.addCollapsedClassToSeries(this.elSeries, v), n.globals.isXNumeric && n.globals.seriesX.length > 0 && (b = (n.globals.seriesX[v][0] - n.globals.minX) / this.xRatio), g.push(b);
      let k = b, C, _, $ = k, L = this.zeroY, E = this.zeroY, A = 0;
      L = this.lineHelpers.determineFirstPrevY({
        i: m,
        series: e,
        prevY: L,
        lineYPosition: A,
        translationsIndex: r
      }).prevY, n.config.stroke.curve === "monotonCubic" && e[m][0] === null ? h.push(null) : h.push(L), C = L;
      let w;
      l === "rangeArea" && (w = this.lineHelpers.determineFirstPrevY({
        i: m,
        series: s,
        prevY: E,
        lineYPosition: A,
        translationsIndex: r
      }), E = w.prevY, _ = E, u.push(E));
      let T = this._calculatePathsFrom({
        type: l,
        series: e,
        i: m,
        realIndex: v,
        prevX: $,
        prevY: L,
        prevY2: E
      });
      const P = {
        type: l,
        series: e,
        realIndex: v,
        translationsIndex: r,
        i: m,
        x: b,
        y: O,
        pX: k,
        pY: C,
        pathsFrom: T,
        linePaths: x,
        areaPaths: S,
        seriesIndex: i,
        lineYPosition: A,
        xArrj: g,
        yArrj: h,
        y2Arrj: u,
        seriesRangeEnd: s
      };
      let R = this._iterateOverDataPoints({
        ...P,
        iterations: l === "rangeArea" ? e[m].length - 1 : void 0,
        isRangeStart: !0
      });
      if (l === "rangeArea") {
        let Q = this._calculatePathsFrom({
          series: s,
          i: m,
          realIndex: v,
          prevX: $,
          prevY: E
        }), z = this._iterateOverDataPoints({
          ...P,
          series: s,
          pY: _,
          pathsFrom: Q,
          iterations: s[m].length - 1,
          isRangeStart: !1
        });
        R.linePaths[0] = z.linePath + R.linePath, R.pathFromLine = z.pathFromLine + R.pathFromLine;
      }
      this._handlePaths({ type: l, realIndex: v, i: m, paths: R }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), f.push(this.elSeries);
    }
    if (typeof ((p = n.config.series[0]) == null ? void 0 : p.zIndex) < "u" && f.sort(
      (m, v) => Number(m.node.getAttribute("zIndex")) - Number(v.node.getAttribute("zIndex"))
    ), n.config.chart.stacked)
      for (let m = f.length; m > 0; m--)
        c.add(f[m - 1]);
    else
      for (let m = 0; m < f.length; m++)
        c.add(f[m]);
    return c;
  }
  _initSerieVariables(e, t, i) {
    const s = this.w, n = new K(this.ctx);
    this.xDivision = s.globals.gridWidth / (s.globals.dataPoints - (s.config.xaxis.tickPlacement === "on" ? 1 : 0)), this.strokeWidth = Array.isArray(s.config.stroke.width) ? s.config.stroke.width[i] : s.config.stroke.width;
    let o = 0;
    this.yRatio.length > 1 && (this.yaxisIndex = s.globals.seriesYAxisReverseMap[i], o = i), this.isReversed = s.config.yaxis[this.yaxisIndex] && s.config.yaxis[this.yaxisIndex].reversed, this.zeroY = s.globals.gridHeight - this.baseLineY[o] - (this.isReversed ? s.globals.gridHeight : 0) + (this.isReversed ? this.baseLineY[o] * 2 : 0), this.areaBottomY = this.zeroY, (this.zeroY > s.globals.gridHeight || s.config.plotOptions.area.fillTo === "end") && (this.areaBottomY = s.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = n.group({
      class: "apexcharts-series",
      zIndex: typeof s.config.series[i].zIndex < "u" ? s.config.series[i].zIndex : i,
      seriesName: N.escapeString(s.globals.seriesNames[i])
    }), this.elPointsMain = n.group({
      class: "apexcharts-series-markers-wrap",
      "data:realIndex": i
    }), this.elDataLabelsWrap = n.group({
      class: "apexcharts-datalabels",
      "data:realIndex": i
    });
    let l = e[t].length === s.globals.dataPoints;
    this.elSeries.attr({
      "data:longestSeries": l,
      rel: t + 1,
      "data:realIndex": i
    }), this.appendPathFrom = !0;
  }
  _calculatePathsFrom({ type: e, series: t, i, realIndex: s, prevX: n, prevY: o, prevY2: l }) {
    const c = this.w, d = new K(this.ctx);
    let f, p, m, v;
    if (t[i][0] === null) {
      for (let r = 0; r < t[i].length; r++)
        if (t[i][r] !== null) {
          n = this.xDivision * r, o = this.zeroY - t[i][r] / this.yRatio[s], f = d.move(n, o), p = d.move(n, this.areaBottomY);
          break;
        }
    } else
      f = d.move(n, o), e === "rangeArea" && (f = d.move(n, l) + d.line(n, o)), p = d.move(n, this.areaBottomY) + d.line(n, o);
    if (m = d.move(-1, this.zeroY) + d.line(-1, this.zeroY), v = d.move(-1, this.zeroY) + d.line(-1, this.zeroY), c.globals.previousPaths.length > 0) {
      const r = this.lineHelpers.checkPreviousPaths({
        pathFromLine: m,
        pathFromArea: v,
        realIndex: s
      });
      m = r.pathFromLine, v = r.pathFromArea;
    }
    return {
      prevX: n,
      prevY: o,
      linePath: f,
      areaPath: p,
      pathFromLine: m,
      pathFromArea: v
    };
  }
  _handlePaths({ type: e, realIndex: t, i, paths: s }) {
    const n = this.w, o = new K(this.ctx), l = new _i(this.ctx);
    this.prevSeriesY.push(s.yArrj), n.globals.seriesXvalues[t] = s.xArrj, n.globals.seriesYvalues[t] = s.yArrj;
    const c = n.config.forecastDataPoints;
    if (c.count > 0 && e !== "rangeArea") {
      const f = n.globals.seriesXvalues[t][n.globals.seriesXvalues[t].length - c.count - 1], p = o.drawRect(
        f,
        0,
        n.globals.gridWidth,
        n.globals.gridHeight,
        0
      );
      n.globals.dom.elForecastMask.appendChild(p.node);
      const m = o.drawRect(
        0,
        0,
        f,
        n.globals.gridHeight,
        0
      );
      n.globals.dom.elNonForecastMask.appendChild(m.node);
    }
    this.pointsChart || n.globals.delayedElements.push({
      el: this.elPointsMain.node,
      index: t
    });
    const d = {
      i,
      realIndex: t,
      animationDelay: i,
      initialSpeed: n.config.chart.animations.speed,
      dataChangeSpeed: n.config.chart.animations.dynamicAnimation.speed,
      className: `apexcharts-${e}`
    };
    if (e === "area") {
      let f = l.fillPath({
        seriesNumber: t
      });
      for (let p = 0; p < s.areaPaths.length; p++) {
        let m = o.renderPaths({
          ...d,
          pathFrom: s.pathFromArea,
          pathTo: s.areaPaths[p],
          stroke: "none",
          strokeWidth: 0,
          strokeLineCap: null,
          fill: f
        });
        this.elSeries.add(m);
      }
    }
    if (n.config.stroke.show && !this.pointsChart) {
      let f = null;
      if (e === "line")
        f = l.fillPath({
          seriesNumber: t,
          i
        });
      else if (n.config.stroke.fill.type === "solid")
        f = n.globals.stroke.colors[t];
      else {
        const p = n.config.fill;
        n.config.fill = n.config.stroke.fill, f = l.fillPath({
          seriesNumber: t,
          i
        }), n.config.fill = p;
      }
      for (let p = 0; p < s.linePaths.length; p++) {
        let m = f;
        e === "rangeArea" && (m = l.fillPath({
          seriesNumber: t
        }));
        const v = {
          ...d,
          pathFrom: s.pathFromLine,
          pathTo: s.linePaths[p],
          stroke: f,
          strokeWidth: this.strokeWidth,
          strokeLineCap: n.config.stroke.lineCap,
          fill: e === "rangeArea" ? m : "none"
        };
        let r = o.renderPaths(v);
        if (this.elSeries.add(r), r.attr("fill-rule", "evenodd"), c.count > 0 && e !== "rangeArea") {
          let h = o.renderPaths(v);
          h.node.setAttribute(
            "stroke-dasharray",
            c.dashArray
          ), c.strokeWidth && h.node.setAttribute(
            "stroke-width",
            c.strokeWidth
          ), this.elSeries.add(h), h.attr(
            "clip-path",
            `url(#forecastMask${n.globals.cuid})`
          ), r.attr(
            "clip-path",
            `url(#nonForecastMask${n.globals.cuid})`
          );
        }
      }
    }
  }
  _iterateOverDataPoints({
    type: e,
    series: t,
    iterations: i,
    realIndex: s,
    translationsIndex: n,
    i: o,
    x: l,
    y: c,
    pX: d,
    pY: f,
    pathsFrom: p,
    linePaths: m,
    areaPaths: v,
    seriesIndex: r,
    lineYPosition: h,
    xArrj: u,
    yArrj: g,
    y2Arrj: b,
    isRangeStart: O,
    seriesRangeEnd: x
  }) {
    var R;
    const S = this.w;
    let k = new K(this.ctx), C = this.yRatio, { prevY: _, linePath: $, areaPath: L, pathFromLine: E, pathFromArea: A } = p;
    const y = N.isNumber(S.globals.minYArr[s]) ? S.globals.minYArr[s] : S.globals.minY;
    i || (i = S.globals.dataPoints > 1 ? S.globals.dataPoints - 1 : S.globals.dataPoints);
    const w = (Q, z) => z - Q / C[n] + (this.isReversed ? Q / C[n] : 0) * 2;
    let T = c, P = S.config.chart.stacked && !S.globals.comboCharts || S.config.chart.stacked && S.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || ((R = this.w.config.series[s]) == null ? void 0 : R.type) === "bar");
    for (let Q = 0; Q < i; Q++) {
      const z = typeof t[o][Q + 1] > "u" || t[o][Q + 1] === null;
      if (S.globals.isXNumeric) {
        let de = S.globals.seriesX[s][Q + 1];
        typeof S.globals.seriesX[s][Q + 1] > "u" && (de = S.globals.seriesX[s][i - 1]), l = (de - S.globals.minX) / this.xRatio;
      } else
        l = l + this.xDivision;
      if (P)
        if (o > 0 && S.globals.collapsedSeries.length < S.config.series.length - 1) {
          const de = (xe) => {
            let ie = xe;
            for (let fe = 0; fe < S.globals.series.length; fe++)
              if (S.globals.collapsedSeriesIndices.indexOf(xe) > -1) {
                ie--;
                break;
              }
            return ie >= 0 ? ie : 0;
          };
          h = this.prevSeriesY[de(o - 1)][Q + 1];
        } else
          h = this.zeroY;
      else
        h = this.zeroY;
      z ? c = w(y, h) : (c = w(t[o][Q + 1], h), e === "rangeArea" && (T = w(x[o][Q + 1], h))), u.push(l), z && S.config.stroke.curve === "smooth" ? g.push(null) : g.push(c), b.push(T);
      let W = this.lineHelpers.calculatePoints({
        series: t,
        x: l,
        y: c,
        realIndex: s,
        i: o,
        j: Q,
        prevY: _
      }), G = this._createPaths({
        type: e,
        series: t,
        i: o,
        realIndex: s,
        j: Q,
        x: l,
        y: c,
        y2: T,
        xArrj: u,
        yArrj: g,
        y2Arrj: b,
        pX: d,
        pY: f,
        linePath: $,
        areaPath: L,
        linePaths: m,
        areaPaths: v,
        seriesIndex: r,
        isRangeStart: O
      });
      v = G.areaPaths, m = G.linePaths, d = G.pX, f = G.pY, L = G.areaPath, $ = G.linePath, this.appendPathFrom && !(S.config.stroke.curve === "monotoneCubic" && e === "rangeArea") && (E = E + k.line(l, this.zeroY), A = A + k.line(l, this.zeroY)), this.handleNullDataPoints(t, W, o, Q, s), this._handleMarkersAndLabels({
        type: e,
        pointsPos: W,
        i: o,
        j: Q,
        realIndex: s,
        isRangeStart: O
      });
    }
    return {
      yArrj: g,
      xArrj: u,
      pathFromArea: A,
      areaPaths: v,
      pathFromLine: E,
      linePaths: m,
      linePath: $,
      areaPath: L
    };
  }
  _handleMarkersAndLabels({ type: e, pointsPos: t, isRangeStart: i, i: s, j: n, realIndex: o }) {
    const l = this.w;
    let c = new Yn(this.ctx);
    if (this.pointsChart)
      this.scatter.draw(this.elSeries, n, {
        realIndex: o,
        pointsPos: t,
        zRatio: this.zRatio,
        elParent: this.elPointsMain
      });
    else {
      l.globals.series[s].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
      let f = this.markers.plotChartMarkers(
        t,
        o,
        n + 1
      );
      f !== null && this.elPointsMain.add(f);
    }
    let d = c.drawDataLabel({
      type: e,
      isRangeStart: i,
      pos: t,
      i: o,
      j: n + 1
    });
    d !== null && this.elDataLabelsWrap.add(d);
  }
  _createPaths({
    type: e,
    series: t,
    i,
    realIndex: s,
    j: n,
    x: o,
    y: l,
    xArrj: c,
    yArrj: d,
    y2: f,
    y2Arrj: p,
    pX: m,
    pY: v,
    linePath: r,
    areaPath: h,
    linePaths: u,
    areaPaths: g,
    seriesIndex: b,
    isRangeStart: O
  }) {
    let x = this.w, S = new K(this.ctx), k = x.config.stroke.curve;
    const C = this.areaBottomY;
    if (Array.isArray(x.config.stroke.curve) && (Array.isArray(b) ? k = x.config.stroke.curve[b[i]] : k = x.config.stroke.curve[i]), e === "rangeArea" && (x.globals.hasNullValues || x.config.forecastDataPoints.count > 0) && k === "monotoneCubic" && (k = "straight"), k === "monotoneCubic") {
      const _ = e === "rangeArea" ? c.length === x.globals.dataPoints : n === t[i].length - 2, $ = c.map((L, E) => [c[E], d[E]]).filter((L) => L[1] !== null);
      if (_ && $.length > 1) {
        const L = qf.points($);
        if (r += vc(L), t[i][0] === null ? h = r : h += vc(L), e === "rangeArea" && O) {
          r += S.line(
            c[c.length - 1],
            p[p.length - 1]
          );
          const E = c.slice().reverse(), A = p.slice().reverse(), y = E.map((T, P) => [E[P], A[P]]), w = qf.points(y);
          r += vc(w), h = r;
        } else
          h += S.line(
            $[$.length - 1][0],
            C
          ) + S.line($[0][0], C) + S.move($[0][0], $[0][1]) + "z";
        u.push(r), g.push(h);
      }
    } else if (k === "smooth") {
      let _ = (o - m) * 0.35;
      x.globals.hasNullValues ? (t[i][n] !== null && (t[i][n + 1] !== null ? (r = S.move(m, v) + S.curve(m + _, v, o - _, l, o + 1, l), h = S.move(m + 1, v) + S.curve(m + _, v, o - _, l, o + 1, l) + S.line(o, C) + S.line(m, C) + "z") : (r = S.move(m, v), h = S.move(m, v) + "z")), u.push(r), g.push(h)) : (r = r + S.curve(m + _, v, o - _, l, o, l), h = h + S.curve(m + _, v, o - _, l, o, l)), m = o, v = l, n === t[i].length - 2 && (h = h + S.curve(m, v, o, l, o, C) + S.move(o, l) + "z", e === "rangeArea" && O ? r = r + S.curve(m, v, o, l, o, f) + S.move(o, f) + "z" : x.globals.hasNullValues || (u.push(r), g.push(h)));
    } else {
      if (t[i][n + 1] === null) {
        r = r + S.move(o, l);
        const _ = x.globals.isXNumeric ? (x.globals.seriesX[s][n] - x.globals.minX) / this.xRatio : o - this.xDivision;
        h = h + S.line(_, C) + S.move(o, l) + "z";
      }
      t[i][n] === null && (r = r + S.move(o, l), h = h + S.move(o, C)), k === "stepline" ? (r = r + S.line(o, null, "H") + S.line(null, l, "V"), h = h + S.line(o, null, "H") + S.line(null, l, "V")) : k === "linestep" ? (r = r + S.line(null, l, "V") + S.line(o, null, "H"), h = h + S.line(null, l, "V") + S.line(o, null, "H")) : k === "straight" && (r = r + S.line(o, l), h = h + S.line(o, l)), n === t[i].length - 2 && (h = h + S.line(o, C) + S.move(o, l) + "z", e === "rangeArea" && O ? r = r + S.line(o, f) + S.move(o, f) + "z" : (u.push(r), g.push(h)));
    }
    return {
      linePaths: u,
      areaPaths: g,
      pX: m,
      pY: v,
      linePath: r,
      areaPath: h
    };
  }
  handleNullDataPoints(e, t, i, s, n) {
    const o = this.w;
    if (e[i][s] === null && o.config.markers.showNullDataPoints || e[i].length === 1) {
      let l = this.markers.plotChartMarkers(
        t,
        n,
        s + 1,
        this.strokeWidth - o.config.markers.strokeWidth / 2,
        !0
      );
      l !== null && this.elPointsMain.add(l);
    }
  }
};
window.TreemapSquared = {};
(function() {
  window.TreemapSquared.generate = function() {
    function a(p, m, v, r) {
      this.xoffset = p, this.yoffset = m, this.height = r, this.width = v, this.shortestEdge = function() {
        return Math.min(this.height, this.width);
      }, this.getCoordinates = function(h) {
        let u = [], g = this.xoffset, b = this.yoffset, O = d(h) / this.height, x = d(h) / this.width, S;
        if (this.width >= this.height)
          for (S = 0; S < h.length; S++)
            u.push([
              g,
              b,
              g + O,
              b + h[S] / O
            ]), b = b + h[S] / O;
        else
          for (S = 0; S < h.length; S++)
            u.push([
              g,
              b,
              g + h[S] / x,
              b + x
            ]), g = g + h[S] / x;
        return u;
      }, this.cutArea = function(h) {
        let u;
        if (this.width >= this.height) {
          let g = h / this.height, b = this.width - g;
          u = new a(
            this.xoffset + g,
            this.yoffset,
            b,
            this.height
          );
        } else {
          let g = h / this.width, b = this.height - g;
          u = new a(
            this.xoffset,
            this.yoffset + g,
            this.width,
            b
          );
        }
        return u;
      };
    }
    function e(p, m) {
      let v = [], r = d(p), h = m / r, u;
      for (u = 0; u < p.length; u++)
        v[u] = p[u] * h;
      return v;
    }
    function t(p, m, v, r, h) {
      r = typeof r > "u" ? 0 : r, h = typeof h > "u" ? 0 : h;
      let u = [], g, b = [], O;
      if (c(p[0])) {
        for (O = 0; O < p.length; O++)
          u[O] = f(p[O]);
        for (g = i(
          u,
          m,
          v,
          r,
          h
        ), O = 0; O < p.length; O++)
          b.push(
            t(
              p[O],
              g[O][2] - g[O][0],
              g[O][3] - g[O][1],
              g[O][0],
              g[O][1]
            )
          );
      } else
        b = i(
          p,
          m,
          v,
          r,
          h
        );
      return b;
    }
    function i(p, m, v, r, h) {
      r = typeof r > "u" ? 0 : r, h = typeof h > "u" ? 0 : h;
      let u = n(
        e(p, m * v),
        [],
        new a(r, h, m, v),
        []
      );
      return s(u);
    }
    function s(p) {
      let m = [], v, r;
      for (v = 0; v < p.length; v++)
        for (r = 0; r < p[v].length; r++)
          m.push(p[v][r]);
      return m;
    }
    function n(p, m, v, r) {
      let h, u, g;
      if (p.length === 0) {
        r.push(v.getCoordinates(m));
        return;
      }
      return h = v.shortestEdge(), u = p[0], o(m, u, h) ? (m.push(u), n(p.slice(1), m, v, r)) : (g = v.cutArea(d(m), r), r.push(v.getCoordinates(m)), n(p, [], g, r)), r;
    }
    function o(p, m, v) {
      let r;
      if (p.length === 0)
        return !0;
      r = p.slice(), r.push(m);
      let h = l(p, v), u = l(r, v);
      return h >= u;
    }
    function l(p, m) {
      let v = Math.min.apply(Math, p), r = Math.max.apply(Math, p), h = d(p);
      return Math.max(
        Math.pow(m, 2) * r / Math.pow(h, 2),
        Math.pow(h, 2) / (Math.pow(m, 2) * v)
      );
    }
    function c(p) {
      return p && p.constructor === Array;
    }
    function d(p) {
      let m = 0, v;
      for (v = 0; v < p.length; v++)
        m += p[v];
      return m;
    }
    function f(p) {
      let m, v = 0;
      if (c(p[0]))
        for (m = 0; m < p.length; m++)
          v += f(p[m]);
      else
        v = d(p);
      return v;
    }
    return t;
  }();
})();
class IL {
  constructor(e, t) {
    this.ctx = e, this.w = e.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new Iv(e), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = [];
  }
  draw(e) {
    let t = this.w;
    const i = new K(this.ctx), s = new _i(this.ctx);
    let n = i.group({
      class: "apexcharts-treemap"
    });
    if (t.globals.noData)
      return n;
    let o = [];
    return e.forEach((c) => {
      let d = c.map((f) => Math.abs(f));
      o.push(d);
    }), this.negRange = this.helpers.checkColorRange(), t.config.series.forEach((c, d) => {
      c.data.forEach((f) => {
        Array.isArray(this.labels[d]) || (this.labels[d] = []), this.labels[d].push(f.x);
      });
    }), window.TreemapSquared.generate(
      o,
      t.globals.gridWidth,
      t.globals.gridHeight
    ).forEach((c, d) => {
      let f = i.group({
        class: "apexcharts-series apexcharts-treemap-series",
        seriesName: N.escapeString(t.globals.seriesNames[d]),
        rel: d + 1,
        "data:realIndex": d
      });
      if (t.config.chart.dropShadow.enabled) {
        const m = t.config.chart.dropShadow;
        new It(this.ctx).dropShadow(n, m, d);
      }
      let p = i.group({
        class: "apexcharts-data-labels"
      });
      c.forEach((m, v) => {
        const r = m[0], h = m[1], u = m[2], g = m[3];
        let b = i.drawRect(
          r,
          h,
          u - r,
          g - h,
          t.config.plotOptions.treemap.borderRadius,
          "#fff",
          1,
          this.strokeWidth,
          t.config.plotOptions.treemap.useFillColorAsStroke ? x : t.globals.stroke.colors[d]
        );
        b.attr({
          cx: r,
          cy: h,
          index: d,
          i: d,
          j: v,
          width: u - r,
          height: g - h
        });
        let O = this.helpers.getShadeColor(
          t.config.chart.type,
          d,
          v,
          this.negRange
        ), x = O.color;
        typeof t.config.series[d].data[v] < "u" && t.config.series[d].data[v].fillColor && (x = t.config.series[d].data[v].fillColor);
        let S = s.fillPath({
          color: x,
          seriesNumber: d,
          dataPointIndex: v
        });
        b.node.classList.add("apexcharts-treemap-rect"), b.attr({
          fill: S
        }), this.helpers.addListeners(b);
        let k = {
          x: r + (u - r) / 2,
          y: h + (g - h) / 2,
          width: 0,
          height: 0
        }, C = {
          x: r,
          y: h,
          width: u - r,
          height: g - h
        };
        if (t.config.chart.animations.enabled && !t.globals.dataChanged) {
          let E = 1;
          t.globals.resized || (E = t.config.chart.animations.speed), this.animateTreemap(b, k, C, E);
        }
        if (t.globals.dataChanged) {
          let E = 1;
          this.dynamicAnim.enabled && t.globals.shouldAnimate && (E = this.dynamicAnim.speed, t.globals.previousPaths[d] && t.globals.previousPaths[d][v] && t.globals.previousPaths[d][v].rect && (k = t.globals.previousPaths[d][v].rect), this.animateTreemap(b, k, C, E));
        }
        let _ = this.getFontSize(m), $ = t.config.dataLabels.formatter(this.labels[d][v], {
          value: t.globals.series[d][v],
          seriesIndex: d,
          dataPointIndex: v,
          w: t
        });
        t.config.plotOptions.treemap.dataLabels.format === "truncate" && (_ = parseInt(t.config.dataLabels.style.fontSize, 10), $ = this.truncateLabels(
          $,
          _,
          r,
          h,
          u,
          g
        ));
        let L = this.helpers.calculateDataLabels({
          text: $,
          x: (r + u) / 2,
          y: (h + g) / 2 + this.strokeWidth / 2 + _ / 3,
          i: d,
          j: v,
          colorProps: O,
          fontSize: _,
          series: e
        });
        t.config.dataLabels.enabled && L && this.rotateToFitLabel(
          L,
          _,
          $,
          r,
          h,
          u,
          g
        ), f.add(b), L !== null && f.add(L);
      }), f.add(p), n.add(f);
    }), n;
  }
  // This calculates a font-size based upon
  // average label length and the size of the box the label is
  // going into. The maximum font size is set in chart config.
  getFontSize(e) {
    const t = this.w;
    function i(l) {
      let c, d = 0;
      if (Array.isArray(l[0]))
        for (c = 0; c < l.length; c++)
          d += i(l[c]);
      else
        for (c = 0; c < l.length; c++)
          d += l[c].length;
      return d;
    }
    function s(l) {
      let c, d = 0;
      if (Array.isArray(l[0]))
        for (c = 0; c < l.length; c++)
          d += s(l[c]);
      else
        for (c = 0; c < l.length; c++)
          d += 1;
      return d;
    }
    let n = i(this.labels) / s(this.labels);
    function o(l, c) {
      let d = l * c, f = Math.pow(d, 0.5);
      return Math.min(
        f / n,
        parseInt(t.config.dataLabels.style.fontSize, 10)
      );
    }
    return o(
      e[2] - e[0],
      e[3] - e[1]
    );
  }
  rotateToFitLabel(e, t, i, s, n, o, l) {
    const c = new K(this.ctx), d = c.getTextRects(i, t);
    if (d.width + this.w.config.stroke.width + 5 > o - s && d.width <= l - n) {
      let f = c.rotateAroundCenter(e.node);
      e.node.setAttribute(
        "transform",
        `rotate(-90 ${f.x} ${f.y}) translate(${d.height / 3})`
      );
    }
  }
  // This is an alternative label formatting method that uses a
  // consistent font size, and trims the edge of long labels
  truncateLabels(e, t, i, s, n, o) {
    const l = new K(this.ctx), d = l.getTextRects(e, t).width + this.w.config.stroke.width + 5 > n - i && o - s > n - i ? o - s : n - i, f = l.getTextBasedOnMaxWidth({
      text: e,
      maxWidth: d,
      fontSize: t
    });
    return e.length !== f.length && d / t < 5 ? "" : f;
  }
  animateTreemap(e, t, i, s) {
    const n = new cr(this.ctx);
    n.animateRect(
      e,
      {
        x: t.x,
        y: t.y,
        width: t.width,
        height: t.height
      },
      {
        x: i.x,
        y: i.y,
        width: i.width,
        height: i.height
      },
      s,
      () => {
        n.animationCompleted(e);
      }
    );
  }
}
const Fv = 24 * 60, vh = Fv * 60, QL = 10 / vh;
class NL {
  constructor(e) {
    this.ctx = e, this.w = e.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC;
  }
  calculateTimeScaleTicks(e, t) {
    let i = this.w;
    if (i.globals.allSeriesCollapsed)
      return i.globals.labels = [], i.globals.timescaleLabels = [], [];
    let s = new Tt(this.ctx);
    const n = (t - e) / (1e3 * vh);
    this.determineInterval(n), i.globals.disableZoomIn = !1, i.globals.disableZoomOut = !1, n < QL ? i.globals.disableZoomIn = !0 : n > 5e4 && (i.globals.disableZoomOut = !0);
    const o = s.getTimeUnitsfromTimestamp(e, t, this.utc), l = i.globals.gridWidth / n, c = l / 24, d = c / 60, f = d / 60;
    let p = Math.floor(n * 24), m = Math.floor(n * Fv), v = Math.floor(n * vh), r = Math.floor(n), h = Math.floor(n / 30), u = Math.floor(n / 365);
    const g = {
      minMillisecond: o.minMillisecond,
      minSecond: o.minSecond,
      minMinute: o.minMinute,
      minHour: o.minHour,
      minDate: o.minDate,
      minMonth: o.minMonth,
      minYear: o.minYear
    };
    let b = g.minMillisecond, O = g.minSecond, x = g.minMinute, S = g.minHour, k = g.minDate, C = g.minDate, _ = g.minMonth, $ = g.minYear;
    const L = {
      firstVal: g,
      currentMillisecond: b,
      currentSecond: O,
      currentMinute: x,
      currentHour: S,
      currentMonthDate: k,
      currentDate: C,
      currentMonth: _,
      currentYear: $,
      daysWidthOnXAxis: l,
      hoursWidthOnXAxis: c,
      minutesWidthOnXAxis: d,
      secondsWidthOnXAxis: f,
      numberOfSeconds: v,
      numberOfMinutes: m,
      numberOfHours: p,
      numberOfDays: r,
      numberOfMonths: h,
      numberOfYears: u
    };
    switch (this.tickInterval) {
      case "years": {
        this.generateYearScale(L);
        break;
      }
      case "months":
      case "half_year": {
        this.generateMonthScale(L);
        break;
      }
      case "months_days":
      case "months_fortnight":
      case "days":
      case "week_days": {
        this.generateDayScale(L);
        break;
      }
      case "hours": {
        this.generateHourScale(L);
        break;
      }
      case "minutes_fives":
      case "minutes":
        this.generateMinuteScale(L);
        break;
      case "seconds_tens":
      case "seconds_fives":
      case "seconds":
        this.generateSecondScale(L);
        break;
    }
    const E = this.timeScaleArray.map((y) => {
      let w = {
        position: y.position,
        unit: y.unit,
        year: y.year,
        day: y.day ? y.day : 1,
        hour: y.hour ? y.hour : 0,
        month: y.month + 1
      };
      return y.unit === "month" ? {
        ...w,
        day: 1,
        value: y.value + 1
      } : y.unit === "day" || y.unit === "hour" ? {
        ...w,
        value: y.value
      } : y.unit === "minute" ? {
        ...w,
        value: y.value,
        minute: y.value
      } : y.unit === "second" ? {
        ...w,
        value: y.value,
        minute: y.minute,
        second: y.second
      } : y;
    });
    return E.filter((y) => {
      let w = 1, T = Math.ceil(i.globals.gridWidth / 120), P = y.value;
      i.config.xaxis.tickAmount !== void 0 && (T = i.config.xaxis.tickAmount), E.length > T && (w = Math.floor(E.length / T));
      let R = !1, Q = !1;
      switch (this.tickInterval) {
        case "years":
          y.unit === "year" && (R = !0);
          break;
        case "half_year":
          w = 7, y.unit === "year" && (R = !0);
          break;
        case "months":
          w = 1, y.unit === "year" && (R = !0);
          break;
        case "months_fortnight":
          w = 15, (y.unit === "year" || y.unit === "month") && (R = !0), P === 30 && (Q = !0);
          break;
        case "months_days":
          w = 10, y.unit === "month" && (R = !0), P === 30 && (Q = !0);
          break;
        case "week_days":
          w = 8, y.unit === "month" && (R = !0);
          break;
        case "days":
          w = 1, y.unit === "month" && (R = !0);
          break;
        case "hours":
          y.unit === "day" && (R = !0);
          break;
        case "minutes_fives":
          P % 5 !== 0 && (Q = !0);
          break;
        case "seconds_tens":
          P % 10 !== 0 && (Q = !0);
          break;
        case "seconds_fives":
          P % 5 !== 0 && (Q = !0);
          break;
      }
      if (this.tickInterval === "hours" || this.tickInterval === "minutes_fives" || this.tickInterval === "seconds_tens" || this.tickInterval === "seconds_fives") {
        if (!Q)
          return !0;
      } else if ((P % w === 0 || R) && !Q)
        return !0;
    });
  }
  recalcDimensionsBasedOnFormat(e, t) {
    const i = this.w, s = this.formatDates(e), n = this.removeOverlappingTS(
      s
    );
    i.globals.timescaleLabels = n.slice(), new Po(this.ctx).plotCoords();
  }
  determineInterval(e) {
    const t = e / 365, i = e * 24, s = i * 60, n = s * 60;
    switch (!0) {
      case t > 5:
        this.tickInterval = "years";
        break;
      case e > 800:
        this.tickInterval = "half_year";
        break;
      case e > 180:
        this.tickInterval = "months";
        break;
      case e > 90:
        this.tickInterval = "months_fortnight";
        break;
      case e > 60:
        this.tickInterval = "months_days";
        break;
      case e > 30:
        this.tickInterval = "week_days";
        break;
      case e > 2:
        this.tickInterval = "days";
        break;
      case i > 2.4:
        this.tickInterval = "hours";
        break;
      case s > 15:
        this.tickInterval = "minutes_fives";
        break;
      case s > 5:
        this.tickInterval = "minutes";
        break;
      case s > 1:
        this.tickInterval = "seconds_tens";
        break;
      case n > 20:
        this.tickInterval = "seconds_fives";
        break;
      default:
        this.tickInterval = "seconds";
        break;
    }
  }
  generateYearScale({
    firstVal: e,
    currentMonth: t,
    currentYear: i,
    daysWidthOnXAxis: s,
    numberOfYears: n
  }) {
    let o = e.minYear, l = 0;
    const c = new Tt(this.ctx);
    let d = "year";
    if (e.minDate > 1 || e.minMonth > 0) {
      let m = c.determineRemainingDaysOfYear(
        e.minYear,
        e.minMonth,
        e.minDate
      );
      l = (c.determineDaysOfYear(e.minYear) - m + 1) * s, o = e.minYear + 1, this.timeScaleArray.push({
        position: l,
        value: o,
        unit: d,
        year: o,
        month: N.monthMod(t + 1)
      });
    } else
      e.minDate === 1 && e.minMonth === 0 && this.timeScaleArray.push({
        position: l,
        value: o,
        unit: d,
        year: i,
        month: N.monthMod(t + 1)
      });
    let f = o, p = l;
    for (let m = 0; m < n; m++)
      f++, p = c.determineDaysOfYear(f - 1) * s + p, this.timeScaleArray.push({
        position: p,
        value: f,
        unit: d,
        year: f,
        month: 1
      });
  }
  generateMonthScale({
    firstVal: e,
    currentMonthDate: t,
    currentMonth: i,
    currentYear: s,
    daysWidthOnXAxis: n,
    numberOfMonths: o
  }) {
    let l = i, c = 0;
    const d = new Tt(this.ctx);
    let f = "month", p = 0;
    if (e.minDate > 1) {
      c = (d.determineDaysOfMonths(i + 1, e.minYear) - t + 1) * n, l = N.monthMod(i + 1);
      let h = s + p, u = N.monthMod(l), g = l;
      l === 0 && (f = "year", g = h, u = 1, p += 1, h = h + p), this.timeScaleArray.push({
        position: c,
        value: g,
        unit: f,
        year: h,
        month: u
      });
    } else
      this.timeScaleArray.push({
        position: c,
        value: l,
        unit: f,
        year: s,
        month: N.monthMod(i)
      });
    let m = l + 1, v = c;
    for (let r = 0, h = 1; r < o; r++, h++) {
      m = N.monthMod(m), m === 0 ? (f = "year", p += 1) : f = "month";
      let u = this._getYear(s, m, p);
      v = d.determineDaysOfMonths(m, u) * n + v;
      let g = m === 0 ? u : m;
      this.timeScaleArray.push({
        position: v,
        value: g,
        unit: f,
        year: u,
        month: m === 0 ? 1 : m
      }), m++;
    }
  }
  generateDayScale({
    firstVal: e,
    currentMonth: t,
    currentYear: i,
    hoursWidthOnXAxis: s,
    numberOfDays: n
  }) {
    const o = new Tt(this.ctx);
    let l = "day", c = e.minDate + 1, d = c;
    const f = (g, b, O) => {
      let x = o.determineDaysOfMonths(b + 1, O);
      return g > x && (b = b + 1, d = 1, l = "month", r = b), b;
    };
    let p = 24 - e.minHour, m = 0, v = p * s, r = c, h = f(d, t, i);
    e.minHour === 0 && e.minDate === 1 ? (v = 0, r = N.monthMod(e.minMonth), l = "month", d = e.minDate) : e.minDate !== 1 && e.minHour === 0 && e.minMinute === 0 && (v = 0, c = e.minDate, d = c, r = c, h = f(d, t, i)), this.timeScaleArray.push({
      position: v,
      value: r,
      unit: l,
      year: this._getYear(i, h, m),
      month: N.monthMod(h),
      day: d
    });
    let u = v;
    for (let g = 0; g < n; g++) {
      d += 1, l = "day", h = f(
        d,
        h,
        this._getYear(i, h, m)
      );
      let b = this._getYear(i, h, m);
      u = 24 * s + u;
      let O = d === 1 ? N.monthMod(h) : d;
      this.timeScaleArray.push({
        position: u,
        value: O,
        unit: l,
        year: b,
        month: N.monthMod(h),
        day: O
      });
    }
  }
  generateHourScale({
    firstVal: e,
    currentDate: t,
    currentMonth: i,
    currentYear: s,
    minutesWidthOnXAxis: n,
    numberOfHours: o
  }) {
    const l = new Tt(this.ctx);
    let c = 0, d = "hour";
    const f = (x, S) => {
      let k = l.determineDaysOfMonths(S + 1, s);
      return x > k && (u = 1, S = S + 1), { month: S, date: u };
    }, p = (x, S) => {
      let k = l.determineDaysOfMonths(S + 1, s);
      return x > k && (S = S + 1), S;
    };
    let m = 60 - (e.minMinute + e.minSecond / 60), v = m * n, r = e.minHour + 1, h = r;
    m === 60 && (v = 0, r = e.minHour, h = r);
    let u = t;
    h >= 24 && (h = 0, u += 1, d = "day");
    let b = f(u, i).month;
    b = p(u, b), this.timeScaleArray.push({
      position: v,
      value: r,
      unit: d,
      day: u,
      hour: h,
      year: s,
      month: N.monthMod(b)
    }), h++;
    let O = v;
    for (let x = 0; x < o; x++) {
      d = "hour", h >= 24 && (h = 0, u += 1, d = "day", b = f(u, b).month, b = p(u, b));
      let S = this._getYear(s, b, c);
      O = 60 * n + O;
      let k = h === 0 ? u : h;
      this.timeScaleArray.push({
        position: O,
        value: k,
        unit: d,
        hour: h,
        day: u,
        year: S,
        month: N.monthMod(b)
      }), h++;
    }
  }
  generateMinuteScale({
    currentMillisecond: e,
    currentSecond: t,
    currentMinute: i,
    currentHour: s,
    currentDate: n,
    currentMonth: o,
    currentYear: l,
    minutesWidthOnXAxis: c,
    secondsWidthOnXAxis: d,
    numberOfMinutes: f
  }) {
    let p = 0, m = "minute", r = (60 - t - e / 1e3) * d, h = i + 1, u = n, g = o, b = l, O = s, x = r;
    for (let S = 0; S < f; S++)
      h >= 60 && (h = 0, O += 1, O === 24 && (O = 0)), this.timeScaleArray.push({
        position: x,
        value: h,
        unit: m,
        hour: O,
        minute: h,
        day: u,
        year: this._getYear(b, g, p),
        month: N.monthMod(g)
      }), x += c, h++;
  }
  generateSecondScale({
    currentMillisecond: e,
    currentSecond: t,
    currentMinute: i,
    currentHour: s,
    currentDate: n,
    currentMonth: o,
    currentYear: l,
    secondsWidthOnXAxis: c,
    numberOfSeconds: d
  }) {
    let f = 0, p = "second", v = (1e3 - e) / 1e3 * c, r = t + 1, h = i, u = n, g = o, b = l, O = s, x = v;
    for (let S = 0; S < d; S++)
      r >= 60 && (h++, r = 0, h >= 60 && (O++, h = 0, O === 24 && (O = 0))), this.timeScaleArray.push({
        position: x,
        value: r,
        unit: p,
        hour: O,
        minute: h,
        second: r,
        day: u,
        year: this._getYear(b, g, f),
        month: N.monthMod(g)
      }), x += c, r++;
  }
  createRawDateString(e, t) {
    let i = e.year;
    return e.month === 0 && (e.month = 1), i += "-" + ("0" + e.month.toString()).slice(-2), e.unit === "day" ? i += e.unit === "day" ? "-" + ("0" + t).slice(-2) : "-01" : i += "-" + ("0" + (e.day ? e.day : "1")).slice(-2), e.unit === "hour" ? i += e.unit === "hour" ? "T" + ("0" + t).slice(-2) : "T00" : i += "T" + ("0" + (e.hour ? e.hour : "0")).slice(-2), e.unit === "minute" ? i += ":" + ("0" + t).slice(-2) : i += ":" + (e.minute ? ("0" + e.minute).slice(-2) : "00"), e.unit === "second" ? i += ":" + ("0" + t).slice(-2) : i += ":00", this.utc && (i += ".000Z"), i;
  }
  formatDates(e) {
    const t = this.w;
    return e.map((s) => {
      let n = s.value.toString(), o = new Tt(this.ctx);
      const l = this.createRawDateString(s, n);
      let c = o.getDate(o.parseDate(l));
      if (this.utc || (c = o.getDate(o.parseDateWithTimezone(l))), t.config.xaxis.labels.format === void 0) {
        let d = "dd MMM";
        const f = t.config.xaxis.labels.datetimeFormatter;
        s.unit === "year" && (d = f.year), s.unit === "month" && (d = f.month), s.unit === "day" && (d = f.day), s.unit === "hour" && (d = f.hour), s.unit === "minute" && (d = f.minute), s.unit === "second" && (d = f.second), n = o.formatDate(c, d);
      } else
        n = o.formatDate(c, t.config.xaxis.labels.format);
      return {
        dateString: l,
        position: s.position,
        value: n,
        unit: s.unit,
        year: s.year,
        month: s.month
      };
    });
  }
  removeOverlappingTS(e) {
    const t = new K(this.ctx);
    let i = !1, s;
    e.length > 0 && // check arr length
    e[0].value && // check arr[0] contains value
    e.every((l) => l.value.length === e[0].value.length) && (i = !0, s = t.getTextRects(e[0].value).width);
    let n = 0, o = e.map((l, c) => {
      if (c > 0 && this.w.config.xaxis.labels.hideOverlappingLabels) {
        const d = i ? s : t.getTextRects(e[n].value).width, f = e[n].position;
        return l.position > f + d + 10 ? (n = c, l) : null;
      } else
        return l;
    });
    return o = o.filter((l) => l !== null), o;
  }
  _getYear(e, t, i) {
    return e + Math.floor(t / 12) + i;
  }
}
class FL {
  constructor(e, t) {
    this.ctx = t, this.w = t.w, this.el = e;
  }
  // get data and store into appropriate vars
  setupElements() {
    let e = this.w.globals, t = this.w.config, i = t.chart.type, s = [
      "line",
      "area",
      "bar",
      "rangeBar",
      "rangeArea",
      "candlestick",
      "boxPlot",
      "scatter",
      "bubble",
      "radar",
      "heatmap",
      "treemap"
    ], n = [
      "line",
      "area",
      "bar",
      "rangeBar",
      "rangeArea",
      "candlestick",
      "boxPlot",
      "scatter",
      "bubble"
    ];
    e.axisCharts = s.indexOf(i) > -1, e.xyCharts = n.indexOf(i) > -1, e.isBarHorizontal = (t.chart.type === "bar" || t.chart.type === "rangeBar" || t.chart.type === "boxPlot") && t.plotOptions.bar.horizontal, e.chartClass = ".apexcharts" + e.chartID, e.dom.baseEl = this.el, e.dom.elWrap = document.createElement("div"), K.setAttrs(e.dom.elWrap, {
      id: e.chartClass.substring(1),
      class: "apexcharts-canvas " + e.chartClass.substring(1)
    }), this.el.appendChild(e.dom.elWrap), e.dom.Paper = new window.SVG.Doc(e.dom.elWrap), e.dom.Paper.attr({
      class: "apexcharts-svg",
      "xmlns:data": "ApexChartsNS",
      transform: `translate(${t.chart.offsetX}, ${t.chart.offsetY})`
    }), e.dom.Paper.node.style.background = t.theme.mode === "dark" && !t.chart.background ? "rgba(0, 0, 0, 0.8)" : t.chart.background, this.setSVGDimensions(), e.dom.elLegendForeign = document.createElementNS(e.SVGNS, "foreignObject"), K.setAttrs(e.dom.elLegendForeign, {
      x: 0,
      y: 0,
      width: e.svgWidth,
      height: e.svgHeight
    }), e.dom.elLegendWrap = document.createElement("div"), e.dom.elLegendWrap.classList.add("apexcharts-legend"), e.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), e.dom.elLegendForeign.appendChild(e.dom.elLegendWrap), e.dom.Paper.node.appendChild(e.dom.elLegendForeign), e.dom.elGraphical = e.dom.Paper.group().attr({
      class: "apexcharts-inner apexcharts-graphical"
    }), e.dom.elDefs = e.dom.Paper.defs(), e.dom.Paper.add(e.dom.elGraphical), e.dom.elGraphical.add(e.dom.elDefs);
  }
  plotChartType(e, t) {
    const i = this.w, s = i.config, n = i.globals;
    let o = {
      series: [],
      i: []
    }, l = {
      series: [],
      i: []
    }, c = {
      series: [],
      i: []
    }, d = {
      series: [],
      i: []
    }, f = {
      series: [],
      i: []
    }, p = {
      series: [],
      i: []
    }, m = {
      series: [],
      i: []
    }, v = {
      series: [],
      i: []
    }, r = {
      series: [],
      seriesRangeEnd: [],
      i: []
    }, h = s.chart.type !== void 0 ? s.chart.type : "line", u = 0;
    n.series.map((k, C) => {
      typeof e[C].type < "u" ? e[C].type === "column" || e[C].type === "bar" ? (n.series.length > 1 && s.plotOptions.bar.horizontal && console.warn(
        "Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"
      ), f.series.push(k), f.i.push(C), h !== "bar" && u++, i.globals.columnSeries = f.series) : e[C].type === "area" ? (l.series.push(k), l.i.push(C), h !== e[C].type && u++) : e[C].type === "line" ? (o.series.push(k), o.i.push(C), h !== e[C].type && u++) : e[C].type === "scatter" ? (c.series.push(k), c.i.push(C)) : e[C].type === "bubble" ? (d.series.push(k), d.i.push(C), h !== e[C].type && u++) : e[C].type === "candlestick" ? (p.series.push(k), p.i.push(C), h !== e[C].type && u++) : e[C].type === "boxPlot" ? (m.series.push(k), m.i.push(C), h !== e[C].type && u++) : e[C].type === "rangeBar" ? (v.series.push(k), v.i.push(C), h !== e[C].type && u++) : e[C].type === "rangeArea" ? (r.series.push(n.seriesRangeStart[C]), r.seriesRangeEnd.push(n.seriesRangeEnd[C]), r.i.push(C), h !== e[C].type && u++) : console.warn(
        "You have specified an unrecognized chart type. Available types for this property are line/area/column/bar/scatter/bubble/candlestick/boxPlot/rangeBar/rangeArea"
      ) : (o.series.push(k), o.i.push(C));
    }), n.comboCharts || (n.comboCharts = u > 0);
    let g = new yc(this.ctx, t), b = new bc(this.ctx, t);
    this.ctx.pie = new Nv(this.ctx);
    let O = new PL(this.ctx);
    this.ctx.rangeBar = new LL(this.ctx, t);
    let x = new EL(this.ctx), S = [];
    if (n.comboCharts) {
      if (l.series.length > 0 && S.push(g.draw(l.series, "area", l.i)), f.series.length > 0)
        if (i.config.chart.stacked) {
          let k = new Zf(this.ctx, t);
          S.push(k.draw(f.series, f.i));
        } else
          this.ctx.bar = new Vn(this.ctx, t), S.push(this.ctx.bar.draw(f.series, f.i));
      if (r.series.length > 0 && S.push(
        g.draw(
          r.series,
          "rangeArea",
          r.i,
          r.seriesRangeEnd
        )
      ), o.series.length > 0 && S.push(g.draw(o.series, "line", o.i)), p.series.length > 0 && S.push(
        b.draw(
          p.series,
          "candlestick",
          p.i
        )
      ), m.series.length > 0 && S.push(
        b.draw(m.series, "boxPlot", m.i)
      ), v.series.length > 0 && S.push(
        this.ctx.rangeBar.draw(v.series, v.i)
      ), c.series.length > 0) {
        const k = new yc(this.ctx, t, !0);
        S.push(
          k.draw(c.series, "scatter", c.i)
        );
      }
      if (d.series.length > 0) {
        const k = new yc(this.ctx, t, !0);
        S.push(
          k.draw(d.series, "bubble", d.i)
        );
      }
    } else
      switch (s.chart.type) {
        case "line":
          S = g.draw(n.series, "line");
          break;
        case "area":
          S = g.draw(n.series, "area");
          break;
        case "bar":
          s.chart.stacked ? S = new Zf(this.ctx, t).draw(n.series) : (this.ctx.bar = new Vn(this.ctx, t), S = this.ctx.bar.draw(n.series));
          break;
        case "candlestick":
          S = new bc(this.ctx, t).draw(n.series, "candlestick");
          break;
        case "boxPlot":
          S = new bc(this.ctx, t).draw(n.series, s.chart.type);
          break;
        case "rangeBar":
          S = this.ctx.rangeBar.draw(n.series);
          break;
        case "rangeArea":
          S = g.draw(
            n.seriesRangeStart,
            "rangeArea",
            void 0,
            n.seriesRangeEnd
          );
          break;
        case "heatmap":
          S = new $L(this.ctx, t).draw(n.series);
          break;
        case "treemap":
          S = new IL(this.ctx, t).draw(n.series);
          break;
        case "pie":
        case "donut":
        case "polarArea":
          S = this.ctx.pie.draw(n.series);
          break;
        case "radialBar":
          S = O.draw(n.series);
          break;
        case "radar":
          S = x.draw(n.series);
          break;
        default:
          S = g.draw(n.series);
      }
    return S;
  }
  setSVGDimensions() {
    let e = this.w.globals, t = this.w.config;
    e.svgWidth = t.chart.width, e.svgHeight = t.chart.height;
    let i = N.getDimensions(this.el), s = t.chart.width.toString().split(/[0-9]+/g).pop();
    s === "%" ? N.isNumber(i[0]) && (i[0].width === 0 && (i = N.getDimensions(this.el.parentNode)), e.svgWidth = i[0] * parseInt(t.chart.width, 10) / 100) : (s === "px" || s === "") && (e.svgWidth = parseInt(t.chart.width, 10));
    let n = t.chart.height.toString().split(/[0-9]+/g).pop();
    if (e.svgHeight !== "auto" && e.svgHeight !== "")
      if (n === "%") {
        let o = N.getDimensions(this.el.parentNode);
        e.svgHeight = o[1] * parseInt(t.chart.height, 10) / 100;
      } else
        e.svgHeight = parseInt(t.chart.height, 10);
    else
      e.axisCharts ? e.svgHeight = e.svgWidth / 1.61 : e.svgHeight = e.svgWidth / 1.2;
    if (e.svgWidth < 0 && (e.svgWidth = 0), e.svgHeight < 0 && (e.svgHeight = 0), K.setAttrs(e.dom.Paper.node, {
      width: e.svgWidth,
      height: e.svgHeight
    }), n !== "%") {
      let o = t.chart.sparkline.enabled ? 0 : e.axisCharts ? t.chart.parentHeightOffset : 0;
      e.dom.Paper.node.parentNode.parentNode.style.minHeight = e.svgHeight + o + "px";
    }
    e.dom.elWrap.style.width = e.svgWidth + "px", e.dom.elWrap.style.height = e.svgHeight + "px";
  }
  shiftGraphPosition() {
    let e = this.w.globals, t = e.translateY, s = {
      transform: "translate(" + e.translateX + ", " + t + ")"
    };
    K.setAttrs(e.dom.elGraphical.node, s);
  }
  // To prevent extra spacings in the bottom of the chart, we need to recalculate the height for pie/donut/radialbar charts
  resizeNonAxisCharts() {
    const e = this.w, t = e.globals;
    let i = 0, s = e.config.chart.sparkline.enabled ? 1 : 15;
    s = s + e.config.grid.padding.bottom, (e.config.legend.position === "top" || e.config.legend.position === "bottom") && e.config.legend.show && !e.config.legend.floating && (i = new Lv(this.ctx).legendHelpers.getLegendBBox().clwh + 10);
    let n = e.globals.dom.baseEl.querySelector(
      ".apexcharts-radialbar, .apexcharts-pie"
    ), o = e.globals.radialSize * 2.05;
    if (n && !e.config.chart.sparkline.enabled && e.config.plotOptions.radialBar.startAngle !== 0) {
      let c = N.getBoundingClientRect(n);
      o = c.bottom;
      let d = c.bottom - c.top;
      o = Math.max(e.globals.radialSize * 2.05, d);
    }
    let l = o + t.translateY + i + s;
    t.dom.elLegendForeign && t.dom.elLegendForeign.setAttribute("height", l), !(e.config.chart.height && String(e.config.chart.height).indexOf("%") > 0) && (t.dom.elWrap.style.height = l + "px", K.setAttrs(t.dom.Paper.node, {
      height: l
    }), t.dom.Paper.node.parentNode.parentNode.style.minHeight = l + "px");
  }
  /*
   ** All the calculations for setting range in charts will be done here
   */
  coreCalculations() {
    new gh(this.ctx).init();
  }
  resetGlobals() {
    const e = () => this.w.config.series.map((s) => []), t = new Tv();
    let i = this.w.globals;
    t.initGlobalVars(i), i.seriesXvalues = e(), i.seriesYvalues = e();
  }
  isMultipleY() {
    if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1)
      return this.w.globals.isMultipleYAxis = !0, !0;
  }
  xySettings() {
    let e = null;
    const t = this.w;
    if (t.globals.axisCharts) {
      if (t.config.xaxis.crosshairs.position === "back" && new mh(this.ctx).drawXCrosshairs(), t.config.yaxis[0].crosshairs.position === "back" && new mh(this.ctx).drawYCrosshairs(), t.config.xaxis.type === "datetime" && t.config.xaxis.labels.formatter === void 0) {
        this.ctx.timeScale = new NL(this.ctx);
        let s = [];
        isFinite(t.globals.minX) && isFinite(t.globals.maxX) && !t.globals.isBarHorizontal ? s = this.ctx.timeScale.calculateTimeScaleTicks(
          t.globals.minX,
          t.globals.maxX
        ) : t.globals.isBarHorizontal && (s = this.ctx.timeScale.calculateTimeScaleTicks(
          t.globals.minY,
          t.globals.maxY
        )), this.ctx.timeScale.recalcDimensionsBasedOnFormat(s);
      }
      e = new vt(this.ctx).getCalculatedRatios();
    }
    return e;
  }
  updateSourceChart(e) {
    this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions(
      {
        chart: {
          selection: {
            xaxis: {
              min: e.w.globals.minX,
              max: e.w.globals.maxX
            }
          }
        }
      },
      !1,
      !1
    );
  }
  setupBrushHandler() {
    const e = this.w;
    if (e.config.chart.brush.enabled && typeof e.config.chart.events.selection != "function") {
      let t = Array.isArray(e.config.chart.brush.targets) ? e.config.chart.brush.targets : [
        e.config.chart.brush.target
      ];
      t.forEach((i) => {
        let s = ApexCharts.getChartByID(i);
        s.w.globals.brushSource = this.ctx, typeof s.w.config.chart.events.zoomed != "function" && (s.w.config.chart.events.zoomed = () => {
          this.updateSourceChart(s);
        }), typeof s.w.config.chart.events.scrolled != "function" && (s.w.config.chart.events.scrolled = () => {
          this.updateSourceChart(s);
        });
      }), e.config.chart.events.selection = (i, s) => {
        t.forEach((n) => {
          ApexCharts.getChartByID(n).ctx.updateHelpers._updateOptions(
            {
              xaxis: {
                min: s.xaxis.min,
                max: s.xaxis.max
              }
            },
            !1,
            !1,
            !1,
            !1
          );
        });
      };
    }
  }
}
class WL {
  constructor(e) {
    this.ctx = e, this.w = e.w;
  }
  /**
   * private method to update Options.
   *
   * @param {object} options - A new config object can be passed which will be merged with the existing config object
   * @param {boolean} redraw - should redraw from beginning or should use existing paths and redraw from there
   * @param {boolean} animate - should animate or not on updating Options
   * @param {boolean} overwriteInitialConfig - should update the initial config or not
   */
  _updateOptions(e, t = !1, i = !0, s = !0, n = !1) {
    return new Promise((o) => {
      let l = [this.ctx];
      s && (l = this.ctx.getSyncedCharts()), this.ctx.w.globals.isExecCalled && (l = [this.ctx], this.ctx.w.globals.isExecCalled = !1), l.forEach((c, d) => {
        let f = c.w;
        if (f.globals.shouldAnimate = i, t || (f.globals.resized = !0, f.globals.dataChanged = !0, i && c.series.getPreviousPaths()), e && typeof e == "object" && (c.config = new Ur(e), e = vt.extendArrayProps(c.config, e, f), c.w.globals.chartID !== this.ctx.w.globals.chartID && delete e.series, f.config = N.extend(f.config, e), n && (f.globals.lastXAxis = e.xaxis ? N.clone(e.xaxis) : [], f.globals.lastYAxis = e.yaxis ? N.clone(e.yaxis) : [], f.globals.initialConfig = N.extend({}, f.config), f.globals.initialSeries = N.clone(f.config.series), e.series))) {
          for (let p = 0; p < f.globals.collapsedSeriesIndices.length; p++) {
            let m = f.config.series[f.globals.collapsedSeriesIndices[p]];
            f.globals.collapsedSeries[p].data = f.globals.axisCharts ? m.data.slice() : m;
          }
          for (let p = 0; p < f.globals.ancillaryCollapsedSeriesIndices.length; p++) {
            let m = f.config.series[f.globals.ancillaryCollapsedSeriesIndices[p]];
            f.globals.ancillaryCollapsedSeries[p].data = f.globals.axisCharts ? m.data.slice() : m;
          }
          c.series.emptyCollapsedSeries(f.config.series);
        }
        return c.update(e).then(() => {
          d === l.length - 1 && o(c);
        });
      });
    });
  }
  /**
   * Private method to update Series.
   *
   * @param {array} series - New series which will override the existing
   */
  _updateSeries(e, t, i = !1) {
    return new Promise((s) => {
      const n = this.w;
      n.globals.shouldAnimate = t, n.globals.dataChanged = !0, t && this.ctx.series.getPreviousPaths();
      let o;
      return n.globals.axisCharts ? (o = e.map((l, c) => this._extendSeries(l, c)), o.length === 0 && (o = [{ data: [] }]), n.config.series = o) : n.config.series = e.slice(), i && (n.globals.initialConfig.series = N.clone(n.config.series), n.globals.initialSeries = N.clone(n.config.series)), this.ctx.update().then(() => {
        s(this.ctx);
      });
    });
  }
  _extendSeries(e, t) {
    const i = this.w, s = i.config.series[t];
    return {
      ...i.config.series[t],
      name: e.name ? e.name : s == null ? void 0 : s.name,
      color: e.color ? e.color : s == null ? void 0 : s.color,
      type: e.type ? e.type : s == null ? void 0 : s.type,
      group: e.group ? e.group : s == null ? void 0 : s.group,
      data: e.data ? e.data : s == null ? void 0 : s.data,
      zIndex: typeof e.zIndex < "u" ? e.zIndex : t
    };
  }
  toggleDataPointSelection(e, t) {
    const i = this.w;
    let s = null;
    const n = `.apexcharts-series[data\\:realIndex='${e}']`;
    if (i.globals.axisCharts ? s = i.globals.dom.Paper.select(
      `${n} path[j='${t}'], ${n} circle[j='${t}'], ${n} rect[j='${t}']`
    ).members[0] : typeof t > "u" && (s = i.globals.dom.Paper.select(
      `${n} path[j='${e}']`
    ).members[0], (i.config.chart.type === "pie" || i.config.chart.type === "polarArea" || i.config.chart.type === "donut") && this.ctx.pie.pieClicked(e)), s)
      new K(this.ctx).pathMouseDown(s, null);
    else
      return console.warn("toggleDataPointSelection: Element not found"), null;
    return s.node ? s.node : null;
  }
  forceXAxisUpdate(e) {
    const t = this.w;
    return ["min", "max"].forEach((s) => {
      typeof e.xaxis[s] < "u" && (t.config.xaxis[s] = e.xaxis[s], t.globals.lastXAxis[s] = e.xaxis[s]);
    }), e.xaxis.categories && e.xaxis.categories.length && (t.config.xaxis.categories = e.xaxis.categories), t.config.xaxis.convertedCatToNumeric && (e = new jr(e).convertCatToNumericXaxis(e, this.ctx)), e;
  }
  forceYAxisUpdate(e) {
    return e.chart && e.chart.stacked && e.chart.stackType === "100%" && (Array.isArray(e.yaxis) ? e.yaxis.forEach((t, i) => {
      e.yaxis[i].min = 0, e.yaxis[i].max = 100;
    }) : (e.yaxis.min = 0, e.yaxis.max = 100)), e;
  }
  /**
   * This function reverts the yaxis and xaxis min/max values to what it was when the chart was defined.
   * This function fixes an important bug where a user might load a new series after zooming in/out of previous series which resulted in wrong min/max
   * Also, this should never be called internally on zoom/pan - the reset should only happen when user calls the updateSeries() function externally
   * The function also accepts an object {xaxis, yaxis} which when present is set as the new xaxis/yaxis
   */
  revertDefaultAxisMinMax(e) {
    const t = this.w;
    let i = t.globals.lastXAxis, s = t.globals.lastYAxis;
    e && e.xaxis && (i = e.xaxis), e && e.yaxis && (s = e.yaxis), t.config.xaxis.min = i.min, t.config.xaxis.max = i.max;
    const n = (o) => {
      typeof s[o] < "u" && (t.config.yaxis[o].min = s[o].min, t.config.yaxis[o].max = s[o].max);
    };
    t.config.yaxis.map((o, l) => {
      t.globals.zoomed || typeof s[l] < "u" ? n(l) : typeof this.ctx.opts.yaxis[l] < "u" && (o.min = this.ctx.opts.yaxis[l].min, o.max = this.ctx.opts.yaxis[l].max);
    });
  }
}
var BL = { exports: {} };
/*!
* svg.js - A lightweight library for manipulating and animating SVG.
* @version 2.6.6
* https://svgdotjs.github.io/
*/
(function(a, e) {
  (function(t, i) {
    a.exports = t.document ? i(t, t.document) : function(s) {
      return i(s, s.document);
    };
  })(typeof window < "u" ? window : kA, function(t, i) {
    var s = typeof this < "u" ? this : t, n = s.SVG = function(y) {
      if (n.supported)
        return y = new n.Doc(y), n.parser.draw || n.prepare(), y;
    };
    if (n.ns = "http://www.w3.org/2000/svg", n.xmlns = "http://www.w3.org/2000/xmlns/", n.xlink = "http://www.w3.org/1999/xlink", n.svgjs = "http://svgjs.dev", n.supported = function() {
      return !0;
    }(), !n.supported)
      return !1;
    n.did = 1e3, n.eid = function(y) {
      return "Svgjs" + h(y) + n.did++;
    }, n.create = function(y) {
      var w = i.createElementNS(this.ns, y);
      return w.setAttribute("id", this.eid(y)), w;
    }, n.extend = function() {
      var y, w;
      y = [].slice.call(arguments), w = y.pop();
      for (var T = y.length - 1; T >= 0; T--)
        if (y[T])
          for (var P in w)
            y[T].prototype[P] = w[P];
      n.Set && n.Set.inherit && n.Set.inherit();
    }, n.invent = function(y) {
      var w = typeof y.create == "function" ? y.create : function() {
        this.constructor.call(this, n.create(y.create));
      };
      return y.inherit && (w.prototype = new y.inherit()), y.extend && n.extend(w, y.extend), y.construct && n.extend(y.parent || n.Container, y.construct), w;
    }, n.adopt = function(y) {
      if (!y)
        return null;
      if (y.instance)
        return y.instance;
      var w;
      return y.nodeName == "svg" ? w = y.parentNode instanceof t.SVGElement ? new n.Nested() : new n.Doc() : y.nodeName == "linearGradient" ? w = new n.Gradient("linear") : y.nodeName == "radialGradient" ? w = new n.Gradient("radial") : n[h(y.nodeName)] ? w = new n[h(y.nodeName)]() : w = new n.Element(y), w.type = y.nodeName, w.node = y, y.instance = w, w instanceof n.Doc && w.namespace().defs(), w.setData(JSON.parse(y.getAttribute("svgjs:data")) || {}), w;
    }, n.prepare = function() {
      var y = i.getElementsByTagName("body")[0], w = (y ? new n.Doc(y) : n.adopt(i.documentElement).nested()).size(2, 0);
      n.parser = {
        body: y || i.documentElement,
        draw: w.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node,
        poly: w.polyline().node,
        path: w.path().node,
        native: n.create("svg")
      };
    }, n.parser = {
      native: n.create("svg")
    }, i.addEventListener("DOMContentLoaded", function() {
      n.parser.draw || n.prepare();
    }, !1), n.regex = {
      // Parse unit value
      numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i,
      // Parse hex value
      hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
      // Parse rgb value
      rgb: /rgb\((\d+),(\d+),(\d+)\)/,
      // Parse reference id
      reference: /#([a-z0-9\-_]+)/i,
      // splits a transformation chain
      transforms: /\)\s*,?\s*/,
      // Whitespace
      whitespace: /\s/g,
      // Test hex value
      isHex: /^#[a-f0-9]{3,6}$/i,
      // Test rgb value
      isRgb: /^rgb\(/,
      // Test css declaration
      isCss: /[^:]+:[^;]+;?/,
      // Test for blank string
      isBlank: /^(\s+)?$/,
      // Test for numeric string
      isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
      // Test for percent value
      isPercent: /^-?[\d\.]+%$/,
      // Test for image url
      isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i,
      // split at whitespace and comma
      delimiter: /[\s,]+/,
      // The following regex are used to parse the d attribute of a path
      // Matches all hyphens which are not after an exponent
      hyphen: /([^e])\-/gi,
      // Replaces and tests for all path letters
      pathLetters: /[MLHVCSQTAZ]/gi,
      // yes we need this one, too
      isPathLetter: /[MLHVCSQTAZ]/i,
      // matches 0.154.23.45
      numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi,
      // matches .
      dots: /\./g
    }, n.utils = {
      // Map function
      map: function(y, w) {
        for (var T = y.length, P = [], R = 0; R < T; R++)
          P.push(w(y[R]));
        return P;
      },
      // Filter function
      filter: function(y, w) {
        for (var T = y.length, P = [], R = 0; R < T; R++)
          w(y[R]) && P.push(y[R]);
        return P;
      },
      filterSVGElements: function(y) {
        return this.filter(y, function(w) {
          return w instanceof t.SVGElement;
        });
      }
    }, n.defaults = {
      // Default attribute values
      attrs: {
        // fill and stroke
        "fill-opacity": 1,
        "stroke-opacity": 1,
        "stroke-width": 0,
        "stroke-linejoin": "miter",
        "stroke-linecap": "butt",
        fill: "#000000",
        stroke: "#000000",
        opacity: 1,
        // position
        x: 0,
        y: 0,
        cx: 0,
        cy: 0,
        // size
        width: 0,
        height: 0,
        // radius
        r: 0,
        rx: 0,
        ry: 0,
        // gradient
        offset: 0,
        "stop-opacity": 1,
        "stop-color": "#000000",
        // text
        "font-size": 16,
        "font-family": "Helvetica, Arial, sans-serif",
        "text-anchor": "start"
      }
    }, n.Color = function(y) {
      var w;
      this.r = 0, this.g = 0, this.b = 0, y && (typeof y == "string" ? n.regex.isRgb.test(y) ? (w = n.regex.rgb.exec(y.replace(n.regex.whitespace, "")), this.r = parseInt(w[1]), this.g = parseInt(w[2]), this.b = parseInt(w[3])) : n.regex.isHex.test(y) && (w = n.regex.hex.exec(u(y)), this.r = parseInt(w[1], 16), this.g = parseInt(w[2], 16), this.b = parseInt(w[3], 16)) : typeof y == "object" && (this.r = y.r, this.g = y.g, this.b = y.b));
    }, n.extend(n.Color, {
      // Default to hex conversion
      toString: function() {
        return this.toHex();
      },
      // Build hex value
      toHex: function() {
        return "#" + g(this.r) + g(this.g) + g(this.b);
      },
      // Build rgb value
      toRgb: function() {
        return "rgb(" + [this.r, this.g, this.b].join() + ")";
      },
      // Calculate true brightness
      brightness: function() {
        return this.r / 255 * 0.3 + this.g / 255 * 0.59 + this.b / 255 * 0.11;
      },
      // Make color morphable
      morph: function(y) {
        return this.destination = new n.Color(y), this;
      },
      // Get morphed color at given position
      at: function(y) {
        return this.destination ? (y = y < 0 ? 0 : y > 1 ? 1 : y, new n.Color({
          r: ~~(this.r + (this.destination.r - this.r) * y),
          g: ~~(this.g + (this.destination.g - this.g) * y),
          b: ~~(this.b + (this.destination.b - this.b) * y)
        })) : this;
      }
    }), n.Color.test = function(y) {
      return y += "", n.regex.isHex.test(y) || n.regex.isRgb.test(y);
    }, n.Color.isRgb = function(y) {
      return y && typeof y.r == "number" && typeof y.g == "number" && typeof y.b == "number";
    }, n.Color.isColor = function(y) {
      return n.Color.isRgb(y) || n.Color.test(y);
    }, n.Array = function(y, w) {
      y = (y || []).valueOf(), y.length == 0 && w && (y = w.valueOf()), this.value = this.parse(y);
    }, n.extend(n.Array, {
      // Convert array to string
      toString: function() {
        return this.value.join(" ");
      },
      // Real value
      valueOf: function() {
        return this.value;
      },
      // Parse whitespace separated string
      parse: function(y) {
        return y = y.valueOf(), Array.isArray(y) ? y : this.split(y);
      }
    }), n.PointArray = function(y, w) {
      n.Array.call(this, y, w || [[0, 0]]);
    }, n.PointArray.prototype = new n.Array(), n.PointArray.prototype.constructor = n.PointArray;
    for (var o = {
      M: function(y, w, T) {
        return w.x = T.x = y[0], w.y = T.y = y[1], ["M", w.x, w.y];
      },
      L: function(y, w) {
        return w.x = y[0], w.y = y[1], ["L", y[0], y[1]];
      },
      H: function(y, w) {
        return w.x = y[0], ["H", y[0]];
      },
      V: function(y, w) {
        return w.y = y[0], ["V", y[0]];
      },
      C: function(y, w) {
        return w.x = y[4], w.y = y[5], ["C", y[0], y[1], y[2], y[3], y[4], y[5]];
      },
      Q: function(y, w) {
        return w.x = y[2], w.y = y[3], ["Q", y[0], y[1], y[2], y[3]];
      },
      S: function(y, w) {
        return w.x = y[2], w.y = y[3], ["S", y[0], y[1], y[2], y[3]];
      },
      Z: function(y, w, T) {
        return w.x = T.x, w.y = T.y, ["Z"];
      }
    }, l = "mlhvqtcsaz".split(""), c = 0, d = l.length; c < d; ++c)
      o[l[c]] = function(y) {
        return function(w, T, P) {
          if (y == "H")
            w[0] = w[0] + T.x;
          else if (y == "V")
            w[0] = w[0] + T.y;
          else if (y == "A")
            w[5] = w[5] + T.x, w[6] = w[6] + T.y;
          else
            for (var R = 0, Q = w.length; R < Q; ++R)
              w[R] = w[R] + (R % 2 ? T.y : T.x);
          if (o && typeof o[y] == "function")
            return o[y](w, T, P);
        };
      }(l[c].toUpperCase());
    n.PathArray = function(y, w) {
      n.Array.call(this, y, w || [["M", 0, 0]]);
    }, n.PathArray.prototype = new n.Array(), n.PathArray.prototype.constructor = n.PathArray, n.extend(n.PathArray, {
      // Convert array to string
      toString: function() {
        return k(this.value);
      },
      // Move path string
      move: function(y, w) {
        var T = this.bbox();
        return y -= T.x, w -= T.y, this;
      },
      // Get morphed path array at given position
      at: function(y) {
        if (!this.destination)
          return this;
        for (var w = this.value, T = this.destination.value, P = [], R = new n.PathArray(), Q, z, W = 0, Q = w.length; W < Q; W++) {
          P[W] = [w[W][0]];
          for (var G = 1, z = w[W].length; G < z; G++)
            P[W][G] = w[W][G] + (T[W][G] - w[W][G]) * y;
          P[W][0] === "A" && (P[W][4] = +(P[W][4] != 0), P[W][5] = +(P[W][5] != 0));
        }
        return R.value = P, R;
      },
      // Absolutize and parse path to array
      parse: function(y) {
        if (y instanceof n.PathArray)
          return y.valueOf();
        var w, P, T = { M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0 };
        typeof y == "string" ? y = y.replace(n.regex.numbersWithDots, p).replace(n.regex.pathLetters, " $& ").replace(n.regex.hyphen, "$1 -").trim().split(n.regex.delimiter) : y = y.reduce(function(G, de) {
          return [].concat.call(G, de);
        }, []);
        var P = [], R = new n.Point(), Q = new n.Point(), z = 0, W = y.length;
        do
          n.regex.isPathLetter.test(y[z]) ? (w = y[z], ++z) : w == "M" ? w = "L" : w == "m" && (w = "l"), P.push(
            o[w].call(
              null,
              y.slice(z, z = z + T[w.toUpperCase()]).map(parseFloat),
              R,
              Q
            )
          );
        while (W > z);
        return P;
      },
      // Get bounding box of path
      bbox: function() {
        return n.parser.draw || n.prepare(), n.parser.path.setAttribute("d", this.toString()), n.parser.path.getBBox();
      }
    }), n.Number = n.invent({
      // Initialize
      create: function(y, w) {
        this.value = 0, this.unit = w || "", typeof y == "number" ? this.value = isNaN(y) ? 0 : isFinite(y) ? y : y < 0 ? -34e37 : 34e37 : typeof y == "string" ? (w = y.match(n.regex.numberAndUnit), w && (this.value = parseFloat(w[1]), w[5] == "%" ? this.value /= 100 : w[5] == "s" && (this.value *= 1e3), this.unit = w[5])) : y instanceof n.Number && (this.value = y.valueOf(), this.unit = y.unit);
      },
      // Add methods
      extend: {
        // Stringalize
        toString: function() {
          return (this.unit == "%" ? ~~(this.value * 1e8) / 1e6 : this.unit == "s" ? this.value / 1e3 : this.value) + this.unit;
        },
        toJSON: function() {
          return this.toString();
        },
        // Convert to primitive
        valueOf: function() {
          return this.value;
        },
        // Add number
        plus: function(y) {
          return y = new n.Number(y), new n.Number(this + y, this.unit || y.unit);
        },
        // Subtract number
        minus: function(y) {
          return y = new n.Number(y), new n.Number(this - y, this.unit || y.unit);
        },
        // Multiply number
        times: function(y) {
          return y = new n.Number(y), new n.Number(this * y, this.unit || y.unit);
        },
        // Divide number
        divide: function(y) {
          return y = new n.Number(y), new n.Number(this / y, this.unit || y.unit);
        },
        // Convert to different unit
        to: function(y) {
          var w = new n.Number(this);
          return typeof y == "string" && (w.unit = y), w;
        },
        // Make number morphable
        morph: function(y) {
          return this.destination = new n.Number(y), y.relative && (this.destination.value += this.value), this;
        },
        // Get morphed number at given position
        at: function(y) {
          return this.destination ? new n.Number(this.destination).minus(this).times(y).plus(this) : this;
        }
      }
    }), n.Element = n.invent({
      // Initialize node
      create: function(y) {
        this._stroke = n.defaults.attrs.stroke, this._event = null, this.dom = {}, (this.node = y) && (this.type = y.nodeName, this.node.instance = this, this._stroke = y.getAttribute("stroke") || this._stroke);
      },
      // Add class methods
      extend: {
        // Move over x-axis
        x: function(y) {
          return this.attr("x", y);
        },
        // Move over y-axis
        y: function(y) {
          return this.attr("y", y);
        },
        // Move by center over x-axis
        cx: function(y) {
          return y == null ? this.x() + this.width() / 2 : this.x(y - this.width() / 2);
        },
        // Move by center over y-axis
        cy: function(y) {
          return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2);
        },
        // Move element to given x and y values
        move: function(y, w) {
          return this.x(y).y(w);
        },
        // Move element by its center
        center: function(y, w) {
          return this.cx(y).cy(w);
        },
        // Set width of element
        width: function(y) {
          return this.attr("width", y);
        },
        // Set height of element
        height: function(y) {
          return this.attr("height", y);
        },
        // Set element size to given width and height
        size: function(y, w) {
          var T = b(this, y, w);
          return this.width(new n.Number(T.width)).height(new n.Number(T.height));
        },
        // Clone element
        clone: function(y) {
          this.writeDataToDom();
          var w = C(this.node.cloneNode(!0));
          return y ? y.add(w) : this.after(w), w;
        },
        // Remove element
        remove: function() {
          return this.parent() && this.parent().removeElement(this), this;
        },
        // Replace element
        replace: function(y) {
          return this.after(y).remove(), y;
        },
        // Add element to given container and return self
        addTo: function(y) {
          return y.put(this);
        },
        // Add element to given container and return container
        putIn: function(y) {
          return y.add(this);
        },
        // Get / set id
        id: function(y) {
          return this.attr("id", y);
        },
        // Show element
        show: function() {
          return this.style("display", "");
        },
        // Hide element
        hide: function() {
          return this.style("display", "none");
        },
        // Is element visible?
        visible: function() {
          return this.style("display") != "none";
        },
        // Return id on string conversion
        toString: function() {
          return this.attr("id");
        },
        // Return array of classes on the node
        classes: function() {
          var y = this.attr("class");
          return y == null ? [] : y.trim().split(n.regex.delimiter);
        },
        // Return true if class exists on the node, false otherwise
        hasClass: function(y) {
          return this.classes().indexOf(y) != -1;
        },
        // Add class to the node
        addClass: function(y) {
          if (!this.hasClass(y)) {
            var w = this.classes();
            w.push(y), this.attr("class", w.join(" "));
          }
          return this;
        },
        // Remove class from the node
        removeClass: function(y) {
          return this.hasClass(y) && this.attr("class", this.classes().filter(function(w) {
            return w != y;
          }).join(" ")), this;
        },
        // Toggle the presence of a class on the node
        toggleClass: function(y) {
          return this.hasClass(y) ? this.removeClass(y) : this.addClass(y);
        },
        // Get referenced element form attribute value
        reference: function(y) {
          return n.get(this.attr(y));
        },
        // Returns the parent element instance
        parent: function(y) {
          var w = this;
          if (!w.node.parentNode)
            return null;
          if (w = n.adopt(w.node.parentNode), !y)
            return w;
          for (; w && w.node instanceof t.SVGElement; ) {
            if (typeof y == "string" ? w.matches(y) : w instanceof y)
              return w;
            if (!w.node.parentNode || w.node.parentNode.nodeName == "#document")
              return null;
            w = n.adopt(w.node.parentNode);
          }
        },
        // Get parent document
        doc: function() {
          return this instanceof n.Doc ? this : this.parent(n.Doc);
        },
        // return array of all ancestors of given type up to the root svg
        parents: function(y) {
          var w = [], T = this;
          do {
            if (T = T.parent(y), !T || !T.node)
              break;
            w.push(T);
          } while (T.parent);
          return w;
        },
        // matches the element vs a css selector
        matches: function(y) {
          return v(this.node, y);
        },
        // Returns the svg node to call native svg methods on it
        native: function() {
          return this.node;
        },
        // Import raw svg
        svg: function(y) {
          var w = i.createElement("svg");
          if (y && this instanceof n.Parent) {
            w.innerHTML = "<svg>" + y.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
            for (var T = 0, P = w.firstChild.childNodes.length; T < P; T++)
              this.node.appendChild(w.firstChild.firstChild);
          } else
            return w.appendChild(y = i.createElement("svg")), this.writeDataToDom(), y.appendChild(this.node.cloneNode(!0)), w.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "");
          return this;
        },
        // write svgjs data to the dom
        writeDataToDom: function() {
          if (this.each || this.lines) {
            var y = this.each ? this : this.lines();
            y.each(function() {
              this.writeDataToDom();
            });
          }
          return this.node.removeAttribute("svgjs:data"), Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)), this;
        },
        // set given data to the elements data property
        setData: function(y) {
          return this.dom = y, this;
        },
        is: function(y) {
          return m(this, y);
        }
      }
    }), n.easing = {
      "-": function(y) {
        return y;
      },
      "<>": function(y) {
        return -Math.cos(y * Math.PI) / 2 + 0.5;
      },
      ">": function(y) {
        return Math.sin(y * Math.PI / 2);
      },
      "<": function(y) {
        return -Math.cos(y * Math.PI / 2) + 1;
      }
    }, n.morph = function(y) {
      return function(w, T) {
        return new n.MorphObj(w, T).at(y);
      };
    }, n.Situation = n.invent({
      create: function(y) {
        this.init = !1, this.reversed = !1, this.reversing = !1, this.duration = new n.Number(y.duration).valueOf(), this.delay = new n.Number(y.delay).valueOf(), this.start = +/* @__PURE__ */ new Date() + this.delay, this.finish = this.start + this.duration, this.ease = y.ease, this.loop = 0, this.loops = !1, this.animations = {
          // functionToCall: [list of morphable objects]
          // e.g. move: [SVG.Number, SVG.Number]
        }, this.attrs = {
          // holds all attributes which are not represented from a function svg.js provides
          // e.g. someAttr: SVG.Number
        }, this.styles = {
          // holds all styles which should be animated
          // e.g. fill-color: SVG.Color
        }, this.transforms = [
          // holds all transformations as transformation objects
          // e.g. [SVG.Rotate, SVG.Translate, SVG.Matrix]
        ], this.once = {
          // functions to fire at a specific position
          // e.g. "0.5": function foo(){}
        };
      }
    }), n.FX = n.invent({
      create: function(y) {
        this._target = y, this.situations = [], this.active = !1, this.situation = null, this.paused = !1, this.lastPos = 0, this.pos = 0, this.absPos = 0, this._speed = 1;
      },
      extend: {
        /**
         * sets or returns the target of this animation
         * @param o object || number In case of Object it holds all parameters. In case of number its the duration of the animation
         * @param ease function || string Function which should be used for easing or easing keyword
         * @param delay Number indicating the delay before the animation starts
         * @return target || this
         */
        animate: function(y, w, T) {
          typeof y == "object" && (w = y.ease, T = y.delay, y = y.duration);
          var P = new n.Situation({
            duration: y || 1e3,
            delay: T || 0,
            ease: n.easing[w || "-"] || w
          });
          return this.queue(P), this;
        },
        /**
        * sets a delay before the next element of the queue is called
        * @param delay Duration of delay in milliseconds
        * @return this.target()
        */
        /**
        * sets or returns the target of this animation
        * @param null || target SVG.Element which should be set as new target
        * @return target || this
        */
        target: function(y) {
          return y && y instanceof n.Element ? (this._target = y, this) : this._target;
        },
        // returns the absolute position at a given time
        timeToAbsPos: function(y) {
          return (y - this.situation.start) / (this.situation.duration / this._speed);
        },
        // returns the timestamp from a given absolute positon
        absPosToTime: function(y) {
          return this.situation.duration / this._speed * y + this.situation.start;
        },
        // starts the animationloop
        startAnimFrame: function() {
          this.stopAnimFrame(), this.animationFrame = t.requestAnimationFrame((function() {
            this.step();
          }).bind(this));
        },
        // cancels the animationframe
        stopAnimFrame: function() {
          t.cancelAnimationFrame(this.animationFrame);
        },
        // kicks off the animation - only does something when the queue is currently not active and at least one situation is set
        start: function() {
          return !this.active && this.situation && (this.active = !0, this.startCurrent()), this;
        },
        // start the current situation
        startCurrent: function() {
          return this.situation.start = +/* @__PURE__ */ new Date() + this.situation.delay / this._speed, this.situation.finish = this.situation.start + this.situation.duration / this._speed, this.initAnimations().step();
        },
        /**
        * adds a function / Situation to the animation queue
        * @param fn function / situation to add
        * @return this
        */
        queue: function(y) {
          return (typeof y == "function" || y instanceof n.Situation) && this.situations.push(y), this.situation || (this.situation = this.situations.shift()), this;
        },
        /**
        * pulls next element from the queue and execute it
        * @return this
        */
        dequeue: function() {
          return this.stop(), this.situation = this.situations.shift(), this.situation && (this.situation instanceof n.Situation ? this.start() : this.situation.call(this)), this;
        },
        // updates all animations to the current state of the element
        // this is important when one property could be changed from another property
        initAnimations: function() {
          var y, w = this.situation;
          if (w.init)
            return this;
          for (var T in w.animations) {
            y = this.target()[T](), Array.isArray(y) || (y = [y]), Array.isArray(w.animations[T]) || (w.animations[T] = [w.animations[T]]);
            for (var P = y.length; P--; )
              w.animations[T][P] instanceof n.Number && (y[P] = new n.Number(y[P])), w.animations[T][P] = y[P].morph(w.animations[T][P]);
          }
          for (var T in w.attrs)
            w.attrs[T] = new n.MorphObj(this.target().attr(T), w.attrs[T]);
          for (var T in w.styles)
            w.styles[T] = new n.MorphObj(this.target().style(T), w.styles[T]);
          return w.initialTransformation = this.target().matrixify(), w.init = !0, this;
        },
        clearQueue: function() {
          return this.situations = [], this;
        },
        clearCurrent: function() {
          return this.situation = null, this;
        },
        /** stops the animation immediately
        * @param jumpToEnd A Boolean indicating whether to complete the current animation immediately.
        * @param clearQueue A Boolean indicating whether to remove queued animation as well.
        * @return this
        */
        stop: function(y, w) {
          var T = this.active;
          return this.active = !1, w && this.clearQueue(), y && this.situation && (!T && this.startCurrent(), this.atEnd()), this.stopAnimFrame(), this.clearCurrent();
        },
        after: function(y) {
          var w = this.last(), T = function P(R) {
            R.detail.situation == w && (y.call(this, w), this.off("finished.fx", P));
          };
          return this.target().on("finished.fx", T), this._callStart();
        },
        // adds a callback which is called whenever one animation step is performed
        during: function(y) {
          var w = this.last(), T = function(P) {
            P.detail.situation == w && y.call(this, P.detail.pos, n.morph(P.detail.pos), P.detail.eased, w);
          };
          return this.target().off("during.fx", T).on("during.fx", T), this.after(function() {
            this.off("during.fx", T);
          }), this._callStart();
        },
        // calls after ALL animations in the queue are finished
        afterAll: function(y) {
          var w = function T(P) {
            y.call(this), this.off("allfinished.fx", T);
          };
          return this.target().off("allfinished.fx", w).on("allfinished.fx", w), this._callStart();
        },
        last: function() {
          return this.situations.length ? this.situations[this.situations.length - 1] : this.situation;
        },
        // adds one property to the animations
        add: function(y, w, T) {
          return this.last()[T || "animations"][y] = w, this._callStart();
        },
        /** perform one step of the animation
        *  @param ignoreTime Boolean indicating whether to ignore time and use position directly or recalculate position based on time
        *  @return this
        */
        step: function(y) {
          if (y || (this.absPos = this.timeToAbsPos(+/* @__PURE__ */ new Date())), this.situation.loops !== !1) {
            var w, T, P;
            w = Math.max(this.absPos, 0), T = Math.floor(w), this.situation.loops === !0 || T < this.situation.loops ? (this.pos = w - T, P = this.situation.loop, this.situation.loop = T) : (this.absPos = this.situation.loops, this.pos = 1, P = this.situation.loop - 1, this.situation.loop = this.situation.loops), this.situation.reversing && (this.situation.reversed = this.situation.reversed != !!((this.situation.loop - P) % 2));
          } else
            this.absPos = Math.min(this.absPos, 1), this.pos = this.absPos;
          this.pos < 0 && (this.pos = 0), this.situation.reversed && (this.pos = 1 - this.pos);
          var R = this.situation.ease(this.pos);
          for (var Q in this.situation.once)
            Q > this.lastPos && Q <= R && (this.situation.once[Q].call(this.target(), this.pos, R), delete this.situation.once[Q]);
          return this.active && this.target().fire("during", { pos: this.pos, eased: R, fx: this, situation: this.situation }), this.situation ? (this.eachAt(), this.pos == 1 && !this.situation.reversed || this.situation.reversed && this.pos == 0 ? (this.stopAnimFrame(), this.target().fire("finished", { fx: this, situation: this.situation }), this.situations.length || (this.target().fire("allfinished"), this.situations.length || (this.target().off(".fx"), this.active = !1)), this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(), this.lastPos = R, this) : this;
        },
        // calculates the step for every property and calls block with it
        eachAt: function() {
          var y, w, T = this, P = this.target(), R = this.situation;
          for (var Q in R.animations)
            w = [].concat(R.animations[Q]).map(function(W) {
              return typeof W != "string" && W.at ? W.at(R.ease(T.pos), T.pos) : W;
            }), P[Q].apply(P, w);
          for (var Q in R.attrs)
            w = [Q].concat(R.attrs[Q]).map(function(G) {
              return typeof G != "string" && G.at ? G.at(R.ease(T.pos), T.pos) : G;
            }), P.attr.apply(P, w);
          for (var Q in R.styles)
            w = [Q].concat(R.styles[Q]).map(function(G) {
              return typeof G != "string" && G.at ? G.at(R.ease(T.pos), T.pos) : G;
            }), P.style.apply(P, w);
          if (R.transforms.length) {
            w = R.initialTransformation;
            for (var Q = 0, y = R.transforms.length; Q < y; Q++) {
              var z = R.transforms[Q];
              if (z instanceof n.Matrix) {
                z.relative ? w = w.multiply(new n.Matrix().morph(z).at(R.ease(this.pos))) : w = w.morph(z).at(R.ease(this.pos));
                continue;
              }
              z.relative || z.undo(w.extract()), w = w.multiply(z.at(R.ease(this.pos)));
            }
            P.matrix(w);
          }
          return this;
        },
        // adds an once-callback which is called at a specific position and never again
        once: function(y, w, T) {
          var P = this.last();
          return T || (y = P.ease(y)), P.once[y] = w, this;
        },
        _callStart: function() {
          return setTimeout((function() {
            this.start();
          }).bind(this), 0), this;
        }
      },
      parent: n.Element,
      // Add method to parent elements
      construct: {
        // Get fx module or create a new one, then animate with given duration and ease
        animate: function(y, w, T) {
          return (this.fx || (this.fx = new n.FX(this))).animate(y, w, T);
        },
        delay: function(y) {
          return (this.fx || (this.fx = new n.FX(this))).delay(y);
        },
        stop: function(y, w) {
          return this.fx && this.fx.stop(y, w), this;
        },
        finish: function() {
          return this.fx && this.fx.finish(), this;
        }
      }
    }), n.MorphObj = n.invent({
      create: function(y, w) {
        if (n.Color.isColor(w))
          return new n.Color(y).morph(w);
        if (n.regex.delimiter.test(y))
          return n.regex.pathLetters.test(y) ? new n.PathArray(y).morph(w) : new n.Array(y).morph(w);
        if (n.regex.numberAndUnit.test(w))
          return new n.Number(y).morph(w);
        this.value = y, this.destination = w;
      },
      extend: {
        at: function(y, w) {
          return w < 1 ? this.value : this.destination;
        },
        valueOf: function() {
          return this.value;
        }
      }
    }), n.extend(n.FX, {
      // Add animatable attributes
      attr: function(y, w, T) {
        if (typeof y == "object")
          for (var P in y)
            this.attr(P, y[P]);
        else
          this.add(y, w, "attrs");
        return this;
      },
      // Add animatable plot
      plot: function(y, w, T, P) {
        return arguments.length == 4 ? this.plot([y, w, T, P]) : this.add("plot", new (this.target()).morphArray(y));
      }
    }), n.Box = n.invent({
      create: function(y, w, T, P) {
        if (typeof y == "object" && !(y instanceof n.Element))
          return n.Box.call(this, y.left != null ? y.left : y.x, y.top != null ? y.top : y.y, y.width, y.height);
        arguments.length == 4 && (this.x = y, this.y = w, this.width = T, this.height = P), _(this);
      }
    }), n.BBox = n.invent({
      // Initialize
      create: function(y) {
        if (n.Box.apply(this, [].slice.call(arguments)), y instanceof n.Element) {
          var w;
          try {
            if (!i.documentElement.contains) {
              for (var T = y.node; T.parentNode; )
                T = T.parentNode;
              if (T != i)
                throw new Error("Element not in the dom");
            }
            w = y.node.getBBox();
          } catch {
            if (y instanceof n.Shape) {
              n.parser.draw || n.prepare();
              var P = y.clone(n.parser.draw.instance).show();
              P && P.node && typeof P.node.getBBox == "function" && (w = P.node.getBBox()), P && typeof P.remove == "function" && P.remove();
            } else
              w = {
                x: y.node.clientLeft,
                y: y.node.clientTop,
                width: y.node.clientWidth,
                height: y.node.clientHeight
              };
          }
          n.Box.call(this, w);
        }
      },
      // Define ancestor
      inherit: n.Box,
      // Define Parent
      parent: n.Element,
      // Constructor
      construct: {
        // Get bounding box
        bbox: function() {
          return new n.BBox(this);
        }
      }
    }), n.BBox.prototype.constructor = n.BBox, n.Matrix = n.invent({
      // Initialize
      create: function(y) {
        var w = x([1, 0, 0, 1, 0, 0]);
        y = y === null ? w : y instanceof n.Element ? y.matrixify() : typeof y == "string" ? x(y.split(n.regex.delimiter).map(parseFloat)) : arguments.length == 6 ? x([].slice.call(arguments)) : Array.isArray(y) ? x(y) : y && typeof y == "object" ? y : w;
        for (var T = E.length - 1; T >= 0; --T)
          this[E[T]] = y[E[T]] != null ? y[E[T]] : w[E[T]];
      },
      // Add methods
      extend: {
        // Extract individual transformations
        extract: function() {
          var y = O(this, 0, 1);
          O(this, 1, 0);
          var w = 180 / Math.PI * Math.atan2(y.y, y.x) - 90;
          return {
            // translation
            x: this.e,
            y: this.f,
            transformedX: (this.e * Math.cos(w * Math.PI / 180) + this.f * Math.sin(w * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b),
            transformedY: (this.f * Math.cos(w * Math.PI / 180) + this.e * Math.sin(-w * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d),
            // rotation
            rotation: w,
            a: this.a,
            b: this.b,
            c: this.c,
            d: this.d,
            e: this.e,
            f: this.f,
            matrix: new n.Matrix(this)
          };
        },
        // Clone matrix
        clone: function() {
          return new n.Matrix(this);
        },
        // Morph one matrix into another
        morph: function(y) {
          return this.destination = new n.Matrix(y), this;
        },
        // Multiplies by given matrix
        multiply: function(y) {
          return new n.Matrix(this.native().multiply(S(y).native()));
        },
        // Inverses matrix
        inverse: function() {
          return new n.Matrix(this.native().inverse());
        },
        // Translate matrix
        translate: function(y, w) {
          return new n.Matrix(this.native().translate(y || 0, w || 0));
        },
        // Convert to native SVGMatrix
        native: function() {
          for (var y = n.parser.native.createSVGMatrix(), w = E.length - 1; w >= 0; w--)
            y[E[w]] = this[E[w]];
          return y;
        },
        // Convert matrix to string
        toString: function() {
          return "matrix(" + L(this.a) + "," + L(this.b) + "," + L(this.c) + "," + L(this.d) + "," + L(this.e) + "," + L(this.f) + ")";
        }
      },
      // Define parent
      parent: n.Element,
      // Add parent method
      construct: {
        // Get current matrix
        ctm: function() {
          return new n.Matrix(this.node.getCTM());
        },
        // Get current screen matrix
        screenCTM: function() {
          if (this instanceof n.Nested) {
            var y = this.rect(1, 1), w = y.node.getScreenCTM();
            return y.remove(), new n.Matrix(w);
          }
          return new n.Matrix(this.node.getScreenCTM());
        }
      }
    }), n.Point = n.invent({
      // Initialize
      create: function(y, w) {
        var T, P = { x: 0, y: 0 };
        T = Array.isArray(y) ? { x: y[0], y: y[1] } : typeof y == "object" ? { x: y.x, y: y.y } : y != null ? { x: y, y: w ?? y } : P, this.x = T.x, this.y = T.y;
      },
      // Add methods
      extend: {
        // Clone point
        clone: function() {
          return new n.Point(this);
        },
        // Morph one point into another
        morph: function(y, w) {
          return this.destination = new n.Point(y, w), this;
        }
      }
    }), n.extend(n.Element, {
      // Get point
      point: function(y, w) {
        return new n.Point(y, w).transform(this.screenCTM().inverse());
      }
    }), n.extend(n.Element, {
      // Set svg element attribute
      attr: function(y, w, T) {
        if (y == null) {
          y = {}, w = this.node.attributes;
          for (var T = w.length - 1; T >= 0; T--)
            y[w[T].nodeName] = n.regex.isNumber.test(w[T].nodeValue) ? parseFloat(w[T].nodeValue) : w[T].nodeValue;
          return y;
        } else if (typeof y == "object")
          for (var P in y)
            this.attr(P, y[P]);
        else if (w === null)
          this.node.removeAttribute(y);
        else {
          if (w == null)
            return w = this.node.getAttribute(y), w == null ? n.defaults.attrs[y] : n.regex.isNumber.test(w) ? parseFloat(w) : w;
          y == "stroke-width" ? this.attr("stroke", parseFloat(w) > 0 ? this._stroke : null) : y == "stroke" && (this._stroke = w), (y == "fill" || y == "stroke") && (n.regex.isImage.test(w) && (w = this.doc().defs().image(w, 0, 0)), w instanceof n.Image && (w = this.doc().defs().pattern(0, 0, function() {
            this.add(w);
          }))), typeof w == "number" ? w = new n.Number(w) : n.Color.isColor(w) ? w = new n.Color(w) : Array.isArray(w) && (w = new n.Array(w)), y == "leading" ? this.leading && this.leading(w) : typeof T == "string" ? this.node.setAttributeNS(T, y, w.toString()) : this.node.setAttribute(y, w.toString()), this.rebuild && (y == "font-size" || y == "x") && this.rebuild(y, w);
        }
        return this;
      }
    }), n.extend(n.Element, {
      // Add transformations
      transform: function(y, w) {
        var T = this, P;
        return typeof y != "object" ? (P = new n.Matrix(T).extract(), typeof y == "string" ? P[y] : P) : (P = new n.Matrix(T), w = !!w || !!y.relative, y.a != null && (P = w ? P.multiply(new n.Matrix(y)) : new n.Matrix(y)), this.attr("transform", P));
      }
    }), n.extend(n.Element, {
      // Reset all transformations
      untransform: function() {
        return this.attr("transform", null);
      },
      // merge the whole transformation chain into one matrix and returns it
      matrixify: function() {
        var y = (this.attr("transform") || "").split(n.regex.transforms).slice(0, -1).map(function(w) {
          var T = w.trim().split("(");
          return [T[0], T[1].split(n.regex.delimiter).map(function(P) {
            return parseFloat(P);
          })];
        }).reduce(function(w, T) {
          return T[0] == "matrix" ? w.multiply(x(T[1])) : w[T[0]].apply(w, T[1]);
        }, new n.Matrix());
        return y;
      },
      // add an element to another parent without changing the visual representation on the screen
      toParent: function(y) {
        if (this == y)
          return this;
        var w = this.screenCTM(), T = y.screenCTM().inverse();
        return this.addTo(y).untransform().transform(T.multiply(w)), this;
      },
      // same as above with parent equals root-svg
      toDoc: function() {
        return this.toParent(this.doc());
      }
    }), n.Transformation = n.invent({
      create: function(y, w) {
        if (arguments.length > 1 && typeof w != "boolean")
          return this.constructor.call(this, [].slice.call(arguments));
        if (Array.isArray(y))
          for (var T = 0, P = this.arguments.length; T < P; ++T)
            this[this.arguments[T]] = y[T];
        else if (y && typeof y == "object")
          for (var T = 0, P = this.arguments.length; T < P; ++T)
            this[this.arguments[T]] = y[this.arguments[T]];
        this.inversed = !1, w === !0 && (this.inversed = !0);
      }
    }), n.Translate = n.invent({
      parent: n.Matrix,
      inherit: n.Transformation,
      create: function(y, w) {
        this.constructor.apply(this, [].slice.call(arguments));
      },
      extend: {
        arguments: ["transformedX", "transformedY"],
        method: "translate"
      }
    }), n.extend(n.Element, {
      // Dynamic style generator
      style: function(y, w) {
        if (arguments.length == 0)
          return this.node.style.cssText || "";
        if (arguments.length < 2)
          if (typeof y == "object")
            for (var T in y)
              this.style(T, y[T]);
          else if (n.regex.isCss.test(y))
            for (y = y.split(/\s*;\s*/).filter(function(P) {
              return !!P;
            }).map(function(P) {
              return P.split(/\s*:\s*/);
            }); w = y.pop(); )
              this.style(w[0], w[1]);
          else
            return this.node.style[r(y)];
        else
          this.node.style[r(y)] = w === null || n.regex.isBlank.test(w) ? "" : w;
        return this;
      }
    }), n.Parent = n.invent({
      // Initialize node
      create: function(y) {
        this.constructor.call(this, y);
      },
      // Inherit from
      inherit: n.Element,
      // Add class methods
      extend: {
        // Returns all child elements
        children: function() {
          return n.utils.map(n.utils.filterSVGElements(this.node.childNodes), function(y) {
            return n.adopt(y);
          });
        },
        // Add given element at a position
        add: function(y, w) {
          return w == null ? this.node.appendChild(y.node) : y.node != this.node.childNodes[w] && this.node.insertBefore(y.node, this.node.childNodes[w]), this;
        },
        // Basically does the same as `add()` but returns the added element instead
        put: function(y, w) {
          return this.add(y, w), y;
        },
        // Checks if the given element is a child
        has: function(y) {
          return this.index(y) >= 0;
        },
        // Gets index of given element
        index: function(y) {
          return [].slice.call(this.node.childNodes).indexOf(y.node);
        },
        // Get a element at the given index
        get: function(y) {
          return n.adopt(this.node.childNodes[y]);
        },
        // Get first child
        first: function() {
          return this.get(0);
        },
        // Get the last child
        last: function() {
          return this.get(this.node.childNodes.length - 1);
        },
        // Iterates over all children and invokes a given block
        each: function(y, w) {
          for (var T, P = this.children(), R = 0, T = P.length; R < T; R++)
            P[R] instanceof n.Element && y.apply(P[R], [R, P]), w && P[R] instanceof n.Container && P[R].each(y, w);
          return this;
        },
        // Remove a given child
        removeElement: function(y) {
          return this.node.removeChild(y.node), this;
        },
        // Remove all elements in this container
        clear: function() {
          for (; this.node.hasChildNodes(); )
            this.node.removeChild(this.node.lastChild);
          return delete this._defs, this;
        },
        // Get defs
        defs: function() {
          return this.doc().defs();
        }
      }
    }), n.extend(n.Parent, {
      ungroup: function(y, w) {
        return w === 0 || this instanceof n.Defs || this.node == n.parser.draw ? this : (y = y || (this instanceof n.Doc ? this : this.parent(n.Parent)), w = w || 1 / 0, this.each(function() {
          return this instanceof n.Defs ? this : this instanceof n.Parent ? this.ungroup(y, w - 1) : this.toParent(y);
        }), this.node.firstChild || this.remove(), this);
      },
      flatten: function(y, w) {
        return this.ungroup(y, w);
      }
    }), n.Container = n.invent({
      // Initialize node
      create: function(y) {
        this.constructor.call(this, y);
      },
      // Inherit from
      inherit: n.Parent
    }), n.ViewBox = n.invent({
      // Define parent
      parent: n.Container,
      // Add parent method
      construct: {}
    }), [
      "click",
      "dblclick",
      "mousedown",
      "mouseup",
      "mouseover",
      "mouseout",
      "mousemove",
      // , 'mouseenter' -> not supported by IE
      // , 'mouseleave' -> not supported by IE
      "touchstart",
      "touchmove",
      "touchleave",
      "touchend",
      "touchcancel"
    ].forEach(function(y) {
      n.Element.prototype[y] = function(w) {
        return n.on(this.node, y, w), this;
      };
    }), n.listeners = [], n.handlerMap = [], n.listenerId = 0, n.on = function(y, w, T, P, R) {
      var Q = T.bind(P || y.instance || y), z = (n.handlerMap.indexOf(y) + 1 || n.handlerMap.push(y)) - 1, W = w.split(".")[0], G = w.split(".")[1] || "*";
      n.listeners[z] = n.listeners[z] || {}, n.listeners[z][W] = n.listeners[z][W] || {}, n.listeners[z][W][G] = n.listeners[z][W][G] || {}, T._svgjsListenerId || (T._svgjsListenerId = ++n.listenerId), n.listeners[z][W][G][T._svgjsListenerId] = Q, y.addEventListener(W, Q, R || { passive: !1 });
    }, n.off = function(y, w, T) {
      var P = n.handlerMap.indexOf(y), R = w && w.split(".")[0], Q = w && w.split(".")[1], z = "";
      if (P != -1)
        if (T) {
          if (typeof T == "function" && (T = T._svgjsListenerId), !T)
            return;
          n.listeners[P][R] && n.listeners[P][R][Q || "*"] && (y.removeEventListener(R, n.listeners[P][R][Q || "*"][T], !1), delete n.listeners[P][R][Q || "*"][T]);
        } else if (Q && R) {
          if (n.listeners[P][R] && n.listeners[P][R][Q]) {
            for (var W in n.listeners[P][R][Q])
              n.off(y, [R, Q].join("."), W);
            delete n.listeners[P][R][Q];
          }
        } else if (Q)
          for (var G in n.listeners[P])
            for (var z in n.listeners[P][G])
              Q === z && n.off(y, [G, Q].join("."));
        else if (R) {
          if (n.listeners[P][R]) {
            for (var z in n.listeners[P][R])
              n.off(y, [R, z].join("."));
            delete n.listeners[P][R];
          }
        } else {
          for (var G in n.listeners[P])
            n.off(y, G);
          delete n.listeners[P], delete n.handlerMap[P];
        }
    }, n.extend(n.Element, {
      // Bind given event to listener
      on: function(y, w, T, P) {
        return n.on(this.node, y, w, T, P), this;
      },
      // Unbind event from listener
      off: function(y, w) {
        return n.off(this.node, y, w), this;
      },
      // Fire given event
      fire: function(y, w) {
        return y instanceof t.Event ? this.node.dispatchEvent(y) : this.node.dispatchEvent(y = new n.CustomEvent(y, { detail: w, cancelable: !0 })), this._event = y, this;
      },
      event: function() {
        return this._event;
      }
    }), n.Defs = n.invent({
      // Initialize node
      create: "defs",
      // Inherit from
      inherit: n.Container
    }), n.G = n.invent({
      // Initialize node
      create: "g",
      // Inherit from
      inherit: n.Container,
      // Add class methods
      extend: {
        // Move over x-axis
        x: function(y) {
          return y == null ? this.transform("x") : this.transform({ x: y - this.x() }, !0);
        }
      },
      // Add parent method
      construct: {
        // Create a group element
        group: function() {
          return this.put(new n.G());
        }
      }
    }), n.Doc = n.invent({
      // Initialize node
      create: function(y) {
        y && (y = typeof y == "string" ? i.getElementById(y) : y, y.nodeName == "svg" ? this.constructor.call(this, y) : (this.constructor.call(this, n.create("svg")), y.appendChild(this.node), this.size("100%", "100%")), this.namespace().defs());
      },
      // Inherit from
      inherit: n.Container,
      // Add class methods
      extend: {
        // Add namespaces
        namespace: function() {
          return this.attr({ xmlns: n.ns, version: "1.1" }).attr("xmlns:xlink", n.xlink, n.xmlns).attr("xmlns:svgjs", n.svgjs, n.xmlns);
        },
        // Creates and returns defs element
        defs: function() {
          if (!this._defs) {
            var y;
            (y = this.node.getElementsByTagName("defs")[0]) ? this._defs = n.adopt(y) : this._defs = new n.Defs(), this.node.appendChild(this._defs.node);
          }
          return this._defs;
        },
        // custom parent method
        parent: function() {
          return !this.node.parentNode || this.node.parentNode.nodeName == "#document" ? null : this.node.parentNode;
        },
        // Removes the doc from the DOM
        remove: function() {
          return this.parent() && this.parent().removeChild(this.node), this;
        },
        clear: function() {
          for (; this.node.hasChildNodes(); )
            this.node.removeChild(this.node.lastChild);
          return delete this._defs, n.parser.draw && !n.parser.draw.parentNode && this.node.appendChild(n.parser.draw), this;
        },
        clone: function(y) {
          this.writeDataToDom();
          var w = this.node, T = C(w.cloneNode(!0));
          return y ? (y.node || y).appendChild(T.node) : w.parentNode.insertBefore(T.node, w.nextSibling), T;
        }
      }
    }), n.extend(n.Element, {
      // Get all siblings, including myself
    }), n.Gradient = n.invent({
      // Initialize node
      create: function(y) {
        this.constructor.call(this, n.create(y + "Gradient")), this.type = y;
      },
      // Inherit from
      inherit: n.Container,
      // Add class methods
      extend: {
        // Add a color stop
        at: function(y, w, T) {
          return this.put(new n.Stop()).update(y, w, T);
        },
        // Update gradient
        update: function(y) {
          return this.clear(), typeof y == "function" && y.call(this, this), this;
        },
        // Return the fill id
        fill: function() {
          return "url(#" + this.id() + ")";
        },
        // Alias string convertion to fill
        toString: function() {
          return this.fill();
        },
        // custom attr to handle transform
        attr: function(y, w, T) {
          return y == "transform" && (y = "gradientTransform"), n.Container.prototype.attr.call(this, y, w, T);
        }
      },
      // Add parent method
      construct: {
        // Create gradient element in defs
        gradient: function(y, w) {
          return this.defs().gradient(y, w);
        }
      }
    }), n.extend(n.Gradient, n.FX, {
      // From position
      from: function(y, w) {
        return (this._target || this).type == "radial" ? this.attr({ fx: new n.Number(y), fy: new n.Number(w) }) : this.attr({ x1: new n.Number(y), y1: new n.Number(w) });
      },
      // To position
      to: function(y, w) {
        return (this._target || this).type == "radial" ? this.attr({ cx: new n.Number(y), cy: new n.Number(w) }) : this.attr({ x2: new n.Number(y), y2: new n.Number(w) });
      }
    }), n.extend(n.Defs, {
      // define gradient
      gradient: function(y, w) {
        return this.put(new n.Gradient(y)).update(w);
      }
    }), n.Stop = n.invent({
      // Initialize node
      create: "stop",
      // Inherit from
      inherit: n.Element,
      // Add class methods
      extend: {
        // add color stops
        update: function(y) {
          return (typeof y == "number" || y instanceof n.Number) && (y = {
            offset: arguments[0],
            color: arguments[1],
            opacity: arguments[2]
          }), y.opacity != null && this.attr("stop-opacity", y.opacity), y.color != null && this.attr("stop-color", y.color), y.offset != null && this.attr("offset", new n.Number(y.offset)), this;
        }
      }
    }), n.Pattern = n.invent({
      // Initialize node
      create: "pattern",
      // Inherit from
      inherit: n.Container,
      // Add class methods
      extend: {
        // Return the fill id
        fill: function() {
          return "url(#" + this.id() + ")";
        },
        // Update pattern by rebuilding
        update: function(y) {
          return this.clear(), typeof y == "function" && y.call(this, this), this;
        },
        // Alias string convertion to fill
        toString: function() {
          return this.fill();
        },
        // custom attr to handle transform
        attr: function(y, w, T) {
          return y == "transform" && (y = "patternTransform"), n.Container.prototype.attr.call(this, y, w, T);
        }
      },
      // Add parent method
      construct: {
        // Create pattern element in defs
        pattern: function(y, w, T) {
          return this.defs().pattern(y, w, T);
        }
      }
    }), n.extend(n.Defs, {
      // Define gradient
      pattern: function(y, w, T) {
        return this.put(new n.Pattern()).update(T).attr({
          x: 0,
          y: 0,
          width: y,
          height: w,
          patternUnits: "userSpaceOnUse"
        });
      }
    }), n.Shape = n.invent({
      // Initialize node
      create: function(y) {
        this.constructor.call(this, y);
      },
      // Inherit from
      inherit: n.Element
    }), n.Symbol = n.invent({
      // Initialize node
      create: "symbol",
      // Inherit from
      inherit: n.Container,
      construct: {
        // create symbol
        symbol: function() {
          return this.put(new n.Symbol());
        }
      }
    }), n.Use = n.invent({
      // Initialize node
      create: "use",
      // Inherit from
      inherit: n.Shape,
      // Add class methods
      extend: {
        // Use element as a reference
        element: function(y, w) {
          return this.attr("href", (w || "") + "#" + y, n.xlink);
        }
      },
      // Add parent method
      construct: {
        // Create a use element
        use: function(y, w) {
          return this.put(new n.Use()).element(y, w);
        }
      }
    }), n.Rect = n.invent({
      // Initialize node
      create: "rect",
      // Inherit from
      inherit: n.Shape,
      // Add parent method
      construct: {
        // Create a rect element
        rect: function(y, w) {
          return this.put(new n.Rect()).size(y, w);
        }
      }
    }), n.Circle = n.invent({
      // Initialize node
      create: "circle",
      // Inherit from
      inherit: n.Shape,
      // Add parent method
      construct: {
        // Create circle element, based on ellipse
        circle: function(y) {
          return this.put(new n.Circle()).rx(new n.Number(y).divide(2)).move(0, 0);
        }
      }
    }), n.extend(n.Circle, n.FX, {
      // Radius x value
      rx: function(y) {
        return this.attr("r", y);
      },
      // Alias radius x value
      ry: function(y) {
        return this.rx(y);
      }
    }), n.Ellipse = n.invent({
      // Initialize node
      create: "ellipse",
      // Inherit from
      inherit: n.Shape,
      // Add parent method
      construct: {
        // Create an ellipse
        ellipse: function(y, w) {
          return this.put(new n.Ellipse()).size(y, w).move(0, 0);
        }
      }
    }), n.extend(n.Ellipse, n.Rect, n.FX, {
      // Radius x value
      rx: function(y) {
        return this.attr("rx", y);
      },
      // Radius y value
      ry: function(y) {
        return this.attr("ry", y);
      }
    }), n.extend(n.Circle, n.Ellipse, {
      // Move over x-axis
      x: function(y) {
        return y == null ? this.cx() - this.rx() : this.cx(y + this.rx());
      },
      // Move over y-axis
      y: function(y) {
        return y == null ? this.cy() - this.ry() : this.cy(y + this.ry());
      },
      // Move by center over x-axis
      cx: function(y) {
        return y == null ? this.attr("cx") : this.attr("cx", y);
      },
      // Move by center over y-axis
      cy: function(y) {
        return y == null ? this.attr("cy") : this.attr("cy", y);
      },
      // Set width of element
      width: function(y) {
        return y == null ? this.rx() * 2 : this.rx(new n.Number(y).divide(2));
      },
      // Set height of element
      height: function(y) {
        return y == null ? this.ry() * 2 : this.ry(new n.Number(y).divide(2));
      },
      // Custom size function
      size: function(y, w) {
        var T = b(this, y, w);
        return this.rx(new n.Number(T.width).divide(2)).ry(new n.Number(T.height).divide(2));
      }
    }), n.Line = n.invent({
      // Initialize node
      create: "line",
      // Inherit from
      inherit: n.Shape,
      // Add class methods
      extend: {
        // Get array
        array: function() {
          return new n.PointArray([
            [this.attr("x1"), this.attr("y1")],
            [this.attr("x2"), this.attr("y2")]
          ]);
        },
        // Overwrite native plot() method
        plot: function(y, w, T, P) {
          return y == null ? this.array() : (typeof w < "u" ? y = { x1: y, y1: w, x2: T, y2: P } : y = new n.PointArray(y).toLine(), this.attr(y));
        },
        // Move by left top corner
        move: function(y, w) {
          return this.attr(this.array().move(y, w).toLine());
        },
        // Set element size to given width and height
        size: function(y, w) {
          var T = b(this, y, w);
          return this.attr(this.array().size(T.width, T.height).toLine());
        }
      },
      // Add parent method
      construct: {
        // Create a line element
        line: function(y, w, T, P) {
          return n.Line.prototype.plot.apply(
            this.put(new n.Line()),
            y != null ? [y, w, T, P] : [0, 0, 0, 0]
          );
        }
      }
    }), n.Polyline = n.invent({
      // Initialize node
      create: "polyline",
      // Inherit from
      inherit: n.Shape,
      // Add parent method
      construct: {
        // Create a wrapped polyline element
        polyline: function(y) {
          return this.put(new n.Polyline()).plot(y || new n.PointArray());
        }
      }
    }), n.Polygon = n.invent({
      // Initialize node
      create: "polygon",
      // Inherit from
      inherit: n.Shape,
      // Add parent method
      construct: {
        // Create a wrapped polygon element
        polygon: function(y) {
          return this.put(new n.Polygon()).plot(y || new n.PointArray());
        }
      }
    }), n.extend(n.Polyline, n.Polygon, {
      // Get array
      array: function() {
        return this._array || (this._array = new n.PointArray(this.attr("points")));
      },
      // Plot new path
      plot: function(y) {
        return y == null ? this.array() : this.clear().attr("points", typeof y == "string" ? y : this._array = new n.PointArray(y));
      },
      // Clear array cache
      clear: function() {
        return delete this._array, this;
      },
      // Move by left top corner
      move: function(y, w) {
        return this.attr("points", this.array().move(y, w));
      },
      // Set element size to given width and height
      size: function(y, w) {
        var T = b(this, y, w);
        return this.attr("points", this.array().size(T.width, T.height));
      }
    }), n.extend(n.Line, n.Polyline, n.Polygon, {
      // Define morphable array
      morphArray: n.PointArray,
      // Move by left top corner over x-axis
      x: function(y) {
        return y == null ? this.bbox().x : this.move(y, this.bbox().y);
      },
      // Move by left top corner over y-axis
      y: function(y) {
        return y == null ? this.bbox().y : this.move(this.bbox().x, y);
      },
      // Set width of element
      width: function(y) {
        var w = this.bbox();
        return y == null ? w.width : this.size(y, w.height);
      },
      // Set height of element
      height: function(y) {
        var w = this.bbox();
        return y == null ? w.height : this.size(w.width, y);
      }
    }), n.Path = n.invent({
      // Initialize node
      create: "path",
      // Inherit from
      inherit: n.Shape,
      // Add class methods
      extend: {
        // Define morphable array
        morphArray: n.PathArray,
        // Get array
        array: function() {
          return this._array || (this._array = new n.PathArray(this.attr("d")));
        },
        // Plot new path
        plot: function(y) {
          return y == null ? this.array() : this.clear().attr("d", typeof y == "string" ? y : this._array = new n.PathArray(y));
        },
        // Clear array cache
        clear: function() {
          return delete this._array, this;
        }
      },
      // Add parent method
      construct: {
        // Create a wrapped path element
        path: function(y) {
          return this.put(new n.Path()).plot(y || new n.PathArray());
        }
      }
    }), n.Image = n.invent({
      // Initialize node
      create: "image",
      // Inherit from
      inherit: n.Shape,
      // Add class methods
      extend: {
        // (re)load image	
        load: function(y) {
          if (!y)
            return this;
          var w = this, T = new t.Image();
          return n.on(T, "load", function() {
            n.off(T);
            var P = w.parent(n.Pattern);
            P !== null && (w.width() == 0 && w.height() == 0 && w.size(T.width, T.height), P && P.width() == 0 && P.height() == 0 && P.size(w.width(), w.height()), typeof w._loaded == "function" && w._loaded.call(w, {
              width: T.width,
              height: T.height,
              ratio: T.width / T.height,
              url: y
            }));
          }), n.on(T, "error", function(P) {
            n.off(T), typeof w._error == "function" && w._error.call(w, P);
          }), this.attr("href", T.src = this.src = y, n.xlink);
        },
        // Add loaded callback	
        loaded: function(y) {
          return this._loaded = y, this;
        },
        error: function(y) {
          return this._error = y, this;
        }
      },
      // Add parent method
      construct: {
        // create image element, load image and set its size	
        image: function(y, w, T) {
          return this.put(new n.Image()).load(y).size(w || 0, T || w || 0);
        }
      }
    }), n.Text = n.invent({
      // Initialize node
      create: function() {
        this.constructor.call(this, n.create("text")), this.dom.leading = new n.Number(1.3), this._rebuild = !0, this._build = !1, this.attr("font-family", n.defaults.attrs["font-family"]);
      },
      // Inherit from
      inherit: n.Shape,
      // Add class methods
      extend: {
        // Move over x-axis
        x: function(y) {
          return y == null ? this.attr("x") : this.attr("x", y);
        },
        // Set the text content
        text: function(y) {
          if (typeof y > "u") {
            for (var y = "", w = this.node.childNodes, T = 0, P = w.length; T < P; ++T)
              T != 0 && w[T].nodeType != 3 && n.adopt(w[T]).dom.newLined == !0 && (y += `
`), y += w[T].textContent;
            return y;
          }
          if (this.clear().build(!0), typeof y == "function")
            y.call(this, this);
          else {
            y = y.split(`
`);
            for (var T = 0, R = y.length; T < R; T++)
              this.tspan(y[T]).newLine();
          }
          return this.build(!1).rebuild();
        },
        // Set font size
        size: function(y) {
          return this.attr("font-size", y).rebuild();
        },
        // Set / get leading
        leading: function(y) {
          return y == null ? this.dom.leading : (this.dom.leading = new n.Number(y), this.rebuild());
        },
        // Get all the first level lines
        lines: function() {
          var y = (this.textPath && this.textPath() || this).node, w = n.utils.map(n.utils.filterSVGElements(y.childNodes), function(T) {
            return n.adopt(T);
          });
          return new n.Set(w);
        },
        // Rebuild appearance type
        rebuild: function(y) {
          if (typeof y == "boolean" && (this._rebuild = y), this._rebuild) {
            var w = this, T = 0, P = this.dom.leading * new n.Number(this.attr("font-size"));
            this.lines().each(function() {
              this.dom.newLined && (w.textPath() || this.attr("x", w.attr("x")), this.text() == `
` ? T += P : (this.attr("dy", P + T), T = 0));
            }), this.fire("rebuild");
          }
          return this;
        },
        // Enable / disable build mode
        build: function(y) {
          return this._build = !!y, this;
        },
        // overwrite method from parent to set data properly
        setData: function(y) {
          return this.dom = y, this.dom.leading = new n.Number(y.leading || 1.3), this;
        }
      },
      // Add parent method
      construct: {
        // Create text element
        text: function(y) {
          return this.put(new n.Text()).text(y);
        },
        // Create plain text element
        plain: function(y) {
          return this.put(new n.Text()).plain(y);
        }
      }
    }), n.Tspan = n.invent({
      // Initialize node
      create: "tspan",
      // Inherit from
      inherit: n.Shape,
      // Add class methods
      extend: {
        // Set text content
        text: function(y) {
          return y == null ? this.node.textContent + (this.dom.newLined ? `
` : "") : (typeof y == "function" ? y.call(this, this) : this.plain(y), this);
        },
        // Shortcut dx
        dx: function(y) {
          return this.attr("dx", y);
        },
        // Shortcut dy
        dy: function(y) {
          return this.attr("dy", y);
        },
        // Create new line
        newLine: function() {
          var y = this.parent(n.Text);
          return this.dom.newLined = !0, this.dy(y.dom.leading * y.attr("font-size")).attr("x", y.x());
        }
      }
    }), n.extend(n.Text, n.Tspan, {
      // Create plain text node
      plain: function(y) {
        return this._build === !1 && this.clear(), this.node.appendChild(i.createTextNode(y)), this;
      },
      // Create a tspan
      tspan: function(y) {
        var w = (this.textPath && this.textPath() || this).node, T = new n.Tspan();
        return this._build === !1 && this.clear(), w.appendChild(T.node), T.text(y);
      },
      // Clear all lines
      clear: function() {
        for (var y = (this.textPath && this.textPath() || this).node; y.hasChildNodes(); )
          y.removeChild(y.lastChild);
        return this;
      },
      // Get length of text element
      length: function() {
        return this.node.getComputedTextLength();
      }
    }), n.TextPath = n.invent({
      // Initialize node
      create: "textPath",
      // Inherit from
      inherit: n.Parent,
      // Define parent class
      parent: n.Text,
      // Add parent method
      construct: {
        morphArray: n.PathArray,
        // return the array of the path track element
        array: function() {
          var y = this.track();
          return y ? y.array() : null;
        },
        // Plot path if any
        plot: function(y) {
          var w = this.track(), T = null;
          return w && (T = w.plot(y)), y == null ? T : this;
        },
        // Get the path track element
        track: function() {
          var y = this.textPath();
          if (y)
            return y.reference("href");
        },
        // Get the textPath child
        textPath: function() {
          if (this.node.firstChild && this.node.firstChild.nodeName == "textPath")
            return n.adopt(this.node.firstChild);
        }
      }
    }), n.Nested = n.invent({
      // Initialize node
      create: function() {
        this.constructor.call(this, n.create("svg")), this.style("overflow", "visible");
      },
      // Inherit from
      inherit: n.Container,
      // Add parent method
      construct: {
        // Create nested svg document
        nested: function() {
          return this.put(new n.Nested());
        }
      }
    });
    var f = {
      stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"],
      fill: ["color", "opacity", "rule"],
      prefix: function(y, w) {
        return w == "color" ? y : y + "-" + w;
      }
    };
    ["fill", "stroke"].forEach(function(y) {
      var w = {};
      w[y] = function(T) {
        if (typeof T > "u")
          return this;
        if (typeof T == "string" || n.Color.isRgb(T) || T && typeof T.fill == "function")
          this.attr(y, T);
        else
          for (var P = f[y].length - 1; P >= 0; P--)
            T[f[y][P]] != null && this.attr(f.prefix(y, f[y][P]), T[f[y][P]]);
        return this;
      }, n.extend(n.Element, n.FX, w);
    }), n.extend(n.Element, n.FX, {
      // Map translate to transform
      translate: function(y, w) {
        return this.transform({ x: y, y: w });
      },
      // Map matrix to transform
      matrix: function(y) {
        return this.attr("transform", new n.Matrix(arguments.length == 6 ? [].slice.call(arguments) : y));
      },
      // Opacity
      opacity: function(y) {
        return this.attr("opacity", y);
      },
      // Relative move over x axis
      dx: function(y) {
        return this.x(new n.Number(y).plus(this instanceof n.FX ? 0 : this.x()), !0);
      },
      // Relative move over y axis
      dy: function(y) {
        return this.y(new n.Number(y).plus(this instanceof n.FX ? 0 : this.y()), !0);
      }
    }), n.extend(n.Path, {
      // Get path length
      length: function() {
        return this.node.getTotalLength();
      },
      // Get point at length
      pointAt: function(y) {
        return this.node.getPointAtLength(y);
      }
    }), n.Set = n.invent({
      // Initialize
      create: function(y) {
        Array.isArray(y) ? this.members = y : this.clear();
      },
      // Add class methods
      extend: {
        // Add element to set
        add: function() {
          for (var y, w = [].slice.call(arguments), T = 0, y = w.length; T < y; T++)
            this.members.push(w[T]);
          return this;
        },
        // Remove element from set
        remove: function(y) {
          var w = this.index(y);
          return w > -1 && this.members.splice(w, 1), this;
        },
        // Iterate over all members
        each: function(y) {
          for (var w = 0, T = this.members.length; w < T; w++)
            y.apply(this.members[w], [w, this.members]);
          return this;
        },
        // Restore to defaults
        clear: function() {
          return this.members = [], this;
        },
        // Get the length of a set
        length: function() {
          return this.members.length;
        },
        // Checks if a given element is present in set
        has: function(y) {
          return this.index(y) >= 0;
        },
        // retuns index of given element in set
        index: function(y) {
          return this.members.indexOf(y);
        },
        // Get member at given index
        get: function(y) {
          return this.members[y];
        },
        // Get first member
        first: function() {
          return this.get(0);
        },
        // Get last member
        last: function() {
          return this.get(this.members.length - 1);
        },
        // Default value
        valueOf: function() {
          return this.members;
        }
      },
      // Add parent method
      construct: {
        // Create a new set
        set: function(y) {
          return new n.Set(y);
        }
      }
    }), n.FX.Set = n.invent({
      // Initialize node
      create: function(y) {
        this.set = y;
      }
    }), n.Set.inherit = function() {
      var y = [];
      for (var w in n.Shape.prototype)
        typeof n.Shape.prototype[w] == "function" && typeof n.Set.prototype[w] != "function" && y.push(w);
      y.forEach(function(T) {
        n.Set.prototype[T] = function() {
          for (var P = 0, R = this.members.length; P < R; P++)
            this.members[P] && typeof this.members[P][T] == "function" && this.members[P][T].apply(this.members[P], arguments);
          return T == "animate" ? this.fx || (this.fx = new n.FX.Set(this)) : this;
        };
      }), y = [];
      for (var w in n.FX.prototype)
        typeof n.FX.prototype[w] == "function" && typeof n.FX.Set.prototype[w] != "function" && y.push(w);
      y.forEach(function(T) {
        n.FX.Set.prototype[T] = function() {
          for (var P = 0, R = this.set.members.length; P < R; P++)
            this.set.members[P].fx[T].apply(this.set.members[P].fx, arguments);
          return this;
        };
      });
    }, n.extend(n.Element, {}), n.extend(n.Element, {
      // Remember arbitrary data
      remember: function(y, w) {
        if (typeof arguments[0] == "object")
          for (var T in y)
            this.remember(T, y[T]);
        else {
          if (arguments.length == 1)
            return this.memory()[y];
          this.memory()[y] = w;
        }
        return this;
      },
      // Erase a given memory
      forget: function() {
        if (arguments.length == 0)
          this._memory = {};
        else
          for (var y = arguments.length - 1; y >= 0; y--)
            delete this.memory()[arguments[y]];
        return this;
      },
      // Initialize or return local memory object
      memory: function() {
        return this._memory || (this._memory = {});
      }
    }), n.get = function(y) {
      var w = i.getElementById($(y) || y);
      return n.adopt(w);
    }, n.select = function(y, w) {
      return new n.Set(
        n.utils.map((w || i).querySelectorAll(y), function(T) {
          return n.adopt(T);
        })
      );
    }, n.extend(n.Parent, {
      // Scoped select method
      select: function(y) {
        return n.select(y, this.node);
      }
    });
    function p(y, w, T, P) {
      return T + P.replace(n.regex.dots, " .");
    }
    function m(y, w) {
      return y instanceof w;
    }
    function v(y, w) {
      return (y.matches || y.matchesSelector || y.msMatchesSelector || y.mozMatchesSelector || y.webkitMatchesSelector || y.oMatchesSelector).call(y, w);
    }
    function r(y) {
      return y.toLowerCase().replace(/-(.)/g, function(w, T) {
        return T.toUpperCase();
      });
    }
    function h(y) {
      return y.charAt(0).toUpperCase() + y.slice(1);
    }
    function u(y) {
      return y.length == 4 ? [
        "#",
        y.substring(1, 2),
        y.substring(1, 2),
        y.substring(2, 3),
        y.substring(2, 3),
        y.substring(3, 4),
        y.substring(3, 4)
      ].join("") : y;
    }
    function g(y) {
      var w = y.toString(16);
      return w.length == 1 ? "0" + w : w;
    }
    function b(y, w, T) {
      if (w == null || T == null) {
        var P = y.bbox();
        w == null ? w = P.width / P.height * T : T == null && (T = P.height / P.width * w);
      }
      return {
        width: w,
        height: T
      };
    }
    function O(y, w, T) {
      return {
        x: w * y.a + T * y.c + 0,
        y: w * y.b + T * y.d + 0
      };
    }
    function x(y) {
      return { a: y[0], b: y[1], c: y[2], d: y[3], e: y[4], f: y[5] };
    }
    function S(y) {
      return y instanceof n.Matrix || (y = new n.Matrix(y)), y;
    }
    function k(y) {
      for (var w = 0, T = y.length, P = ""; w < T; w++)
        P += y[w][0], y[w][1] != null && (P += y[w][1], y[w][2] != null && (P += " ", P += y[w][2], y[w][3] != null && (P += " ", P += y[w][3], P += " ", P += y[w][4], y[w][5] != null && (P += " ", P += y[w][5], P += " ", P += y[w][6], y[w][7] != null && (P += " ", P += y[w][7])))));
      return P + " ";
    }
    function C(y) {
      for (var w = y.childNodes.length - 1; w >= 0; w--)
        y.childNodes[w] instanceof t.SVGElement && C(y.childNodes[w]);
      return n.adopt(y).id(n.eid(y.nodeName));
    }
    function _(y) {
      return y.x == null && (y.x = 0, y.y = 0, y.width = 0, y.height = 0), y.w = y.width, y.h = y.height, y.x2 = y.x + y.width, y.y2 = y.y + y.height, y.cx = y.x + y.width / 2, y.cy = y.y + y.height / 2, y;
    }
    function $(y) {
      var w = (y || "").toString().match(n.regex.reference);
      if (w)
        return w[1];
    }
    function L(y) {
      return Math.abs(y) > 1e-37 ? y : 0;
    }
    var E = "abcdef".split("");
    if (typeof t.CustomEvent != "function") {
      var A = function(y, w) {
        w = w || { bubbles: !1, cancelable: !1, detail: void 0 };
        var T = i.createEvent("CustomEvent");
        return T.initCustomEvent(y, w.bubbles, w.cancelable, w.detail), T;
      };
      A.prototype = t.Event.prototype, n.CustomEvent = A;
    } else
      n.CustomEvent = t.CustomEvent;
    return n;
  });
})(BL);
/*! svg.filter.js - v2.0.2 - 2016-02-24
* https://github.com/wout/svg.filter.js
* Copyright (c) 2016 Wout Fierens; Licensed MIT */
(function() {
  SVG.Filter = SVG.invent({
    create: "filter",
    inherit: SVG.Parent,
    extend: {
      // Static strings
      source: "SourceGraphic",
      sourceAlpha: "SourceAlpha",
      background: "BackgroundImage",
      backgroundAlpha: "BackgroundAlpha",
      fill: "FillPaint",
      stroke: "StrokePaint",
      autoSetIn: !0,
      // Custom put method for leaner code
      put: function(l, c) {
        return this.add(l, c), !l.attr("in") && this.autoSetIn && l.attr("in", this.source), l.attr("result") || l.attr("result", l), l;
      },
      // Blend effect
      blend: function(l, c, d) {
        return this.put(new SVG.BlendEffect(l, c, d));
      },
      // ColorMatrix effect
      colorMatrix: function(l, c) {
        return this.put(new SVG.ColorMatrixEffect(l, c));
      },
      // ConvolveMatrix effect
      convolveMatrix: function(l) {
        return this.put(new SVG.ConvolveMatrixEffect(l));
      },
      // ComponentTransfer effect
      componentTransfer: function(l) {
        return this.put(new SVG.ComponentTransferEffect(l));
      },
      // Composite effect
      composite: function(l, c, d) {
        return this.put(new SVG.CompositeEffect(l, c, d));
      },
      // Flood effect
      flood: function(l, c) {
        return this.put(new SVG.FloodEffect(l, c));
      },
      // Offset effect
      offset: function(l, c) {
        return this.put(new SVG.OffsetEffect(l, c));
      },
      // Image effect
      image: function(l) {
        return this.put(new SVG.ImageEffect(l));
      },
      // Merge effect
      merge: function() {
        var l = [void 0];
        for (var c in arguments)
          l.push(arguments[c]);
        return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect, l))());
      },
      // Gaussian Blur effect
      gaussianBlur: function(l, c) {
        return this.put(new SVG.GaussianBlurEffect(l, c));
      },
      // Morphology effect
      morphology: function(l, c) {
        return this.put(new SVG.MorphologyEffect(l, c));
      },
      // DiffuseLighting effect
      diffuseLighting: function(l, c, d) {
        return this.put(new SVG.DiffuseLightingEffect(l, c, d));
      },
      // DisplacementMap effect
      displacementMap: function(l, c, d, f, p) {
        return this.put(new SVG.DisplacementMapEffect(l, c, d, f, p));
      },
      // SpecularLighting effect
      specularLighting: function(l, c, d, f) {
        return this.put(new SVG.SpecularLightingEffect(l, c, d, f));
      },
      // Tile effect
      tile: function() {
        return this.put(new SVG.TileEffect());
      },
      // Turbulence effect
      turbulence: function(l, c, d, f, p) {
        return this.put(new SVG.TurbulenceEffect(l, c, d, f, p));
      },
      // Default string value
      toString: function() {
        return "url(#" + this.attr("id") + ")";
      }
    }
  }), SVG.extend(SVG.Defs, {
    // Define filter
    filter: function(l) {
      var c = this.put(new SVG.Filter());
      return typeof l == "function" && l.call(c, c), c;
    }
  }), SVG.extend(SVG.Container, {
    // Define filter on defs
    filter: function(l) {
      return this.defs().filter(l);
    }
  }), SVG.extend(SVG.Element, SVG.G, SVG.Nested, {
    // Create filter element in defs and store reference
    filter: function(l) {
      return this.filterer = l instanceof SVG.Element ? l : this.doc().filter(l), this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer), this.attr("filter", this.filterer), this.filterer;
    },
    // Remove filter
    unfilter: function(l) {
      return this.filterer && l === !0 && this.filterer.remove(), delete this.filterer, this.attr("filter", null);
    }
  }), SVG.Effect = SVG.invent({
    create: function() {
      this.constructor.call(this);
    },
    inherit: SVG.Element,
    extend: {
      // Set in attribute
      in: function(l) {
        return l == null ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", l);
      },
      // Named result
      result: function(l) {
        return l == null ? this.attr("result") : this.attr("result", l);
      },
      // Stringification
      toString: function() {
        return this.result();
      }
    }
  }), SVG.ParentEffect = SVG.invent({
    create: function() {
      this.constructor.call(this);
    },
    inherit: SVG.Parent,
    extend: {
      // Set in attribute
      in: function(l) {
        return l == null ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", l);
      },
      // Named result
      result: function(l) {
        return l == null ? this.attr("result") : this.attr("result", l);
      },
      // Stringification
      toString: function() {
        return this.result();
      }
    }
  });
  var a = {
    // Blend effect
    blend: function(l, c) {
      return this.parent() && this.parent().blend(this, l, c);
    },
    // ColorMatrix effect
    colorMatrix: function(l, c) {
      return this.parent() && this.parent().colorMatrix(l, c).in(this);
    },
    // ConvolveMatrix effect
    convolveMatrix: function(l) {
      return this.parent() && this.parent().convolveMatrix(l).in(this);
    },
    // ComponentTransfer effect
    componentTransfer: function(l) {
      return this.parent() && this.parent().componentTransfer(l).in(this);
    },
    // Composite effect
    composite: function(l, c) {
      return this.parent() && this.parent().composite(this, l, c);
    },
    // Flood effect
    flood: function(l, c) {
      return this.parent() && this.parent().flood(l, c);
    },
    // Offset effect
    offset: function(l, c) {
      return this.parent() && this.parent().offset(l, c).in(this);
    },
    // Image effect
    image: function(l) {
      return this.parent() && this.parent().image(l);
    },
    // Merge effect
    merge: function() {
      return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments));
    },
    // Gaussian Blur effect
    gaussianBlur: function(l, c) {
      return this.parent() && this.parent().gaussianBlur(l, c).in(this);
    },
    // Morphology effect
    morphology: function(l, c) {
      return this.parent() && this.parent().morphology(l, c).in(this);
    },
    // DiffuseLighting effect
    diffuseLighting: function(l, c, d) {
      return this.parent() && this.parent().diffuseLighting(l, c, d).in(this);
    },
    // DisplacementMap effect
    displacementMap: function(l, c, d, f) {
      return this.parent() && this.parent().displacementMap(this, l, c, d, f);
    },
    // SpecularLighting effect
    specularLighting: function(l, c, d, f) {
      return this.parent() && this.parent().specularLighting(l, c, d, f).in(this);
    },
    // Tile effect
    tile: function() {
      return this.parent() && this.parent().tile().in(this);
    },
    // Turbulence effect
    turbulence: function(l, c, d, f, p) {
      return this.parent() && this.parent().turbulence(l, c, d, f, p).in(this);
    }
  };
  SVG.extend(SVG.Effect, a), SVG.extend(SVG.ParentEffect, a), SVG.ChildEffect = SVG.invent({
    create: function() {
      this.constructor.call(this);
    },
    inherit: SVG.Element,
    extend: {
      in: function(l) {
        this.attr("in", l);
      }
      //dont include any "result" functions because these types of nodes dont have them
    }
  });
  var e = {
    blend: function(l, c, d) {
      this.attr({
        in: l,
        in2: c,
        mode: d || "normal"
      });
    },
    colorMatrix: function(l, c) {
      l == "matrix" && (c = s(c)), this.attr({
        type: l,
        values: typeof c > "u" ? null : c
      });
    },
    convolveMatrix: function(l) {
      l = s(l), this.attr({
        order: Math.sqrt(l.split(" ").length),
        kernelMatrix: l
      });
    },
    composite: function(l, c, d) {
      this.attr({
        in: l,
        in2: c,
        operator: d
      });
    },
    flood: function(l, c) {
      this.attr("flood-color", l), c != null && this.attr("flood-opacity", c);
    },
    offset: function(l, c) {
      this.attr({
        dx: l,
        dy: c
      });
    },
    image: function(l) {
      this.attr("href", l, SVG.xlink);
    },
    displacementMap: function(l, c, d, f, p) {
      this.attr({
        in: l,
        in2: c,
        scale: d,
        xChannelSelector: f,
        yChannelSelector: p
      });
    },
    gaussianBlur: function(l, c) {
      l != null || c != null ? this.attr("stdDeviation", n(Array.prototype.slice.call(arguments))) : this.attr("stdDeviation", "0 0");
    },
    morphology: function(l, c) {
      this.attr({
        operator: l,
        radius: c
      });
    },
    tile: function() {
    },
    turbulence: function(l, c, d, f, p) {
      this.attr({
        numOctaves: c,
        seed: d,
        stitchTiles: f,
        baseFrequency: l,
        type: p
      });
    }
  }, t = {
    merge: function() {
      var l;
      if (arguments[0] instanceof SVG.Set) {
        var c = this;
        arguments[0].each(function(f) {
          this instanceof SVG.MergeNode ? c.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && c.put(new SVG.MergeNode(this));
        });
      } else {
        Array.isArray(arguments[0]) ? l = arguments[0] : l = arguments;
        for (var d = 0; d < l.length; d++)
          l[d] instanceof SVG.MergeNode ? this.put(l[d]) : this.put(new SVG.MergeNode(l[d]));
      }
    },
    componentTransfer: function(l) {
      if (this.rgb = new SVG.Set(), ["r", "g", "b", "a"].forEach((function(d) {
        this[d] = new SVG["Func" + d.toUpperCase()]("identity"), this.rgb.add(this[d]), this.node.appendChild(this[d].node);
      }).bind(this)), l) {
        l.rgb && (["r", "g", "b"].forEach((function(d) {
          this[d].attr(l.rgb);
        }).bind(this)), delete l.rgb);
        for (var c in l)
          this[c].attr(l[c]);
      }
    },
    diffuseLighting: function(l, c, d) {
      this.attr({
        surfaceScale: l,
        diffuseConstant: c,
        kernelUnitLength: d
      });
    },
    specularLighting: function(l, c, d, f) {
      this.attr({
        surfaceScale: l,
        diffuseConstant: c,
        specularExponent: d,
        kernelUnitLength: f
      });
    }
  }, i = {
    distantLight: function(l, c) {
      this.attr({
        azimuth: l,
        elevation: c
      });
    },
    pointLight: function(l, c, d) {
      this.attr({
        x: l,
        y: c,
        z: d
      });
    },
    spotLight: function(l, c, d, f, p, m) {
      this.attr({
        x: l,
        y: c,
        z: d,
        pointsAtX: f,
        pointsAtY: p,
        pointsAtZ: m
      });
    },
    mergeNode: function(l) {
      this.attr("in", l);
    }
  };
  ["r", "g", "b", "a"].forEach(function(l) {
    i["Func" + l.toUpperCase()] = function(c) {
      switch (this.attr("type", c), c) {
        case "table":
          this.attr("tableValues", arguments[1]);
          break;
        case "linear":
          this.attr("slope", arguments[1]), this.attr("intercept", arguments[2]);
          break;
        case "gamma":
          this.attr("amplitude", arguments[1]), this.attr("exponent", arguments[2]), this.attr("offset", arguments[2]);
          break;
      }
    };
  }), o(e, function(l, c) {
    var d = c.charAt(0).toUpperCase() + c.slice(1), f = {};
    SVG[d + "Effect"] = SVG.invent({
      create: function() {
        this.constructor.call(this, SVG.create("fe" + d)), l.apply(this, arguments), this.result(this.attr("id") + "Out");
      },
      inherit: SVG.Effect,
      extend: f
    });
  }), o(t, function(l, c) {
    var d = c.charAt(0).toUpperCase() + c.slice(1), f = {};
    SVG[d + "Effect"] = SVG.invent({
      create: function() {
        this.constructor.call(this, SVG.create("fe" + d)), l.apply(this, arguments), this.result(this.attr("id") + "Out");
      },
      inherit: SVG.ParentEffect,
      extend: f
    });
  }), o(i, function(l, c) {
    var d = c.charAt(0).toUpperCase() + c.slice(1), f = {};
    SVG[d] = SVG.invent({
      create: function() {
        this.constructor.call(this, SVG.create("fe" + d)), l.apply(this, arguments);
      },
      inherit: SVG.ChildEffect,
      extend: f
    });
  }), SVG.extend(SVG.MergeEffect, {
    in: function(l) {
      return l instanceof SVG.MergeNode ? this.add(l, 0) : this.add(new SVG.MergeNode(l), 0), this;
    }
  }), SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, {
    in2: function(l) {
      return l == null ? this.parent() && this.parent().select('[result="' + this.attr("in2") + '"]').get(0) || this.attr("in2") : this.attr("in2", l);
    }
  }), SVG.filter = {
    sepiatone: [
      0.343,
      0.669,
      0.119,
      0,
      0,
      0.249,
      0.626,
      0.13,
      0,
      0,
      0.172,
      0.334,
      0.111,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ]
  };
  function s(l) {
    return Array.isArray(l) && (l = new SVG.Array(l)), l.toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ");
  }
  function n(l) {
    if (!Array.isArray(l))
      return l;
    for (var c = 0, d = l.length, f = []; c < d; c++)
      f.push(l[c]);
    return f.join(" ");
  }
  function o() {
    var l = function() {
    };
    typeof arguments[arguments.length - 1] == "function" && (l = arguments[arguments.length - 1], Array.prototype.splice.call(arguments, arguments.length - 1, 1));
    for (var c in arguments)
      for (var d in arguments[c])
        l(arguments[c][d], d, arguments[c]);
  }
}).call(globalThis);
(function() {
  SVG.extend(SVG.PathArray, {
    morph: function(o) {
      for (var l = this.value, c = this.parse(o), d = 0, f = 0, p = !1, m = !1; !(d === !1 && f === !1); ) {
        if (p = s(l, d === !1 ? !1 : d + 1), m = s(c, f === !1 ? !1 : f + 1), d === !1) {
          var v = new SVG.PathArray(r.start).bbox();
          v.height == 0 || v.width == 0 ? d = l.push(l[0]) - 1 : d = l.push(["M", v.x + v.width / 2, v.y + v.height / 2]) - 1;
        }
        if (f === !1) {
          var v = new SVG.PathArray(r.dest).bbox();
          v.height == 0 || v.width == 0 ? f = c.push(c[0]) - 1 : f = c.push(["M", v.x + v.width / 2, v.y + v.height / 2]) - 1;
        }
        var r = a(l, d, p, c, f, m);
        l = l.slice(0, d).concat(r.start, p === !1 ? [] : l.slice(p)), c = c.slice(0, f).concat(r.dest, m === !1 ? [] : c.slice(m)), d = p === !1 ? !1 : d + r.start.length, f = m === !1 ? !1 : f + r.dest.length;
      }
      return this.value = l, this.destination = new SVG.PathArray(), this.destination.value = c, this;
    }
  });
  function a(o, l, c, d, f, p, m) {
    var v = o.slice(l, c || m), r = d.slice(f, p || m), h = 0, u = { pos: [0, 0], start: [0, 0] }, g = { pos: [0, 0], start: [0, 0] };
    do {
      if (v[h] = e.call(u, v[h]), r[h] = e.call(g, r[h]), v[h][0] != r[h][0] || v[h][0] == "M" || v[h][0] == "A" && (v[h][4] != r[h][4] || v[h][5] != r[h][5]) ? (Array.prototype.splice.apply(v, [h, 1].concat(i.call(u, v[h]))), Array.prototype.splice.apply(r, [h, 1].concat(i.call(g, r[h])))) : (v[h] = t.call(u, v[h]), r[h] = t.call(g, r[h])), ++h == v.length && h == r.length)
        break;
      h == v.length && v.push([
        "C",
        u.pos[0],
        u.pos[1],
        u.pos[0],
        u.pos[1],
        u.pos[0],
        u.pos[1]
      ]), h == r.length && r.push([
        "C",
        g.pos[0],
        g.pos[1],
        g.pos[0],
        g.pos[1],
        g.pos[0],
        g.pos[1]
      ]);
    } while (!0);
    return { start: v, dest: r };
  }
  function e(o) {
    switch (o[0]) {
      case "z":
      case "Z":
        o[0] = "L", o[1] = this.start[0], o[2] = this.start[1];
        break;
      case "H":
        o[0] = "L", o[2] = this.pos[1];
        break;
      case "V":
        o[0] = "L", o[2] = o[1], o[1] = this.pos[0];
        break;
      case "T":
        o[0] = "Q", o[3] = o[1], o[4] = o[2], o[1] = this.reflection[1], o[2] = this.reflection[0];
        break;
      case "S":
        o[0] = "C", o[6] = o[4], o[5] = o[3], o[4] = o[2], o[3] = o[1], o[2] = this.reflection[1], o[1] = this.reflection[0];
        break;
    }
    return o;
  }
  function t(o) {
    var l = o.length;
    return this.pos = [o[l - 2], o[l - 1]], "SCQT".indexOf(o[0]) != -1 && (this.reflection = [2 * this.pos[0] - o[l - 4], 2 * this.pos[1] - o[l - 3]]), o;
  }
  function i(o) {
    var l = [o];
    switch (o[0]) {
      case "M":
        return this.pos = this.start = [o[1], o[2]], l;
      case "L":
        o[5] = o[3] = o[1], o[6] = o[4] = o[2], o[1] = this.pos[0], o[2] = this.pos[1];
        break;
      case "Q":
        o[6] = o[4], o[5] = o[3], o[4] = o[4] * 1 / 3 + o[2] * 2 / 3, o[3] = o[3] * 1 / 3 + o[1] * 2 / 3, o[2] = this.pos[1] * 1 / 3 + o[2] * 2 / 3, o[1] = this.pos[0] * 1 / 3 + o[1] * 2 / 3;
        break;
      case "A":
        l = n(this.pos, o), o = l[0];
        break;
    }
    return o[0] = "C", this.pos = [o[5], o[6]], this.reflection = [2 * o[5] - o[3], 2 * o[6] - o[4]], l;
  }
  function s(o, l) {
    if (l === !1)
      return !1;
    for (var c = l, d = o.length; c < d; ++c)
      if (o[c][0] == "M")
        return c;
    return !1;
  }
  function n(o, l) {
    var c = Math.abs(l[1]), d = Math.abs(l[2]), f = l[3] % 360, p = l[4], m = l[5], v = l[6], r = l[7], h = new SVG.Point(o), u = new SVG.Point(v, r), g, b, O, x, S, k, C, _, $, L, E, A, y, w, T, P, R, Q, z, W, G, de, xe = [], ie, fe, $e, Me;
    if (c === 0 || d === 0 || h.x === u.x && h.y === u.y)
      return [["C", h.x, h.y, u.x, u.y, u.x, u.y]];
    for (g = new SVG.Point((h.x - u.x) / 2, (h.y - u.y) / 2).transform(new SVG.Matrix().rotate(f)), b = g.x * g.x / (c * c) + g.y * g.y / (d * d), b > 1 && (b = Math.sqrt(b), c = b * c, d = b * d), O = new SVG.Matrix().rotate(f).scale(1 / c, 1 / d).rotate(-f), h = h.transform(O), u = u.transform(O), x = [u.x - h.x, u.y - h.y], k = x[0] * x[0] + x[1] * x[1], S = Math.sqrt(k), x[0] /= S, x[1] /= S, C = k < 4 ? Math.sqrt(1 - k / 4) : 0, p === m && (C *= -1), _ = new SVG.Point((u.x + h.x) / 2 + C * -x[1], (u.y + h.y) / 2 + C * x[0]), $ = new SVG.Point(h.x - _.x, h.y - _.y), L = new SVG.Point(u.x - _.x, u.y - _.y), E = Math.acos($.x / Math.sqrt($.x * $.x + $.y * $.y)), $.y < 0 && (E *= -1), A = Math.acos(L.x / Math.sqrt(L.x * L.x + L.y * L.y)), L.y < 0 && (A *= -1), m && E > A && (A += 2 * Math.PI), !m && E < A && (A -= 2 * Math.PI), w = Math.ceil(Math.abs(E - A) * 2 / Math.PI), P = [], R = E, y = (A - E) / w, T = 4 * Math.tan(y / 4) / 3, G = 0; G <= w; G++)
      z = Math.cos(R), Q = Math.sin(R), W = new SVG.Point(_.x + z, _.y + Q), P[G] = [new SVG.Point(W.x + T * Q, W.y - T * z), W, new SVG.Point(W.x - T * Q, W.y + T * z)], R += y;
    for (P[0][0] = P[0][1].clone(), P[P.length - 1][2] = P[P.length - 1][1].clone(), O = new SVG.Matrix().rotate(f).scale(c, d).rotate(-f), G = 0, de = P.length; G < de; G++)
      P[G][0] = P[G][0].transform(O), P[G][1] = P[G][1].transform(O), P[G][2] = P[G][2].transform(O);
    for (G = 1, de = P.length; G < de; G++)
      W = P[G - 1][2], ie = W.x, fe = W.y, W = P[G][0], $e = W.x, Me = W.y, W = P[G][1], v = W.x, r = W.y, xe.push(["C", ie, fe, $e, Me, v, r]);
    return xe;
  }
})();
/*! svg.draggable.js - v2.2.2 - 2019-01-08
* https://github.com/svgdotjs/svg.draggable.js
* Copyright (c) 2019 Wout Fierens; Licensed MIT */
(function() {
  function a(e) {
    e.remember("_draggable", this), this.el = e;
  }
  a.prototype.init = function(e, t) {
    var i = this;
    this.constraint = e, this.value = t, this.el.on("mousedown.drag", function(s) {
      i.start(s);
    }), this.el.on("touchstart.drag", function(s) {
      i.start(s);
    });
  }, a.prototype.transformPoint = function(e, t) {
    e = e || window.event;
    var i = e.changedTouches && e.changedTouches[0] || e;
    return this.p.x = i.clientX - (t || 0), this.p.y = i.clientY, this.p.matrixTransform(this.m);
  }, a.prototype.getBBox = function() {
    var e = this.el.bbox();
    return this.el instanceof SVG.Nested && (e = this.el.rbox()), (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (e.x = this.el.x(), e.y = this.el.y()), e;
  }, a.prototype.start = function(e) {
    if (!((e.type == "click" || e.type == "mousedown" || e.type == "mousemove") && (e.which || e.buttons) != 1)) {
      var t = this;
      if (this.el.fire("beforedrag", { event: e, handler: this }), !this.el.event().defaultPrevented) {
        e.preventDefault(), e.stopPropagation(), this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc), this.p = this.parent.node.createSVGPoint(), this.m = this.el.node.getScreenCTM().inverse();
        var i = this.getBBox(), s;
        if (this.el instanceof SVG.Text)
          switch (s = this.el.node.getComputedTextLength(), this.el.attr("text-anchor")) {
            case "middle":
              s /= 2;
              break;
            case "start":
              s = 0;
              break;
          }
        this.startPoints = {
          // We take absolute coordinates since we are just using a delta here
          point: this.transformPoint(e, s),
          box: i,
          transform: this.el.transform()
        }, SVG.on(window, "mousemove.drag", function(n) {
          t.drag(n);
        }), SVG.on(window, "touchmove.drag", function(n) {
          t.drag(n);
        }), SVG.on(window, "mouseup.drag", function(n) {
          t.end(n);
        }), SVG.on(window, "touchend.drag", function(n) {
          t.end(n);
        }), this.el.fire("dragstart", { event: e, p: this.startPoints.point, m: this.m, handler: this });
      }
    }
  }, a.prototype.drag = function(e) {
    var t = this.getBBox(), i = this.transformPoint(e), s = this.startPoints.box.x + i.x - this.startPoints.point.x, n = this.startPoints.box.y + i.y - this.startPoints.point.y, o = this.constraint, l = i.x - this.startPoints.point.x, c = i.y - this.startPoints.point.y;
    if (this.el.fire("dragmove", {
      event: e,
      p: i,
      m: this.m,
      handler: this
    }), this.el.event().defaultPrevented)
      return i;
    if (typeof o == "function") {
      var d = o.call(this.el, s, n, this.m);
      typeof d == "boolean" && (d = {
        x: d,
        y: d
      }), d.x === !0 ? this.el.x(s) : d.x !== !1 && this.el.x(d.x), d.y === !0 ? this.el.y(n) : d.y !== !1 && this.el.y(d.y);
    } else
      typeof o == "object" && (o.minX != null && s < o.minX ? (s = o.minX, l = s - this.startPoints.box.x) : o.maxX != null && s > o.maxX - t.width && (s = o.maxX - t.width, l = s - this.startPoints.box.x), o.minY != null && n < o.minY ? (n = o.minY, c = n - this.startPoints.box.y) : o.maxY != null && n > o.maxY - t.height && (n = o.maxY - t.height, c = n - this.startPoints.box.y), o.snapToGrid != null && (s = s - s % o.snapToGrid, n = n - n % o.snapToGrid, l = l - l % o.snapToGrid, c = c - c % o.snapToGrid), this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({ x: l, y: c }, !0) : this.el.move(s, n));
    return i;
  }, a.prototype.end = function(e) {
    var t = this.drag(e);
    this.el.fire("dragend", { event: e, p: t, m: this.m, handler: this }), SVG.off(window, "mousemove.drag"), SVG.off(window, "touchmove.drag"), SVG.off(window, "mouseup.drag"), SVG.off(window, "touchend.drag");
  }, SVG.extend(SVG.Element, {
    // Make element draggable
    // Constraint might be an object (as described in readme.md) or a function in the form "function (x, y)" that gets called before every move.
    // The function can return a boolean or an object of the form {x, y}, to which the element will be moved. "False" skips moving, true moves to raw x, y.
    draggable: function(e, t) {
      (typeof e == "function" || typeof e == "object") && (t = e, e = !0);
      var i = this.remember("_draggable") || new a(this);
      return e = typeof e > "u" ? !0 : e, e ? i.init(t || {}, e) : (this.off("mousedown.drag"), this.off("touchstart.drag")), this;
    }
  });
}).call(globalThis);
(function() {
  function a(e) {
    this.el = e, e.remember("_selectHandler", this), this.pointSelection = { isSelected: !1 }, this.rectSelection = { isSelected: !1 }, this.pointsList = {
      lt: [0, 0],
      rt: ["width", 0],
      rb: ["width", "height"],
      lb: [0, "height"],
      t: ["width", 0],
      r: ["width", "height"],
      b: ["width", "height"],
      l: [0, "height"]
    }, this.pointCoord = function(t, i, s) {
      var n = typeof t != "string" ? t : i[t];
      return s ? n / 2 : n;
    }, this.pointCoords = function(t, i) {
      var s = this.pointsList[t];
      return {
        x: this.pointCoord(s[0], i, t === "t" || t === "b"),
        y: this.pointCoord(s[1], i, t === "r" || t === "l")
      };
    };
  }
  a.prototype.init = function(e, t) {
    var i = this.el.bbox();
    this.options = {};
    var s = this.el.selectize.defaults.points;
    for (var n in this.el.selectize.defaults)
      this.options[n] = this.el.selectize.defaults[n], t[n] !== void 0 && (this.options[n] = t[n]);
    var o = ["points", "pointsExclude"];
    for (var n in o) {
      var l = this.options[o[n]];
      typeof l == "string" ? l.length > 0 ? l = l.split(/\s*,\s*/i) : l = [] : typeof l == "boolean" && o[n] === "points" && (l = l ? s : []), this.options[o[n]] = l;
    }
    this.options.points = [s, this.options.points].reduce(
      function(c, d) {
        return c.filter(
          function(f) {
            return d.indexOf(f) > -1;
          }
        );
      }
    ), this.options.points = [this.options.points, this.options.pointsExclude].reduce(
      function(c, d) {
        return c.filter(
          function(f) {
            return d.indexOf(f) < 0;
          }
        );
      }
    ), this.parent = this.el.parent(), this.nested = this.nested || this.parent.group(), this.nested.matrix(new SVG.Matrix(this.el).translate(i.x, i.y)), this.options.deepSelect && ["line", "polyline", "polygon"].indexOf(this.el.type) !== -1 ? this.selectPoints(e) : this.selectRect(e), this.observe(), this.cleanup();
  }, a.prototype.selectPoints = function(e) {
    return this.pointSelection.isSelected = e, this.pointSelection.set ? this : (this.pointSelection.set = this.parent.set(), this.drawPoints(), this);
  }, a.prototype.getPointArray = function() {
    var e = this.el.bbox();
    return this.el.array().valueOf().map(function(t) {
      return [t[0] - e.x, t[1] - e.y];
    });
  }, a.prototype.drawPoints = function() {
    for (var e = this, t = this.getPointArray(), i = 0, s = t.length; i < s; ++i) {
      var n = function(l) {
        return function(c) {
          c = c || window.event, c.preventDefault ? c.preventDefault() : c.returnValue = !1, c.stopPropagation();
          var d = c.pageX || c.touches[0].pageX, f = c.pageY || c.touches[0].pageY;
          e.el.fire("point", { x: d, y: f, i: l, event: c });
        };
      }(i), o = this.drawPoint(t[i][0], t[i][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + "_point").on("touchstart", n).on("mousedown", n);
      this.pointSelection.set.add(o);
    }
  }, a.prototype.drawPoint = function(e, t) {
    var i = this.options.pointType;
    switch (i) {
      case "circle":
        return this.drawCircle(e, t);
      case "rect":
        return this.drawRect(e, t);
      default:
        if (typeof i == "function")
          return i.call(this, e, t);
        throw new Error("Unknown " + i + " point type!");
    }
  }, a.prototype.drawCircle = function(e, t) {
    return this.nested.circle(this.options.pointSize).center(e, t);
  }, a.prototype.drawRect = function(e, t) {
    return this.nested.rect(this.options.pointSize, this.options.pointSize).center(e, t);
  }, a.prototype.updatePointSelection = function() {
    var e = this.getPointArray();
    this.pointSelection.set.each(function(t) {
      this.cx() === e[t][0] && this.cy() === e[t][1] || this.center(e[t][0], e[t][1]);
    });
  }, a.prototype.updateRectSelection = function() {
    var e = this, t = this.el.bbox();
    if (this.rectSelection.set.get(0).attr({
      width: t.width,
      height: t.height
    }), this.options.points.length && this.options.points.map(function(s, n) {
      var o = e.pointCoords(s, t);
      e.rectSelection.set.get(n + 1).center(o.x, o.y);
    }), this.options.rotationPoint) {
      var i = this.rectSelection.set.length();
      this.rectSelection.set.get(i - 1).center(t.width / 2, 20);
    }
  }, a.prototype.selectRect = function(e) {
    var t = this, i = this.el.bbox();
    this.rectSelection.isSelected = e, this.rectSelection.set = this.rectSelection.set || this.parent.set();
    function s(d) {
      return function(f) {
        f = f || window.event, f.preventDefault ? f.preventDefault() : f.returnValue = !1, f.stopPropagation();
        var p = f.pageX || f.touches[0].pageX, m = f.pageY || f.touches[0].pageY;
        t.el.fire(d, { x: p, y: m, event: f });
      };
    }
    if (this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(i.width, i.height).addClass(this.options.classRect)), this.options.points.length && this.rectSelection.set.length() < 2) {
      var n = "touchstart", o = "mousedown";
      this.options.points.map(function(d, f) {
        var p = t.pointCoords(d, i), m = t.drawPoint(p.x, p.y).attr("class", t.options.classPoints + "_" + d).on(o, s(d)).on(n, s(d));
        t.rectSelection.set.add(m);
      }), this.rectSelection.set.each(function() {
        this.addClass(t.options.classPoints);
      });
    }
    if (this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
      var l = function(d) {
        d = d || window.event, d.preventDefault ? d.preventDefault() : d.returnValue = !1, d.stopPropagation();
        var f = d.pageX || d.touches[0].pageX, p = d.pageY || d.touches[0].pageY;
        t.el.fire("rot", { x: f, y: p, event: d });
      }, c = this.drawPoint(i.width / 2, 20).attr("class", this.options.classPoints + "_rot").on("touchstart", l).on("mousedown", l);
      this.rectSelection.set.add(c);
    }
  }, a.prototype.handler = function() {
    var e = this.el.bbox();
    this.nested.matrix(new SVG.Matrix(this.el).translate(e.x, e.y)), this.rectSelection.isSelected && this.updateRectSelection(), this.pointSelection.isSelected && this.updatePointSelection();
  }, a.prototype.observe = function() {
    var e = this;
    if (MutationObserver)
      if (this.rectSelection.isSelected || this.pointSelection.isSelected)
        this.observerInst = this.observerInst || new MutationObserver(function() {
          e.handler();
        }), this.observerInst.observe(this.el.node, { attributes: !0 });
      else
        try {
          this.observerInst.disconnect(), delete this.observerInst;
        } catch {
        }
    else
      this.el.off("DOMAttrModified.select"), (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on("DOMAttrModified.select", function() {
        e.handler();
      });
  }, a.prototype.cleanup = function() {
    !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each(function() {
      this.remove();
    }), this.rectSelection.set.clear(), delete this.rectSelection.set), !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each(function() {
      this.remove();
    }), this.pointSelection.set.clear(), delete this.pointSelection.set), !this.pointSelection.isSelected && !this.rectSelection.isSelected && (this.nested.remove(), delete this.nested);
  }, SVG.extend(SVG.Element, {
    // Select element with mouse
    selectize: function(e, t) {
      typeof e == "object" && (t = e, e = !0);
      var i = this.remember("_selectHandler") || new a(this);
      return i.init(e === void 0 ? !0 : e, t || {}), this;
    }
  }), SVG.Element.prototype.selectize.defaults = {
    points: ["lt", "rt", "rb", "lb", "t", "r", "b", "l"],
    // which points to draw, default all
    pointsExclude: [],
    // easier option if to exclude few than rewrite all
    classRect: "svg_select_boundingRect",
    // Css-class added to the rect
    classPoints: "svg_select_points",
    // Css-class added to the points
    pointSize: 7,
    // size of point
    rotationPoint: !0,
    // If true, rotation point is drawn. Needed for rotation!
    deepSelect: !1,
    // If true, moving of single points is possible (only line, polyline, polyon)
    pointType: "circle"
    // Point type: circle or rect, default circle
  };
})();
(function() {
  (function() {
    function a(e) {
      e.remember("_resizeHandler", this), this.el = e, this.parameters = {}, this.lastUpdateCall = null, this.p = e.doc().node.createSVGPoint();
    }
    a.prototype.transformPoint = function(e, t, i) {
      return this.p.x = e - (this.offset.x - window.pageXOffset), this.p.y = t - (this.offset.y - window.pageYOffset), this.p.matrixTransform(i || this.m);
    }, a.prototype._extractPosition = function(e) {
      return {
        x: e.clientX != null ? e.clientX : e.touches[0].clientX,
        y: e.clientY != null ? e.clientY : e.touches[0].clientY
      };
    }, a.prototype.init = function(e) {
      var t = this;
      if (this.stop(), e !== "stop") {
        this.options = {};
        for (var i in this.el.resize.defaults)
          this.options[i] = this.el.resize.defaults[i], typeof e[i] < "u" && (this.options[i] = e[i]);
        this.el.on("lt.resize", function(s) {
          t.resize(s || window.event);
        }), this.el.on("rt.resize", function(s) {
          t.resize(s || window.event);
        }), this.el.on("rb.resize", function(s) {
          t.resize(s || window.event);
        }), this.el.on("lb.resize", function(s) {
          t.resize(s || window.event);
        }), this.el.on("t.resize", function(s) {
          t.resize(s || window.event);
        }), this.el.on("r.resize", function(s) {
          t.resize(s || window.event);
        }), this.el.on("b.resize", function(s) {
          t.resize(s || window.event);
        }), this.el.on("l.resize", function(s) {
          t.resize(s || window.event);
        }), this.el.on("rot.resize", function(s) {
          t.resize(s || window.event);
        }), this.el.on("point.resize", function(s) {
          t.resize(s || window.event);
        }), this.update();
      }
    }, a.prototype.stop = function() {
      return this.el.off("lt.resize"), this.el.off("rt.resize"), this.el.off("rb.resize"), this.el.off("lb.resize"), this.el.off("t.resize"), this.el.off("r.resize"), this.el.off("b.resize"), this.el.off("l.resize"), this.el.off("rot.resize"), this.el.off("point.resize"), this;
    }, a.prototype.resize = function(e) {
      var t = this;
      this.m = this.el.node.getScreenCTM().inverse(), this.offset = { x: window.pageXOffset, y: window.pageYOffset };
      var i = this._extractPosition(e.detail.event);
      if (this.parameters = {
        type: this.el.type,
        // the type of element
        p: this.transformPoint(i.x, i.y),
        x: e.detail.x,
        // x-position of the mouse when resizing started
        y: e.detail.y,
        // y-position of the mouse when resizing started
        box: this.el.bbox(),
        // The bounding-box of the element
        rotation: this.el.transform().rotation
        // The current rotation of the element
      }, this.el.type === "text" && (this.parameters.fontSize = this.el.attr()["font-size"]), e.detail.i !== void 0) {
        var s = this.el.array().valueOf();
        this.parameters.i = e.detail.i, this.parameters.pointCoords = [s[e.detail.i][0], s[e.detail.i][1]];
      }
      switch (e.type) {
        case "lt":
          this.calc = function(n, o) {
            var l = this.snapToGrid(n, o);
            if (this.parameters.box.width - l[0] > 0 && this.parameters.box.height - l[1] > 0) {
              if (this.parameters.type === "text") {
                this.el.move(this.parameters.box.x + l[0], this.parameters.box.y), this.el.attr("font-size", this.parameters.fontSize - l[0]);
                return;
              }
              l = this.checkAspectRatio(l), this.el.move(this.parameters.box.x + l[0], this.parameters.box.y + l[1]).size(this.parameters.box.width - l[0], this.parameters.box.height - l[1]);
            }
          };
          break;
        case "rt":
          this.calc = function(n, o) {
            var l = this.snapToGrid(n, o, 2);
            if (this.parameters.box.width + l[0] > 0 && this.parameters.box.height - l[1] > 0) {
              if (this.parameters.type === "text") {
                this.el.move(this.parameters.box.x - l[0], this.parameters.box.y), this.el.attr("font-size", this.parameters.fontSize + l[0]);
                return;
              }
              l = this.checkAspectRatio(l, !0), this.el.move(this.parameters.box.x, this.parameters.box.y + l[1]).size(this.parameters.box.width + l[0], this.parameters.box.height - l[1]);
            }
          };
          break;
        case "rb":
          this.calc = function(n, o) {
            var l = this.snapToGrid(n, o, 0);
            if (this.parameters.box.width + l[0] > 0 && this.parameters.box.height + l[1] > 0) {
              if (this.parameters.type === "text") {
                this.el.move(this.parameters.box.x - l[0], this.parameters.box.y), this.el.attr("font-size", this.parameters.fontSize + l[0]);
                return;
              }
              l = this.checkAspectRatio(l), this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + l[0], this.parameters.box.height + l[1]);
            }
          };
          break;
        case "lb":
          this.calc = function(n, o) {
            var l = this.snapToGrid(n, o, 1);
            if (this.parameters.box.width - l[0] > 0 && this.parameters.box.height + l[1] > 0) {
              if (this.parameters.type === "text") {
                this.el.move(this.parameters.box.x + l[0], this.parameters.box.y), this.el.attr("font-size", this.parameters.fontSize - l[0]);
                return;
              }
              l = this.checkAspectRatio(l, !0), this.el.move(this.parameters.box.x + l[0], this.parameters.box.y).size(this.parameters.box.width - l[0], this.parameters.box.height + l[1]);
            }
          };
          break;
        case "t":
          this.calc = function(n, o) {
            var l = this.snapToGrid(n, o, 2);
            if (this.parameters.box.height - l[1] > 0) {
              if (this.parameters.type === "text")
                return;
              this.el.move(this.parameters.box.x, this.parameters.box.y + l[1]).height(this.parameters.box.height - l[1]);
            }
          };
          break;
        case "r":
          this.calc = function(n, o) {
            var l = this.snapToGrid(n, o, 0);
            if (this.parameters.box.width + l[0] > 0) {
              if (this.parameters.type === "text")
                return;
              this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + l[0]);
            }
          };
          break;
        case "b":
          this.calc = function(n, o) {
            var l = this.snapToGrid(n, o, 0);
            if (this.parameters.box.height + l[1] > 0) {
              if (this.parameters.type === "text")
                return;
              this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + l[1]);
            }
          };
          break;
        case "l":
          this.calc = function(n, o) {
            var l = this.snapToGrid(n, o, 1);
            if (this.parameters.box.width - l[0] > 0) {
              if (this.parameters.type === "text")
                return;
              this.el.move(this.parameters.box.x + l[0], this.parameters.box.y).width(this.parameters.box.width - l[0]);
            }
          };
          break;
        case "rot":
          this.calc = function(n, o) {
            var l = { x: n + this.parameters.p.x, y: o + this.parameters.p.y }, c = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2), d = Math.atan2(l.y - this.parameters.box.y - this.parameters.box.height / 2, l.x - this.parameters.box.x - this.parameters.box.width / 2), f = this.parameters.rotation + (d - c) * 180 / Math.PI + this.options.snapToAngle / 2;
            this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(f - f % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy);
          };
          break;
        case "point":
          this.calc = function(n, o) {
            var l = this.snapToGrid(n, o, this.parameters.pointCoords[0], this.parameters.pointCoords[1]), c = this.el.array().valueOf();
            c[this.parameters.i][0] = this.parameters.pointCoords[0] + l[0], c[this.parameters.i][1] = this.parameters.pointCoords[1] + l[1], this.el.plot(c);
          };
      }
      this.el.fire("resizestart", { dx: this.parameters.x, dy: this.parameters.y, event: e }), SVG.on(window, "touchmove.resize", function(n) {
        t.update(n || window.event);
      }), SVG.on(window, "touchend.resize", function() {
        t.done();
      }), SVG.on(window, "mousemove.resize", function(n) {
        t.update(n || window.event);
      }), SVG.on(window, "mouseup.resize", function() {
        t.done();
      });
    }, a.prototype.update = function(e) {
      if (!e) {
        this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]);
        return;
      }
      var t = this._extractPosition(e), i = this.transformPoint(t.x, t.y), s = i.x - this.parameters.p.x, n = i.y - this.parameters.p.y;
      this.lastUpdateCall = [s, n], this.calc(s, n), this.el.fire("resizing", { dx: s, dy: n, event: e });
    }, a.prototype.done = function() {
      this.lastUpdateCall = null, SVG.off(window, "mousemove.resize"), SVG.off(window, "mouseup.resize"), SVG.off(window, "touchmove.resize"), SVG.off(window, "touchend.resize"), this.el.fire("resizedone");
    }, a.prototype.snapToGrid = function(e, t, i, s) {
      var n;
      return typeof s < "u" ? n = [(i + e) % this.options.snapToGrid, (s + t) % this.options.snapToGrid] : (i = i ?? 3, n = [(this.parameters.box.x + e + (i & 1 ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + t + (i & 2 ? 0 : this.parameters.box.height)) % this.options.snapToGrid]), e < 0 && (n[0] -= this.options.snapToGrid), t < 0 && (n[1] -= this.options.snapToGrid), e -= Math.abs(n[0]) < this.options.snapToGrid / 2 ? n[0] : n[0] - (e < 0 ? -this.options.snapToGrid : this.options.snapToGrid), t -= Math.abs(n[1]) < this.options.snapToGrid / 2 ? n[1] : n[1] - (t < 0 ? -this.options.snapToGrid : this.options.snapToGrid), this.constraintToBox(e, t, i, s);
    }, a.prototype.constraintToBox = function(e, t, i, s) {
      var n = this.options.constraint || {}, o, l;
      return typeof s < "u" ? (o = i, l = s) : (o = this.parameters.box.x + (i & 1 ? 0 : this.parameters.box.width), l = this.parameters.box.y + (i & 2 ? 0 : this.parameters.box.height)), typeof n.minX < "u" && o + e < n.minX && (e = n.minX - o), typeof n.maxX < "u" && o + e > n.maxX && (e = n.maxX - o), typeof n.minY < "u" && l + t < n.minY && (t = n.minY - l), typeof n.maxY < "u" && l + t > n.maxY && (t = n.maxY - l), [e, t];
    }, a.prototype.checkAspectRatio = function(e, t) {
      if (!this.options.saveAspectRatio)
        return e;
      var i = e.slice(), s = this.parameters.box.width / this.parameters.box.height, n = this.parameters.box.width + e[0], o = this.parameters.box.height - e[1], l = n / o;
      return l < s ? (i[1] = n / s - this.parameters.box.height, t && (i[1] = -i[1])) : l > s && (i[0] = this.parameters.box.width - o * s, t && (i[0] = -i[0])), i;
    }, SVG.extend(SVG.Element, {
      // Resize element with mouse
      resize: function(e) {
        return (this.remember("_resizeHandler") || new a(this)).init(e || {}), this;
      }
    }), SVG.Element.prototype.resize.defaults = {
      snapToAngle: 0.1,
      // Specifies the speed the rotation is happening when moving the mouse
      snapToGrid: 1,
      // Snaps to a grid of `snapToGrid` Pixels
      constraint: {},
      // keep element within constrained box
      saveAspectRatio: !1
      // Save aspect ratio when resizing using lt, rt, rb or lb points
    };
  }).call(this);
})();
typeof window.Apex > "u" && (window.Apex = {});
class Kf {
  constructor(e) {
    this.ctx = e, this.w = e.w;
  }
  initModules() {
    this.ctx.publicMethods = [
      "updateOptions",
      "updateSeries",
      "appendData",
      "appendSeries",
      "isSeriesHidden",
      "toggleSeries",
      "showSeries",
      "hideSeries",
      "setLocale",
      "resetSeries",
      "zoomX",
      "toggleDataPointSelection",
      "dataURI",
      "exportToCSV",
      "addXaxisAnnotation",
      "addYaxisAnnotation",
      "addPointAnnotation",
      "clearAnnotations",
      "removeAnnotation",
      "paper",
      "destroy"
    ], this.ctx.eventList = [
      "click",
      "mousedown",
      "mousemove",
      "mouseleave",
      "touchstart",
      "touchmove",
      "touchleave",
      "mouseup",
      "touchend"
    ], this.ctx.animations = new cr(this.ctx), this.ctx.axes = new aL(this.ctx), this.ctx.core = new FL(this.ctx.el, this.ctx), this.ctx.config = new Ur({}), this.ctx.data = new $v(this.ctx), this.ctx.grid = new Ev(this.ctx), this.ctx.graphics = new K(this.ctx), this.ctx.coreUtils = new vt(this.ctx), this.ctx.crosshairs = new mh(this.ctx), this.ctx.events = new nL(this.ctx), this.ctx.exports = new Eo(this.ctx), this.ctx.localization = new rL(this.ctx), this.ctx.options = new Gs(), this.ctx.responsive = new oL(this.ctx), this.ctx.series = new mi(this.ctx), this.ctx.theme = new lL(this.ctx), this.ctx.formatters = new ba(this.ctx), this.ctx.titleSubtitle = new cL(this.ctx), this.ctx.legend = new Lv(this.ctx), this.ctx.toolbar = new Mv(this.ctx), this.ctx.tooltip = new Uf(this.ctx), this.ctx.dimensions = new Po(this.ctx), this.ctx.updateHelpers = new WL(this.ctx), this.ctx.zoomPanSelection = new wL(this.ctx), this.ctx.w.globals.tooltip = new Uf(this.ctx);
  }
}
class Jf {
  constructor(e) {
    this.ctx = e, this.w = e.w;
  }
  clear({ isUpdating: e }) {
    this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({ isUpdating: e });
  }
  killSVG(e) {
    e.each(function(t, i) {
      this.removeClass("*"), this.off(), this.stop();
    }, !0), e.ungroup(), e.clear();
  }
  clearDomElements({ isUpdating: e }) {
    const t = this.w.globals.dom.Paper.node;
    t.parentNode && t.parentNode.parentNode && !e && (t.parentNode.parentNode.style.minHeight = "unset");
    const i = this.w.globals.dom.baseEl;
    i && this.ctx.eventList.forEach((n) => {
      i.removeEventListener(n, this.ctx.events.documentEvent);
    });
    const s = this.w.globals.dom;
    if (this.ctx.el !== null)
      for (; this.ctx.el.firstChild; )
        this.ctx.el.removeChild(this.ctx.el.firstChild);
    this.killSVG(s.Paper), s.Paper.remove(), s.elWrap = null, s.elGraphical = null, s.elLegendWrap = null, s.elLegendForeign = null, s.baseEl = null, s.elGridRect = null, s.elGridRectMask = null, s.elGridRectMarkerMask = null, s.elForecastMask = null, s.elNonForecastMask = null, s.elDefs = null;
  }
}
let yh = /* @__PURE__ */ new WeakMap();
function zL(a, e) {
  let t = !1;
  if (a.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
    const s = a.getBoundingClientRect();
    (a.style.display === "none" || s.width === 0) && (t = !0);
  }
  let i = new ResizeObserver((s) => {
    t && e.call(a, s), t = !0;
  });
  a.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(a.children).forEach((s) => i.observe(s)) : i.observe(a), yh.set(e, i);
}
function XL(a, e) {
  let t = yh.get(e);
  t && (t.disconnect(), yh.delete(e));
}
const YL = "";
let VL = class Wv {
  constructor(e, t) {
    this.opts = t, this.ctx = this, this.w = new sL(t).init(), this.el = e, this.w.globals.cuid = N.randomId(), this.w.globals.chartID = this.w.config.chart.id ? N.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new Kf(this).initModules(), this.create = N.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this);
  }
  /**
   * The primary method user will call to render the chart.
   */
  render() {
    return new Promise((e, t) => {
      var i;
      if (this.el !== null) {
        typeof Apex._chartInstances > "u" && (Apex._chartInstances = []), this.w.config.chart.id && Apex._chartInstances.push({
          id: this.w.globals.chartID,
          group: this.w.config.chart.group,
          chart: this
        }), this.setLocale(this.w.config.chart.defaultLocale);
        const s = this.w.config.chart.events.beforeMount;
        typeof s == "function" && s(this, this.w), this.events.fireEvent("beforeMount", [this, this.w]), window.addEventListener("resize", this.windowResizeHandler), zL(this.el.parentNode, this.parentResizeHandler);
        let n = this.el.getRootNode && this.el.getRootNode(), o = N.is("ShadowRoot", n), l = this.el.ownerDocument, c = o ? n.getElementById("apexcharts-css") : l.getElementById("apexcharts-css");
        if (!c) {
          c = document.createElement("style"), c.id = "apexcharts-css", c.textContent = YL;
          const f = ((i = this.opts.chart) == null ? void 0 : i.nonce) || this.w.config.chart.nonce;
          f && c.setAttribute("nonce", f), o ? n.prepend(c) : l.head.appendChild(c);
        }
        let d = this.create(this.w.config.series, {});
        if (!d)
          return e(this);
        this.mount(d).then(() => {
          typeof this.w.config.chart.events.mounted == "function" && this.w.config.chart.events.mounted(this, this.w), this.events.fireEvent("mounted", [this, this.w]), e(d);
        }).catch((f) => {
          t(f);
        });
      } else
        t(new Error("Element not found"));
    });
  }
  create(e, t) {
    let i = this.w;
    new Kf(this).initModules();
    let n = this.w.globals;
    if (n.noData = !1, n.animationEnded = !1, this.responsive.checkResponsiveConfig(t), i.config.xaxis.convertedCatToNumeric && new jr(i.config).convertCatToNumericXaxis(i.config, this.ctx), this.el === null || (this.core.setupElements(), i.config.chart.type === "treemap" && (i.config.grid.show = !1, i.config.yaxis[0].show = !1), n.svgWidth === 0))
      return n.animationEnded = !0, null;
    const o = vt.checkComboSeries(e, i.config.chart.type);
    n.comboCharts = o.comboCharts, n.comboBarCount = o.comboBarCount;
    const l = e.every((r) => r.data && r.data.length === 0);
    (e.length === 0 || l) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(e), this.theme.init(), new va(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), (!n.noData || n.collapsedSeries.length === n.series.length || i.config.legend.showForSingleSeries) && this.legend.init(), this.series.hasAllSeriesEqualX(), n.axisCharts && (this.core.coreCalculations(), i.config.xaxis.type !== "category" && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = i.globals.minX, this.ctx.toolbar.maxX = i.globals.maxX), this.formatters.heatmapLabelFormatters(), new vt(this).getLargestMarkerSize(), this.dimensions.plotCoords();
    const f = this.core.xySettings();
    this.grid.createGridMask();
    const p = this.core.plotChartType(e, f), m = new Yn(this);
    m.bringForward(), i.config.dataLabels.background.enabled && m.dataLabelsBackground(), this.core.shiftGraphPosition();
    const v = {
      plot: {
        left: i.globals.translateX,
        top: i.globals.translateY,
        width: i.globals.gridWidth,
        height: i.globals.gridHeight
      }
    };
    return {
      elGraph: p,
      xyRatios: f,
      dimensions: v
    };
  }
  mount(e = null) {
    let t = this, i = t.w;
    return new Promise((s, n) => {
      var d, f;
      if (t.el === null)
        return n(
          new Error("Not enough data to display or target element not found")
        );
      (e === null || i.globals.allSeriesCollapsed) && t.series.handleNoData(), t.grid = new Ev(t);
      let o = t.grid.drawGrid();
      if (t.annotations = new iL(t), t.annotations.drawImageAnnos(), t.annotations.drawTextAnnos(), i.config.grid.position === "back" && (o && i.globals.dom.elGraphical.add(o.el), (d = o == null ? void 0 : o.elGridBorders) != null && d.node && i.globals.dom.elGraphical.add(o.elGridBorders)), Array.isArray(e.elGraph))
        for (let p = 0; p < e.elGraph.length; p++)
          i.globals.dom.elGraphical.add(e.elGraph[p]);
      else
        i.globals.dom.elGraphical.add(e.elGraph);
      i.config.grid.position === "front" && (o && i.globals.dom.elGraphical.add(o.el), (f = o == null ? void 0 : o.elGridBorders) != null && f.node && i.globals.dom.elGraphical.add(o.elGridBorders)), i.config.xaxis.crosshairs.position === "front" && t.crosshairs.drawXCrosshairs(), i.config.yaxis[0].crosshairs.position === "front" && t.crosshairs.drawYCrosshairs(), i.config.chart.type !== "treemap" && t.axes.drawAxis(i.config.chart.type, o);
      let l = new Zr(this.ctx, o), c = new Bd(this.ctx, o);
      if (o !== null && (l.xAxisLabelCorrections(o.xAxisTickWidth), c.setYAxisTextAlignments(), i.config.yaxis.map((p, m) => {
        i.globals.ignoreYAxisIndexes.indexOf(m) === -1 && c.yAxisTitleRotate(m, p.opposite);
      })), t.annotations.drawAxesAnnotations(), !i.globals.noData) {
        if (i.config.tooltip.enabled && !i.globals.noData && t.w.globals.tooltip.drawTooltip(e.xyRatios), i.globals.axisCharts && (i.globals.isXNumeric || i.config.xaxis.convertedCatToNumeric || i.globals.isRangeBar))
          (i.config.chart.zoom.enabled || i.config.chart.selection && i.config.chart.selection.enabled || i.config.chart.pan && i.config.chart.pan.enabled) && t.zoomPanSelection.init({
            xyRatios: e.xyRatios
          });
        else {
          const p = i.config.chart.toolbar.tools;
          [
            "zoom",
            "zoomin",
            "zoomout",
            "selection",
            "pan",
            "reset"
          ].forEach((v) => {
            p[v] = !1;
          });
        }
        i.config.chart.toolbar.show && !i.globals.allSeriesCollapsed && t.toolbar.createToolbar();
      }
      i.globals.memory.methodsToExec.length > 0 && i.globals.memory.methodsToExec.forEach((p) => {
        p.method(p.params, !1, p.context);
      }), !i.globals.axisCharts && !i.globals.noData && t.core.resizeNonAxisCharts(), s(t);
    });
  }
  /**
   * Destroy the chart instance by removing all elements which also clean up event listeners on those elements.
   */
  destroy() {
    window.removeEventListener("resize", this.windowResizeHandler), XL(this.el.parentNode, this.parentResizeHandler);
    const e = this.w.config.chart.id;
    e && Apex._chartInstances.forEach((t, i) => {
      t.id === N.escapeString(e) && Apex._chartInstances.splice(i, 1);
    }), new Jf(this.ctx).clear({ isUpdating: !1 });
  }
  /**
   * Allows users to update Options after the chart has rendered.
   *
   * @param {object} options - A new config object can be passed which will be merged with the existing config object
   * @param {boolean} redraw - should redraw from beginning or should use existing paths and redraw from there
   * @param {boolean} animate - should animate or not on updating Options
   */
  updateOptions(e, t = !1, i = !0, s = !0, n = !0) {
    const o = this.w;
    return o.globals.selection = void 0, e.series && (this.series.resetSeries(!1, !0, !1), e.series.length && e.series[0].data && (e.series = e.series.map((l, c) => this.updateHelpers._extendSeries(l, c))), this.updateHelpers.revertDefaultAxisMinMax()), e.xaxis && (e = this.updateHelpers.forceXAxisUpdate(e)), e.yaxis && (e = this.updateHelpers.forceYAxisUpdate(e)), o.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), e.theme && (e = this.theme.updateThemeOptions(e)), this.updateHelpers._updateOptions(
      e,
      t,
      i,
      s,
      n
    );
  }
  /**
   * Allows users to update Series after the chart has rendered.
   *
   * @param {array} series - New series which will override the existing
   */
  updateSeries(e = [], t = !0, i = !0) {
    return this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(
      e,
      t,
      i
    );
  }
  /**
   * Allows users to append a new series after the chart has rendered.
   *
   * @param {array} newSerie - New serie which will be appended to the existing series
   */
  appendSeries(e, t = !0, i = !0) {
    const s = this.w.config.series.slice();
    return s.push(e), this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(
      s,
      t,
      i
    );
  }
  /**
   * Allows users to append Data to series.
   *
   * @param {array} newData - New data in the same format as series
   */
  appendData(e, t = !0) {
    let i = this;
    i.w.globals.dataChanged = !0, i.series.getPreviousPaths();
    let s = i.w.config.series.slice();
    for (let n = 0; n < s.length; n++)
      if (e[n] !== null && typeof e[n] < "u")
        for (let o = 0; o < e[n].data.length; o++)
          s[n].data.push(e[n].data[o]);
    return i.w.config.series = s, t && (i.w.globals.initialSeries = N.clone(i.w.config.series)), this.update();
  }
  update(e) {
    return new Promise((t, i) => {
      new Jf(this.ctx).clear({ isUpdating: !0 });
      const s = this.create(this.w.config.series, e);
      if (!s)
        return t(this);
      this.mount(s).then(() => {
        typeof this.w.config.chart.events.updated == "function" && this.w.config.chart.events.updated(this, this.w), this.events.fireEvent("updated", [this, this.w]), this.w.globals.isDirty = !0, t(this);
      }).catch((n) => {
        i(n);
      });
    });
  }
  /**
   * Get all charts in the same "group" (including the instance which is called upon) to sync them when user zooms in/out or pan.
   */
  getSyncedCharts() {
    const e = this.getGroupedCharts();
    let t = [this];
    return e.length && (t = [], e.forEach((i) => {
      t.push(i);
    })), t;
  }
  /**
   * Get charts in the same "group" (excluding the instance which is called upon) to perform operations on the other charts of the same group (eg., tooltip hovering)
   */
  getGroupedCharts() {
    return Apex._chartInstances.filter((e) => {
      if (e.group)
        return !0;
    }).map((e) => this.w.config.chart.group === e.group ? e.chart : this);
  }
  static getChartByID(e) {
    const t = N.escapeString(e);
    if (!Apex._chartInstances)
      return;
    const i = Apex._chartInstances.filter((s) => s.id === t)[0];
    return i && i.chart;
  }
  /**
   * Allows the user to provide data attrs in the element and the chart will render automatically when this method is called by searching for the elements containing 'data-apexcharts' attribute
   */
  static initOnLoad() {
    const e = document.querySelectorAll("[data-apexcharts]");
    for (let t = 0; t < e.length; t++) {
      const i = e[t], s = JSON.parse(e[t].getAttribute("data-options"));
      new Wv(i, s).render();
    }
  }
  /**
   * This static method allows users to call chart methods without necessarily from the
   * instance of the chart in case user has assigned chartID to the targeted chart.
   * The chartID is used for mapping the instance stored in Apex._chartInstances global variable
   *
   * This is helpful in cases when you don't have reference of the chart instance
   * easily and need to call the method from anywhere.
   * For eg, in React/Vue applications when you have many parent/child components,
   * and need easy reference to other charts for performing dynamic operations
   *
   * @param {string} chartID - The unique identifier which will be used to call methods
   * on that chart instance
   * @param {function} fn - The method name to call
   * @param {object} opts - The parameters which are accepted in the original method will be passed here in the same order.
   */
  static exec(e, t, ...i) {
    const s = this.getChartByID(e);
    if (!s)
      return;
    s.w.globals.isExecCalled = !0;
    let n = null;
    return s.publicMethods.indexOf(t) !== -1 && (n = s[t](...i)), n;
  }
  static merge(e, t) {
    return N.extend(e, t);
  }
  toggleSeries(e) {
    return this.series.toggleSeries(e);
  }
  highlightSeriesOnLegendHover(e, t) {
    return this.series.toggleSeriesOnHover(e, t);
  }
  showSeries(e) {
    this.series.showSeries(e);
  }
  hideSeries(e) {
    this.series.hideSeries(e);
  }
  isSeriesHidden(e) {
    this.series.isSeriesHidden(e);
  }
  resetSeries(e = !0, t = !0) {
    this.series.resetSeries(e, t);
  }
  // Public method to add event listener on chart context
  addEventListener(e, t) {
    this.events.addEventListener(e, t);
  }
  // Public method to remove event listener on chart context
  removeEventListener(e, t) {
    this.events.removeEventListener(e, t);
  }
  addXaxisAnnotation(e, t = !0, i = void 0) {
    let s = this;
    i && (s = i), s.annotations.addXaxisAnnotationExternal(e, t, s);
  }
  addYaxisAnnotation(e, t = !0, i = void 0) {
    let s = this;
    i && (s = i), s.annotations.addYaxisAnnotationExternal(e, t, s);
  }
  addPointAnnotation(e, t = !0, i = void 0) {
    let s = this;
    i && (s = i), s.annotations.addPointAnnotationExternal(e, t, s);
  }
  clearAnnotations(e = void 0) {
    let t = this;
    e && (t = e), t.annotations.clearAnnotations(t);
  }
  removeAnnotation(e, t = void 0) {
    let i = this;
    t && (i = t), i.annotations.removeAnnotation(i, e);
  }
  getChartArea() {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner");
  }
  getSeriesTotalXRange(e, t) {
    return this.coreUtils.getSeriesTotalsXRange(e, t);
  }
  getHighestValueInSeries(e = 0) {
    return new gh(this.ctx).getMinYMaxY(e).highestY;
  }
  getLowestValueInSeries(e = 0) {
    return new gh(this.ctx).getMinYMaxY(e).lowestY;
  }
  getSeriesTotal() {
    return this.w.globals.seriesTotals;
  }
  toggleDataPointSelection(e, t) {
    return this.updateHelpers.toggleDataPointSelection(
      e,
      t
    );
  }
  zoomX(e, t) {
    this.ctx.toolbar.zoomUpdateOptions(e, t);
  }
  setLocale(e) {
    this.localization.setCurrentLocaleValues(e);
  }
  dataURI(e) {
    return new Eo(this.ctx).dataURI(e);
  }
  exportToCSV(e = {}) {
    return new Eo(this.ctx).exportToCSV(e);
  }
  paper() {
    return this.w.globals.dom.Paper;
  }
  _parentResizeCallback() {
    this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize();
  }
  /**
   * Handle window resize and re-draw the whole chart.
   */
  _windowResize() {
    clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout(() => {
      this.w.globals.resized = !0, this.w.globals.dataChanged = !1, this.ctx.update();
    }, 150);
  }
  _windowResizeHandler() {
    let { redrawOnWindowResize: e } = this.w.config.chart;
    typeof e == "function" && (e = e()), e && this._windowResize();
  }
};
const MH = j({
  __name: "Apexchart",
  props: {
    options: {},
    series: {},
    height: { default: "auto" },
    type: {}
  },
  setup(a) {
    var n;
    const e = a, t = `apex-${(n = yt()) == null ? void 0 : n.uid}`, i = Z({
      chart: {
        type: e.type
      },
      series: [
        {
          data: []
        }
      ],
      ...e.options
    }), s = Ci();
    return Lt(() => {
      i.value.chart && (i.value.chart.type = e.type, i.value.chart.height = e.height), s.value && s.value.updateSeries(e.series);
    }), at(() => {
      s.value = new VL(document.querySelector(`#${t}`), i.value), s.value.render();
    }), (o, l) => (M(), D("div", { id: t }));
  }
});
const ya = j({
  __name: "Dropdown",
  props: {
    dropUp: { type: Boolean },
    right: { type: Boolean },
    left: { type: Boolean },
    closeOn: { type: Boolean },
    noCloseOnClickTag: {},
    disabled: { type: Boolean }
  },
  emits: ["show", "hide"],
  setup(a, { expose: e, emit: t }) {
    var u, g;
    ol((b) => ({
      "1b45c305": f.value
    }));
    const i = a, s = t, n = Z(!1), o = `ui-dropdown-${(u = yt()) == null ? void 0 : u.uid}`, l = `ui-dropdown-${(g = yt()) == null ? void 0 : g.uid}-menu`, c = Z({});
    let d = 0;
    const f = ge(() => i.dropUp ? "-480px" : "unset"), p = (b) => {
      var O, x;
      b instanceof KeyboardEvent && b.key != "Escape" || i.closeOn && ((O = b.target) == null ? void 0 : O.tagName) == i.noCloseOnClickTag || ((x = b.target) == null ? void 0 : x.tagName) != "INPUT" && h();
    }, m = (b) => {
      n.value = b, b ? (s("show"), $s(v)) : s("hide");
    }, v = () => {
      const b = document.getElementById(l), O = b == null ? void 0 : b.getBoundingClientRect(), x = document.documentElement.clientHeight;
      d || (d = O == null ? void 0 : O.height);
      const S = x - (O == null ? void 0 : O.top) - 10, k = d < S ? d : S;
      c.value.height = `${k}px`;
    }, r = (b) => {
      if (i.disabled) {
        b.preventDefault(), b.stopPropagation();
        return;
      }
      n.value || (window.addEventListener("mouseup", p, !1), window.addEventListener("keydown", p, !1), window.addEventListener("wheel", v, !1)), m(!n.value);
    }, h = () => {
      setTimeout(() => {
        window.removeEventListener("wheel", v, !1), window.removeEventListener("keydown", p, !1), window.removeEventListener("mouseup", p, !1), m(!1);
      }, 100);
    };
    return e({
      hide: h
    }), (b, O) => (M(), D("div", {
      class: he(["ui-dropdown", { "-open": n.value, "-left": b.left, "-right": b.right }]),
      id: o
    }, [
      I("div", {
        class: "ui-dropdown-button",
        onClick: r
      }, [
        te(b.$slots, "button-content", { class: "ui-dropdown-menu" })
      ]),
      I("div", {
        class: "ui-dropdown-menu",
        id: l,
        style: wt(c.value)
      }, [
        te(b.$slots, "default")
      ], 4)
    ], 2));
  }
});
const HL = { class: "ui-dropdown-item-wrapper" }, GL = ["data-close"], jL = { class: "ui-dropdown-item-label" }, UL = j({
  __name: "DropdownItemButton",
  props: {
    label: {},
    close: { type: Boolean },
    class: {},
    leadingIcon: {}
  },
  setup(a) {
    return (e, t) => (M(), D("div", HL, [
      I("button", {
        class: he(["ui-dropdown-item -button", e.class]),
        type: "button",
        "data-close": e.close
      }, [
        te(e.$slots, "default", {}, () => [
          I("p", jL, ne(e.label), 1)
        ], !0),
        e.leadingIcon ? (M(), q(Pe, {
          key: 0,
          class: "leading-icon",
          name: e.leadingIcon,
          filled: ""
        }, null, 8, ["name"])) : X("", !0)
      ], 10, GL)
    ]));
  }
}), kl = /* @__PURE__ */ gt(UL, [["__scopeId", "data-v-38d8b38c"]]);
const ZL = { class: "titlebar" }, qL = { class: "titlebar-content" }, KL = { class: "titlebar-content-title" }, JL = { class: "titlebar-content-title-text" }, e2 = {
  key: 0,
  class: "titlebar-subtitle"
}, t2 = { class: "titlebar-actions" }, i2 = {
  key: 0,
  class: "titlebar-actions-secondary"
}, s2 = {
  key: 1,
  class: "titlebar-actions-primary"
}, ep = "more_vert", n2 = j({
  __name: "Titlebar",
  props: {
    title: {},
    to: {},
    backlink: {},
    primaryAction: {},
    secondaryActions: {},
    groupActions: {}
  },
  setup(a) {
    const e = () => window.innerWidth > 768, t = Ci(e()), i = ge(
      () => (s, n) => t.value || !n ? s : void 0
    );
    return at(() => {
      window.onresize = () => {
        t.value = e();
      };
    }), $m(() => {
      window.onresize = null;
    }), (s, n) => {
      var o, l;
      return M(), D("div", ZL, [
        I("div", qL, [
          s.backlink ? (M(), q(Ti, {
            key: 0,
            to: { name: s.backlink.to },
            icon: "arrow_back",
            size: "lg"
          }, null, 8, ["to"])) : X("", !0),
          I("div", KL, [
            I("h2", JL, ne(s.title), 1),
            s.$slots["titlebar-subtitle"] ? (M(), D("div", e2, [
              te(s.$slots, "titlebar-subtitle")
            ])) : X("", !0)
          ])
        ]),
        I("div", t2, [
          (o = s.secondaryActions) != null && o.length ? (M(), D("div", i2, [
            ((l = s.secondaryActions) == null ? void 0 : l.length) == 1 ? (M(!0), D(ke, { key: 0 }, Ae(s.secondaryActions, (c, d) => (M(), q(Le, {
              key: d,
              class: he(c.class),
              variant: "plain",
              label: i.value(c.label, c.leadingIcon),
              to: c.to,
              "leading-icon": c.leadingIcon,
              onClick: c.onAction
            }, null, 8, ["class", "label", "to", "leading-icon", "onClick"]))), 128)) : (M(), q(ya, { key: 1 }, {
              "button-content": U(() => [
                B(Le, {
                  label: i.value("Mais ações", ep),
                  trailingIcon: t.value ? "expand_more" : ep,
                  size: t.value ? "md" : "lg"
                }, null, 8, ["label", "trailingIcon", "size"])
              ]),
              default: U(() => [
                (M(!0), D(ke, null, Ae(s.secondaryActions, (c, d) => (M(), q(kl, {
                  key: d,
                  label: c.label,
                  onClick: c.onAction,
                  "leading-icon": c.leadingIcon,
                  class: he(c.class)
                }, null, 8, ["label", "onClick", "leading-icon", "class"]))), 128))
              ]),
              _: 1
            }))
          ])) : X("", !0),
          s.primaryAction ? (M(), D("div", s2, [
            B(Le, {
              variant: "primary",
              to: s.primaryAction.to,
              label: i.value(s.primaryAction.label, s.primaryAction.leadingIcon),
              onClick: s.primaryAction.onAction,
              class: he(s.primaryAction.class),
              "leading-icon": s.primaryAction.leadingIcon,
              size: t.value ? "md" : "lg"
            }, null, 8, ["to", "label", "onClick", "class", "leading-icon", "size"])
          ])) : X("", !0)
        ])
      ]);
    };
  }
});
const r2 = { class: "ui-empty-data-content" }, a2 = { class: "ui-empty-data-text" }, o2 = {
  key: 0,
  class: "ui-empty-data-caption"
}, l2 = {
  key: 1,
  class: "ui-empty-data-actions"
}, DH = j({
  __name: "EmptyData",
  props: {
    label: {},
    icon: {},
    caption: {},
    iconType: {},
    link: { type: Boolean },
    actions: {},
    noBorder: { type: Boolean }
  },
  setup(a) {
    return (e, t) => (M(), D("div", {
      class: he(["ui-empty-data", { "ui-empty-data-link": e.link, "-border": !e.noBorder }])
    }, [
      I("div", r2, [
        e.icon ? Ze((M(), q(Pe, {
          key: 0,
          name: e.icon,
          type: e.iconType,
          class: "ui-empty-data-icon",
          size: "24"
        }, null, 8, ["name", "type"])), [
          [bt, e.icon]
        ]) : X("", !0),
        I("p", a2, [
          te(e.$slots, "default", {}, () => [
            ye(ne(e.label), 1)
          ])
        ])
      ]),
      e.caption ? (M(), D("div", o2, [
        te(e.$slots, "caption", {}, () => [
          ye(ne(e.caption), 1)
        ])
      ])) : X("", !0),
      e.actions ? (M(), D("div", l2, [
        (M(!0), D(ke, null, Ae(e.actions, (i) => (M(), q(Le, {
          size: "sm",
          label: i.label,
          onClick: i.onAction
        }, null, 8, ["label", "onClick"]))), 256))
      ])) : X("", !0)
    ], 2));
  }
});
const c2 = j({
  __name: "Container",
  setup(a) {
    const e = Ci(["container"]);
    return (t, i) => (M(), D("div", {
      class: he(e.value)
    }, [
      te(t.$slots, "default")
    ], 2));
  }
});
const h2 = /* @__PURE__ */ I("div", { class: "ui-savebar-text" }, "Alterações feitas", -1), d2 = { class: "ui-savebar-actions" }, u2 = /* @__PURE__ */ I("div", null, "Descartar alterações", -1), f2 = j({
  __name: "Savebar",
  props: {
    loading: { type: Boolean },
    editing: { type: Boolean }
  },
  emits: ["discard", "save"],
  setup(a, { emit: e }) {
    const t = la("register") || {}, i = e, s = a, n = ge(() => {
      const c = t.editing || s.editing || !1;
      return c ? document.body.classList.add("is-editing") : document.body.classList.remove("is-editing"), c;
    }), o = () => {
      i("discard"), ha(t.discard) && t.discard();
    }, l = () => i("save");
    return (c, d) => (M(), D("div", {
      class: he(["ui-savebar", { "-show": n.value }])
    }, [
      B(c2, { class: "ui-savebar-container" }, {
        default: U(() => [
          h2,
          I("div", d2, [
            B(Le, {
              onClick: o,
              class: "ui-savebar-restore",
              disabled: c.loading
            }, {
              default: U(() => [
                u2
              ]),
              _: 1
            }, 8, ["disabled"]),
            B(Le, {
              variant: "success",
              type: "submit",
              leadingIcon: "check",
              label: "Salvar",
              loading: c.loading,
              onClick: l
            }, null, 8, ["loading"])
          ])
        ]),
        _: 1
      })
    ], 2));
  }
}), RH = j({
  __name: "FormRegister",
  props: {
    resource: {},
    validate: {},
    editing: { type: Boolean }
  },
  emits: ["save"],
  setup(a, { emit: e }) {
    const t = e, i = a, s = Z(), n = Z(null), o = Z(), l = async () => {
      if (!(!i.editing || !i.resource) && !s.value) {
        s.value = !0;
        try {
          t("save");
        } catch (c) {
          n.value = c;
        }
        setTimeout(() => {
          s.value = !1;
        }, 1e3);
      }
    };
    return (c, d) => (M(), D("form", {
      onSubmit: Xt(l, ["prevent"]),
      id: "form-register",
      class: "ui-form-register"
    }, [
      B(f2, { editing: c.editing }, null, 8, ["editing"]),
      B(Ob, {
        modelValue: n.value,
        "onUpdate:modelValue": d[0] || (d[0] = (f) => n.value = f),
        translate: c.validate
      }, null, 8, ["modelValue", "translate"]),
      te(c.$slots, "default"),
      I("button", {
        ref_key: "buttonSubmitRef",
        ref: o,
        tabindex: "-1",
        type: "submit",
        style: { opacity: "0", width: "0", height: "0", border: "none", padding: "0", position: "absolute" }
      }, null, 512)
    ], 32));
  }
});
const p2 = {
  key: 1,
  class: "new-indicator"
}, tp = j({
  __name: "NewsIndicator",
  props: {
    label: {}
  },
  setup(a) {
    return (e, t) => e.label ? (M(), q(Xw, {
      key: 0,
      label: e.label,
      variant: "highlight",
      size: "sm"
    }, null, 8, ["label"])) : (M(), D("div", p2));
  }
});
const g2 = { class: "ui-sidebar-mobile" }, m2 = ["onClick"], b2 = { class: "action-title" }, v2 = j({
  __name: "SidebarMobile",
  props: {
    mobileMenus: {}
  },
  emits: ["onClickAction"],
  setup(a, { emit: e }) {
    const t = e;
    return (i, s) => (M(), D("div", g2, [
      (M(!0), D(ke, null, Ae(i.mobileMenus, (n) => (M(), D("div", {
        key: n.title,
        class: "ui-sidebar-mobile-action",
        onClick: (o) => t("onClickAction", n)
      }, [
        B(Pe, {
          name: n.icon,
          size: "20",
          filled: ""
        }, null, 8, ["name"]),
        I("p", b2, ne(n.title), 1)
      ], 8, m2))), 128))
    ]));
  }
}), y2 = /* @__PURE__ */ gt(v2, [["__scopeId", "data-v-ca6183b4"]]);
const O2 = {
  class: "ui-sidebar",
  id: "ui-sidebar"
}, x2 = { class: "ui-sidebar-wrapper" }, w2 = { class: "ui-sidebar-container" }, S2 = { class: "ui-sidebar-content" }, k2 = { class: "ui-sidebar-nav" }, _2 = { class: "ui-sidebar-list" }, C2 = { class: "ui-sidebar-list -primary" }, T2 = {
  key: 0,
  class: "ui-sidebar-link-caption"
}, A2 = { class: "d-flex" }, $2 = { class: "ui-sidebar-link-icon" }, E2 = { class: "ui-sidebar-link-text -title" }, P2 = { class: "ui-sidebar-link-right-icons" }, L2 = {
  key: 0,
  class: "news-indicator"
}, M2 = {
  key: 1,
  class: "ui-sidebar-sublist"
}, D2 = { class: "ui-sidebar-link-icon" }, R2 = { class: "ui-sidebar-link-content" }, I2 = { class: "ui-sidebar-link-text" }, Q2 = { class: "ui-sidebar-footer" }, IH = j({
  __name: "Sidebar",
  props: {
    isActive: { type: Function },
    menuOpen: { type: Boolean },
    menus: {},
    mobileNavigationBar: {}
  },
  emits: ["onClickItem"],
  setup(a, { emit: e }) {
    const t = la("menu"), i = e, s = (c) => {
      t && (t == null || t.toggle(), i("onClickItem", "sub", c));
    }, n = (c, d) => {
      var f;
      i("onClickItem", c, d), (f = d == null ? void 0 : d.nodes) != null && f.length || t == null || t.toggle();
    }, o = (c) => {
      if (c.type === "action") {
        t == null || t.toggle();
        return;
      }
      i("onClickItem", "node", c), t.close();
    }, l = (c) => c.to ? "router-link" : "div";
    return (c, d) => (M(), D(ke, null, [
      I("div", O2, [
        I("div", x2, [
          I("div", w2, [
            I("div", S2, [
              I("div", k2, [
                I("div", {
                  class: "ui-sidebar-logo",
                  onClick: d[0] || (d[0] = (f) => n("logo"))
                }, [
                  te(c.$slots, "logo")
                ]),
                te(c.$slots, "select-button")
              ]),
              I("div", _2, [
                I("ul", C2, [
                  (M(!0), D(ke, null, Ae(c.menus, (f, p) => (M(), D("li", {
                    class: he(["ui-sidebar-item", [
                      {
                        "-disabled": f.disabled,
                        "-spacer": f.spacer,
                        "-spacer-last": f.last
                      },
                      f.to
                    ]]),
                    redirectLink: "",
                    key: p
                  }, [
                    f.caption ? (M(), D("small", T2, ne(f.caption), 1)) : X("", !0),
                    (M(), q(Ut(l(f)), {
                      class: he(["ui-sidebar-link", {
                        "-node-active": f.active,
                        "-active": f.active
                      }]),
                      to: { name: f.to },
                      activeClass: "-active",
                      onClick: (m) => n("node", f)
                    }, {
                      default: U(() => {
                        var m;
                        return [
                          I("div", A2, [
                            I("span", $2, [
                              B(Pe, {
                                size: "16",
                                name: f.icon,
                                filled: ""
                              }, null, 8, ["name"])
                            ]),
                            I("span", E2, ne(f.name), 1)
                          ]),
                          I("div", P2, [
                            f.isNew ? (M(), D("div", L2, [
                              B(tp)
                            ])) : X("", !0),
                            (m = f.nodes) != null && m.length ? (M(), q(Pe, {
                              key: 1,
                              class: "icon-arrow",
                              name: "expand_more"
                            })) : X("", !0)
                          ])
                        ];
                      }),
                      _: 2
                    }, 1032, ["to", "class", "onClick"])),
                    f.nodes && f.dropdown !== !1 ? (M(), D("ul", M2, [
                      (M(!0), D(ke, null, Ae(f.nodes, (m, v) => (M(), D("li", {
                        class: "ui-sidebar-item",
                        key: v
                      }, [
                        (M(), q(Ut(l(m)), {
                          to: { name: m.to },
                          class: he(["ui-sidebar-link -sub", {
                            "-active": c.isActive(m),
                            "-disabled": m.disabled
                          }]),
                          onClick: (r) => s(m)
                        }, {
                          default: U(() => [
                            I("span", D2, [
                              B(Pe, {
                                size: "16",
                                name: "subdirectory_arrow_right"
                              })
                            ]),
                            I("div", R2, [
                              I("span", I2, ne(m.name), 1),
                              m.isNew ? (M(), q(tp, {
                                key: 0,
                                label: "Novo"
                              })) : X("", !0)
                            ])
                          ]),
                          _: 2
                        }, 1032, ["to", "onClick", "class"]))
                      ]))), 128))
                    ])) : X("", !0)
                  ], 2))), 128))
                ])
              ]),
              I("div", Q2, [
                te(c.$slots, "footer", {
                  class: "ui-sidebar-footer",
                  onClick: d[1] || (d[1] = (f) => n("footer"))
                })
              ])
            ])
          ])
        ]),
        I("div", {
          class: "ui-sidebar-overlay",
          onClick: s
        })
      ]),
      B(y2, {
        "mobile-menus": c.mobileNavigationBar,
        onOnClickAction: o
      }, null, 8, ["mobile-menus"])
    ], 64));
  }
});
/*!
  * vue-router v4.3.0
  * (c) 2024 Eduardo San Martin Morote
  * @license MIT
  */
var ip;
(function(a) {
  a.pop = "pop", a.push = "push";
})(ip || (ip = {}));
var sp;
(function(a) {
  a.back = "back", a.forward = "forward", a.unknown = "";
})(sp || (sp = {}));
Symbol(process.env.NODE_ENV !== "production" ? "navigation failure" : "");
var np;
(function(a) {
  a[a.aborted = 4] = "aborted", a[a.cancelled = 8] = "cancelled", a[a.duplicated = 16] = "duplicated";
})(np || (np = {}));
Symbol(process.env.NODE_ENV !== "production" ? "router view location matched" : "");
Symbol(process.env.NODE_ENV !== "production" ? "router view depth" : "");
Symbol(process.env.NODE_ENV !== "production" ? "router" : "");
const N2 = Symbol(process.env.NODE_ENV !== "production" ? "route location" : "");
Symbol(process.env.NODE_ENV !== "production" ? "router view location" : "");
function rp() {
  return la(N2);
}
const F2 = (a, e = []) => {
  const t = Vr(a, e), i = [];
  Object.keys(t).map((n) => {
    t[n] != "" && t[n] != null && i.push(encodeURIComponent(n) + "=" + encodeURIComponent(t[n]));
  });
  let s = "";
  i.length && (s = `?${i.join("&")}`), history.replaceState({}, "", `${window.location.pathname}${s}`);
}, ap = {
  setObj: (a, e) => {
    (Array.isArray(e) || typeof e == "object") && (e = JSON.stringify(e)), localStorage.setItem(a, e);
  },
  getObj: (a) => {
    const e = localStorage.getItem(a);
    return e ? JSON.parse(e) : null;
  },
  set: (a, e) => {
    localStorage.setItem(a, e);
  },
  get: (a) => localStorage.getItem(a),
  remove: (a) => {
    localStorage.removeItem(a);
  }
};
const W2 = {
  key: 0,
  class: "ui-card-loading"
}, B2 = { class: "ui-card-header-content" }, z2 = { class: "ui-header-content-title" }, X2 = {
  key: 0,
  class: "ui-card-title"
}, Y2 = ["innerHTML"], V2 = ["innerHTML"], H2 = {
  key: 1,
  class: "ui-card-caption"
}, G2 = { class: "ui-card-header-content-button" }, j2 = {
  key: 2,
  type: "button",
  class: "btn-collapse"
}, U2 = { key: 0 }, Z2 = { key: 1 }, q2 = {
  key: 0,
  class: "ui-card-caption"
}, K2 = {
  key: 1,
  class: "ui-card-caption"
}, J2 = {
  key: 2,
  class: "ui-card-caption"
}, eM = { class: "ui-card-body" }, tM = {
  key: 2,
  class: "ui-card-footer"
}, Oa = j({
  __name: "Card",
  props: {
    title: {},
    titleMuted: {},
    caption: {},
    dropdown: { type: Boolean },
    dropdownLabel: {},
    dropdownClosed: { type: Boolean, default: !1 },
    fullHeight: { type: Boolean },
    fullWidth: { type: Boolean },
    noBorder: { type: Boolean },
    noPadding: { type: Boolean },
    closeCaption: {},
    gray: { type: Boolean },
    last: { type: Boolean },
    loading: { type: Boolean },
    transparent: { type: Boolean },
    plain: { type: Boolean },
    actions: {}
  },
  emits: ["toggleShowBody", "open", "close"],
  setup(a, { emit: e }) {
    var f;
    const t = e, i = a, s = Z(i.dropdown), n = Z(!i.dropdownClosed), o = `ui-card-${(f = yt()) == null ? void 0 : f.uid}`, l = oa(), c = (p = "default") => !!l[p], d = () => {
      t("toggleShowBody"), n.value || t("open"), n.value && t("close"), n.value = !n.value;
    };
    return Lt(() => n.value = !i.dropdownClosed), (p, m) => (M(), D("div", {
      class: he(["ui-card", {
        "-hide": !n.value,
        "-collapse": s.value,
        "-gray": p.gray,
        "-last": p.last,
        "-full-height": p.fullHeight,
        "-full-width": p.fullWidth,
        "-loading": p.loading,
        "-transparent": p.transparent,
        "-no-padding": p.noPadding,
        "-plain": p.plain
      }]),
      id: o
    }, [
      p.loading ? (M(), D("div", W2, [
        B(dn, { size: "50" })
      ])) : X("", !0),
      p.title || c("header-title") ? (M(), D("div", {
        key: 1,
        class: "ui-card-header",
        onClick: m[0] || (m[0] = (v) => s.value ? d() : null)
      }, [
        I("div", B2, [
          I("div", z2, [
            te(p.$slots, "header-title", {}, () => [
              p.title ? (M(), D("h4", X2, [
                I("span", null, ne(p.title), 1),
                p.titleMuted ? (M(), D("span", {
                  key: 0,
                  class: "muted",
                  innerHTML: p.titleMuted
                }, null, 8, Y2)) : X("", !0)
              ])) : X("", !0)
            ]),
            p.caption ? (M(), D("div", {
              key: 0,
              class: "ui-card-caption",
              innerHTML: p.caption
            }, null, 8, V2)) : X("", !0),
            c("caption") ? (M(), D("span", H2, [
              te(p.$slots, "caption")
            ])) : X("", !0)
          ]),
          I("div", G2, [
            p.actions ? (M(!0), D(ke, { key: 0 }, Ae(p.actions, (v) => (M(), q(Ai, {
              key: v.label,
              onClick: v.onAction
            }, {
              default: U(() => [
                ye(ne(v.label), 1)
              ]),
              _: 2
            }, 1032, ["onClick"]))), 128)) : X("", !0),
            c("header-button") ? te(p.$slots, "header-button", { key: 1 }) : X("", !0),
            s.value ? (M(), D("button", j2, [
              n.value ? (M(), D("div", U2, [
                B(Pe, {
                  class: "btn-collapse-icon",
                  name: "expand_less",
                  size: 24
                })
              ])) : X("", !0),
              n.value ? X("", !0) : (M(), D("div", Z2, [
                p.dropdownLabel ? (M(), q(Ai, { key: 0 }, {
                  default: U(() => [
                    ye(ne(p.dropdownLabel), 1)
                  ]),
                  _: 1
                })) : (M(), q(Pe, {
                  key: 1,
                  class: "btn-collapse-icon",
                  name: "expand_more",
                  size: 24
                }))
              ]))
            ])) : X("", !0)
          ])
        ]),
        p.closeCaption && !n.value ? (M(), D("div", q2, ne(p.closeCaption), 1)) : X("", !0),
        c("close-caption") && !n.value ? (M(), D("div", K2, [
          te(p.$slots, "close-caption")
        ])) : X("", !0),
        c("header-caption") ? (M(), D("div", J2, [
          te(p.$slots, "header-caption")
        ])) : X("", !0)
      ])) : X("", !0),
      Ze(I("div", eM, [
        te(p.$slots, "default")
      ], 512), [
        [bt, n.value]
      ]),
      c("footer") ? Ze((M(), D("div", tM, [
        te(p.$slots, "footer")
      ], 512)), [
        [bt, n.value]
      ]) : X("", !0)
    ], 2));
  }
});
const iM = /* @__PURE__ */ I("span", null, "Carregando dados da tabela", -1), sM = j({
  __name: "TableListNavLoader",
  props: {
    loading: { type: Boolean }
  },
  setup(a) {
    return (e, t) => (M(), D("div", {
      class: he(["table-list-loader", { "-show": e.loading }])
    }, [
      B(dn, {
        class: "table-list-loader-spinner",
        size: "24"
      }),
      iM
    ], 2));
  }
});
const nM = { class: "table-list-nav" }, rM = { class: "table-list-nav-wrapper" }, aM = { class: "table-list-nav-content" }, oM = j({
  __name: "TableListNav",
  props: {
    loading: { type: Boolean }
  },
  setup(a) {
    return (e, t) => (M(), D("div", nM, [
      I("div", rM, [
        I("div", aM, [
          te(e.$slots, "default")
        ]),
        B(sM, { loading: e.loading }, null, 8, ["loading"])
      ])
    ]));
  }
});
const lM = j({
  __name: "TableListTags",
  props: {
    state: {}
  },
  setup(a) {
    const e = a, t = e.state.removeFilter, i = (l) => {
      let c = l;
      return gi(e.state.config.filters, (d, f) => {
        l == f && (c = d.name);
      }), c;
    }, s = (l) => {
      let c = l.split("--");
      const d = tt.fromSQL(c[0]).toFormat("dd/MM/yyyy");
      if (c.length > 1) {
        const f = tt.fromSQL(c[1]).toFormat("dd/MM/yyyy");
        c = `${d} ~ ${f}`;
      } else
        c = d;
      return c;
    }, n = (l, c) => {
      const d = [];
      let f = [];
      return !e.state.config.filters || !e.state.config.filters[c] ? l : c == "created_at" ? s(l) : c == "q" || c == "category_ids" || ["text", "number"].indexOf(e.state.config.filters[c].type) >= 0 ? l : (isNaN(l) ? f = l.split(",") : f = [l], gi(e.state.config.filters, (p, m) => {
        m == c && (ha(p.filters) && (p.filters = p.filters()), gi(f, (v) => {
          isNaN(v) || (v = Number(v));
          const r = Mr(p.filters, { value: v });
          r && d.push(r.name);
        }));
      }), d.join(", "));
    }, o = ge(() => {
      const l = Vr(e.state.omitFilters, ["q"]);
      return Object.keys(l).length > 0;
    });
    return (l, c) => o.value ? (M(), q(t$, {
      key: 0,
      class: "table-list-tags"
    }, {
      default: U(() => [
        (M(!0), D(ke, null, Ae(l.state.omitFilters, (d, f) => Ze((M(), q(qA, {
          variant: "primary",
          onRemove: (p) => et(t)(String(f)),
          key: d
        }, {
          default: U(() => [
            ye(ne(i(String(f))) + ": " + ne(n(d, String(f))), 1)
          ]),
          _: 2
        }, 1032, ["onRemove"])), [
          [bt, String(f) != "q"]
        ])), 128))
      ]),
      _: 1
    })) : X("", !0);
  }
});
/*!
 * perfect-scrollbar v1.5.3
 * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors
 * Licensed under MIT
 */
function Ni(a) {
  return getComputedStyle(a);
}
function Vt(a, e) {
  for (var t in e) {
    var i = e[t];
    typeof i == "number" && (i = i + "px"), a.style[t] = i;
  }
  return a;
}
function Ya(a) {
  var e = document.createElement("div");
  return e.className = a, e;
}
var op = typeof Element < "u" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
function ks(a, e) {
  if (!op)
    throw new Error("No element matching method supported");
  return op.call(a, e);
}
function $n(a) {
  a.remove ? a.remove() : a.parentNode && a.parentNode.removeChild(a);
}
function lp(a, e) {
  return Array.prototype.filter.call(
    a.children,
    function(t) {
      return ks(t, e);
    }
  );
}
var ft = {
  main: "ps",
  rtl: "ps__rtl",
  element: {
    thumb: function(a) {
      return "ps__thumb-" + a;
    },
    rail: function(a) {
      return "ps__rail-" + a;
    },
    consuming: "ps__child--consume"
  },
  state: {
    focus: "ps--focus",
    clicking: "ps--clicking",
    active: function(a) {
      return "ps--active-" + a;
    },
    scrolling: function(a) {
      return "ps--scrolling-" + a;
    }
  }
}, Bv = { x: null, y: null };
function zv(a, e) {
  var t = a.element.classList, i = ft.state.scrolling(e);
  t.contains(i) ? clearTimeout(Bv[e]) : t.add(i);
}
function Xv(a, e) {
  Bv[e] = setTimeout(
    function() {
      return a.isAlive && a.element.classList.remove(ft.state.scrolling(e));
    },
    a.settings.scrollingThreshold
  );
}
function cM(a, e) {
  zv(a, e), Xv(a, e);
}
var xa = function(e) {
  this.element = e, this.handlers = {};
}, Yv = { isEmpty: { configurable: !0 } };
xa.prototype.bind = function(e, t) {
  typeof this.handlers[e] > "u" && (this.handlers[e] = []), this.handlers[e].push(t), this.element.addEventListener(e, t, !1);
};
xa.prototype.unbind = function(e, t) {
  var i = this;
  this.handlers[e] = this.handlers[e].filter(function(s) {
    return t && s !== t ? !0 : (i.element.removeEventListener(e, s, !1), !1);
  });
};
xa.prototype.unbindAll = function() {
  for (var e in this.handlers)
    this.unbind(e);
};
Yv.isEmpty.get = function() {
  var a = this;
  return Object.keys(this.handlers).every(
    function(e) {
      return a.handlers[e].length === 0;
    }
  );
};
Object.defineProperties(xa.prototype, Yv);
var hr = function() {
  this.eventElements = [];
};
hr.prototype.eventElement = function(e) {
  var t = this.eventElements.filter(function(i) {
    return i.element === e;
  })[0];
  return t || (t = new xa(e), this.eventElements.push(t)), t;
};
hr.prototype.bind = function(e, t, i) {
  this.eventElement(e).bind(t, i);
};
hr.prototype.unbind = function(e, t, i) {
  var s = this.eventElement(e);
  s.unbind(t, i), s.isEmpty && this.eventElements.splice(this.eventElements.indexOf(s), 1);
};
hr.prototype.unbindAll = function() {
  this.eventElements.forEach(function(e) {
    return e.unbindAll();
  }), this.eventElements = [];
};
hr.prototype.once = function(e, t, i) {
  var s = this.eventElement(e), n = function(o) {
    s.unbind(t, n), i(o);
  };
  s.bind(t, n);
};
function Va(a) {
  if (typeof window.CustomEvent == "function")
    return new CustomEvent(a);
  var e = document.createEvent("CustomEvent");
  return e.initCustomEvent(a, !1, !1, void 0), e;
}
function Lo(a, e, t, i, s) {
  i === void 0 && (i = !0), s === void 0 && (s = !1);
  var n;
  if (e === "top")
    n = [
      "contentHeight",
      "containerHeight",
      "scrollTop",
      "y",
      "up",
      "down"
    ];
  else if (e === "left")
    n = [
      "contentWidth",
      "containerWidth",
      "scrollLeft",
      "x",
      "left",
      "right"
    ];
  else
    throw new Error("A proper axis should be provided");
  hM(a, t, n, i, s);
}
function hM(a, e, t, i, s) {
  var n = t[0], o = t[1], l = t[2], c = t[3], d = t[4], f = t[5];
  i === void 0 && (i = !0), s === void 0 && (s = !1);
  var p = a.element;
  a.reach[c] = null, p[l] < 1 && (a.reach[c] = "start"), p[l] > a[n] - a[o] - 1 && (a.reach[c] = "end"), e && (p.dispatchEvent(Va("ps-scroll-" + c)), e < 0 ? p.dispatchEvent(Va("ps-scroll-" + d)) : e > 0 && p.dispatchEvent(Va("ps-scroll-" + f)), i && cM(a, c)), a.reach[c] && (e || s) && p.dispatchEvent(Va("ps-" + c + "-reach-" + a.reach[c]));
}
function Je(a) {
  return parseInt(a, 10) || 0;
}
function dM(a) {
  return ks(a, "input,[contenteditable]") || ks(a, "select,[contenteditable]") || ks(a, "textarea,[contenteditable]") || ks(a, "button,[contenteditable]");
}
function uM(a) {
  var e = Ni(a);
  return Je(e.width) + Je(e.paddingLeft) + Je(e.paddingRight) + Je(e.borderLeftWidth) + Je(e.borderRightWidth);
}
var kn = {
  isWebKit: typeof document < "u" && "WebkitAppearance" in document.documentElement.style,
  supportsTouch: typeof window < "u" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: typeof navigator < "u" && navigator.msMaxTouchPoints,
  isChrome: typeof navigator < "u" && /Chrome/i.test(navigator && navigator.userAgent)
};
function rs(a) {
  var e = a.element, t = Math.floor(e.scrollTop), i = e.getBoundingClientRect();
  a.containerWidth = Math.round(i.width), a.containerHeight = Math.round(i.height), a.contentWidth = e.scrollWidth, a.contentHeight = e.scrollHeight, e.contains(a.scrollbarXRail) || (lp(e, ft.element.rail("x")).forEach(
    function(s) {
      return $n(s);
    }
  ), e.appendChild(a.scrollbarXRail)), e.contains(a.scrollbarYRail) || (lp(e, ft.element.rail("y")).forEach(
    function(s) {
      return $n(s);
    }
  ), e.appendChild(a.scrollbarYRail)), !a.settings.suppressScrollX && a.containerWidth + a.settings.scrollXMarginOffset < a.contentWidth ? (a.scrollbarXActive = !0, a.railXWidth = a.containerWidth - a.railXMarginWidth, a.railXRatio = a.containerWidth / a.railXWidth, a.scrollbarXWidth = cp(
    a,
    Je(a.railXWidth * a.containerWidth / a.contentWidth)
  ), a.scrollbarXLeft = Je(
    (a.negativeScrollAdjustment + e.scrollLeft) * (a.railXWidth - a.scrollbarXWidth) / (a.contentWidth - a.containerWidth)
  )) : a.scrollbarXActive = !1, !a.settings.suppressScrollY && a.containerHeight + a.settings.scrollYMarginOffset < a.contentHeight ? (a.scrollbarYActive = !0, a.railYHeight = a.containerHeight - a.railYMarginHeight, a.railYRatio = a.containerHeight / a.railYHeight, a.scrollbarYHeight = cp(
    a,
    Je(a.railYHeight * a.containerHeight / a.contentHeight)
  ), a.scrollbarYTop = Je(
    t * (a.railYHeight - a.scrollbarYHeight) / (a.contentHeight - a.containerHeight)
  )) : a.scrollbarYActive = !1, a.scrollbarXLeft >= a.railXWidth - a.scrollbarXWidth && (a.scrollbarXLeft = a.railXWidth - a.scrollbarXWidth), a.scrollbarYTop >= a.railYHeight - a.scrollbarYHeight && (a.scrollbarYTop = a.railYHeight - a.scrollbarYHeight), fM(e, a), a.scrollbarXActive ? e.classList.add(ft.state.active("x")) : (e.classList.remove(ft.state.active("x")), a.scrollbarXWidth = 0, a.scrollbarXLeft = 0, e.scrollLeft = a.isRtl === !0 ? a.contentWidth : 0), a.scrollbarYActive ? e.classList.add(ft.state.active("y")) : (e.classList.remove(ft.state.active("y")), a.scrollbarYHeight = 0, a.scrollbarYTop = 0, e.scrollTop = 0);
}
function cp(a, e) {
  return a.settings.minScrollbarLength && (e = Math.max(e, a.settings.minScrollbarLength)), a.settings.maxScrollbarLength && (e = Math.min(e, a.settings.maxScrollbarLength)), e;
}
function fM(a, e) {
  var t = { width: e.railXWidth }, i = Math.floor(a.scrollTop);
  e.isRtl ? t.left = e.negativeScrollAdjustment + a.scrollLeft + e.containerWidth - e.contentWidth : t.left = a.scrollLeft, e.isScrollbarXUsingBottom ? t.bottom = e.scrollbarXBottom - i : t.top = e.scrollbarXTop + i, Vt(e.scrollbarXRail, t);
  var s = { top: i, height: e.railYHeight };
  e.isScrollbarYUsingRight ? e.isRtl ? s.right = e.contentWidth - (e.negativeScrollAdjustment + a.scrollLeft) - e.scrollbarYRight - e.scrollbarYOuterWidth - 9 : s.right = e.scrollbarYRight - a.scrollLeft : e.isRtl ? s.left = e.negativeScrollAdjustment + a.scrollLeft + e.containerWidth * 2 - e.contentWidth - e.scrollbarYLeft - e.scrollbarYOuterWidth : s.left = e.scrollbarYLeft + a.scrollLeft, Vt(e.scrollbarYRail, s), Vt(e.scrollbarX, {
    left: e.scrollbarXLeft,
    width: e.scrollbarXWidth - e.railBorderXWidth
  }), Vt(e.scrollbarY, {
    top: e.scrollbarYTop,
    height: e.scrollbarYHeight - e.railBorderYWidth
  });
}
function pM(a) {
  a.element, a.event.bind(a.scrollbarY, "mousedown", function(e) {
    return e.stopPropagation();
  }), a.event.bind(a.scrollbarYRail, "mousedown", function(e) {
    var t = e.pageY - window.pageYOffset - a.scrollbarYRail.getBoundingClientRect().top, i = t > a.scrollbarYTop ? 1 : -1;
    a.element.scrollTop += i * a.containerHeight, rs(a), e.stopPropagation();
  }), a.event.bind(a.scrollbarX, "mousedown", function(e) {
    return e.stopPropagation();
  }), a.event.bind(a.scrollbarXRail, "mousedown", function(e) {
    var t = e.pageX - window.pageXOffset - a.scrollbarXRail.getBoundingClientRect().left, i = t > a.scrollbarXLeft ? 1 : -1;
    a.element.scrollLeft += i * a.containerWidth, rs(a), e.stopPropagation();
  });
}
function gM(a) {
  hp(a, [
    "containerWidth",
    "contentWidth",
    "pageX",
    "railXWidth",
    "scrollbarX",
    "scrollbarXWidth",
    "scrollLeft",
    "x",
    "scrollbarXRail"
  ]), hp(a, [
    "containerHeight",
    "contentHeight",
    "pageY",
    "railYHeight",
    "scrollbarY",
    "scrollbarYHeight",
    "scrollTop",
    "y",
    "scrollbarYRail"
  ]);
}
function hp(a, e) {
  var t = e[0], i = e[1], s = e[2], n = e[3], o = e[4], l = e[5], c = e[6], d = e[7], f = e[8], p = a.element, m = null, v = null, r = null;
  function h(b) {
    b.touches && b.touches[0] && (b[s] = b.touches[0].pageY), p[c] = m + r * (b[s] - v), zv(a, d), rs(a), b.stopPropagation(), b.type.startsWith("touch") && b.changedTouches.length > 1 && b.preventDefault();
  }
  function u() {
    Xv(a, d), a[f].classList.remove(ft.state.clicking), a.event.unbind(a.ownerDocument, "mousemove", h);
  }
  function g(b, O) {
    m = p[c], O && b.touches && (b[s] = b.touches[0].pageY), v = b[s], r = (a[i] - a[t]) / (a[n] - a[l]), O ? a.event.bind(a.ownerDocument, "touchmove", h) : (a.event.bind(a.ownerDocument, "mousemove", h), a.event.once(a.ownerDocument, "mouseup", u), b.preventDefault()), a[f].classList.add(ft.state.clicking), b.stopPropagation();
  }
  a.event.bind(a[o], "mousedown", function(b) {
    g(b);
  }), a.event.bind(a[o], "touchstart", function(b) {
    g(b, !0);
  });
}
function mM(a) {
  var e = a.element, t = function() {
    return ks(e, ":hover");
  }, i = function() {
    return ks(a.scrollbarX, ":focus") || ks(a.scrollbarY, ":focus");
  };
  function s(n, o) {
    var l = Math.floor(e.scrollTop);
    if (n === 0) {
      if (!a.scrollbarYActive)
        return !1;
      if (l === 0 && o > 0 || l >= a.contentHeight - a.containerHeight && o < 0)
        return !a.settings.wheelPropagation;
    }
    var c = e.scrollLeft;
    if (o === 0) {
      if (!a.scrollbarXActive)
        return !1;
      if (c === 0 && n < 0 || c >= a.contentWidth - a.containerWidth && n > 0)
        return !a.settings.wheelPropagation;
    }
    return !0;
  }
  a.event.bind(a.ownerDocument, "keydown", function(n) {
    if (!(n.isDefaultPrevented && n.isDefaultPrevented() || n.defaultPrevented) && !(!t() && !i())) {
      var o = document.activeElement ? document.activeElement : a.ownerDocument.activeElement;
      if (o) {
        if (o.tagName === "IFRAME")
          o = o.contentDocument.activeElement;
        else
          for (; o.shadowRoot; )
            o = o.shadowRoot.activeElement;
        if (dM(o))
          return;
      }
      var l = 0, c = 0;
      switch (n.which) {
        case 37:
          n.metaKey ? l = -a.contentWidth : n.altKey ? l = -a.containerWidth : l = -30;
          break;
        case 38:
          n.metaKey ? c = a.contentHeight : n.altKey ? c = a.containerHeight : c = 30;
          break;
        case 39:
          n.metaKey ? l = a.contentWidth : n.altKey ? l = a.containerWidth : l = 30;
          break;
        case 40:
          n.metaKey ? c = -a.contentHeight : n.altKey ? c = -a.containerHeight : c = -30;
          break;
        case 32:
          n.shiftKey ? c = a.containerHeight : c = -a.containerHeight;
          break;
        case 33:
          c = a.containerHeight;
          break;
        case 34:
          c = -a.containerHeight;
          break;
        case 36:
          c = a.contentHeight;
          break;
        case 35:
          c = -a.contentHeight;
          break;
        default:
          return;
      }
      a.settings.suppressScrollX && l !== 0 || a.settings.suppressScrollY && c !== 0 || (e.scrollTop -= c, e.scrollLeft += l, rs(a), s(l, c) && n.preventDefault());
    }
  });
}
function bM(a) {
  var e = a.element;
  function t(o, l) {
    var c = Math.floor(e.scrollTop), d = e.scrollTop === 0, f = c + e.offsetHeight === e.scrollHeight, p = e.scrollLeft === 0, m = e.scrollLeft + e.offsetWidth === e.scrollWidth, v;
    return Math.abs(l) > Math.abs(o) ? v = d || f : v = p || m, v ? !a.settings.wheelPropagation : !0;
  }
  function i(o) {
    var l = o.deltaX, c = -1 * o.deltaY;
    return (typeof l > "u" || typeof c > "u") && (l = -1 * o.wheelDeltaX / 6, c = o.wheelDeltaY / 6), o.deltaMode && o.deltaMode === 1 && (l *= 10, c *= 10), l !== l && c !== c && (l = 0, c = o.wheelDelta), o.shiftKey ? [-c, -l] : [l, c];
  }
  function s(o, l, c) {
    if (!kn.isWebKit && e.querySelector("select:focus"))
      return !0;
    if (!e.contains(o))
      return !1;
    for (var d = o; d && d !== e; ) {
      if (d.classList.contains(ft.element.consuming))
        return !0;
      var f = Ni(d);
      if (c && f.overflowY.match(/(scroll|auto)/)) {
        var p = d.scrollHeight - d.clientHeight;
        if (p > 0 && (d.scrollTop > 0 && c < 0 || d.scrollTop < p && c > 0))
          return !0;
      }
      if (l && f.overflowX.match(/(scroll|auto)/)) {
        var m = d.scrollWidth - d.clientWidth;
        if (m > 0 && (d.scrollLeft > 0 && l < 0 || d.scrollLeft < m && l > 0))
          return !0;
      }
      d = d.parentNode;
    }
    return !1;
  }
  function n(o) {
    var l = i(o), c = l[0], d = l[1];
    if (!s(o.target, c, d)) {
      var f = !1;
      a.settings.useBothWheelAxes ? a.scrollbarYActive && !a.scrollbarXActive ? (d ? e.scrollTop -= d * a.settings.wheelSpeed : e.scrollTop += c * a.settings.wheelSpeed, f = !0) : a.scrollbarXActive && !a.scrollbarYActive && (c ? e.scrollLeft += c * a.settings.wheelSpeed : e.scrollLeft -= d * a.settings.wheelSpeed, f = !0) : (e.scrollTop -= d * a.settings.wheelSpeed, e.scrollLeft += c * a.settings.wheelSpeed), rs(a), f = f || t(c, d), f && !o.ctrlKey && (o.stopPropagation(), o.preventDefault());
    }
  }
  typeof window.onwheel < "u" ? a.event.bind(e, "wheel", n) : typeof window.onmousewheel < "u" && a.event.bind(e, "mousewheel", n);
}
function vM(a) {
  if (!kn.supportsTouch && !kn.supportsIePointer)
    return;
  var e = a.element;
  function t(r, h) {
    var u = Math.floor(e.scrollTop), g = e.scrollLeft, b = Math.abs(r), O = Math.abs(h);
    if (O > b) {
      if (h < 0 && u === a.contentHeight - a.containerHeight || h > 0 && u === 0)
        return window.scrollY === 0 && h > 0 && kn.isChrome;
    } else if (b > O && (r < 0 && g === a.contentWidth - a.containerWidth || r > 0 && g === 0))
      return !0;
    return !0;
  }
  function i(r, h) {
    e.scrollTop -= h, e.scrollLeft -= r, rs(a);
  }
  var s = {}, n = 0, o = {}, l = null;
  function c(r) {
    return r.targetTouches ? r.targetTouches[0] : r;
  }
  function d(r) {
    return r.pointerType && r.pointerType === "pen" && r.buttons === 0 ? !1 : !!(r.targetTouches && r.targetTouches.length === 1 || r.pointerType && r.pointerType !== "mouse" && r.pointerType !== r.MSPOINTER_TYPE_MOUSE);
  }
  function f(r) {
    if (d(r)) {
      var h = c(r);
      s.pageX = h.pageX, s.pageY = h.pageY, n = (/* @__PURE__ */ new Date()).getTime(), l !== null && clearInterval(l);
    }
  }
  function p(r, h, u) {
    if (!e.contains(r))
      return !1;
    for (var g = r; g && g !== e; ) {
      if (g.classList.contains(ft.element.consuming))
        return !0;
      var b = Ni(g);
      if (u && b.overflowY.match(/(scroll|auto)/)) {
        var O = g.scrollHeight - g.clientHeight;
        if (O > 0 && (g.scrollTop > 0 && u < 0 || g.scrollTop < O && u > 0))
          return !0;
      }
      if (h && b.overflowX.match(/(scroll|auto)/)) {
        var x = g.scrollWidth - g.clientWidth;
        if (x > 0 && (g.scrollLeft > 0 && h < 0 || g.scrollLeft < x && h > 0))
          return !0;
      }
      g = g.parentNode;
    }
    return !1;
  }
  function m(r) {
    if (d(r)) {
      var h = c(r), u = { pageX: h.pageX, pageY: h.pageY }, g = u.pageX - s.pageX, b = u.pageY - s.pageY;
      if (p(r.target, g, b))
        return;
      i(g, b), s = u;
      var O = (/* @__PURE__ */ new Date()).getTime(), x = O - n;
      x > 0 && (o.x = g / x, o.y = b / x, n = O), t(g, b) && r.preventDefault();
    }
  }
  function v() {
    a.settings.swipeEasing && (clearInterval(l), l = setInterval(function() {
      if (a.isInitialized) {
        clearInterval(l);
        return;
      }
      if (!o.x && !o.y) {
        clearInterval(l);
        return;
      }
      if (Math.abs(o.x) < 0.01 && Math.abs(o.y) < 0.01) {
        clearInterval(l);
        return;
      }
      if (!a.element) {
        clearInterval(l);
        return;
      }
      i(o.x * 30, o.y * 30), o.x *= 0.8, o.y *= 0.8;
    }, 10));
  }
  kn.supportsTouch ? (a.event.bind(e, "touchstart", f), a.event.bind(e, "touchmove", m), a.event.bind(e, "touchend", v)) : kn.supportsIePointer && (window.PointerEvent ? (a.event.bind(e, "pointerdown", f), a.event.bind(e, "pointermove", m), a.event.bind(e, "pointerup", v)) : window.MSPointerEvent && (a.event.bind(e, "MSPointerDown", f), a.event.bind(e, "MSPointerMove", m), a.event.bind(e, "MSPointerUp", v)));
}
var yM = function() {
  return {
    handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
    maxScrollbarLength: null,
    minScrollbarLength: null,
    scrollingThreshold: 1e3,
    scrollXMarginOffset: 0,
    scrollYMarginOffset: 0,
    suppressScrollX: !1,
    suppressScrollY: !1,
    swipeEasing: !0,
    useBothWheelAxes: !1,
    wheelPropagation: !0,
    wheelSpeed: 1
  };
}, OM = {
  "click-rail": pM,
  "drag-thumb": gM,
  keyboard: mM,
  wheel: bM,
  touch: vM
}, wa = function(e, t) {
  var i = this;
  if (t === void 0 && (t = {}), typeof e == "string" && (e = document.querySelector(e)), !e || !e.nodeName)
    throw new Error("no element is specified to initialize PerfectScrollbar");
  this.element = e, e.classList.add(ft.main), this.settings = yM();
  for (var s in t)
    this.settings[s] = t[s];
  this.containerWidth = null, this.containerHeight = null, this.contentWidth = null, this.contentHeight = null;
  var n = function() {
    return e.classList.add(ft.state.focus);
  }, o = function() {
    return e.classList.remove(ft.state.focus);
  };
  this.isRtl = Ni(e).direction === "rtl", this.isRtl === !0 && e.classList.add(ft.rtl), this.isNegativeScroll = function() {
    var d = e.scrollLeft, f = null;
    return e.scrollLeft = -1, f = e.scrollLeft < 0, e.scrollLeft = d, f;
  }(), this.negativeScrollAdjustment = this.isNegativeScroll ? e.scrollWidth - e.clientWidth : 0, this.event = new hr(), this.ownerDocument = e.ownerDocument || document, this.scrollbarXRail = Ya(ft.element.rail("x")), e.appendChild(this.scrollbarXRail), this.scrollbarX = Ya(ft.element.thumb("x")), this.scrollbarXRail.appendChild(this.scrollbarX), this.scrollbarX.setAttribute("tabindex", 0), this.event.bind(this.scrollbarX, "focus", n), this.event.bind(this.scrollbarX, "blur", o), this.scrollbarXActive = null, this.scrollbarXWidth = null, this.scrollbarXLeft = null;
  var l = Ni(this.scrollbarXRail);
  this.scrollbarXBottom = parseInt(l.bottom, 10), isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = !1, this.scrollbarXTop = Je(l.top)) : this.isScrollbarXUsingBottom = !0, this.railBorderXWidth = Je(l.borderLeftWidth) + Je(l.borderRightWidth), Vt(this.scrollbarXRail, { display: "block" }), this.railXMarginWidth = Je(l.marginLeft) + Je(l.marginRight), Vt(this.scrollbarXRail, { display: "" }), this.railXWidth = null, this.railXRatio = null, this.scrollbarYRail = Ya(ft.element.rail("y")), e.appendChild(this.scrollbarYRail), this.scrollbarY = Ya(ft.element.thumb("y")), this.scrollbarYRail.appendChild(this.scrollbarY), this.scrollbarY.setAttribute("tabindex", 0), this.event.bind(this.scrollbarY, "focus", n), this.event.bind(this.scrollbarY, "blur", o), this.scrollbarYActive = null, this.scrollbarYHeight = null, this.scrollbarYTop = null;
  var c = Ni(this.scrollbarYRail);
  this.scrollbarYRight = parseInt(c.right, 10), isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = !1, this.scrollbarYLeft = Je(c.left)) : this.isScrollbarYUsingRight = !0, this.scrollbarYOuterWidth = this.isRtl ? uM(this.scrollbarY) : null, this.railBorderYWidth = Je(c.borderTopWidth) + Je(c.borderBottomWidth), Vt(this.scrollbarYRail, { display: "block" }), this.railYMarginHeight = Je(c.marginTop) + Je(c.marginBottom), Vt(this.scrollbarYRail, { display: "" }), this.railYHeight = null, this.railYRatio = null, this.reach = {
    x: e.scrollLeft <= 0 ? "start" : e.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
    y: e.scrollTop <= 0 ? "start" : e.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
  }, this.isAlive = !0, this.settings.handlers.forEach(function(d) {
    return OM[d](i);
  }), this.lastScrollTop = Math.floor(e.scrollTop), this.lastScrollLeft = e.scrollLeft, this.event.bind(this.element, "scroll", function(d) {
    return i.onScroll(d);
  }), rs(this);
};
wa.prototype.update = function() {
  this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0, Vt(this.scrollbarXRail, { display: "block" }), Vt(this.scrollbarYRail, { display: "block" }), this.railXMarginWidth = Je(Ni(this.scrollbarXRail).marginLeft) + Je(Ni(this.scrollbarXRail).marginRight), this.railYMarginHeight = Je(Ni(this.scrollbarYRail).marginTop) + Je(Ni(this.scrollbarYRail).marginBottom), Vt(this.scrollbarXRail, { display: "none" }), Vt(this.scrollbarYRail, { display: "none" }), rs(this), Lo(this, "top", 0, !1, !0), Lo(this, "left", 0, !1, !0), Vt(this.scrollbarXRail, { display: "" }), Vt(this.scrollbarYRail, { display: "" }));
};
wa.prototype.onScroll = function(e) {
  this.isAlive && (rs(this), Lo(this, "top", this.element.scrollTop - this.lastScrollTop), Lo(
    this,
    "left",
    this.element.scrollLeft - this.lastScrollLeft
  ), this.lastScrollTop = Math.floor(this.element.scrollTop), this.lastScrollLeft = this.element.scrollLeft);
};
wa.prototype.destroy = function() {
  this.isAlive && (this.event.unbindAll(), $n(this.scrollbarX), $n(this.scrollbarY), $n(this.scrollbarXRail), $n(this.scrollbarYRail), this.removePsClasses(), this.element = null, this.scrollbarX = null, this.scrollbarY = null, this.scrollbarXRail = null, this.scrollbarYRail = null, this.isAlive = !1);
};
wa.prototype.removePsClasses = function() {
  this.element.className = this.element.className.split(" ").filter(function(e) {
    return !e.match(/^ps([-_].+|)$/);
  }).join(" ");
};
const xM = j({
  __name: "CustomScroll",
  props: {
    settings: {}
  },
  setup(a) {
    var s;
    const e = a, t = `perfect-scroll-${(s = yt()) == null ? void 0 : s.uid}`, i = {
      ...e.settings
    };
    return at(() => {
      new wa(`#${t}`, i);
    }), (n, o) => (M(), D("div", {
      class: "perfect-scroll",
      id: t
    }, [
      te(n.$slots, "default")
    ]));
  }
});
const wM = j({
  __name: "Tab",
  props: {
    modelValue: {}
  },
  emits: ["update:modelValue"],
  setup(a, { emit: e }) {
    var o;
    const t = a, i = e, s = `ui-tab-${(o = yt()) == null ? void 0 : o.uid}`, n = Wr({
      tabs: [],
      activeTabIndex: t.modelValue,
      active: (l, c) => {
        i("update:modelValue", l);
        const d = document.getElementById(s);
        if (d && d.offsetWidth + d.scrollLeft > c.clientX - c.offsetX) {
          const f = c.clientX - c.offsetX;
          d.scrollTo({ left: f, behavior: "smooth" });
        }
      }
    });
    return C0("tabs", n), Lt(() => {
      n.activeTabIndex = t.modelValue;
    }), (l, c) => (M(), D("div", {
      class: "ui-tab",
      id: s
    }, [
      te(l.$slots, "default")
    ]));
  }
});
const SM = { class: "ui-tab-item-content" }, kM = {
  key: 0,
  class: "ui-tab-item-badge"
}, dp = j({
  __name: "TabItem",
  props: {
    label: {},
    index: {},
    badge: {}
  },
  setup(a) {
    const e = a, t = Z(!1), i = la("tabs");
    let s = 0;
    i && (s = e.index || i.tabs.length, i.tabs.push(s));
    const n = (o) => {
      i && i.active(s, o);
    };
    return Lt(() => {
      (i == null ? void 0 : i.activeTabIndex) == s ? t.value = !0 : t.value = !1;
    }), (o, l) => (M(), D("button", {
      type: "button",
      class: he(["ui-tab-item", { "-active": t.value }]),
      onClick: n
    }, [
      I("span", SM, [
        te(o.$slots, "default", {}, () => [
          ye(ne(o.label), 1)
        ]),
        o.badge ? (M(), D("span", kM, ne(o.badge), 1)) : X("", !0)
      ])
    ], 2));
  }
});
const _M = j({
  __name: "TableListTabs",
  props: {
    queryParams: {},
    state: {}
  },
  setup(a) {
    const e = a, t = (s, n) => {
      n.preventDefault(), n.stopPropagation();
      const o = s.filter;
      (s.id || s.view) && (o.selectedView = s.view), e.state.resetQueryParams(o), e.state.currentTab = s;
    }, i = () => {
      e.state.resetQueryParams({ selectedView: "all" });
    };
    return zt(
      () => e.state.queryParams,
      (s) => {
        e.state.currentTab = s.selectedView || "all";
      },
      { deep: !0, immediate: !0 }
    ), (s, n) => (M(), q(xM, {
      class: "table-list-tabs scroll-area",
      settings: {
        maxScrollbarLength: 80,
        useBothWheelAxes: !0,
        suppressScrollY: !0
      }
    }, {
      default: U(() => [
        B(wM, {
          modelValue: s.state.currentTab,
          "onUpdate:modelValue": n[0] || (n[0] = (o) => s.state.currentTab = o),
          class: "table-list-tabs-content"
        }, {
          default: U(() => [
            B(dp, {
              label: "Todos",
              onClick: i,
              index: "all"
            }),
            (M(!0), D(ke, null, Ae(s.state.tabs, (o, l) => (M(), q(dp, {
              key: l,
              onClick: (c) => t(o, c),
              index: o.view
            }, {
              default: U(() => [
                ye(ne(o.name), 1)
              ]),
              _: 2
            }, 1032, ["onClick", "index"]))), 128))
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]),
      _: 1
    }));
  }
}), Ha = j({
  __name: "TableListItem",
  props: {
    auto: { type: Boolean },
    nowrap: { type: Boolean }
  },
  setup(a) {
    const e = a, t = Z([]);
    return e.auto && t.value.push("-auto"), e.nowrap && t.value.push("-nowrap"), (i, s) => (M(), D("div", {
      class: he(["table-list-item", t.value])
    }, [
      te(i.$slots, "default")
    ], 2));
  }
});
const CM = {
  key: 0,
  class: "table-list-header"
}, TM = j({
  __name: "TableListTable",
  props: {
    state: {},
    rows: {},
    selected: {},
    to: {}
  },
  emits: ["update:selected"],
  setup(a, { emit: e }) {
    const t = a, i = e, s = (l, c) => {
      l.target.getAttribute("class") == "custom-control-label" || l.target.href || t.state.clickRow(c);
    }, n = (l) => {
      l.active = !l.active, t.state.activeOne(l, l.active);
    }, o = (l, c) => {
      if (t.selected.includes(c.id)) {
        c.__checked = !1;
        const d = t.selected.filter((f) => f != c.id);
        i("update:selected", d);
      } else
        c.__checked = !0, t.selected.push(c.id);
    };
    return (l, c) => l.rows.length ? T0([l.rows], () => (M(), D("div", {
      key: 0,
      class: "table table-flex table-hover"
    }, [
      l.$slots.head ? (M(), D("div", CM, [
        l.state.config.hideCheckbox ? X("", !0) : (M(), q(Ha, {
          key: 0,
          auto: "",
          class: "-checkbox"
        })),
        te(l.$slots, "head"),
        l.state.config.actions.length ? (M(), q(Ha, { key: 1 })) : X("", !0)
      ])) : X("", !0),
      (M(!0), D(ke, null, Ae(l.rows, (d, f) => (M(), q(Ut(l.to ? "router-link" : "div"), {
        onClick: (p) => s(p, d),
        class: he(["table-list-row", {
          "-selected": l.selected.includes(d.id),
          "-inactive": d.active == !1
        }]),
        to: { name: l.to, params: { id: d.id } },
        key: d.id
      }, {
        default: U(() => {
          var p;
          return [
            l.state.config.hideCheckbox ? X("", !0) : (M(), q(Ha, {
              key: 0,
              onClick: Xt((m) => o(m, d), ["stop", "prevent"]),
              auto: ""
            }, {
              default: U(() => [
                B(ir, {
                  modelValue: l.selected,
                  value: d.id,
                  noEvents: ""
                }, null, 8, ["modelValue", "value"])
              ]),
              _: 2
            }, 1032, ["onClick"])),
            te(l.$slots, "default", { item: d }),
            (p = l.state.config.actions) != null && p.length ? (M(), q(Ha, {
              key: 1,
              auto: ""
            }, {
              default: U(() => [
                l.state.config.actions && l.state.config.actions.includes("active") ? (M(), q(Le, {
                  key: 0,
                  onClick: Xt((m) => n(d), ["stop", "prevent"]),
                  variant: "plain"
                }, {
                  default: U(() => [
                    d.active ? (M(), q(Hr, {
                      key: 0,
                      variant: "success",
                      label: "Ativo"
                    })) : (M(), q(Hr, {
                      key: 1,
                      variant: "danger",
                      label: "Inativo"
                    }))
                  ]),
                  _: 2
                }, 1032, ["onClick"])) : X("", !0)
              ]),
              _: 2
            }, 1024)) : X("", !0)
          ];
        }),
        _: 2
      }, 1032, ["onClick", "to", "class"]))), 128))
    ])), c, 0) : X("", !0);
  }
});
const AM = { class: "table-list-nav-item table-search" }, $M = { class: "table-search-input" }, EM = j({
  __name: "TableListNavSearch",
  props: {
    state: {},
    placeholder: { default: "Procurar registros" }
  },
  setup(a) {
    const e = a, t = () => {
      e.state.setQueryParams({
        q: e.state.term,
        page: 1
      });
    };
    let i;
    const s = (o = null) => {
      clearTimeout(i), i = setTimeout(
        () => {
          e.state.setQueryParams({
            q: e.state.term,
            page: 1
          });
        },
        o ? 750 : 0
      );
    }, n = () => {
      e.state.term = null, s();
    };
    return (o, l) => (M(), D("span", AM, [
      I("form", {
        autocomplete: "off",
        onSubmit: Xt(t, ["prevent"])
      }, [
        I("div", $M, [
          B(hi, {
            size: "sm",
            leadingIcon: "search",
            clearable: "",
            onClear: n,
            modelValue: o.state.term,
            "onUpdate:modelValue": l[0] || (l[0] = (c) => o.state.term = c),
            id: "term",
            placeholder: o.placeholder,
            last: ""
          }, null, 8, ["modelValue", "placeholder"])
        ])
      ], 32)
    ]));
  }
}), Vv = (a) => {
  if (a) {
    a = a.trim();
    let e = a[0];
    const t = a.split(/\s{1,3}/);
    return t.length > 1 && (e += t[t.length - 1][0]), e;
  }
}, Hv = (a, e = 2) => {
  if (a == 0)
    return 0;
  if (a != null)
    return ("000000" + a).slice(-e);
};
function Mo(a) {
  if (a) {
    a = a.replace(/^\s+|\s+$/g, ""), a = a.toLowerCase();
    const e = "ãàáäâẽèéëêìíïîõòóöôùúüûñç·/_,:;", t = "aaaaaeeeeeiiiiooooouuuunc------";
    for (let i = 0, s = e.length; i < s; i++)
      a = a.replace(new RegExp(e.charAt(i), "g"), t.charAt(i));
    a = a.replace(/[^a-z0-9 -]/g, "").replace(/\s+/g, "-").replace(/-+/g, "-");
  } else
    a = "";
  return a;
}
function PM(a, e, t = "") {
  return a && (e == null && (e = 100), t == null && (t = "..."), a.length > e ? a.substring(0, e - t.length) + t : a);
}
function LM(a, e, t, i = "", s = !0) {
  let n = "";
  const o = parseFloat(String(a));
  return o > 1 ? n = t : o == 1 ? n = e : n = i || t, s && (n = `${o} ${n}`), n;
}
const MM = { class: "table-list-nav-item" }, DM = j({
  __name: "TableListNavBulk",
  props: {
    rows: { default: () => [] },
    selected: { default: () => [] },
    config: {},
    state: {}
  },
  setup(a) {
    const e = a, t = Z([]), i = Z(!1), s = Z(!1), n = Z(!1), o = () => e.state.checkAll(!n.value), l = () => {
      var r, h, u;
      const p = Hv(e.selected.length, 2), m = `Você confirma a exclusão de <b>${p}</b> ${LM(
        p,
        "registro selecionado",
        "registros selecionados",
        "",
        !1
      )}?`;
      function v() {
        var g;
        return (g = e.config.dialogDelete) != null && g.message ? e.config.dialogDelete.message.concatMessage ? `${m} ${e.config.dialogDelete.message.text}` : e.config.dialogDelete.message.text : m;
      }
      fd.open({
        title: ((r = e.config.dialogDelete) == null ? void 0 : r.title) ?? "Excluir registros",
        destructIcon: ((h = e.config.dialogDelete) == null ? void 0 : h.destructIcon) ?? "delete",
        destructLabel: ((u = e.config.dialogDelete) == null ? void 0 : u.destructLabel) ?? "Deletar registros",
        message: v(),
        onCallback: c
      });
    }, c = () => e.state.removeSelected(), d = () => e.state.toggleActiveSelected(!0), f = () => e.state.toggleActiveSelected(!1);
    return Lt(() => {
      e.rows.length && e.selected.length == e.rows.length ? (s.value = !0, i.value = !1) : e.selected.length ? (s.value = !1, i.value = !0) : (s.value = !1, i.value = !1), n.value = s.value;
    }), at(() => {
      gi(e.config.actions, (p) => {
        p == "active" && (t.value.push({
          label: "Ativar registros",
          onAction: d
        }), t.value.push({
          label: "Inativar registros",
          onAction: f
        })), p == "remove" && t.value.push({
          label: "Remover registros",
          variant: "danger",
          onAction: l
        });
      }), e.config.bulk && t.value.push(...e.config.bulk);
    }), (p, m) => {
      var v;
      return Ze((M(), D("div", {
        class: he(["table-list-nav-bulk", { "-active": p.selected.length }])
      }, [
        I("div", {
          onClick: o,
          class: "-checkbox"
        }, [
          B(ir, {
            indeterminate: i.value,
            value: s.value,
            modelValue: n.value,
            "onUpdate:modelValue": m[0] || (m[0] = (r) => n.value = r),
            noEvents: ""
          }, null, 8, ["indeterminate", "value", "modelValue"])
        ]),
        Ze(I("span", MM, [
          B(Le, {
            size: "sm",
            leadingIcon: "delete",
            onClick: l,
            label: "Deletar"
          })
        ], 512), [
          [bt, p.selected.length && ((v = p.config.actions) == null ? void 0 : v.includes("remove"))]
        ]),
        Ze(B(ya, { right: "" }, {
          "button-content": U(() => [
            B(Le, {
              size: "sm",
              "leading-icon": "unfold_more",
              label: "Ação em massa"
            })
          ]),
          default: U(() => [
            (M(!0), D(ke, null, Ae(t.value, (r) => (M(), q(kl, {
              onClick: Xt((h) => r.onAction(p.selected), ["stop"]),
              key: r.label,
              variant: r.variant,
              label: r.label
            }, null, 8, ["onClick", "variant", "label"]))), 128))
          ]),
          _: 1
        }, 512), [
          [bt, p.selected.length && t.value && t.value.length > 0]
        ])
      ], 2)), [
        [bt, !p.config.hideCheckbox]
      ]);
    };
  }
}), RM = j({
  __name: "TableListNavRefresh",
  props: {
    state: {}
  },
  setup(a) {
    const e = a;
    let t;
    const i = () => {
      t || (t = setTimeout(() => t = 0, 2e3), e.state.fetchData());
    };
    return (s, n) => (M(), D("span", {
      class: "table-list-nav-item",
      onClick: i
    }, [
      B(Ti, {
        size: "md",
        class: "table-list-nav-btn",
        icon: "refresh"
      })
    ]));
  }
}), IM = (a) => window.innerWidth <= a, es = (a = 600) => /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || IM(a), QM = { class: "table-list-nav-item" }, NM = { class: "table-list-nav-btn" }, FM = j({
  __name: "TableListNavSortable",
  props: {
    setQueryParams: {},
    sortable: { default: () => [] },
    queryParams: {}
  },
  setup(a) {
    const e = a, t = Z(), i = Z([]), s = (n) => {
      t.value.hide(), e.setQueryParams({
        sort: n.sort,
        page: 1
      });
    };
    return at(() => {
      e.sortable.map((n) => {
        switch (typeof n == "object" && i.value.push(n), n) {
          case "created_at":
            i.value.push({ name: "Criado em (antigos primeiro)", sort: "id" }), i.value.push({ name: "Criado em (novos primeiro)", sort: "-id" });
            break;
          case "updated_at":
            i.value.push({ name: "Atualizado (antigos primeiro)", sort: "updated_at" }), i.value.push({ name: "Atualizado (novos primeiro)", sort: "-updated_at" });
            break;
          case "name":
            i.value.push({ name: "Nome (A-Z)", sort: "name" }), i.value.push({ name: "Nome (Z-A)", sort: "-name" });
            break;
          case "balance":
            i.value.push({ name: "Quantidade em estoque (menores primeiro)", sort: "balance" }), i.value.push({ name: "Quantidade em estoque (maiores primeiro)", sort: "-balance" });
            break;
        }
      });
    }), (n, o) => Ze((M(), D("span", QM, [
      B(ya, {
        ref_key: "dropdownRef",
        ref: t
      }, {
        "button-content": U(() => [
          I("span", NM, [
            B(Le, {
              label: et(es)() ? "" : "Ordenar",
              size: et(es)() ? "md" : "sm",
              leadingIcon: "swap_vert"
            }, null, 8, ["label", "size"])
          ])
        ]),
        default: U(() => [
          (M(!0), D(ke, null, Ae(i.value, (l) => (M(), q(kl, {
            "data-close": "true",
            key: l.sort,
            onClick: (c) => s(l),
            active: n.queryParams.sort == l.sort
          }, {
            default: U(() => [
              B(Mm, {
                modelValue: n.queryParams.sort,
                "onUpdate:modelValue": o[0] || (o[0] = (c) => n.queryParams.sort = c),
                value: l.sort,
                label: l.name,
                noEvents: ""
              }, null, 8, ["modelValue", "value", "label"])
            ]),
            _: 2
          }, 1032, ["onClick", "active"]))), 128))
        ]),
        _: 1
      }, 512)
    ], 512)), [
      [bt, i.value.length]
    ]);
  }
});
const WM = j({
  __name: "ButtonAction",
  props: {
    type: {},
    active: { type: Boolean },
    size: {},
    deleteName: {},
    noEvents: { type: Boolean }
  },
  emits: ["delete", "inactive", "active", "close", "update:active", "toggleActive"],
  setup(a, { emit: e }) {
    const t = a, i = e, s = A0(), n = Z(), o = s.click, l = (f) => {
      n.value = f ? "toggle_on" : "toggle_off";
    }, c = Z(["-btn-" + t.type]);
    t.size && c.value.push(`-${t.size}`), at(() => {
      switch (t.type) {
        case "remove":
          n.value = "close";
          break;
        case "active":
          l(t.active);
          break;
        default:
          n.value = t.type;
          break;
      }
    }), t.type == "active" && Lt(() => {
      l(t.active);
    });
    const d = (f) => {
      if (t.type != "edit") {
        if (t.noEvents || f.stopPropagation(), t.type == "delete" && !o) {
          let p = "Você confirma a exclusão do registro";
          t.deleteName && (p += ` ${t.deleteName}`), p += "?", fd.delete({
            title: "Excluir registro",
            message: p,
            onCallback: (m) => {
              i("delete", m);
            }
          });
        }
        t.type == "active" && (i("update:active", !t.active), i("toggleActive"), t.active ? i("inactive") : i("active"));
      }
    };
    return (f, p) => (M(), D("div", null, [
      f.type == "remove" ? (M(), q(Ti, {
        key: 0,
        class: "ui-button-action",
        icon: "close",
        size: "sm"
      })) : X("", !0),
      f.type == "active" ? (M(), q(Le, {
        key: 1,
        variant: "plain",
        size: "sm",
        onClick: d
      }, {
        default: U(() => [
          f.active ? (M(), q(Hr, {
            key: 0,
            variant: "success",
            label: "Ativo"
          })) : (M(), q(Hr, {
            key: 1,
            variant: "danger",
            label: "Inativo"
          }))
        ]),
        _: 1
      })) : X("", !0)
    ]));
  }
}), BM = j({
  __name: "BrowserSelectCell",
  props: {
    auto: { type: Boolean }
  },
  setup(a) {
    return (e, t) => (M(), D("div", {
      class: he(["browser-list-cell", { "-auto": e.auto }])
    }, [
      te(e.$slots, "default")
    ], 2));
  }
}), zM = j({
  __name: "BrowserSelectDefault",
  props: {
    item: {}
  },
  setup(a) {
    return (e, t) => (M(), q(BM, null, {
      default: U(() => [
        ye(ne(e.item.name), 1)
      ]),
      _: 1
    }));
  }
});
const XM = { className: "ui-infinite-loading-content" }, YM = {
  key: 0,
  className: "ui-infinite-loading-no-more"
}, VM = {
  key: 1,
  className: "ui-infinite-loading-spinner"
}, HM = j({
  __name: "InfiniteScroll",
  props: {
    load: {},
    spinnerSize: {},
    scrollableElementId: {}
  },
  setup(a, { expose: e }) {
    var p;
    const t = a, i = `ui-infinite-loading-${(p = yt()) == null ? void 0 : p.uid}`, s = Z(), n = Z(!0), o = Z(), l = {
      noMore: () => {
        o.value = !0, d();
      },
      loaded: () => {
        n.value = !0;
      }
    };
    at(() => {
      const m = document.getElementById(i), v = document.getElementById(t.scrollableElementId);
      m && (s.value = v ?? m.parentElement, f());
    });
    function c() {
      var r;
      if (!s.value)
        return;
      const m = s.value.getBoundingClientRect();
      s.value.scrollTop + m.height > ((r = s.value) == null ? void 0 : r.scrollHeight) - 1 && n.value && (n.value = !1, t.load(l));
    }
    function d() {
      s.value && (s.value.removeEventListener("scroll", c, !1), n.value = !1);
    }
    function f() {
      s.value && (s.value.scrollTo({ top: 0 }), o.value = !1, s.value.addEventListener("scroll", c, !1), n.value = !0, t.load(l));
    }
    return e({
      reset: () => {
        $s(() => f());
      }
    }), (m, v) => (M(), D("div", {
      className: "ui-infinite-loading",
      id: i
    }, [
      I("div", XM, [
        o.value ? (M(), D("div", YM, [
          B(Hr, {
            variant: "muted",
            label: "Sem mais resultados"
          })
        ])) : X("", !0),
        n.value ? (M(), D("div", VM, [
          B(dn, {
            border: "2",
            size: m.spinnerSize || 25
          }, null, 8, ["size"])
        ])) : X("", !0)
      ])
    ]));
  }
});
const GM = { class: "ui-browser" }, jM = { class: "ui-browser-search" }, UM = { class: "ui-browser-search-input" }, ZM = { class: "box-icon" }, qM = { class: "ui-browser-search-list" }, KM = ["onClick", "onKeyup", "onKeypress"], JM = { class: "ui-browser-list-cell" }, eD = 500, tD = j({
  __name: "BrowserSelectModal",
  props: {
    selectOne: { type: Boolean },
    baseParams: {},
    searchBy: {},
    identifier: { default: "id" },
    limit: { default: 0 },
    title: { default: "Buscar" },
    modelValue: {},
    templateCustom: {},
    service: {}
  },
  emits: ["update"],
  setup(a, { expose: e, emit: t }) {
    const i = {
      default: zM
    }, s = t, n = a, o = Z(), l = Z({ q: null, page: 1 }), c = Z(), d = Z([]), f = Z(), p = Z(!0), m = Z(!1), v = Z(!1), r = Z([]);
    let h;
    const u = () => {
      o.value = "", d.value = [];
    }, g = () => {
      s("update", { ids: f.value, memoryList: r.value }), v.value = !1;
    }, b = (_, $) => {
      $.preventDefault(), O(_);
    }, O = (_) => {
      r.value.push(zn(_)), n.selectOne ? (f.value = [_[n.identifier]], g()) : f.value.includes(_[n.identifier]) ? f.value = f.value.filter(($) => $ != _[n.identifier]) : f.value.push(_[n.identifier]);
    }, x = async (_) => {
      const $ = zn(l.value);
      $.q = o.value;
      const L = await n.service.get($);
      l.value.page++, d.value = d.value.concat(L.data), p.value = !1, L.meta.current_page >= L.meta.last_page ? _.noMore() : _.loaded();
    };
    zt(
      () => o.value,
      (_, $) => {
        clearTimeout(h), !(_ == null || $ == null) && _ != $ && (m.value = !0, h = setTimeout(() => {
          m.value = !1, p.value = !0, l.value = Object.assign(l.value, {
            q: _,
            page: 1
          }), d.value = [], c.value.reset();
        }, eD));
      }
    );
    const S = () => n.templateCustom ? n.templateCustom : i.default, k = () => {
      l.value = { q: null, page: 1 }, d.value = [];
    };
    return e({
      open: ({ searchBy: _, selectedIds: $ }) => {
        k(), v.value = !0, f.value = Tn($), o.value = _;
      }
    }), (_, $) => (M(), q(ll, {
      modelValue: v.value,
      "onUpdate:modelValue": $[2] || ($[2] = (L) => v.value = L),
      title: _.title,
      scrollable: "",
      noCloseOnBackdrop: "",
      "scrollable-content-id": "browser-select-scrollable"
    }, {
      footer: U(() => [
        B(Le, {
          variant: "primary",
          onClick: g
        }, {
          default: U(() => [
            ye(" Aplicar (" + ne(et(Hv)(f.value.length)) + " selecionados) ", 1)
          ]),
          _: 1
        })
      ]),
      default: U(() => [
        I("div", GM, [
          I("div", jM, [
            B(wl, { alignV: "center" }, {
              default: U(() => [
                B(rn, null, {
                  default: U(() => [
                    I("div", UM, [
                      B(hi, {
                        modelValue: o.value,
                        "onUpdate:modelValue": $[0] || ($[0] = (L) => o.value = L),
                        placeholder: "Procurar",
                        autofocus: "",
                        last: "",
                        size: "sm",
                        autocomplete: "off"
                      }, {
                        before: U(() => [
                          I("div", ZM, [
                            Ze(B(dn, {
                              class: "icon",
                              size: "15",
                              border: "2",
                              variant: "primary"
                            }, null, 512), [
                              [bt, m.value]
                            ]),
                            Ze(B(Pe, {
                              class: "icon",
                              name: "search"
                            }, null, 512), [
                              [bt, !m.value]
                            ])
                          ])
                        ]),
                        after: U(() => [
                          Ze(B(Pe, {
                            name: "close",
                            onClick: u
                          }, null, 512), [
                            [bt, o.value]
                          ])
                        ]),
                        _: 1
                      }, 8, ["modelValue"])
                    ])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          I("div", qM, [
            (M(!0), D(ke, null, Ae(d.value, (L) => (M(), D("div", {
              key: String(L[_.identifier]),
              class: he([{ disabled: _.limit >= 1 && _.limit == f.value.length && !f.value.includes(L[_.identifier]) }, "ui-browser-list-row"]),
              tabindex: 0,
              onClick: Xt((E) => b(L, E), ["stop"]),
              onKeyup: eh((E) => b(L, E), ["enter"]),
              onKeypress: eh((E) => b(L, E), ["space"])
            }, [
              I("div", JM, [
                B(ir, {
                  value: L[_.identifier],
                  modelValue: f.value,
                  "onUpdate:modelValue": $[1] || ($[1] = (E) => f.value = E),
                  "no-events": ""
                }, null, 8, ["value", "modelValue"])
              ]),
              (M(), q(Ut(S()), {
                item: L,
                modal: ""
              }, null, 8, ["item"]))
            ], 42, KM))), 128)),
            B(HM, {
              load: x,
              ref_key: "InfiniteScrollRef",
              ref: c,
              "scrollable-element-id": "browser-select-scrollable"
            }, null, 512)
          ])
        ])
      ]),
      _: 1
    }, 8, ["modelValue", "title"]));
  }
});
const iD = { class: "ui-browser-select" }, sD = {
  key: 0,
  class: "ui-browser-select-button"
}, nD = { key: 1 }, rD = { class: "ui-browser-select-input" }, aD = {
  key: 0,
  class: "ui-browser-list"
}, oD = {
  key: 1,
  class: "browser-list-cell"
}, lD = {
  key: 2,
  class: "ui-browser-list-cell -auto"
}, cD = {
  key: 0,
  class: "ui-browser-list-more"
}, hD = j({
  __name: "BrowserSelect",
  props: {
    modelValue: {},
    templateCustom: {},
    id: {},
    service: {},
    selectOne: { type: Boolean },
    title: {},
    hideList: { type: Boolean },
    hideExcludeButton: { type: Boolean },
    searchDisabled: { type: Boolean },
    noFetch: { type: Boolean },
    hideBtn: { type: Boolean },
    size: {},
    thumbSize: { default: 50 },
    selectType: {},
    list: {},
    limit: { default: 0 },
    identifier: { default: "id" },
    placeholder: { default: "Selecione" }
  },
  emits: ["remove", "change", "update:modelValue", "update"],
  setup(a, { expose: e, emit: t }) {
    const i = t, s = a, n = Z(null), o = Z(null), l = Z([]), c = Z([]), d = Z([]), f = Z(5), p = Z(), m = () => {
      p.value.open({
        selectedIds: l.value,
        searchBy: n.value
      });
    }, v = () => {
      o.value && o.value.length > 1 && (n.value = String(o.value), o.value = null, m());
    }, r = () => {
      f.value += 5;
    }, h = (C) => {
      i("remove", C), Mr(c.value, { [s.identifier]: C[s.identifier] }) ? c.value = c.value.filter((_) => _[s.identifier] != C[s.identifier]) : c.value.push(C[s.identifier]), l.value = c.value.map((_) => _[s.identifier]), u(l.value);
    }, u = (C) => {
      const _ = g(C);
      i("update:modelValue", _), i("update", _);
    }, g = (C) => s.selectOne ? eA(C) || null : C, b = (C) => {
      gi(l.value, (_) => {
        const $ = Mr(d.value, { [s.identifier]: _ });
        $ && C.push($);
      });
    }, O = async () => {
      let C = [];
      if (l.value.length && (b(C), C.length != l.value.length))
        if (s.selectOne) {
          const _ = l.value[0];
          C = await s.service.first(_), C = [C];
        } else
          C = (await s.service.get({
            ids: l.value.join(",")
          })).data;
      c.value = C;
    }, x = (C) => {
      C && (Pt(C) || (C = [C]), S(C));
    }, S = (C) => {
      C.map((_) => {
        _.id && !Mr(d.value, { [s.identifier]: _[s.identifier] }) && d.value.push(zn(_));
      });
    }, k = ({ memoryList: C, ids: _ }) => {
      n.value = null, S(C), _ && u(_);
    };
    return zt(
      () => s.list,
      (C) => {
        x(C), c.value = s.list || [];
      },
      { deep: !0, immediate: !0 }
    ), zt(
      () => c.value,
      (C) => {
        i("change", C);
      }
    ), zt(
      () => s.modelValue,
      (C) => {
        C != l.value && (C ? l.value = Pt(C) ? C : [C] : l.value = [], d.value.length || x(s.list), s.noFetch === !1 && O());
      },
      { deep: !0, immediate: !0 }
    ), e({ onClickSearch: m }), (C, _) => (M(), D(ke, null, [
      I("div", iD, [
        C.selectType == "btn" && !C.hideBtn ? (M(), D("div", sD, [
          te(C.$slots, "button", {}, () => [
            I("div", {
              class: he(["area-select", { disabled: Number(C.limit) > 0 && c.value.length == C.limit }]),
              onClick: m
            }, [
              I("span", null, ne(C.placeholder), 1)
            ], 2)
          ])
        ])) : (M(), D("div", nD, [
          I("div", rD, [
            B(hi, {
              modelValue: o.value,
              "onUpdate:modelValue": _[0] || (_[0] = ($) => o.value = $),
              placeholder: "Procurar...",
              onKeyup: v,
              autocomplete: "off",
              disabled: C.searchDisabled
            }, null, 8, ["modelValue", "disabled"]),
            B(Le, {
              variant: "primary",
              onClick: m,
              disabled: C.searchDisabled
            }, {
              default: U(() => [
                ye("Pesquisar")
              ]),
              _: 1
            }, 8, ["disabled"])
          ]),
          !C.hideList && c.value.length ? (M(), D("div", aD, [
            (M(!0), D(ke, null, Ae(c.value.slice(0, f.value), ($) => (M(), D("div", {
              class: he(["ui-browser-list-row", { "-no-button": C.hideExcludeButton }]),
              key: $[C.identifier]
            }, [
              C.templateCustom ? (M(), q(Ut(C.templateCustom), {
                key: 0,
                item: $
              }, null, 8, ["item"])) : (M(), D("div", oD, ne($.name), 1)),
              C.hideExcludeButton ? X("", !0) : (M(), D("div", lD, [
                B(WM, {
                  size: "sm",
                  type: "remove",
                  onClick: (L) => h($)
                }, null, 8, ["onClick"])
              ]))
            ], 2))), 128)),
            c.value.length > f.value ? (M(), D("div", cD, [
              B(Ai, {
                onClick: r,
                label: "Exibir mais"
              })
            ])) : X("", !0)
          ])) : X("", !0)
        ]))
      ]),
      B(tD, {
        ref_key: "browserSelectModalRef",
        ref: p,
        onUpdate: k,
        templateCustom: C.templateCustom,
        service: C.service,
        searchBy: n.value,
        selectOne: C.selectOne,
        identifier: C.identifier,
        limit: C.limit,
        title: C.title
      }, null, 8, ["templateCustom", "service", "searchBy", "selectOne", "identifier", "limit", "title"])
    ], 64));
  }
});
const dD = { class: "filter-list" }, uD = ["onClick"], fD = {
  key: 0,
  class: "filter-list-accordion"
}, pD = { key: 0 }, gD = { key: 1 }, mD = { key: 2 }, bD = {
  key: 0,
  class: "d-block mb-2"
}, vD = {
  key: 1,
  class: "d-block mb-2"
}, yD = { class: "mt-4" }, OD = { class: "filter-list-actions" }, xD = j({
  __name: "TableListNavFilterSidebar",
  props: {
    filters: {},
    currentFilters: {}
  },
  emits: ["close"],
  setup(a, { expose: e, emit: t }) {
    const i = a, s = t, n = Z({}), o = Z(!1), l = Z({});
    let c = null;
    const d = Z([]), f = () => {
      const x = {};
      gi(i.filters, (S, k) => {
        u(), S.type == "checkbox" ? x[k] = [] : x[k] = null;
      }), n.value = Object.assign({}, x), c = Object.assign({}, Tn(x));
    }, p = (x) => {
      l.value[x] || ha(i.filters[x].filters) && (i.filters[x].filters = i.filters[x].filters()), l.value[x] = !l.value[x];
    }, m = f, v = () => {
      s("close", n.value), o.value = !1;
    }, r = () => JSON.stringify(n.value) != JSON.stringify(c), h = (x, S) => {
      switch (x.type) {
        case "checkbox":
          n.value[S] = [];
          break;
        case "date_range":
          u();
          break;
        default:
          n.value[S] = null;
          break;
      }
    }, u = () => {
      d.value[0] && d.value[0].clearDate();
    }, g = (x, S) => x.type == "checkbox" ? !!n.value[S].length : n.value[S] !== null && n.value[S] !== void 0, b = () => {
      const x = {};
      if (gi(i.currentFilters, (S, k) => {
        i.filters[k] !== void 0 && ["checkbox", "browser"].indexOf(i.filters[k].type) >= 0 && (S = S.split(",")), x[k] = S;
      }), n.value = Object.assign(n.value, x), Object.keys(i.filters).length == 1) {
        const S = Is(i.filters)[0];
        p(S);
      }
    };
    return e({
      open: () => {
        f(), b(), o.value = !0;
      }
    }), (x, S) => (M(), q(ll, {
      modelValue: o.value,
      "onUpdate:modelValue": S[0] || (S[0] = (k) => o.value = k),
      title: "Filtros",
      scrollable: ""
    }, {
      footer: U(() => [
        I("div", OD, [
          B(Le, {
            size: "md",
            type: "submit",
            form: "form-filter",
            variant: "primary",
            leadingIcon: "check"
          }, {
            default: U(() => [
              ye("Aplicar")
            ]),
            _: 1
          }),
          B(Le, {
            size: "md",
            onClick: et(m),
            disabled: !r()
          }, {
            default: U(() => [
              ye("Limpar os filtros")
            ]),
            _: 1
          }, 8, ["onClick", "disabled"])
        ])
      ]),
      default: U(() => [
        I("form", {
          onSubmit: Xt(v, ["prevent"]),
          id: "form-filter"
        }, [
          I("div", dD, [
            (M(!0), D(ke, null, Ae(x.filters, (k, C) => (M(), D("div", {
              key: k.name,
              class: he(["filter-list-item", { "-active": l.value[C], "-checked": g(k, C) }])
            }, [
              I("div", {
                class: "filter-list-title",
                onClick: (_) => p(String(C))
              }, [
                I("span", null, ne(k.name), 1),
                B(Pe, { name: "expand_more" })
              ], 8, uD),
              l.value[C] ? Ze((M(), D("div", fD, [
                k.type == "browser" ? (M(), D("div", pD, [
                  B(hD, {
                    modelValue: n.value[C],
                    "onUpdate:modelValue": (_) => n.value[C] = _,
                    name: `check_${C}`,
                    type: k.model,
                    service: k.service,
                    placeholder: "selecione",
                    title: "Selecione",
                    "select-type": "input"
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "name", "type", "service"])
                ])) : X("", !0),
                k.type == "date_range" ? (M(), D("div", gD, [
                  B(DP, {
                    ref_for: !0,
                    ref_key: "datePickerRef",
                    ref: d,
                    modelValue: n.value[C],
                    "onUpdate:modelValue": (_) => n.value[C] = _,
                    range: ""
                  }, null, 8, ["modelValue", "onUpdate:modelValue"])
                ])) : ["text", "number"].indexOf(k.type) >= 0 ? (M(), D("div", mD, [
                  B(hi, {
                    modelValue: n.value[C],
                    "onUpdate:modelValue": (_) => n.value[C] = _,
                    class: "d-block mb-2",
                    name: `check_${C}`,
                    placeholder: k.placeholder,
                    type: k.type
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "name", "placeholder", "type"])
                ])) : (M(!0), D(ke, { key: 3 }, Ae(k.filters, (_) => (M(), D("div", {
                  key: _.key
                }, [
                  k.type == "radio" ? (M(), D("div", bD, [
                    B(Mm, {
                      modelValue: n.value[C],
                      "onUpdate:modelValue": ($) => n.value[C] = $,
                      name: `radio_${C}`,
                      value: _.value,
                      tabindex: "1",
                      label: _.name
                    }, null, 8, ["modelValue", "onUpdate:modelValue", "name", "value", "label"])
                  ])) : X("", !0),
                  k.type == "checkbox" ? (M(), D("div", vD, [
                    B(ir, {
                      modelValue: n.value[C],
                      "onUpdate:modelValue": ($) => n.value[C] = $,
                      name: `check_${C}`,
                      value: _.value,
                      tabindex: "1",
                      label: _.name
                    }, null, 8, ["modelValue", "onUpdate:modelValue", "name", "value", "label"])
                  ])) : X("", !0)
                ]))), 128)),
                I("div", yD, [
                  B(Le, {
                    size: "md",
                    variant: "link",
                    onClick: (_) => h(k, C),
                    disabled: !g(k, C),
                    label: "Limpar"
                  }, null, 8, ["onClick", "disabled"])
                ])
              ], 512)), [
                [bt, l.value[C]]
              ]) : X("", !0)
            ], 2))), 128))
          ])
        ], 32)
      ]),
      _: 1
    }, 8, ["modelValue"]));
  }
}), wD = {
  key: 0,
  class: "table-list-nav-item"
}, SD = j({
  __name: "TableListNavFilter",
  props: {
    state: {}
  },
  setup(a, { expose: e }) {
    const t = a, i = Z(), s = (n) => {
      const o = {};
      gi(n, (l, c) => {
        l == null || Array.isArray(l) && l.length == 0 || (Array.isArray(l) ? o[c] = l.join(",") : o[c] = l);
      }), t.state.resetQueryParams(o), i.value.open();
    };
    return e({
      openFilterSidebar: () => i.value.open()
    }), (n, o) => t.state.config.filters ? (M(), D("span", wD, [
      B(Le, {
        size: et(es)() ? "md" : "sm",
        label: et(es)() ? "" : "Filtros",
        leadingIcon: "filter_list",
        onClick: o[0] || (o[0] = (l) => i.value.open()),
        class: "table-list-nav-btn"
      }, null, 8, ["size", "label"]),
      B(xD, {
        ref_key: "filterSidebarRef",
        ref: i,
        onClose: s,
        filters: t.state.config.filters,
        currentFilters: n.state.omitFilters
      }, null, 8, ["filters", "currentFilters"])
    ])) : X("", !0);
  }
}), kD = {}, _D = { class: "ui-dropdown-section" };
function CD(a, e) {
  return M(), D("div", _D, [
    te(a.$slots, "default")
  ]);
}
const TD = /* @__PURE__ */ gt(kD, [["render", CD]]), AD = {
  key: 0,
  class: "table-list-nav-item -custom-filter"
}, $D = { class: "dropdown-section" }, ED = /* @__PURE__ */ I("h6", null, "Salvar filtro", -1), PD = /* @__PURE__ */ I("div", { class: "mt-2" }, "Os filtros são salvos como uma nova aba no topo desta lista.", -1), LD = { class: "dropdown-section-buttons" }, MD = j({
  __name: "TableListNavCustomFilter",
  props: {
    state: {},
    service: {}
  },
  setup(a) {
    const e = a, t = [], i = Z(), s = Z(), n = Z({
      name: null
    }), o = (p) => {
      p.view = p.id || Mo(p.name), t.push(p);
    };
    at(async () => {
      const p = await e.service.get({ resource: e.state.config.customFilterResource });
      gi(e.state.config.customFilterPresets, (m) => {
        ni(m) && o(m), m == "active" && (o({ name: "Ativo", filter: { active: 1 } }), o({ name: "Inativo", filter: { active: 0 } }));
      }), gi(p.data, (m) => {
        o(m);
      }), e.state.tabs = t;
    });
    const l = ge(() => !(rA(e.state.queryParams.selectedView) || Is(e.state.omitFilters).length && e.state.queryParams.selectedView == "all")), c = async () => {
      e.state.currentTab && (await e.service.delete(e.state.currentTab), s.value.hide(), e.state.tabs = e.state.tabs.filter((p) => p.id != e.state.currentTab), e.state.resetQueryParams({
        selectedView: "all"
      }), Q0.open("Filtro deletado com sucesso"));
    }, d = async () => {
      let p;
      n.value.id ? (p = await e.service.update(n.value.id, mA(n.value, ["name", "filter"])), i.value.name = n.value.name) : (p = await e.service.create({
        name: n.value.name,
        filter: Vr(e.state.queryParams, e.state.omitFiltersValues),
        resource: e.state.config.customFilterResource
      }), p.view = p.id || Mo(p.name), e.state.tabs.push(p), e.state.setQueryParams({
        selectedView: p.id
      })), s.value.hide();
    }, f = () => {
      i.value = Mr(e.state.tabs, { view: Number(e.state.currentTab) }), i.value ? n.value = zn(i.value) : n.value = {
        name: null
      };
    };
    return (p, m) => et(es)() ? X("", !0) : (M(), D("span", AD, [
      B(ya, {
        ref_key: "dropdownRef",
        ref: s,
        onShow: f,
        disabled: l.value,
        right: ""
      }, {
        "button-content": U(() => [
          Number(p.state.currentTab) >= 1 ? (M(), q(Le, {
            key: 0,
            label: "Editar filtro",
            leadingIcon: "star",
            size: "sm",
            variant: "primary",
            disabled: l.value
          }, null, 8, ["disabled"])) : (M(), q(Le, {
            key: 1,
            label: "Salvar filtro",
            size: "sm",
            leadingIcon: "star",
            disabled: l.value
          }, null, 8, ["disabled"]))
        ]),
        default: U(() => [
          I("div", $D, [
            B(TD, null, {
              default: U(() => [
                I("form", {
                  onSubmit: Xt(d, ["prevent"]),
                  id: "form-custom-filter",
                  autocomplete: "off"
                }, [
                  ED,
                  B(hi, {
                    size: "sm",
                    modelValue: n.value.name,
                    "onUpdate:modelValue": m[0] || (m[0] = (v) => n.value.name = v),
                    placeholder: "Nome do filtro",
                    "data-close": "none",
                    required: "",
                    tabindex: "1"
                  }, null, 8, ["modelValue"]),
                  PD
                ], 32)
              ]),
              _: 1
            }),
            I("div", LD, [
              n.value.id ? (M(), q(Le, {
                key: 0,
                size: "sm",
                tabindex: "-1",
                label: "Remover",
                variant: "danger",
                outline: "",
                onClick: c
              })) : X("", !0),
              B(Le, {
                size: "sm",
                label: "Salvar",
                tabindex: "2",
                type: "submit",
                form: "form-custom-filter"
              })
            ])
          ])
        ]),
        _: 1
      }, 8, ["disabled"])
    ]));
  }
});
const DD = { class: "table-list-pagination" }, RD = { class: "table-list-pagination-list" }, ID = { class: "table-list-pagination-item prev" }, QD = { class: "table-list-pagination-item next" }, up = j({
  __name: "TableListNavPagination",
  props: {
    meta: {},
    state: {}
  },
  setup(a) {
    const e = a, t = () => {
      let s = e.state.queryParams.page;
      s > 1 && e.state.setQueryParams({
        page: --s
      });
    }, i = () => {
      let s = e.state.queryParams.page ?? 1;
      e.meta.last_page > s && e.state.setQueryParams({
        page: ++s
      });
    };
    return (s, n) => (M(), D("div", DD, [
      I("div", RD, [
        Ze(I("div", { class: "table-list-pagination-item meta" }, ne(s.meta.from) + " – " + ne(s.meta.to) + " " + ne(s.meta.total ? "de " + s.meta.total : ""), 513), [
          [bt, s.meta.from]
        ]),
        I("div", ID, [
          B(Ti, {
            size: "md",
            onClick: t,
            icon: "arrow_back",
            disabled: s.meta.current_page == 1,
            class: "table-list-nav-btn prev"
          }, null, 8, ["disabled"])
        ]),
        I("div", QD, [
          B(Ti, {
            size: "md",
            onClick: i,
            icon: "arrow_forward",
            disabled: s.meta.last_page == s.meta.current_page || !s.meta.total,
            class: "table-list-nav-btn next"
          }, null, 8, ["disabled"])
        ])
      ])
    ]));
  }
});
const ND = { class: "table-list-empty-search" }, FD = { class: "table-list-empty-search-content" }, WD = { class: "table-list-empty-search-icon" }, BD = /* @__PURE__ */ I("div", { class: "table-list-empty-search-title" }, "Sua pesquisa não retornou nenhum resultado", -1), zD = { class: "table-list-empty-search-text" }, XD = j({
  __name: "TableListEmptySearch",
  emits: ["resetQueryParams"],
  setup(a, { emit: e }) {
    const t = e;
    return (i, s) => (M(), D("div", ND, [
      I("div", FD, [
        I("div", WD, [
          B(Pe, {
            name: "search",
            size: "40"
          })
        ]),
        BD,
        I("div", zD, [
          ye(" Essa opção não existe na sua loja, tente "),
          I("a", {
            onClick: s[0] || (s[0] = (n) => t("resetQueryParams"))
          }, "outra opção de filtro")
        ])
      ])
    ]));
  }
});
const YD = { class: "table-list-empty-message" }, VD = /* @__PURE__ */ I("h4", { class: "table-list-empty-message-title" }, "Esta seção não possui registros", -1), HD = ["innerHTML"], GD = j({
  __name: "TableListEmptyMessage",
  props: {
    msg: String
  },
  setup(a) {
    return (e, t) => (M(), D("div", YD, [
      VD,
      a.msg ? (M(), D("div", {
        key: 0,
        innerHTML: a.msg,
        class: "table-list-empty-message-text"
      }, null, 8, HD)) : X("", !0)
    ]));
  }
});
const jD = {
  key: 2,
  class: "table-list"
}, QH = j({
  __name: "TableList",
  props: {
    config: {},
    filters: {},
    placeholder: {},
    to: {}
  },
  emits: ["clickRow", "emptyData", "deletedItem"],
  setup(a, { expose: e, emit: t }) {
    const i = a, s = t, n = Z(), o = Z([]), l = Z(!1), c = Z([]), d = Z(!1), f = Z(!1), p = Z({}), m = Z({}), v = rp(), r = Z(!1), h = Z({}), u = Object.assign({ actions: ["remove", "active"], hideCheckbox: !1 }, i.config), g = `adm_table_filters_${String(v.name)}`, b = Z(null), O = Z(), x = Object.assign(
      {
        sort: "-id",
        page: "1",
        limit: 25,
        selectedView: "all"
      },
      i.config.queryParams
    );
    let S = ZC(
      ["page", "sort", "_", "limit", "selectedView", "customFilterId", "version"],
      i.config.omitFiltersValues
    );
    const k = (ie) => {
      delete m.value[ie], delete m.value.customFilterId, m.value.selectedView = "all", _(m.value);
    }, C = (ie) => F2(ie, ["_", "limit"]), _ = (ie) => {
      const fe = Object.assign({}, m.value, { selectedView: "all" }, ie);
      m.value = fe;
    }, $ = (ie = {}) => {
      xe.term = null, m.value = Object.assign(Tn(x), ie);
    }, L = () => s("emptyData"), E = async () => {
      const ie = Tn(m.value);
      c.value = [], r.value = !0, p.value = Vr(ie, S), C(ie), ap.setObj(g, ie);
      const fe = await i.config.service.get(ie);
      !fe.data.length && sA(x, Vr(ie, "_")) && L(), h.value = fe.meta, o.value = fe.data, f.value = Object.keys(p.value).length === 0 && !ie.q && !fe.data.length, r.value = !1, T(fe.data);
    }, A = (ie) => {
      if (ie && o.value) {
        const fe = [];
        o.value.forEach(($e) => {
          fe.push(Number($e.id));
        }), c.value = fe;
      } else
        c.value = [];
    }, y = async (ie) => {
      i.config.remove ? await i.config.remove(ie) : await i.config.service.delete(Number(ie.id)), E();
    }, w = (ie, fe) => i.config.service.update(Number(ie.id), { active: fe }), T = (ie) => {
      d.value = !0, i.config.onGet && typeof i.config.onGet == "function" && i.config.onGet(ie);
    }, P = (ie) => s("clickRow", ie), R = (ie) => {
      const fe = ie.target;
      return l.value = fe.scrollLeft > 10;
    }, Q = (ie) => {
      o.value && o.value.unshift(ie);
    }, z = async (ie) => {
      for (const fe of c.value)
        await w({ id: fe }, ie);
      E();
    }, W = async () => {
      const ie = [], fe = [];
      for (const $e of c.value)
        fe.push($e), ie.push(y({ id: $e }));
      try {
        await Promise.all(ie), s("deletedItem", fe);
      } catch ($e) {
        b.value = {
          erro: [$e.data.error]
        };
      }
      E();
    }, G = () => Object.assign(Tn(x), Tn(rp().query));
    $0(() => {
      O.value = v.query.sort;
    }), at(() => {
      S = SA(S, i.config.omitFilters);
      const ie = ap.getObj(g), fe = v.query;
      !O.value && ie ? m.value = Object.assign(ie, fe ?? {}) : m.value = G();
    });
    let de;
    zt(
      () => m.value,
      (ie, fe) => {
        clearTimeout(de), ie != fe && (de = setTimeout(() => {
          ie.q && (xe.term = ie.q), !ie.selectedView && !ie.customFilterId && (ie.selectedView = "all"), E();
        }, 100));
      },
      { deep: !0 }
    ), zt(
      () => v.query,
      (ie) => {
        ie.q && _({
          q: String(ie.q),
          page: 1
        });
      }
    );
    const xe = Wr({
      queryParams: m,
      omitFilters: p,
      config: u,
      tabs: [],
      currentTab: {},
      term: null,
      omitFiltersValues: S,
      fetchData: E,
      checkAll: A,
      setQueryParams: _,
      resetQueryParams: $,
      removeFilter: k,
      removeSelected: W,
      toggleActiveSelected: z,
      activeOne: w,
      deleteOne: y,
      clickRow: P
    });
    return e({
      unshiftItem: Q,
      refresh: E,
      openFilterSidebar: () => n.value.openFilterSidebar()
    }), (ie, fe) => (M(), D(ke, null, [
      B(Ob, {
        modelValue: b.value,
        "onUpdate:modelValue": fe[0] || (fe[0] = ($e) => b.value = $e)
      }, null, 8, ["modelValue"]),
      r.value && !d.value ? (M(), q(Oa, {
        key: 0,
        class: "table-list-skeleton",
        noPadding: ""
      }, {
        default: U(() => [
          B(VA, {
            cols: "3",
            rows: "6",
            withAction: "1"
          })
        ]),
        _: 1
      })) : X("", !0),
      !r.value && f.value ? (M(), q(GD, {
        key: 1,
        msg: ie.config.empty
      }, null, 8, ["msg"])) : Ze((M(), D("div", jD, [
        B(_M, { state: xe }, null, 8, ["state"]),
        B(oM, { loading: r.value }, {
          default: U(() => [
            B(DM, {
              state: xe,
              selected: c.value,
              config: et(u),
              rows: o.value
            }, null, 8, ["state", "selected", "config", "rows"]),
            et(es)() ? X("", !0) : (M(), q(RM, {
              key: 0,
              state: xe
            }, null, 8, ["state"])),
            B(EM, {
              onRefresh: E,
              placeholder: et(u).placeholder,
              state: xe
            }, null, 8, ["placeholder", "state"]),
            ie.config.customFilterService ? (M(), q(MD, {
              key: 1,
              service: ie.config.customFilterService,
              state: xe
            }, null, 8, ["service", "state"])) : X("", !0),
            B(FM, {
              sortable: et(u).sortable,
              queryParams: m.value,
              setQueryParams: _
            }, null, 8, ["sortable", "queryParams"]),
            B(SD, {
              ref_key: "tableListNavFilterRef",
              ref: n,
              state: xe
            }, null, 8, ["state"]),
            et(es)() ? X("", !0) : (M(), q(up, {
              key: 2,
              meta: h.value,
              state: xe
            }, null, 8, ["meta", "state"]))
          ]),
          _: 1
        }, 8, ["loading"]),
        B(lM, { state: xe }, null, 8, ["state"]),
        I("div", {
          class: he(["table-list-wrapper", { "-scroll": l.value }]),
          onScroll: R
        }, [
          Ze(B(XD, { onResetQueryParams: $ }, null, 512), [
            [bt, !o.value.length && !r.value]
          ]),
          B(TM, {
            selected: c.value,
            "onUpdate:selected": fe[1] || (fe[1] = ($e) => c.value = $e),
            rows: o.value,
            state: xe,
            to: ie.to
          }, dd({
            default: U(({ item: $e }) => [
              te(ie.$slots, "default", { item: $e })
            ]),
            _: 2
          }, [
            ie.$slots.head ? {
              name: "head",
              fn: U(() => [
                te(ie.$slots, "head")
              ]),
              key: "0"
            } : void 0
          ]), 1032, ["selected", "rows", "state", "to"])
        ], 34),
        et(es)() ? (M(), q(up, {
          key: 0,
          meta: h.value,
          state: xe
        }, null, 8, ["meta", "state"])) : X("", !0)
      ], 512)), [
        [bt, d.value]
      ])
    ], 64));
  }
}), UD = { id: "player" }, ZD = j({
  __name: "YoutubePlayer",
  props: {
    videoId: {},
    width: {},
    height: {}
  },
  setup(a) {
    const e = a, t = Z();
    window.onYouTubeIframeAPIReady = i;
    function i() {
      t.value = new YT.Player("player", {
        height: e.height || "360",
        width: e.width || "640",
        videoId: e.videoId,
        events: {
          onReady: s
        }
      });
    }
    function s(n) {
      n.target.playVideo();
    }
    return at(() => {
      if (window.onYTReady)
        i();
      else {
        const n = document.createElement("script");
        n.src = "https://www.youtube.com/iframe_api";
        const o = document.getElementsByTagName("script")[0];
        o.parentNode.insertBefore(n, o);
      }
    }), (n, o) => (M(), D("div", UD));
  }
});
const qD = { class: "page-helper-video-modal" }, KD = { class: "videoWrapper" }, JD = { class: "page-helper-video-title" }, eR = { class: "page-helper-video-default" }, tR = { class: "page-helper-video-default-title" }, iR = { class: "page-helper-video-default-support" }, sR = { class: "page-helper-video-modal-list" }, nR = j({
  __name: "PageHelperVideoModal",
  props: {
    title: { default: "Base de conhecimento" },
    supportTitle: { default: "Para encontrar ainda mais informações, explore nossos artigos disponíveis na base de conhecimento." }
  },
  setup(a, { expose: e }) {
    const t = Z({}), i = Z(!1);
    return e({
      open: (n) => {
        t.value = n, i.value = !0;
      }
    }), (n, o) => (M(), q(ll, {
      modelValue: i.value,
      "onUpdate:modelValue": o[0] || (o[0] = (l) => i.value = l),
      title: "Ajuda",
      size: "sm"
    }, {
      default: U(() => [
        I("div", qD, [
          B(Fu, null, {
            default: U(() => [
              I("div", KD, [
                B(ZD, {
                  "video-id": t.value.video_id,
                  width: 480,
                  height: 320,
                  style: { width: "100%" }
                }, null, 8, ["video-id"])
              ])
            ]),
            _: 1
          }),
          B(Fu, null, {
            default: U(() => [
              I("div", JD, [
                I("div", eR, [
                  I("h3", tR, ne(n.title), 1),
                  I("p", iR, ne(n.supportTitle), 1)
                ])
              ]),
              I("ul", sR, [
                (M(!0), D(ke, null, Ae(t.value.articles, (l) => (M(), D("li", {
                  key: l.url
                }, [
                  B(Ai, {
                    href: l.url,
                    target: "_blank"
                  }, {
                    default: U(() => [
                      ye(ne(l.name), 1)
                    ]),
                    _: 2
                  }, 1032, ["href"])
                ]))), 128))
              ])
            ]),
            _: 1
          })
        ])
      ]),
      _: 1
    }, 8, ["modelValue"]));
  }
});
const rR = { class: "ui-page-helper-video-message" }, aR = /* @__PURE__ */ I("b", null, "Precisa de ajuda?", -1), oR = { class: "text-lowercase" }, lR = j({
  __name: "PageHelperVideo",
  props: {
    video: {}
  },
  setup(a) {
    const e = a, t = Z(), i = () => {
      t.value.open(e.video);
    };
    return (s, n) => (M(), D(ke, null, [
      s.video.video_id ? (M(), D("div", {
        key: 0,
        class: "ui-page-helper-video",
        onClick: i
      }, [
        I("div", rR, [
          B(Pe, {
            class: "ui-page-helper-video-icon",
            name: "play_circle",
            filled: "",
            size: "24"
          }),
          I("span", null, [
            aR,
            ye(" Assista o vídeo sobre "),
            I("b", oR, ne(s.video.name), 1)
          ])
        ])
      ])) : X("", !0),
      B(nR, {
        ref_key: "pageHelperVideoModalRef",
        ref: t
      }, null, 512)
    ], 64));
  }
});
const cR = { class: "page-message-support" }, hR = { class: "page-message-support-text" }, dR = { class: "page-message-support-link" }, uR = j({
  __name: "PageMessageSupport",
  props: {
    name: {},
    link: {}
  },
  setup(a) {
    return (e, t) => (M(), D("div", cR, [
      B(Pe, {
        class: "icon",
        name: "info"
      }),
      I("span", hR, [
        ye(" Saiba mais sobre "),
        I("span", dR, [
          B(Ai, {
            href: e.link,
            external: "",
            label: e.name
          }, null, 8, ["href", "label"])
        ]),
        ye(" na base de conhecimento. ")
      ])
    ]));
  }
});
const fR = /* @__PURE__ */ I("b", null, "Precisa de ajuda?", -1), pR = { class: "ui-page-helper-name" }, gR = j({
  __name: "PageHelper",
  props: {
    helperName: {},
    helperLink: {}
  },
  emits: ["onClickLink"],
  setup(a, { emit: e }) {
    const t = a, i = e;
    function s() {
      i("onClickLink"), t.helperLink && window.open(t.helperLink, "blank");
    }
    return (n, o) => (M(), D("div", {
      class: "ui-page-helper",
      onClick: s
    }, [
      B(Pe, {
        name: "info",
        filled: "",
        size: "24"
      }),
      I("span", null, [
        fR,
        ye(" Acesse o material sobre "),
        I("b", pR, ne(n.helperName), 1)
      ])
    ]));
  }
});
const mR = { class: "page-helper-articles" }, bR = /* @__PURE__ */ I("p", { class: "page-helper-articles-support" }, " Para encontrar ainda mais informações, explore nossos artigos disponíveis na base de conhecimento. ", -1), vR = { class: "page-helper-articles-list" }, yR = j({
  __name: "PageHelperArticlesModal",
  setup(a, { expose: e }) {
    const t = Z(!1), i = Z("Ajuda"), s = Z();
    return e({
      open: (o) => {
        s.value = o.articles, o.title && (i.value = o.title), t.value = !0;
      }
    }), (o, l) => (M(), q(ll, {
      modelValue: t.value,
      "onUpdate:modelValue": l[0] || (l[0] = (c) => t.value = c),
      title: "Ajuda",
      size: "sm"
    }, {
      default: U(() => [
        I("div", mR, [
          bR,
          I("ul", vR, [
            (M(!0), D(ke, null, Ae(s.value, (c) => (M(), D("li", {
              class: "page-helper-articles-item",
              key: c.url
            }, [
              B(Ai, {
                href: c.url,
                target: "_blank"
              }, {
                default: U(() => [
                  ye(ne(c.name), 1)
                ]),
                _: 2
              }, 1032, ["href"])
            ]))), 128))
          ])
        ])
      ]),
      _: 1
    }, 8, ["modelValue"]));
  }
}), OR = j({
  __name: "PageHelperArticles",
  props: {
    title: {},
    articles: {}
  },
  setup(a) {
    const e = a, t = Z(), i = () => {
      t.value.open({ title: e.title, articles: e.articles });
    };
    return (s, n) => (M(), D(ke, null, [
      B(gR, {
        "helper-name": s.title || "esse item",
        onOnClickLink: i
      }, null, 8, ["helper-name"]),
      B(yR, {
        ref_key: "pageHelperArticleModalRef",
        ref: t
      }, null, 512)
    ], 64));
  }
});
const xR = {
  key: 1,
  class: "ui-page-help"
}, NH = j({
  __name: "Page",
  props: {
    hideTitle: { type: Boolean },
    primaryAction: {},
    secondaryActions: {},
    to: {},
    backlink: {},
    size: {},
    videoHelp: {},
    articlesHelp: {},
    footerHelp: {},
    title: {},
    groupActions: {}
  },
  setup(a) {
    const e = a, t = Z([]), i = ge(() => {
      var n, o;
      const s = {
        title: e == null ? void 0 : e.title,
        articles: []
      };
      return (n = e == null ? void 0 : e.articlesHelp) != null && n.length && (s.articles = e.articlesHelp), s.articles = ((o = e.videoHelp) == null ? void 0 : o.articles) || [], s;
    });
    return e.size && t.value.push(`-${e.size}`), (s, n) => {
      var o, l, c, d;
      return M(), D("div", {
        class: he(["ui-page", t.value])
      }, [
        e.hideTitle ? X("", !0) : (M(), q(n2, {
          key: 0,
          title: s.title,
          to: s.to,
          backlink: s.backlink,
          groupActions: s.groupActions,
          "primary-action": s.primaryAction,
          "secondary-actions": s.secondaryActions
        }, {
          "titlebar-subtitle": U(() => [
            te(s.$slots, "titlebar-subtitle")
          ]),
          _: 3
        }, 8, ["title", "to", "backlink", "groupActions", "primary-action", "secondary-actions"])),
        (o = s.videoHelp) != null && o.video_id ? (M(), D("div", xR, [
          B(lR, { video: s.videoHelp }, null, 8, ["video"]),
          !((l = s.videoHelp) != null && l.video_id) && ((d = (c = i.value) == null ? void 0 : c.articles) != null && d.length) ? (M(), q(OR, {
            key: 0,
            articles: i.value.articles,
            title: i.value.title
          }, null, 8, ["articles", "title"])) : X("", !0)
        ])) : X("", !0),
        te(s.$slots, "default"),
        s.footerHelp ? (M(), q(uR, {
          key: 2,
          name: s.footerHelp.name,
          link: s.footerHelp.link
        }, null, 8, ["name", "link"])) : X("", !0)
      ], 2);
    };
  }
});
const wR = { class: "selectable-list" }, SR = ["onClick"], kR = { class: "selectable-list-item-text" }, FH = j({
  __name: "RowExclude",
  props: {
    rows: {},
    modelValue: {}
  },
  emits: ["update:modelValue", "update"],
  setup(a, { emit: e }) {
    const t = e, i = a, s = Z([]), n = (c) => {
      rc(s.value, c.id) != -1 ? s.value = s.value.filter((d) => d != c.id) : s.value.push(c.id), o();
    }, o = () => {
      if (i.rows) {
        const c = [];
        i.rows.map((d) => {
          rc(s.value, d.id) == -1 && c.push(d.id);
        }), t("update", c), t("update:modelValue", c);
      }
    }, l = () => {
      i.rows && (s.value = [], i.rows.map((c) => {
        rc(i.modelValue, c.id) == -1 && s.value.push(c.id);
      }));
    };
    return zt([() => i.modelValue, () => i.rows], () => l(), { immediate: !0 }), (c, d) => (M(), D("div", wR, [
      (M(!0), D(ke, null, Ae(c.rows, (f) => (M(), D("div", {
        class: he(["selectable-list-item", { "-selected": s.value.includes(f.id) }]),
        key: f.id,
        onClick: Xt((p) => n(f), ["stop"])
      }, [
        B(ir, {
          modelValue: s.value,
          "onUpdate:modelValue": d[0] || (d[0] = (p) => s.value = p),
          value: f.id
        }, null, 8, ["modelValue", "value"]),
        I("span", kR, ne(f.name), 1)
      ], 10, SR))), 128))
    ]));
  }
}), WH = j({
  __name: "CardActive",
  props: {
    modelValue: { default: () => ({ active: !0 }) },
    hideDelete: { type: Boolean },
    preventActive: {},
    delete: {}
  },
  emits: ["delete", "toggleActive", "update:modelValue"],
  setup(a, { emit: e }) {
    const t = e, i = a, s = async () => {
      fd.delete({
        title: "Remover o registro",
        message: `A ação removerá o registro ${i.modelValue.name}.`,
        onCallback: async () => {
          i.delete && i.modelValue.id && await i.delete(i.modelValue.id), t("delete", { id: i.modelValue.id });
        }
      });
    }, n = (l) => {
      i.preventActive && (i.preventActive(), l.preventDefault());
    }, o = () => {
      t("toggleActive", i.modelValue.active);
    };
    return (l, c) => (M(), q(Oa, { class: "ui-card-active" }, {
      default: U(() => [
        B(wl, { alignV: "center" }, {
          default: U(() => [
            B(rn, null, {
              default: U(() => [
                B(ir, {
                  modelValue: l.modelValue.active,
                  "onUpdate:modelValue": c[0] || (c[0] = (d) => l.modelValue.active = d),
                  switch: "",
                  onChange: o,
                  onClick: Xt(n, ["stop"])
                }, {
                  default: U(() => [
                    Ze(I("span", null, "Ativo", 512), [
                      [bt, l.modelValue.active]
                    ]),
                    Ze(I("span", null, "Inativo", 512), [
                      [bt, !l.modelValue.active]
                    ])
                  ]),
                  _: 1
                }, 8, ["modelValue"])
              ]),
              _: 1
            }),
            B(rn, { auto: "" }, {
              default: U(() => [
                !l.hideDelete && l.modelValue.id ? (M(), q(Ti, {
                  key: 0,
                  icon: "delete",
                  onClick: s
                })) : X("", !0)
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
});
const _R = { class: "ui-stats-item" }, CR = { class: "ui-stats-item-label" }, TR = { class: "ui-stats-item-value" }, AR = ["textContent"], ER = j({
  __name: "StatsItem",
  props: {
    label: {},
    value: {},
    perc: {},
    info: {},
    primaryAction: {},
    text: {}
  },
  setup(a) {
    return (e, t) => (M(), D("div", _R, [
      I("small", CR, [
        ye(ne(e.label) + " ", 1),
        e.info ? Ze((M(), q(Pe, {
          key: 0,
          name: "info"
        }, null, 512)), [
          [et(Pm), e.info, "top"]
        ]) : X("", !0)
      ]),
      I("span", TR, ne(e.value), 1),
      e.perc != null ? (M(), D("div", {
        key: 0,
        class: he(["stats-perc", { positive: Number(e.perc) > 0 }])
      }, [
        B(Pe, { name: "south" }),
        B(Pe, { name: "north" }),
        I("span", null, ne(e.perc) + "%", 1)
      ], 2)) : X("", !0),
      e.text ? (M(), D("small", {
        key: 1,
        textContent: ne(e.text)
      }, null, 8, AR)) : X("", !0),
      e.primaryAction ? (M(!0), D(ke, { key: 2 }, Ae(e.primaryAction, (i) => (M(), D("small", {
        class: "stats-action",
        key: i.text
      }, [
        i.button == !0 ? (M(), q(Le, {
          key: 0,
          label: i.text,
          href: i.href,
          to: i.to,
          size: "sm",
          variant: "primary"
        }, null, 8, ["label", "href", "to"])) : (M(), q(Ai, {
          key: 1,
          label: i.text,
          href: i.href,
          to: i.to
        }, null, 8, ["label", "href", "to"]))
      ]))), 128)) : X("", !0),
      te(e.$slots, "default")
    ]));
  }
});
const PR = { class: "stats-group" }, LR = {
  key: 0,
  class: "stats-group-wrapper"
}, MR = {
  key: 1,
  class: "stats-group-wrapper"
}, BH = j({
  __name: "StatsGroup",
  props: {
    infos: {}
  },
  setup(a) {
    return (e, t) => (M(), D("div", PR, [
      e.infos ? (M(), D("div", LR, [
        (M(!0), D(ke, null, Ae(e.infos, (i) => (M(), q(ER, {
          key: i.label,
          value: i.value,
          label: i.label,
          primaryAction: i.primaryAction,
          text: i.text
        }, null, 8, ["value", "label", "primaryAction", "text"]))), 128)),
        te(e.$slots, "default")
      ])) : (M(), D("div", MR, [
        te(e.$slots, "default")
      ]))
    ]));
  }
});
let Qn = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((a) => a ? parseInt(a, 36) : 1);
for (let a = 1; a < Qn.length; a++)
  Qn[a] += Qn[a - 1];
function DR(a) {
  for (let e = 1; e < Qn.length; e += 2)
    if (Qn[e] > a)
      return Qn[e - 1] <= a;
  return !1;
}
function fp(a) {
  return a >= 127462 && a <= 127487;
}
const pp = 8205;
function ti(a, e, t = !0, i = !0) {
  return (t ? Gv : RR)(a, e, i);
}
function Gv(a, e, t) {
  if (e == a.length)
    return e;
  e && jv(a.charCodeAt(e)) && Uv(a.charCodeAt(e - 1)) && e--;
  let i = Dt(a, e);
  for (e += ci(i); e < a.length; ) {
    let s = Dt(a, e);
    if (i == pp || s == pp || t && DR(s))
      e += ci(s), i = s;
    else if (fp(s)) {
      let n = 0, o = e - 2;
      for (; o >= 0 && fp(Dt(a, o)); )
        n++, o -= 2;
      if (n % 2 == 0)
        break;
      e += 2;
    } else
      break;
  }
  return e;
}
function RR(a, e, t) {
  for (; e > 0; ) {
    let i = Gv(a, e - 2, t);
    if (i < e)
      return i;
    e--;
  }
  return 0;
}
function jv(a) {
  return a >= 56320 && a < 57344;
}
function Uv(a) {
  return a >= 55296 && a < 56320;
}
function Dt(a, e) {
  let t = a.charCodeAt(e);
  if (!Uv(t) || e + 1 == a.length)
    return t;
  let i = a.charCodeAt(e + 1);
  return jv(i) ? (t - 55296 << 10) + (i - 56320) + 65536 : t;
}
function zd(a) {
  return a <= 65535 ? String.fromCharCode(a) : (a -= 65536, String.fromCharCode((a >> 10) + 55296, (a & 1023) + 56320));
}
function ci(a) {
  return a < 65536 ? 1 : 2;
}
function Sa(a, e, t = a.length) {
  let i = 0;
  for (let s = 0; s < t; )
    a.charCodeAt(s) == 9 ? (i += e - i % e, s++) : (i++, s = ti(a, s));
  return i;
}
function Oh(a, e, t, i) {
  for (let s = 0, n = 0; ; ) {
    if (n >= e)
      return s;
    if (s == a.length)
      break;
    n += a.charCodeAt(s) == 9 ? t - n % t : 1, s = ti(a, s);
  }
  return i === !0 ? -1 : a.length;
}
class We {
  /**
  @internal
  */
  constructor() {
  }
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, t, i) {
    let s = [];
    return this.decompose(
      0,
      e,
      s,
      2
      /* To */
    ), i.length && i.decompose(
      0,
      i.length,
      s,
      3
      /* To */
    ), this.decompose(
      t,
      this.length,
      s,
      1
      /* From */
    ), Qi.from(s, this.length - (t - e) + i.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, t = this.length) {
    let i = [];
    return this.decompose(e, t, i, 0), Qi.from(i, t - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let t = this.scanIdentical(e, 1), i = this.length - this.scanIdentical(e, -1), s = new Ir(this), n = new Ir(e);
    for (let o = t, l = t; ; ) {
      if (s.next(o), n.next(o), o = 0, s.lineBreak != n.lineBreak || s.done != n.done || s.value != n.value)
        return !1;
      if (l += s.value.length, s.done || l >= i)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings, and for long lines, might split lines
  themselves into multiple chunks as well.
  */
  iter(e = 1) {
    return new Ir(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, t = this.length) {
    return new Zv(this, e, t);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, t) {
    let i;
    if (e == null)
      i = this.iter();
    else {
      t == null && (t = this.lines + 1);
      let s = this.line(e).from;
      i = this.iterRange(s, Math.max(s, t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to));
    }
    return new qv(i);
  }
  /**
  @internal
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#text.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? We.empty : e.length <= 32 ? new ht(e) : Qi.from(ht.split(e, []));
  }
}
class ht extends We {
  constructor(e, t = IR(e)) {
    super(), this.text = e, this.length = t;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, t, i, s) {
    for (let n = 0; ; n++) {
      let o = this.text[n], l = s + o.length;
      if ((t ? i : l) >= e)
        return new QR(s, l, i, o);
      s = l + 1, i++;
    }
  }
  decompose(e, t, i, s) {
    let n = e <= 0 && t >= this.length ? this : new ht(gp(this.text, e, t), Math.min(t, this.length) - Math.max(0, e));
    if (s & 1) {
      let o = i.pop(), l = fo(n.text, o.text.slice(), 0, n.length);
      if (l.length <= 32)
        i.push(new ht(l, o.length + n.length));
      else {
        let c = l.length >> 1;
        i.push(new ht(l.slice(0, c)), new ht(l.slice(c)));
      }
    } else
      i.push(n);
  }
  replace(e, t, i) {
    if (!(i instanceof ht))
      return super.replace(e, t, i);
    let s = fo(this.text, fo(i.text, gp(this.text, 0, e)), t), n = this.length + i.length - (t - e);
    return s.length <= 32 ? new ht(s, n) : Qi.from(ht.split(s, []), n);
  }
  sliceString(e, t = this.length, i = `
`) {
    let s = "";
    for (let n = 0, o = 0; n <= t && o < this.text.length; o++) {
      let l = this.text[o], c = n + l.length;
      n > e && o && (s += i), e < c && t > n && (s += l.slice(Math.max(0, e - n), t - n)), n = c + 1;
    }
    return s;
  }
  flatten(e) {
    for (let t of this.text)
      e.push(t);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, t) {
    let i = [], s = -1;
    for (let n of e)
      i.push(n), s += n.length + 1, i.length == 32 && (t.push(new ht(i, s)), i = [], s = -1);
    return s > -1 && t.push(new ht(i, s)), t;
  }
}
class Qi extends We {
  constructor(e, t) {
    super(), this.children = e, this.length = t, this.lines = 0;
    for (let i of e)
      this.lines += i.lines;
  }
  lineInner(e, t, i, s) {
    for (let n = 0; ; n++) {
      let o = this.children[n], l = s + o.length, c = i + o.lines - 1;
      if ((t ? c : l) >= e)
        return o.lineInner(e, t, i, s);
      s = l + 1, i = c + 1;
    }
  }
  decompose(e, t, i, s) {
    for (let n = 0, o = 0; o <= t && n < this.children.length; n++) {
      let l = this.children[n], c = o + l.length;
      if (e <= c && t >= o) {
        let d = s & ((o <= e ? 1 : 0) | (c >= t ? 2 : 0));
        o >= e && c <= t && !d ? i.push(l) : l.decompose(e - o, t - o, i, d);
      }
      o = c + 1;
    }
  }
  replace(e, t, i) {
    if (i.lines < this.lines)
      for (let s = 0, n = 0; s < this.children.length; s++) {
        let o = this.children[s], l = n + o.length;
        if (e >= n && t <= l) {
          let c = o.replace(e - n, t - n, i), d = this.lines - o.lines + c.lines;
          if (c.lines < d >> 5 - 1 && c.lines > d >> 5 + 1) {
            let f = this.children.slice();
            return f[s] = c, new Qi(f, this.length - (t - e) + i.length);
          }
          return super.replace(n, l, c);
        }
        n = l + 1;
      }
    return super.replace(e, t, i);
  }
  sliceString(e, t = this.length, i = `
`) {
    let s = "";
    for (let n = 0, o = 0; n < this.children.length && o <= t; n++) {
      let l = this.children[n], c = o + l.length;
      o > e && n && (s += i), e < c && t > o && (s += l.sliceString(e - o, t - o, i)), o = c + 1;
    }
    return s;
  }
  flatten(e) {
    for (let t of this.children)
      t.flatten(e);
  }
  scanIdentical(e, t) {
    if (!(e instanceof Qi))
      return 0;
    let i = 0, [s, n, o, l] = t > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; s += t, n += t) {
      if (s == o || n == l)
        return i;
      let c = this.children[s], d = e.children[n];
      if (c != d)
        return i + c.scanIdentical(d, t);
      i += c.length + 1;
    }
  }
  static from(e, t = e.reduce((i, s) => i + s.length + 1, -1)) {
    let i = 0;
    for (let v of e)
      i += v.lines;
    if (i < 32) {
      let v = [];
      for (let r of e)
        r.flatten(v);
      return new ht(v, t);
    }
    let s = Math.max(
      32,
      i >> 5
      /* BranchShift */
    ), n = s << 1, o = s >> 1, l = [], c = 0, d = -1, f = [];
    function p(v) {
      let r;
      if (v.lines > n && v instanceof Qi)
        for (let h of v.children)
          p(h);
      else
        v.lines > o && (c > o || !c) ? (m(), l.push(v)) : v instanceof ht && c && (r = f[f.length - 1]) instanceof ht && v.lines + r.lines <= 32 ? (c += v.lines, d += v.length + 1, f[f.length - 1] = new ht(r.text.concat(v.text), r.length + 1 + v.length)) : (c + v.lines > s && m(), c += v.lines, d += v.length + 1, f.push(v));
    }
    function m() {
      c != 0 && (l.push(f.length == 1 ? f[0] : Qi.from(f, d)), d = -1, c = f.length = 0);
    }
    for (let v of e)
      p(v);
    return m(), l.length == 1 ? l[0] : new Qi(l, t);
  }
}
We.empty = /* @__PURE__ */ new ht([""], 0);
function IR(a) {
  let e = -1;
  for (let t of a)
    e += t.length + 1;
  return e;
}
function fo(a, e, t = 0, i = 1e9) {
  for (let s = 0, n = 0, o = !0; n < a.length && s <= i; n++) {
    let l = a[n], c = s + l.length;
    c >= t && (c > i && (l = l.slice(0, i - s)), s < t && (l = l.slice(t - s)), o ? (e[e.length - 1] += l, o = !1) : e.push(l)), s = c + 1;
  }
  return e;
}
function gp(a, e, t) {
  return fo(a, [""], e, t);
}
class Ir {
  constructor(e, t = 1) {
    this.dir = t, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [t > 0 ? 1 : (e instanceof ht ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, t) {
    for (this.done = this.lineBreak = !1; ; ) {
      let i = this.nodes.length - 1, s = this.nodes[i], n = this.offsets[i], o = n >> 1, l = s instanceof ht ? s.text.length : s.children.length;
      if (o == (t > 0 ? l : 0)) {
        if (i == 0)
          return this.done = !0, this.value = "", this;
        t > 0 && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((n & 1) == (t > 0 ? 0 : 1)) {
        if (this.offsets[i] += t, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (s instanceof ht) {
        let c = s.text[o + (t < 0 ? -1 : 0)];
        if (this.offsets[i] += t, c.length > Math.max(0, e))
          return this.value = e == 0 ? c : t > 0 ? c.slice(e) : c.slice(0, c.length - e), this;
        e -= c.length;
      } else {
        let c = s.children[o + (t < 0 ? -1 : 0)];
        e > c.length ? (e -= c.length, this.offsets[i] += t) : (t < 0 && this.offsets[i]--, this.nodes.push(c), this.offsets.push(t > 0 ? 1 : (c instanceof ht ? c.text.length : c.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class Zv {
  constructor(e, t, i) {
    this.value = "", this.done = !1, this.cursor = new Ir(e, t > i ? -1 : 1), this.pos = t > i ? e.length : 0, this.from = Math.min(t, i), this.to = Math.max(t, i);
  }
  nextInner(e, t) {
    if (t < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos);
    let i = t < 0 ? this.pos - this.from : this.to - this.pos;
    e > i && (e = i), i -= e;
    let { value: s } = this.cursor.next(e);
    return this.pos += (s.length + e) * t, this.value = s.length <= i ? s : t < 0 ? s.slice(s.length - i) : s.slice(0, i), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class qv {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: t, lineBreak: i, value: s } = this.inner.next(e);
    return t ? (this.done = !0, this.value = "") : i ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = s, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (We.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Ir.prototype[Symbol.iterator] = Zv.prototype[Symbol.iterator] = qv.prototype[Symbol.iterator] = function() {
  return this;
});
class QR {
  /**
  @internal
  */
  constructor(e, t, i, s) {
    this.from = e, this.to = t, this.number = i, this.text = s;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
const xh = /\r\n?|\n/;
var $t = /* @__PURE__ */ function(a) {
  return a[a.Simple = 0] = "Simple", a[a.TrackDel = 1] = "TrackDel", a[a.TrackBefore = 2] = "TrackBefore", a[a.TrackAfter = 3] = "TrackAfter", a;
}($t || ($t = {}));
class ts {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2)
      e += this.sections[t];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2) {
      let i = this.sections[t + 1];
      e += i < 0 ? this.sections[t] : i;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes.
  */
  iterGaps(e) {
    for (let t = 0, i = 0, s = 0; t < this.sections.length; ) {
      let n = this.sections[t++], o = this.sections[t++];
      o < 0 ? (e(i, s, n), s += n) : s += o, i += n;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, t = !1) {
    wh(this, e, t);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let t = 0; t < this.sections.length; ) {
      let i = this.sections[t++], s = this.sections[t++];
      s < 0 ? e.push(i, s) : e.push(s, i);
    }
    return new ts(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : Kv(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(e, t = !1) {
    return e.empty ? this : Sh(this, e, t);
  }
  mapPos(e, t = -1, i = $t.Simple) {
    let s = 0, n = 0;
    for (let o = 0; o < this.sections.length; ) {
      let l = this.sections[o++], c = this.sections[o++], d = s + l;
      if (c < 0) {
        if (d > e)
          return n + (e - s);
        n += l;
      } else {
        if (i != $t.Simple && d >= e && (i == $t.TrackDel && s < e && d > e || i == $t.TrackBefore && s < e || i == $t.TrackAfter && d > e))
          return null;
        if (d > e || d == e && t < 0 && !l)
          return e == s || t < 0 ? n : n + c;
        n += c;
      }
      s = d;
    }
    if (e > s)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${s}`);
    return n;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, t = e) {
    for (let i = 0, s = 0; i < this.sections.length && s <= t; ) {
      let n = this.sections[i++], o = this.sections[i++], l = s + n;
      if (o >= 0 && s <= t && l >= e)
        return s < e && l > t ? "cover" : !0;
      s = l;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 0; t < this.sections.length; ) {
      let i = this.sections[t++], s = this.sections[t++];
      e += (e ? " " : "") + i + (s >= 0 ? ":" + s : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((t) => typeof t != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new ts(e);
  }
}
class xt extends ts {
  /**
  @internal
  */
  constructor(e, t) {
    super(e), this.inserted = t;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return wh(this, (t, i, s, n, o) => e = e.replace(s, s + (i - t), o), !1), e;
  }
  mapDesc(e, t = !1) {
    return Sh(this, e, t, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let t = this.sections.slice(), i = [];
    for (let s = 0, n = 0; s < t.length; s += 2) {
      let o = t[s], l = t[s + 1];
      if (l >= 0) {
        t[s] = l, t[s + 1] = o;
        let c = s >> 1;
        for (; i.length < c; )
          i.push(We.empty);
        i.push(o ? e.slice(n, n + o) : We.empty);
      }
      n += o;
    }
    return new xt(t, i);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : Kv(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, t = !1) {
    return e.empty ? this : Sh(this, e, t, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, t = !1) {
    wh(this, e, t);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return new ts(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let t = [], i = [], s = [], n = new qr(this);
    e:
      for (let o = 0, l = 0; ; ) {
        let c = o == e.length ? 1e9 : e[o++];
        for (; l < c || l == c && n.len == 0; ) {
          if (n.done)
            break e;
          let f = Math.min(n.len, c - l);
          Nt(s, f, -1);
          let p = n.ins == -1 ? -1 : n.off == 0 ? n.ins : 0;
          Nt(t, f, p), p > 0 && Zs(i, t, n.text), n.forward(f), l += f;
        }
        let d = e[o++];
        for (; l < d; ) {
          if (n.done)
            break e;
          let f = Math.min(n.len, d - l);
          Nt(t, f, -1), Nt(s, f, n.ins == -1 ? -1 : n.off == 0 ? n.ins : 0), n.forward(f), l += f;
        }
      }
    return {
      changes: new xt(t, i),
      filtered: new ts(s)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let t = 0; t < this.sections.length; t += 2) {
      let i = this.sections[t], s = this.sections[t + 1];
      s < 0 ? e.push(i) : s == 0 ? e.push([i]) : e.push([i].concat(this.inserted[t >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, t, i) {
    let s = [], n = [], o = 0, l = null;
    function c(f = !1) {
      if (!f && !s.length)
        return;
      o < t && Nt(s, t - o, -1);
      let p = new xt(s, n);
      l = l ? l.compose(p.map(l)) : p, s = [], n = [], o = 0;
    }
    function d(f) {
      if (Array.isArray(f))
        for (let p of f)
          d(p);
      else if (f instanceof xt) {
        if (f.length != t)
          throw new RangeError(`Mismatched change set length (got ${f.length}, expected ${t})`);
        c(), l = l ? l.compose(f.map(l)) : f;
      } else {
        let { from: p, to: m = p, insert: v } = f;
        if (p > m || p < 0 || m > t)
          throw new RangeError(`Invalid change range ${p} to ${m} (in doc of length ${t})`);
        let r = v ? typeof v == "string" ? We.of(v.split(i || xh)) : v : We.empty, h = r.length;
        if (p == m && h == 0)
          return;
        p < o && c(), p > o && Nt(s, p - o, -1), Nt(s, m - p, h), Zs(n, s, r), o = m;
      }
    }
    return d(e), c(!l), l;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new xt(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let t = [], i = [];
    for (let s = 0; s < e.length; s++) {
      let n = e[s];
      if (typeof n == "number")
        t.push(n, -1);
      else {
        if (!Array.isArray(n) || typeof n[0] != "number" || n.some((o, l) => l && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (n.length == 1)
          t.push(n[0], 0);
        else {
          for (; i.length < s; )
            i.push(We.empty);
          i[s] = We.of(n.slice(1)), t.push(n[0], i[s].length);
        }
      }
    }
    return new xt(t, i);
  }
}
function Nt(a, e, t, i = !1) {
  if (e == 0 && t <= 0)
    return;
  let s = a.length - 2;
  s >= 0 && t <= 0 && t == a[s + 1] ? a[s] += e : e == 0 && a[s] == 0 ? a[s + 1] += t : i ? (a[s] += e, a[s + 1] += t) : a.push(e, t);
}
function Zs(a, e, t) {
  if (t.length == 0)
    return;
  let i = e.length - 2 >> 1;
  if (i < a.length)
    a[a.length - 1] = a[a.length - 1].append(t);
  else {
    for (; a.length < i; )
      a.push(We.empty);
    a.push(t);
  }
}
function wh(a, e, t) {
  let i = a.inserted;
  for (let s = 0, n = 0, o = 0; o < a.sections.length; ) {
    let l = a.sections[o++], c = a.sections[o++];
    if (c < 0)
      s += l, n += l;
    else {
      let d = s, f = n, p = We.empty;
      for (; d += l, f += c, c && i && (p = p.append(i[o - 2 >> 1])), !(t || o == a.sections.length || a.sections[o + 1] < 0); )
        l = a.sections[o++], c = a.sections[o++];
      e(s, d, n, f, p), s = d, n = f;
    }
  }
}
function Sh(a, e, t, i = !1) {
  let s = [], n = i ? [] : null, o = new qr(a), l = new qr(e);
  for (let c = 0, d = 0; ; )
    if (o.ins == -1)
      c += o.len, o.next();
    else if (l.ins == -1 && d < c) {
      let f = Math.min(l.len, c - d);
      l.forward(f), Nt(s, f, -1), d += f;
    } else if (l.ins >= 0 && (o.done || d < c || d == c && (l.len < o.len || l.len == o.len && !t))) {
      for (Nt(s, l.ins, -1); c > d && !o.done && c + o.len < d + l.len; )
        c += o.len, o.next();
      d += l.len, l.next();
    } else if (o.ins >= 0) {
      let f = 0, p = c + o.len;
      for (; ; )
        if (l.ins >= 0 && d > c && d + l.len < p)
          f += l.ins, d += l.len, l.next();
        else if (l.ins == -1 && d < p) {
          let m = Math.min(l.len, p - d);
          f += m, l.forward(m), d += m;
        } else
          break;
      Nt(s, f, o.ins), n && Zs(n, s, o.text), c = p, o.next();
    } else {
      if (o.done && l.done)
        return n ? new xt(s, n) : new ts(s);
      throw new Error("Mismatched change set lengths");
    }
}
function Kv(a, e, t = !1) {
  let i = [], s = t ? [] : null, n = new qr(a), o = new qr(e);
  for (let l = !1; ; ) {
    if (n.done && o.done)
      return s ? new xt(i, s) : new ts(i);
    if (n.ins == 0)
      Nt(i, n.len, 0, l), n.next();
    else if (o.len == 0 && !o.done)
      Nt(i, 0, o.ins, l), s && Zs(s, i, o.text), o.next();
    else {
      if (n.done || o.done)
        throw new Error("Mismatched change set lengths");
      {
        let c = Math.min(n.len2, o.len), d = i.length;
        if (n.ins == -1) {
          let f = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          Nt(i, c, f, l), s && f && Zs(s, i, o.text);
        } else
          o.ins == -1 ? (Nt(i, n.off ? 0 : n.len, c, l), s && Zs(s, i, n.textBit(c))) : (Nt(i, n.off ? 0 : n.len, o.off ? 0 : o.ins, l), s && !o.off && Zs(s, i, o.text));
        l = (n.ins > c || o.ins >= 0 && o.len > c) && (l || i.length > d), n.forward2(c), o.forward(c);
      }
    }
  }
}
class qr {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, t = this.i - 2 >> 1;
    return t >= e.length ? We.empty : e[t];
  }
  textBit(e) {
    let { inserted: t } = this.set, i = this.i - 2 >> 1;
    return i >= t.length && !e ? We.empty : t[i].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class En {
  /**
  @internal
  */
  constructor(e, t, i) {
    this.from = e, this.to = t, this.flags = i;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 16 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 16 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 3;
    return e == 3 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 5;
    return e == 33554431 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, t = -1) {
    let i, s;
    return this.empty ? i = s = e.mapPos(this.from, t) : (i = e.mapPos(this.from, 1), s = e.mapPos(this.to, -1)), i == this.from && s == this.to ? this : new En(i, s, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, t = e) {
    if (e <= this.anchor && t >= this.anchor)
      return ee.range(e, t);
    let i = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t;
    return ee.range(this.anchor, i);
  }
  /**
  Compare this range to another range.
  */
  eq(e) {
    return this.anchor == e.anchor && this.head == e.head;
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return ee.range(e.anchor, e.head);
  }
}
class ee {
  /**
  @internal
  */
  constructor(e, t = 0) {
    this.ranges = e, this.mainIndex = t;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, t = -1) {
    return e.empty ? this : ee.create(this.ranges.map((i) => i.map(e, t)), this.mainIndex);
  }
  /**
  Compare this selection to another selection.
  */
  eq(e) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let t = 0; t < this.ranges.length; t++)
      if (!this.ranges[t].eq(e.ranges[t]))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new ee([this.main]);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, t = !0) {
    return ee.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, t = this.mainIndex) {
    let i = this.ranges.slice();
    return i[t] = e, ee.create(i, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new ee(e.ranges.map((t) => En.fromJSON(t)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, t = e) {
    return new ee([ee.range(e, t)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, t = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let i = 0, s = 0; s < e.length; s++) {
      let n = e[s];
      if (n.empty ? n.from <= i : n.from < i)
        return NR(e.slice(), t);
      i = n.to;
    }
    return new ee(e, t);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, t = 0, i, s) {
    return new En(e, e, (t == 0 ? 0 : t < 0 ? 4 : 8) | (i == null ? 3 : Math.min(2, i)) | (s ?? 33554431) << 5);
  }
  /**
  Create a selection range.
  */
  static range(e, t, i) {
    let s = (i ?? 33554431) << 5;
    return t < e ? new En(
      t,
      e,
      16 | s | 8
      /* AssocAfter */
    ) : new En(e, t, s | (t > e ? 4 : 0));
  }
}
function NR(a, e = 0) {
  let t = a[e];
  a.sort((i, s) => i.from - s.from), e = a.indexOf(t);
  for (let i = 1; i < a.length; i++) {
    let s = a[i], n = a[i - 1];
    if (s.empty ? s.from <= n.to : s.from < n.to) {
      let o = n.from, l = Math.max(s.to, n.to);
      i <= e && e--, a.splice(--i, 2, s.anchor > s.head ? ee.range(l, o) : ee.range(o, l));
    }
  }
  return new ee(a, e);
}
function Jv(a, e) {
  for (let t of a.ranges)
    if (t.to > e)
      throw new RangeError("Selection points outside of document");
}
let Xd = 0;
class be {
  constructor(e, t, i, s, n) {
    this.combine = e, this.compareInput = t, this.compare = i, this.isStatic = s, this.extensions = n, this.id = Xd++, this.default = e([]);
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new be(e.combine || ((t) => t), e.compareInput || ((t, i) => t === i), e.compare || (e.combine ? (t, i) => t === i : Yd), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value for this facet.
  */
  of(e) {
    return new po([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In most cases, you'll want to use the
  [`provide`](https://codemirror.net/6/docs/ref/#state.StateField^define^config.provide) option when
  defining a field instead.
  */
  compute(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new po(e, this, 1, t);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new po(e, this, 2, t);
  }
  from(e, t) {
    return t || (t = (i) => i), this.compute([e], (i) => t(i.field(e)));
  }
}
function Yd(a, e) {
  return a == e || a.length == e.length && a.every((t, i) => t === e[i]);
}
class po {
  constructor(e, t, i, s) {
    this.dependencies = e, this.facet = t, this.type = i, this.value = s, this.id = Xd++;
  }
  dynamicSlot(e) {
    var t;
    let i = this.value, s = this.facet.compareInput, n = this.id, o = e[n] >> 1, l = this.type == 2, c = !1, d = !1, f = [];
    for (let p of this.dependencies)
      p == "doc" ? c = !0 : p == "selection" ? d = !0 : ((t = e[p.id]) !== null && t !== void 0 ? t : 1) & 1 || f.push(e[p.id]);
    return {
      create(p) {
        return p.values[o] = i(p), 1;
      },
      update(p, m) {
        if (c && m.docChanged || d && (m.docChanged || m.selection) || f.some((v) => (en(p, v) & 1) > 0)) {
          let v = i(p);
          if (l ? !mp(v, p.values[o], s) : !s(v, p.values[o]))
            return p.values[o] = v, 1;
        }
        return 0;
      },
      reconfigure(p, m) {
        let v = i(p), r = m.config.address[n];
        if (r != null) {
          let h = Ro(m, r);
          if (l ? mp(v, h, s) : s(v, h))
            return p.values[o] = h, 0;
        }
        return p.values[o] = v, 1;
      }
    };
  }
}
function mp(a, e, t) {
  if (a.length != e.length)
    return !1;
  for (let i = 0; i < a.length; i++)
    if (!t(a[i], e[i]))
      return !1;
  return !0;
}
function FR(a, e, t) {
  let i = t.map((c) => a[c.id]), s = t.map((c) => c.type), n = i.filter((c) => !(c & 1)), o = a[e.id] >> 1;
  function l(c) {
    let d = [];
    for (let f = 0; f < i.length; f++) {
      let p = Ro(c, i[f]);
      if (s[f] == 2)
        for (let m of p)
          d.push(m);
      else
        d.push(p);
    }
    return e.combine(d);
  }
  return {
    create(c) {
      for (let d of i)
        en(c, d);
      return c.values[o] = l(c), 1;
    },
    update(c, d) {
      if (!n.some(
        (p) => en(c, p) & 1
        /* Changed */
      ))
        return 0;
      let f = l(c);
      return e.compare(f, c.values[o]) ? 0 : (c.values[o] = f, 1);
    },
    reconfigure(c, d) {
      let f = i.some(
        (r) => en(c, r) & 1
        /* Changed */
      ), p = d.config.facets[e.id], m = d.facet(e);
      if (p && !f && Yd(t, p))
        return c.values[o] = m, 0;
      let v = l(c);
      return e.compare(v, m) ? (c.values[o] = m, 0) : (c.values[o] = v, 1);
    }
  };
}
const bp = /* @__PURE__ */ be.define({ static: !0 });
class Mt {
  constructor(e, t, i, s, n) {
    this.id = e, this.createF = t, this.updateF = i, this.compareF = s, this.spec = n, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let t = new Mt(Xd++, e.create, e.update, e.compare || ((i, s) => i === s), e);
    return e.provide && (t.provides = e.provide(t)), t;
  }
  create(e) {
    let t = e.facet(bp).find((i) => i.field == this);
    return ((t == null ? void 0 : t.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let t = e[this.id] >> 1;
    return {
      create: (i) => (i.values[t] = this.create(i), 1),
      update: (i, s) => {
        let n = i.values[t], o = this.updateF(n, s);
        return this.compareF(n, o) ? 0 : (i.values[t] = o, 1);
      },
      reconfigure: (i, s) => s.config.address[this.id] != null ? (i.values[t] = s.field(this), 0) : (i.values[t] = this.create(i), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, bp.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const Zi = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function ms(a) {
  return (e) => new ey(e, a);
}
const dr = {
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ ms(Zi.lowest),
  /**
  A lower-than-default precedence, for extensions.
  */
  low: /* @__PURE__ */ ms(Zi.low),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ ms(Zi.default),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ ms(Zi.high),
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ ms(Zi.highest),
  // FIXME Drop these in some future breaking version
  /**
  Backwards-compatible synonym for `Prec.lowest`.
  */
  fallback: /* @__PURE__ */ ms(Zi.lowest),
  /**
  Backwards-compatible synonym for `Prec.high`.
  */
  extend: /* @__PURE__ */ ms(Zi.high),
  /**
  Backwards-compatible synonym for `Prec.highest`.
  */
  override: /* @__PURE__ */ ms(Zi.highest)
};
class ey {
  constructor(e, t) {
    this.inner = e, this.prec = t;
  }
}
class ka {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new kh(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return ka.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class kh {
  constructor(e, t) {
    this.compartment = e, this.inner = t;
  }
}
class Do {
  constructor(e, t, i, s, n, o) {
    for (this.base = e, this.compartments = t, this.dynamicSlots = i, this.address = s, this.staticValues = n, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < i.length; )
      this.statusTemplate.push(
        0
        /* Unresolved */
      );
  }
  staticFacet(e) {
    let t = this.address[e.id];
    return t == null ? e.default : this.staticValues[t >> 1];
  }
  static resolve(e, t, i) {
    let s = [], n = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
    for (let m of WR(e, t, o))
      m instanceof Mt ? s.push(m) : (n[m.facet.id] || (n[m.facet.id] = [])).push(m);
    let l = /* @__PURE__ */ Object.create(null), c = [], d = [];
    for (let m of s)
      l[m.id] = d.length << 1, d.push((v) => m.slot(v));
    let f = i == null ? void 0 : i.config.facets;
    for (let m in n) {
      let v = n[m], r = v[0].facet, h = f && f[m] || [];
      if (v.every(
        (u) => u.type == 0
        /* Static */
      ))
        if (l[r.id] = c.length << 1 | 1, Yd(h, v))
          c.push(i.facet(r));
        else {
          let u = r.combine(v.map((g) => g.value));
          c.push(i && r.compare(u, i.facet(r)) ? i.facet(r) : u);
        }
      else {
        for (let u of v)
          u.type == 0 ? (l[u.id] = c.length << 1 | 1, c.push(u.value)) : (l[u.id] = d.length << 1, d.push((g) => u.dynamicSlot(g)));
        l[r.id] = d.length << 1, d.push((u) => FR(u, r, v));
      }
    }
    let p = d.map((m) => m(l));
    return new Do(e, o, p, l, c, n);
  }
}
function WR(a, e, t) {
  let i = [[], [], [], [], []], s = /* @__PURE__ */ new Map();
  function n(o, l) {
    let c = s.get(o);
    if (c != null) {
      if (c >= l)
        return;
      let d = i[c].indexOf(o);
      d > -1 && i[c].splice(d, 1), o instanceof kh && t.delete(o.compartment);
    }
    if (s.set(o, l), Array.isArray(o))
      for (let d of o)
        n(d, l);
    else if (o instanceof kh) {
      if (t.has(o.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let d = e.get(o.compartment) || o.inner;
      t.set(o.compartment, d), n(d, l);
    } else if (o instanceof ey)
      n(o.inner, o.prec);
    else if (o instanceof Mt)
      i[l].push(o), o.provides && n(o.provides, l);
    else if (o instanceof po)
      i[l].push(o), o.facet.extensions && n(o.facet.extensions, l);
    else {
      let d = o.extension;
      if (!d)
        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      n(d, l);
    }
  }
  return n(a, Zi.default), i.reduce((o, l) => o.concat(l));
}
function en(a, e) {
  if (e & 1)
    return 2;
  let t = e >> 1, i = a.status[t];
  if (i == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (i & 2)
    return i;
  a.status[t] = 4;
  let s = a.computeSlot(a, a.config.dynamicSlots[t]);
  return a.status[t] = 2 | s;
}
function Ro(a, e) {
  return e & 1 ? a.config.staticValues[e >> 1] : a.values[e >> 1];
}
const ty = /* @__PURE__ */ be.define(), iy = /* @__PURE__ */ be.define({
  combine: (a) => a.some((e) => e),
  static: !0
}), sy = /* @__PURE__ */ be.define({
  combine: (a) => a.length ? a[0] : void 0,
  static: !0
}), ny = /* @__PURE__ */ be.define(), ry = /* @__PURE__ */ be.define(), ay = /* @__PURE__ */ be.define(), oy = /* @__PURE__ */ be.define({
  combine: (a) => a.length ? a[0] : !1
});
class Qs {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new BR();
  }
}
class BR {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new Qs(this, e);
  }
}
class zR {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new _e(this, e);
  }
}
class _e {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let t = this.type.map(this.value, e);
    return t === void 0 ? void 0 : t == this.value ? this : new _e(this.type, t);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds.
  */
  static define(e = {}) {
    return new zR(e.map || ((t) => t));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, t) {
    if (!e.length)
      return e;
    let i = [];
    for (let s of e) {
      let n = s.map(t);
      n && i.push(n);
    }
    return i;
  }
}
_e.reconfigure = /* @__PURE__ */ _e.define();
_e.appendConfig = /* @__PURE__ */ _e.define();
class St {
  /**
  @internal
  */
  constructor(e, t, i, s, n, o) {
    this.startState = e, this.changes = t, this.selection = i, this.effects = s, this.annotations = n, this.scrollIntoView = o, this._doc = null, this._state = null, i && Jv(i, t.newLength), n.some((l) => l.type == St.time) || (this.annotations = n.concat(St.time.of(Date.now())));
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so itis recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let t of this.annotations)
      if (t.type == e)
        return t.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let t = this.annotation(St.userEvent);
    return !!(t && (t == e || t.length > e.length && t.slice(0, e.length) == e && t[e.length] == "."));
  }
}
St.time = /* @__PURE__ */ Qs.define();
St.userEvent = /* @__PURE__ */ Qs.define();
St.addToHistory = /* @__PURE__ */ Qs.define();
St.remote = /* @__PURE__ */ Qs.define();
function XR(a, e) {
  let t = [];
  for (let i = 0, s = 0; ; ) {
    let n, o;
    if (i < a.length && (s == e.length || e[s] >= a[i]))
      n = a[i++], o = a[i++];
    else if (s < e.length)
      n = e[s++], o = e[s++];
    else
      return t;
    !t.length || t[t.length - 1] < n ? t.push(n, o) : t[t.length - 1] < o && (t[t.length - 1] = o);
  }
}
function ly(a, e, t) {
  var i;
  let s, n, o;
  return t ? (s = e.changes, n = xt.empty(e.changes.length), o = a.changes.compose(e.changes)) : (s = e.changes.map(a.changes), n = a.changes.mapDesc(e.changes, !0), o = a.changes.compose(s)), {
    changes: o,
    selection: e.selection ? e.selection.map(n) : (i = a.selection) === null || i === void 0 ? void 0 : i.map(s),
    effects: _e.mapEffects(a.effects, s).concat(_e.mapEffects(e.effects, n)),
    annotations: a.annotations.length ? a.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: a.scrollIntoView || e.scrollIntoView
  };
}
function _h(a, e, t) {
  let i = e.selection, s = Nn(e.annotations);
  return e.userEvent && (s = s.concat(St.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof xt ? e.changes : xt.of(e.changes || [], t, a.facet(sy)),
    selection: i && (i instanceof ee ? i : ee.single(i.anchor, i.head)),
    effects: Nn(e.effects),
    annotations: s,
    scrollIntoView: !!e.scrollIntoView
  };
}
function cy(a, e, t) {
  let i = _h(a, e.length ? e[0] : {}, a.doc.length);
  e.length && e[0].filter === !1 && (t = !1);
  for (let n = 1; n < e.length; n++) {
    e[n].filter === !1 && (t = !1);
    let o = !!e[n].sequential;
    i = ly(i, _h(a, e[n], o ? i.changes.newLength : a.doc.length), o);
  }
  let s = new St(a, i.changes, i.selection, i.effects, i.annotations, i.scrollIntoView);
  return VR(t ? YR(s) : s);
}
function YR(a) {
  let e = a.startState, t = !0;
  for (let s of e.facet(ny)) {
    let n = s(a);
    if (n === !1) {
      t = !1;
      break;
    }
    Array.isArray(n) && (t = t === !0 ? n : XR(t, n));
  }
  if (t !== !0) {
    let s, n;
    if (t === !1)
      n = a.changes.invertedDesc, s = xt.empty(e.doc.length);
    else {
      let o = a.changes.filter(t);
      s = o.changes, n = o.filtered.invertedDesc;
    }
    a = new St(e, s, a.selection && a.selection.map(n), _e.mapEffects(a.effects, n), a.annotations, a.scrollIntoView);
  }
  let i = e.facet(ry);
  for (let s = i.length - 1; s >= 0; s--) {
    let n = i[s](a);
    n instanceof St ? a = n : Array.isArray(n) && n.length == 1 && n[0] instanceof St ? a = n[0] : a = cy(e, Nn(n), !1);
  }
  return a;
}
function VR(a) {
  let e = a.startState, t = e.facet(ay), i = a;
  for (let s = t.length - 1; s >= 0; s--) {
    let n = t[s](a);
    n && Object.keys(n).length && (i = ly(a, _h(e, n, a.changes.newLength), !0));
  }
  return i == a ? a : new St(e, a.changes, a.selection, i.effects, i.annotations, i.scrollIntoView);
}
const HR = [];
function Nn(a) {
  return a == null ? HR : Array.isArray(a) ? a : [a];
}
var Wt = /* @__PURE__ */ function(a) {
  return a[a.Word = 0] = "Word", a[a.Space = 1] = "Space", a[a.Other = 2] = "Other", a;
}(Wt || (Wt = {}));
const GR = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let Ch;
try {
  Ch = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function jR(a) {
  if (Ch)
    return Ch.test(a);
  for (let e = 0; e < a.length; e++) {
    let t = a[e];
    if (/\w/.test(t) || t > "" && (t.toUpperCase() != t.toLowerCase() || GR.test(t)))
      return !0;
  }
  return !1;
}
function UR(a) {
  return (e) => {
    if (!/\S/.test(e))
      return Wt.Space;
    if (jR(e))
      return Wt.Word;
    for (let t = 0; t < a.length; t++)
      if (e.indexOf(a[t]) > -1)
        return Wt.Word;
    return Wt.Other;
  };
}
class Re {
  /**
  @internal
  */
  constructor(e, t, i, s, n, o) {
    this.config = e, this.doc = t, this.selection = i, this.values = s, this.status = e.statusTemplate.slice(), this.computeSlot = n, o && (o._state = this);
    for (let l = 0; l < this.config.dynamicSlots.length; l++)
      en(this, l << 1);
    this.computeSlot = null;
  }
  field(e, t = !0) {
    let i = this.config.address[e.id];
    if (i == null) {
      if (t)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return en(this, i), Ro(this, i);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return cy(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let t = this.config, { base: i, compartments: s } = t;
    for (let o of e.effects)
      o.is(ka.reconfigure) ? (t && (s = /* @__PURE__ */ new Map(), t.compartments.forEach((l, c) => s.set(c, l)), t = null), s.set(o.value.compartment, o.value.extension)) : o.is(_e.reconfigure) ? (t = null, i = o.value) : o.is(_e.appendConfig) && (t = null, i = Nn(i).concat(o.value));
    let n;
    t ? n = e.startState.values.slice() : (t = Do.resolve(i, s, this), n = new Re(t, this.doc, this.selection, t.dynamicSlots.map(() => null), (l, c) => c.reconfigure(l, this), null).values), new Re(t, e.newDoc, e.newSelection, n, (o, l) => l.update(o, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((t) => ({
      changes: { from: t.from, to: t.to, insert: e },
      range: ee.cursor(t.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let t = this.selection, i = e(t.ranges[0]), s = this.changes(i.changes), n = [i.range], o = Nn(i.effects);
    for (let l = 1; l < t.ranges.length; l++) {
      let c = e(t.ranges[l]), d = this.changes(c.changes), f = d.map(s);
      for (let m = 0; m < l; m++)
        n[m] = n[m].map(f);
      let p = s.mapDesc(d, !0);
      n.push(c.range.map(p)), s = s.compose(f), o = _e.mapEffects(o, f).concat(_e.mapEffects(Nn(c.effects), p));
    }
    return {
      changes: s,
      selection: ee.create(n, t.mainIndex),
      effects: o
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof xt ? e : xt.of(e, this.doc.length, this.facet(Re.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#text.Text) instance from the given string.
  */
  toText(e) {
    return We.of(e.split(this.facet(Re.lineSeparator) || xh));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, t = this.doc.length) {
    return this.doc.sliceString(e, t, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let t = this.config.address[e.id];
    return t == null ? e.default : (en(this, t), Ro(this, t));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let t = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let i in e) {
        let s = e[i];
        s instanceof Mt && (t[i] = s.spec.toJSON(this.field(e[i]), this));
      }
    return t;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, t = {}, i) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let s = [];
    if (i)
      for (let n in i) {
        let o = i[n], l = e[n];
        s.push(o.init((c) => o.spec.fromJSON(l, c)));
      }
    return Re.create({
      doc: e.doc,
      selection: ee.fromJSON(e.selection),
      extensions: t.extensions ? s.concat([t.extensions]) : s
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let t = Do.resolve(e.extensions || [], /* @__PURE__ */ new Map()), i = e.doc instanceof We ? e.doc : We.of((e.doc || "").split(t.staticFacet(Re.lineSeparator) || xh)), s = e.selection ? e.selection instanceof ee ? e.selection : ee.single(e.selection.anchor, e.selection.head) : ee.single(0);
    return Jv(s, i.length), t.staticFacet(iy) || (s = s.asSingle()), new Re(t, i, s, t.dynamicSlots.map(() => null), (n, o) => o.create(n), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(Re.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(Re.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(oy);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  */
  phrase(e) {
    for (let t of this.facet(Re.phrases))
      if (Object.prototype.hasOwnProperty.call(t, e))
        return t[e];
    return e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  */
  languageDataAt(e, t, i = -1) {
    let s = [];
    for (let n of this.facet(ty))
      for (let o of n(this, t, i))
        Object.prototype.hasOwnProperty.call(o, e) && s.push(o[e]);
    return s;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#text.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return UR(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: t, from: i, length: s } = this.doc.lineAt(e), n = this.charCategorizer(e), o = e - i, l = e - i;
    for (; o > 0; ) {
      let c = ti(t, o, !1);
      if (n(t.slice(c, o)) != Wt.Word)
        break;
      o = c;
    }
    for (; l < s; ) {
      let c = ti(t, l);
      if (n(t.slice(l, c)) != Wt.Word)
        break;
      l = c;
    }
    return o == l ? null : ee.range(o + i, l + i);
  }
}
Re.allowMultipleSelections = iy;
Re.tabSize = /* @__PURE__ */ be.define({
  combine: (a) => a.length ? a[0] : 4
});
Re.lineSeparator = sy;
Re.readOnly = oy;
Re.phrases = /* @__PURE__ */ be.define();
Re.languageData = ty;
Re.changeFilter = ny;
Re.transactionFilter = ry;
Re.transactionExtender = ay;
ka.reconfigure = /* @__PURE__ */ _e.define();
function Ns(a, e, t = {}) {
  let i = {};
  for (let s of a)
    for (let n of Object.keys(s)) {
      let o = s[n], l = i[n];
      if (l === void 0)
        i[n] = o;
      else if (!(l === o || o === void 0))
        if (Object.hasOwnProperty.call(t, n))
          i[n] = t[n](l, o);
        else
          throw new Error("Config merge conflict for field " + n);
    }
  for (let s in e)
    i[s] === void 0 && (i[s] = e[s]);
  return i;
}
const Th = "ͼ", vp = typeof Symbol > "u" ? "__" + Th : Symbol.for(Th), Ah = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), yp = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class Ps {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, t) {
    this.rules = [];
    let { finish: i } = t || {};
    function s(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function n(o, l, c, d) {
      let f = [], p = /^@(\w+)\b/.exec(o[0]), m = p && p[1] == "keyframes";
      if (p && l == null)
        return c.push(o[0] + ";");
      for (let v in l) {
        let r = l[v];
        if (/&/.test(v))
          n(
            v.split(/,\s*/).map((h) => o.map((u) => h.replace(/&/, u))).reduce((h, u) => h.concat(u)),
            r,
            c
          );
        else if (r && typeof r == "object") {
          if (!p)
            throw new RangeError("The value of a property (" + v + ") should be a primitive value.");
          n(s(v), r, f, m);
        } else
          r != null && f.push(v.replace(/_.*/, "").replace(/[A-Z]/g, (h) => "-" + h.toLowerCase()) + ": " + r + ";");
      }
      (f.length || m) && c.push((i && !p && !d ? o.map(i) : o).join(", ") + " {" + f.join(" ") + "}");
    }
    for (let o in e)
      n(s(o), e[o], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let e = yp[vp] || 1;
    return yp[vp] = e + 1, Th + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, t, i) {
    let s = e[Ah], n = i && i.nonce;
    s ? n && s.setNonce(n) : s = new ZR(e, n), s.mount(Array.isArray(t) ? t : [t], e);
  }
}
let Op = /* @__PURE__ */ new Map();
class ZR {
  constructor(e, t) {
    let i = e.ownerDocument || e, s = i.defaultView;
    if (!e.head && e.adoptedStyleSheets && s.CSSStyleSheet) {
      let n = Op.get(i);
      if (n)
        return e[Ah] = n;
      this.sheet = new s.CSSStyleSheet(), Op.set(i, this);
    } else
      this.styleTag = i.createElement("style"), t && this.styleTag.setAttribute("nonce", t);
    this.modules = [], e[Ah] = this;
  }
  mount(e, t) {
    let i = this.sheet, s = 0, n = 0;
    for (let o = 0; o < e.length; o++) {
      let l = e[o], c = this.modules.indexOf(l);
      if (c < n && c > -1 && (this.modules.splice(c, 1), n--, c = -1), c == -1) {
        if (this.modules.splice(n++, 0, l), i)
          for (let d = 0; d < l.rules.length; d++)
            i.insertRule(l.rules[d], s++);
      } else {
        for (; n < c; )
          s += this.modules[n++].rules.length;
        s += l.rules.length, n++;
      }
    }
    if (i)
      t.adoptedStyleSheets.indexOf(this.sheet) < 0 && (t.adoptedStyleSheets = [this.sheet, ...t.adoptedStyleSheets]);
    else {
      let o = "";
      for (let c = 0; c < this.modules.length; c++)
        o += this.modules[c].getRules() + `
`;
      this.styleTag.textContent = o;
      let l = t.head || t;
      this.styleTag.parentNode != l && l.insertBefore(this.styleTag, l.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
class an {
  /**
  Compare this value with another value. The default
  implementation compares by identity.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#rangeset.Range) with this value.
  */
  range(e, t = e) {
    return new $h(e, t, this);
  }
}
an.prototype.startSide = an.prototype.endSide = 0;
an.prototype.point = !1;
an.prototype.mapMode = $t.TrackDel;
let $h = class {
  /**
  @internal
  */
  constructor(e, t, i) {
    this.from = e, this.to = t, this.value = i;
  }
};
function Eh(a, e) {
  return a.from - e.from || a.value.startSide - e.value.startSide;
}
class Vd {
  constructor(e, t, i, s) {
    this.from = e, this.to = t, this.value = i, this.maxPoint = s;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, t, i, s = 0) {
    let n = i ? this.to : this.from;
    for (let o = s, l = n.length; ; ) {
      if (o == l)
        return o;
      let c = o + l >> 1, d = n[c] - e || (i ? this.value[c].endSide : this.value[c].startSide) - t;
      if (c == o)
        return d >= 0 ? o : l;
      d >= 0 ? l = c : o = c + 1;
    }
  }
  between(e, t, i, s) {
    for (let n = this.findIndex(t, -1e9, !0), o = this.findIndex(i, 1e9, !1, n); n < o; n++)
      if (s(this.from[n] + e, this.to[n] + e, this.value[n]) === !1)
        return !1;
  }
  map(e, t) {
    let i = [], s = [], n = [], o = -1, l = -1;
    for (let c = 0; c < this.value.length; c++) {
      let d = this.value[c], f = this.from[c] + e, p = this.to[c] + e, m, v;
      if (f == p) {
        let r = t.mapPos(f, d.startSide, d.mapMode);
        if (r == null || (m = v = r, d.startSide != d.endSide && (v = t.mapPos(f, d.endSide), v < m)))
          continue;
      } else if (m = t.mapPos(f, d.startSide), v = t.mapPos(p, d.endSide), m > v || m == v && d.startSide > 0 && d.endSide <= 0)
        continue;
      (v - m || d.endSide - d.startSide) < 0 || (o < 0 && (o = m), d.point && (l = Math.max(l, v - m)), i.push(d), s.push(m - o), n.push(v - o));
    }
    return { mapped: i.length ? new Vd(s, n, i, l) : null, pos: o };
  }
}
class ze {
  /**
  @internal
  */
  constructor(e, t, i = ze.empty, s) {
    this.chunkPos = e, this.chunk = t, this.nextLayer = i, this.maxPoint = s;
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let t of this.chunk)
      e += t.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (The extra type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: t = [], sort: i = !1, filterFrom: s = 0, filterTo: n = this.length } = e, o = e.filter;
    if (t.length == 0 && !o)
      return this;
    if (i && (t = t.slice().sort(Eh)), this.isEmpty)
      return t.length ? ze.of(t) : this;
    let l = new hy(this, null, -1).goto(0), c = 0, d = [], f = new Ls();
    for (; l.value || c < t.length; )
      if (c < t.length && (l.from - t[c].from || l.startSide - t[c].value.startSide) >= 0) {
        let p = t[c++];
        f.addInner(p.from, p.to, p.value) || d.push(p);
      } else
        l.rangeIndex == 1 && l.chunkIndex < this.chunk.length && (c == t.length || this.chunkEnd(l.chunkIndex) < t[c].from) && (!o || s > this.chunkEnd(l.chunkIndex) || n < this.chunkPos[l.chunkIndex]) && f.addChunk(this.chunkPos[l.chunkIndex], this.chunk[l.chunkIndex]) ? l.nextChunk() : ((!o || s > l.to || n < l.from || o(l.from, l.to, l.value)) && (f.addInner(l.from, l.to, l.value) || d.push(new $h(l.from, l.to, l.value))), l.next());
    return f.finishInner(this.nextLayer.isEmpty && !d.length ? ze.empty : this.nextLayer.update({ add: d, filter: o, filterFrom: s, filterTo: n }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let t = [], i = [], s = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let l = this.chunkPos[o], c = this.chunk[o], d = e.touchesRange(l, l + c.length);
      if (d === !1)
        s = Math.max(s, c.maxPoint), t.push(c), i.push(e.mapPos(l));
      else if (d === !0) {
        let { mapped: f, pos: p } = c.map(l, e);
        f && (s = Math.max(s, f.maxPoint), t.push(f), i.push(p));
      }
    }
    let n = this.nextLayer.map(e);
    return t.length == 0 ? n : new ze(i, t, n, s);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, t, i) {
    if (!this.isEmpty) {
      for (let s = 0; s < this.chunk.length; s++) {
        let n = this.chunkPos[s], o = this.chunk[s];
        if (t >= n && e <= n + o.length && o.between(n, e - n, t - n, i) === !1)
          return;
      }
      this.nextLayer.between(e, t, i);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return Kr.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, t = 0) {
    return Kr.from(e).goto(t);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, t, i, s, n = -1) {
    let o = e.filter((p) => p.maxPoint > 0 || !p.isEmpty && p.maxPoint >= n), l = t.filter((p) => p.maxPoint > 0 || !p.isEmpty && p.maxPoint >= n), c = xp(o, l, i), d = new br(o, c, n), f = new br(l, c, n);
    i.iterGaps((p, m, v) => wp(d, p, f, m, v, s)), i.empty && i.length == 0 && wp(d, 0, f, 0, 0, s);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, t, i = 0, s) {
    s == null && (s = 1e9);
    let n = e.filter((f) => !f.isEmpty && t.indexOf(f) < 0), o = t.filter((f) => !f.isEmpty && e.indexOf(f) < 0);
    if (n.length != o.length)
      return !1;
    if (!n.length)
      return !0;
    let l = xp(n, o), c = new br(n, l, 0).goto(i), d = new br(o, l, 0).goto(i);
    for (; ; ) {
      if (c.to != d.to || !Ph(c.active, d.active) || c.point && (!d.point || !c.point.eq(d.point)))
        return !1;
      if (c.to > s)
        return !0;
      c.next(), d.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#rangeset.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, t, i, s, n = -1) {
    var o;
    let l = new br(e, null, n, (o = s.filterPoint) === null || o === void 0 ? void 0 : o.bind(s)).goto(t), c = t, d = l.openStart;
    for (; ; ) {
      let f = Math.min(l.to, i);
      if (l.point ? (s.point(c, f, l.point, l.activeForPoint(l.to), d), d = l.openEnd(f) + (l.to > f ? 1 : 0)) : f > c && (s.span(c, f, l.active, d), d = l.openEnd(f)), l.to > i)
        break;
      c = l.to, l.next();
    }
    return d;
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, t = !1) {
    let i = new Ls();
    for (let s of e instanceof $h ? [e] : t ? qR(e) : e)
      i.add(s.from, s.to, s.value);
    return i.finish();
  }
}
ze.empty = /* @__PURE__ */ new ze([], [], null, -1);
function qR(a) {
  if (a.length > 1)
    for (let e = a[0], t = 1; t < a.length; t++) {
      let i = a[t];
      if (Eh(e, i) > 0)
        return a.slice().sort(Eh);
      e = i;
    }
  return a;
}
ze.empty.nextLayer = ze.empty;
class Ls {
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  finishChunk(e) {
    this.chunks.push(new Vd(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, t, i) {
    this.addInner(e, t, i) || (this.nextLayer || (this.nextLayer = new Ls())).add(e, t, i);
  }
  /**
  @internal
  */
  addInner(e, t, i) {
    let s = e - this.lastTo || i.startSide - this.last.endSide;
    if (s <= 0 && (e - this.lastFrom || i.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return s < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(t - this.chunkStart), this.last = i, this.lastFrom = e, this.lastTo = t, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, t - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, t) {
    if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint), this.chunks.push(t), this.chunkPos.push(e);
    let i = t.value.length - 1;
    return this.last = t.value[i], this.lastFrom = t.from[i] + e, this.lastTo = t.to[i] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(ze.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let t = new ze(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, t;
  }
}
function xp(a, e, t) {
  let i = /* @__PURE__ */ new Map();
  for (let n of a)
    for (let o = 0; o < n.chunk.length; o++)
      n.chunk[o].maxPoint <= 0 && i.set(n.chunk[o], n.chunkPos[o]);
  let s = /* @__PURE__ */ new Set();
  for (let n of e)
    for (let o = 0; o < n.chunk.length; o++) {
      let l = i.get(n.chunk[o]);
      l != null && (t ? t.mapPos(l) : l) == n.chunkPos[o] && !(t != null && t.touchesRange(l, l + n.chunk[o].length)) && s.add(n.chunk[o]);
    }
  return s;
}
class hy {
  constructor(e, t, i, s = 0) {
    this.layer = e, this.skip = t, this.minPoint = i, this.rank = s;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, t = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, t, !1), this;
  }
  gotoInner(e, t, i) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let s = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(s) || this.layer.chunkEnd(this.chunkIndex) < e || s.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, i = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let s = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], t, !0);
      (!i || this.rangeIndex < s) && this.setRangeIndex(s);
    }
    this.next();
  }
  forward(e, t) {
    (this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], t = this.layer.chunk[this.chunkIndex], i = e + t.from[this.rangeIndex];
        if (this.from = i, this.to = e + t.to[this.rangeIndex], this.value = t.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class Kr {
  constructor(e) {
    this.heap = e;
  }
  static from(e, t = null, i = -1) {
    let s = [];
    for (let n = 0; n < e.length; n++)
      for (let o = e[n]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= i && s.push(new hy(o, t, i, n));
    return s.length == 1 ? s[0] : new Kr(s);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, t = -1e9) {
    for (let i of this.heap)
      i.goto(e, t);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      Oc(this.heap, i);
    return this.next(), this;
  }
  forward(e, t) {
    for (let i of this.heap)
      i.forward(e, t);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      Oc(this.heap, i);
    (this.to - e || this.value.endSide - t) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), Oc(this.heap, 0);
    }
  }
}
function Oc(a, e) {
  for (let t = a[e]; ; ) {
    let i = (e << 1) + 1;
    if (i >= a.length)
      break;
    let s = a[i];
    if (i + 1 < a.length && s.compare(a[i + 1]) >= 0 && (s = a[i + 1], i++), t.compare(s) < 0)
      break;
    a[i] = t, a[e] = s, e = i;
  }
}
class br {
  constructor(e, t, i, s = () => !0) {
    this.minPoint = i, this.filterPoint = s, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Kr.from(e, t, i);
  }
  goto(e, t = -1e9) {
    return this.cursor.goto(e, t), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = t, this.openStart = -1, this.next(), this;
  }
  forward(e, t) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - t) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, t);
  }
  removeActive(e) {
    Ga(this.active, e), Ga(this.activeTo, e), Ga(this.activeRank, e), this.minActive = Sp(this.active, this.activeTo);
  }
  addActive(e) {
    let t = 0, { value: i, to: s, rank: n } = this.cursor;
    for (; t < this.activeRank.length && this.activeRank[t] <= n; )
      t++;
    ja(this.active, t, i), ja(this.activeTo, t, s), ja(this.activeRank, t, n), e && ja(e, t, this.cursor.from), this.minActive = Sp(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, t = this.point;
    this.point = null;
    let i = this.openStart < 0 ? [] : null, s = 0;
    for (; ; ) {
      let n = this.minActive;
      if (n > -1 && (this.activeTo[n] - this.cursor.from || this.active[n].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[n] > e) {
          this.to = this.activeTo[n], this.endSide = this.active[n].endSide;
          break;
        }
        this.removeActive(n), i && Ga(i, n);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let o = this.cursor.value;
          if (!o.point)
            this.addActive(i), this.cursor.next();
          else if (t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else if (!this.filterPoint(this.cursor.from, this.cursor.to, this.cursor.value, this.cursor.rank))
            this.cursor.next();
          else {
            this.point = o, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = o.endSide, this.cursor.from < e && (s = 1), this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (i) {
      let n = 0;
      for (; n < i.length && i[n] < e; )
        n++;
      this.openStart = n + s;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let t = [];
    for (let i = this.active.length - 1; i >= 0 && !(this.activeRank[i] < this.pointRank); i--)
      (this.activeTo[i] > e || this.activeTo[i] == e && this.active[i].endSide >= this.point.endSide) && t.push(this.active[i]);
    return t.reverse();
  }
  openEnd(e) {
    let t = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > e; i--)
      t++;
    return t;
  }
}
function wp(a, e, t, i, s, n) {
  a.goto(e), t.goto(i);
  let o = i + s, l = i, c = i - e;
  for (; ; ) {
    let d = a.to + c - t.to || a.endSide - t.endSide, f = d < 0 ? a.to + c : t.to, p = Math.min(f, o);
    if (a.point || t.point ? a.point && t.point && (a.point == t.point || a.point.eq(t.point)) && Ph(a.activeForPoint(a.to + c), t.activeForPoint(t.to)) || n.comparePoint(l, p, a.point, t.point) : p > l && !Ph(a.active, t.active) && n.compareRange(l, p, a.active, t.active), f > o)
      break;
    l = f, d <= 0 && a.next(), d >= 0 && t.next();
  }
}
function Ph(a, e) {
  if (a.length != e.length)
    return !1;
  for (let t = 0; t < a.length; t++)
    if (a[t] != e[t] && !a[t].eq(e[t]))
      return !1;
  return !0;
}
function Ga(a, e) {
  for (let t = e, i = a.length - 1; t < i; t++)
    a[t] = a[t + 1];
  a.pop();
}
function ja(a, e, t) {
  for (let i = a.length - 1; i >= e; i--)
    a[i + 1] = a[i];
  a[e] = t;
}
function Sp(a, e) {
  let t = -1, i = 1e9;
  for (let s = 0; s < e.length; s++)
    (e[s] - i || a[s].endSide - a[t].endSide) < 0 && (t = s, i = e[s]);
  return t;
}
var Ms = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Io = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, KR = typeof navigator < "u" && /Mac/.test(navigator.platform), JR = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var At = 0; At < 10; At++)
  Ms[48 + At] = Ms[96 + At] = String(At);
for (var At = 1; At <= 24; At++)
  Ms[At + 111] = "F" + At;
for (var At = 65; At <= 90; At++)
  Ms[At] = String.fromCharCode(At + 32), Io[At] = String.fromCharCode(At);
for (var xc in Ms)
  Io.hasOwnProperty(xc) || (Io[xc] = Ms[xc]);
function eI(a) {
  var e = KR && a.metaKey && a.shiftKey && !a.ctrlKey && !a.altKey || JR && a.shiftKey && a.key && a.key.length == 1 || a.key == "Unidentified", t = !e && a.key || (a.shiftKey ? Io : Ms)[a.keyCode] || a.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
function Qo(a) {
  let e;
  return a.nodeType == 11 ? e = a.getSelection ? a : a.ownerDocument : e = a, e.getSelection();
}
function Hn(a, e) {
  return e ? a == e || a.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function tI() {
  let a = document.activeElement;
  for (; a && a.shadowRoot; )
    a = a.shadowRoot.activeElement;
  return a;
}
function Lh(a, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return Hn(a, e.anchorNode);
  } catch {
    return !1;
  }
}
function Jr(a) {
  return a.nodeType == 3 ? ea(a, 0, a.nodeValue.length).getClientRects() : a.nodeType == 1 ? a.getClientRects() : [];
}
function No(a, e, t, i) {
  return t ? kp(a, e, t, i, -1) || kp(a, e, t, i, 1) : !1;
}
function Mh(a) {
  for (var e = 0; ; e++)
    if (a = a.previousSibling, !a)
      return e;
}
function kp(a, e, t, i, s) {
  for (; ; ) {
    if (a == t && e == i)
      return !0;
    if (e == (s < 0 ? 0 : Fo(a))) {
      if (a.nodeName == "DIV")
        return !1;
      let n = a.parentNode;
      if (!n || n.nodeType != 1)
        return !1;
      e = Mh(a) + (s < 0 ? 0 : 1), a = n;
    } else if (a.nodeType == 1) {
      if (a = a.childNodes[e + (s < 0 ? -1 : 0)], a.nodeType == 1 && a.contentEditable == "false")
        return !1;
      e = s < 0 ? Fo(a) : 0;
    } else
      return !1;
  }
}
function Fo(a) {
  return a.nodeType == 3 ? a.nodeValue.length : a.childNodes.length;
}
const dy = { left: 0, right: 0, top: 0, bottom: 0 };
function _l(a, e) {
  let t = e ? a.left : a.right;
  return { left: t, right: t, top: a.top, bottom: a.bottom };
}
function iI(a) {
  return {
    left: 0,
    right: a.innerWidth,
    top: 0,
    bottom: a.innerHeight
  };
}
function sI(a, e, t, i, s, n, o, l) {
  let c = a.ownerDocument, d = c.defaultView;
  for (let f = a; f; )
    if (f.nodeType == 1) {
      let p, m = f == c.body;
      if (m)
        p = iI(d);
      else {
        if (f.scrollHeight <= f.clientHeight && f.scrollWidth <= f.clientWidth) {
          f = f.parentNode;
          continue;
        }
        let h = f.getBoundingClientRect();
        p = {
          left: h.left,
          right: h.left + f.clientWidth,
          top: h.top,
          bottom: h.top + f.clientHeight
        };
      }
      let v = 0, r = 0;
      if (s == "nearest")
        e.top < p.top ? (r = -(p.top - e.top + o), t > 0 && e.bottom > p.bottom + r && (r = e.bottom - p.bottom + r + o)) : e.bottom > p.bottom && (r = e.bottom - p.bottom + o, t < 0 && e.top - r < p.top && (r = -(p.top + r - e.top + o)));
      else {
        let h = e.bottom - e.top, u = p.bottom - p.top;
        r = (s == "center" && h <= u ? e.top + h / 2 - u / 2 : s == "start" || s == "center" && t < 0 ? e.top - o : e.bottom - u + o) - p.top;
      }
      if (i == "nearest" ? e.left < p.left ? (v = -(p.left - e.left + n), t > 0 && e.right > p.right + v && (v = e.right - p.right + v + n)) : e.right > p.right && (v = e.right - p.right + n, t < 0 && e.left < p.left + v && (v = -(p.left + v - e.left + n))) : v = (i == "center" ? e.left + (e.right - e.left) / 2 - (p.right - p.left) / 2 : i == "start" == l ? e.left - n : e.right - (p.right - p.left) + n) - p.left, v || r)
        if (m)
          d.scrollBy(v, r);
        else {
          if (r) {
            let h = f.scrollTop;
            f.scrollTop += r, r = f.scrollTop - h;
          }
          if (v) {
            let h = f.scrollLeft;
            f.scrollLeft += v, v = f.scrollLeft - h;
          }
          e = {
            left: e.left - v,
            top: e.top - r,
            right: e.right - v,
            bottom: e.bottom - r
          };
        }
      if (m)
        break;
      f = f.assignedSlot || f.parentNode, i = s = "nearest";
    } else if (f.nodeType == 11)
      f = f.host;
    else
      break;
}
class nI {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    this.set(e.anchorNode, e.anchorOffset, e.focusNode, e.focusOffset);
  }
  set(e, t, i, s) {
    this.anchorNode = e, this.anchorOffset = t, this.focusNode = i, this.focusOffset = s;
  }
}
let xn = null;
function uy(a) {
  if (a.setActive)
    return a.setActive();
  if (xn)
    return a.focus(xn);
  let e = [];
  for (let t = a; t && (e.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode)
    ;
  if (a.focus(xn == null ? {
    get preventScroll() {
      return xn = { preventScroll: !0 }, !0;
    }
  } : void 0), !xn) {
    xn = !1;
    for (let t = 0; t < e.length; ) {
      let i = e[t++], s = e[t++], n = e[t++];
      i.scrollTop != s && (i.scrollTop = s), i.scrollLeft != n && (i.scrollLeft = n);
    }
  }
}
let _p;
function ea(a, e, t = e) {
  let i = _p || (_p = document.createRange());
  return i.setEnd(a, t), i.setStart(a, e), i;
}
function Qr(a, e, t) {
  let i = { key: e, code: e, keyCode: t, which: t, cancelable: !0 }, s = new KeyboardEvent("keydown", i);
  s.synthetic = !0, a.dispatchEvent(s);
  let n = new KeyboardEvent("keyup", i);
  return n.synthetic = !0, a.dispatchEvent(n), s.defaultPrevented || n.defaultPrevented;
}
function rI(a) {
  for (; a; ) {
    if (a && (a.nodeType == 9 || a.nodeType == 11 && a.host))
      return a;
    a = a.assignedSlot || a.parentNode;
  }
  return null;
}
function fy(a) {
  for (; a.attributes.length; )
    a.removeAttributeNode(a.attributes[0]);
}
class Et {
  constructor(e, t, i = !0) {
    this.node = e, this.offset = t, this.precise = i;
  }
  static before(e, t) {
    return new Et(e.parentNode, Mh(e), t);
  }
  static after(e, t) {
    return new Et(e.parentNode, Mh(e) + 1, t);
  }
}
const Hd = [];
class rt {
  constructor() {
    this.parent = null, this.dom = null, this.dirty = 2;
  }
  get editorView() {
    if (!this.parent)
      throw new Error("Accessing view in orphan content view");
    return this.parent.editorView;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let t = this.posAtStart;
    for (let i of this.children) {
      if (i == e)
        return t;
      t += i.length + i.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  // Will return a rectangle directly before (when side < 0), after
  // (side > 0) or directly on (when the browser supports it) the
  // given position.
  coordsAt(e, t) {
    return null;
  }
  sync(e) {
    if (this.dirty & 2) {
      let t = this.dom, i = null, s;
      for (let n of this.children) {
        if (n.dirty) {
          if (!n.dom && (s = i ? i.nextSibling : t.firstChild)) {
            let o = rt.get(s);
            (!o || !o.parent && o.constructor == n.constructor) && n.reuseDOM(s);
          }
          n.sync(e), n.dirty = 0;
        }
        if (s = i ? i.nextSibling : t.firstChild, e && !e.written && e.node == t && s != n.dom && (e.written = !0), n.dom.parentNode == t)
          for (; s && s != n.dom; )
            s = Cp(s);
        else
          t.insertBefore(n.dom, s);
        i = n.dom;
      }
      for (s = i ? i.nextSibling : t.firstChild, s && e && e.node == t && (e.written = !0); s; )
        s = Cp(s);
    } else if (this.dirty & 1)
      for (let t of this.children)
        t.dirty && (t.sync(e), t.dirty = 0);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, t) {
    let i;
    if (e == this.dom)
      i = this.dom.childNodes[t];
    else {
      let s = Fo(e) == 0 ? 0 : t == 0 ? -1 : 1;
      for (; ; ) {
        let n = e.parentNode;
        if (n == this.dom)
          break;
        s == 0 && n.firstChild != n.lastChild && (e == n.firstChild ? s = -1 : s = 1), e = n;
      }
      s < 0 ? i = e : i = e.nextSibling;
    }
    if (i == this.dom.firstChild)
      return 0;
    for (; i && !rt.get(i); )
      i = i.nextSibling;
    if (!i)
      return this.length;
    for (let s = 0, n = 0; ; s++) {
      let o = this.children[s];
      if (o.dom == i)
        return n;
      n += o.length + o.breakAfter;
    }
  }
  domBoundsAround(e, t, i = 0) {
    let s = -1, n = -1, o = -1, l = -1;
    for (let c = 0, d = i, f = i; c < this.children.length; c++) {
      let p = this.children[c], m = d + p.length;
      if (d < e && m > t)
        return p.domBoundsAround(e, t, d);
      if (m >= e && s == -1 && (s = c, n = d), d > t && p.dom.parentNode == this.dom) {
        o = c, l = f;
        break;
      }
      f = m, d = m + p.breakAfter;
    }
    return {
      from: n,
      to: l < 0 ? i + this.length : l,
      startDOM: (s ? this.children[s - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(e = !1) {
    this.dirty |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let t = this.parent; t; t = t.parent) {
      if (e && (t.dirty |= 2), t.dirty & 1)
        return;
      t.dirty |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.dirty && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this;
  }
  get rootView() {
    for (let e = this; ; ) {
      let t = e.parent;
      if (!t)
        return e;
      e = t;
    }
  }
  replaceChildren(e, t, i = Hd) {
    this.markDirty();
    for (let s = e; s < t; s++) {
      let n = this.children[s];
      n.parent == this && n.destroy();
    }
    this.children.splice(e, t - e, ...i);
    for (let s = 0; s < i.length; s++)
      i[s].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new py(this.children, e, this.children.length);
  }
  childPos(e, t = 1) {
    return this.childCursor().findPos(e, t);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  merge(e, t, i, s, n, o) {
    return !1;
  }
  become(e) {
    return !1;
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    this.parent = null;
  }
}
rt.prototype.breakAfter = 0;
function Cp(a) {
  let e = a.nextSibling;
  return a.parentNode.removeChild(a), e;
}
class py {
  constructor(e, t, i) {
    this.children = e, this.pos = t, this.i = i, this.off = 0;
  }
  findPos(e, t = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (t > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let i = this.children[--this.i];
      this.pos -= i.length + i.breakAfter;
    }
  }
}
function gy(a, e, t, i, s, n, o, l, c) {
  let { children: d } = a, f = d.length ? d[e] : null, p = n.length ? n[n.length - 1] : null, m = p ? p.breakAfter : o;
  if (!(e == i && f && !o && !m && n.length < 2 && f.merge(t, s, n.length ? p : null, t == 0, l, c))) {
    if (i < d.length) {
      let v = d[i];
      v && s < v.length ? (e == i && (v = v.split(s), s = 0), !m && p && v.merge(0, s, p, !0, 0, c) ? n[n.length - 1] = v : (s && v.merge(0, s, null, !1, 0, c), n.push(v))) : v != null && v.breakAfter && (p ? p.breakAfter = 1 : o = 1), i++;
    }
    for (f && (f.breakAfter = o, t > 0 && (!o && n.length && f.merge(t, f.length, n[0], !1, l, 0) ? f.breakAfter = n.shift().breakAfter : (t < f.length || f.children.length && f.children[f.children.length - 1].length == 0) && f.merge(t, f.length, null, !1, l, 0), e++)); e < i && n.length; )
      if (d[i - 1].become(n[n.length - 1]))
        i--, n.pop(), c = n.length ? 0 : l;
      else if (d[e].become(n[0]))
        e++, n.shift(), l = n.length ? 0 : c;
      else
        break;
    !n.length && e && i < d.length && !d[e - 1].breakAfter && d[i].merge(0, 0, d[e - 1], !1, l, c) && e--, (e < i || n.length) && a.replaceChildren(e, i, n);
  }
}
function my(a, e, t, i, s, n) {
  let o = a.childCursor(), { i: l, off: c } = o.findPos(t, 1), { i: d, off: f } = o.findPos(e, -1), p = e - t;
  for (let m of i)
    p += m.length;
  a.length += p, gy(a, d, f, l, c, i, 0, s, n);
}
let ei = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, Dh = typeof document < "u" ? document : { documentElement: { style: {} } };
const Rh = /* @__PURE__ */ /Edge\/(\d+)/.exec(ei.userAgent), by = /* @__PURE__ */ /MSIE \d/.test(ei.userAgent), Ih = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ei.userAgent), Cl = !!(by || Ih || Rh), Tp = !Cl && /* @__PURE__ */ /gecko\/(\d+)/i.test(ei.userAgent), wc = !Cl && /* @__PURE__ */ /Chrome\/(\d+)/.exec(ei.userAgent), Ap = "webkitFontSmoothing" in Dh.documentElement.style, vy = !Cl && /* @__PURE__ */ /Apple Computer/.test(ei.vendor), $p = vy && (/* @__PURE__ */ /Mobile\/\w+/.test(ei.userAgent) || ei.maxTouchPoints > 2);
var we = {
  mac: $p || /* @__PURE__ */ /Mac/.test(ei.platform),
  windows: /* @__PURE__ */ /Win/.test(ei.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(ei.platform),
  ie: Cl,
  ie_version: by ? Dh.documentMode || 6 : Ih ? +Ih[1] : Rh ? +Rh[1] : 0,
  gecko: Tp,
  gecko_version: Tp ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(ei.userAgent) || [0, 0])[1] : 0,
  chrome: !!wc,
  chrome_version: wc ? +wc[1] : 0,
  ios: $p,
  android: /* @__PURE__ */ /Android\b/.test(ei.userAgent),
  webkit: Ap,
  safari: vy,
  webkit_version: Ap ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: Dh.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const aI = 256;
class Ds extends rt {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (e && e.node == this.dom && (e.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, t, i) {
    return i && (!(i instanceof Ds) || this.length - (t - e) + i.length > aI) ? !1 : (this.text = this.text.slice(0, e) + (i ? i.text : "") + this.text.slice(t), this.markDirty(), !0);
  }
  split(e) {
    let t = new Ds(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), t;
  }
  localPosFromDOM(e, t) {
    return e == this.dom ? t : t ? this.text.length : 0;
  }
  domAtPos(e) {
    return new Et(this.dom, e);
  }
  domBoundsAround(e, t, i) {
    return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, t) {
    return Qh(this.dom, e, t);
  }
}
class Yi extends rt {
  constructor(e, t = [], i = 0) {
    super(), this.mark = e, this.children = t, this.length = i;
    for (let s of t)
      s.setParent(this);
  }
  setAttrs(e) {
    if (fy(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let t in this.mark.attrs)
        e.setAttribute(t, this.mark.attrs[t]);
    return e;
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.dirty |= 6);
  }
  sync(e) {
    this.dom ? this.dirty & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e);
  }
  merge(e, t, i, s, n, o) {
    return i && (!(i instanceof Yi && i.mark.eq(this.mark)) || e && n <= 0 || t < this.length && o <= 0) ? !1 : (my(this, e, t, i ? i.children : [], n - 1, o - 1), this.markDirty(), !0);
  }
  split(e) {
    let t = [], i = 0, s = -1, n = 0;
    for (let l of this.children) {
      let c = i + l.length;
      c > e && t.push(i < e ? l.split(e - i) : l), s < 0 && i >= e && (s = n), i = c, n++;
    }
    let o = this.length - e;
    return this.length = e, s > -1 && (this.children.length = s, this.markDirty()), new Yi(this.mark, t, o);
  }
  domAtPos(e) {
    return xy(this.dom, this.children, e);
  }
  coordsAt(e, t) {
    return Sy(this, e, t);
  }
}
function Qh(a, e, t) {
  let i = a.nodeValue.length;
  e > i && (e = i);
  let s = e, n = e, o = 0;
  e == 0 && t < 0 || e == i && t >= 0 ? we.chrome || we.gecko || (e ? (s--, o = 1) : (n++, o = -1)) : t < 0 ? s-- : n++;
  let l = ea(a, s, n).getClientRects();
  if (!l.length)
    return dy;
  let c = l[(o ? o < 0 : t >= 0) ? 0 : l.length - 1];
  return we.safari && !o && c.width == 0 && (c = Array.prototype.find.call(l, (d) => d.width) || c), o ? _l(c, o < 0) : c || null;
}
class _s extends rt {
  constructor(e, t, i) {
    super(), this.widget = e, this.length = t, this.side = i, this.prevWidget = null;
  }
  static create(e, t, i) {
    return new (e.customView || _s)(e, t, i);
  }
  split(e) {
    let t = _s.create(this.widget, this.length - e, this.side);
    return this.length -= e, t;
  }
  sync() {
    (!this.dom || !this.widget.updateDOM(this.dom)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(this.editorView)), this.dom.contentEditable = "false");
  }
  getSide() {
    return this.side;
  }
  merge(e, t, i, s, n, o) {
    return i && (!(i instanceof _s) || !this.widget.compare(i.widget) || e > 0 && n <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - t), !0);
  }
  become(e) {
    return e.length == this.length && e instanceof _s && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.eq(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return We.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let t = e.editorView, i = t && t.state.doc, s = this.posAtStart;
    return i ? i.slice(s, s + this.length) : We.empty;
  }
  domAtPos(e) {
    return e == 0 ? Et.before(this.dom) : Et.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, t) {
    let i = this.dom.getClientRects(), s = null;
    if (!i.length)
      return dy;
    for (let n = e > 0 ? i.length - 1 : 0; s = i[n], !(e > 0 ? n == 0 : n == i.length - 1 || s.top < s.bottom); n += e > 0 ? -1 : 1)
      ;
    return e == 0 && t > 0 || e == this.length && t <= 0 ? s : _l(s, e == 0);
  }
  get isEditable() {
    return !1;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class yy extends _s {
  domAtPos(e) {
    let { topView: t, text: i } = this.widget;
    return t ? Nh(e, 0, t, i, (s, n) => s.domAtPos(n), (s) => new Et(i, Math.min(s, i.nodeValue.length))) : new Et(i, Math.min(e, i.nodeValue.length));
  }
  sync() {
    this.setDOM(this.widget.toDOM());
  }
  localPosFromDOM(e, t) {
    let { topView: i, text: s } = this.widget;
    return i ? Oy(e, t, i, s) : Math.min(t, this.length);
  }
  ignoreMutation() {
    return !1;
  }
  get overrideDOMText() {
    return null;
  }
  coordsAt(e, t) {
    let { topView: i, text: s } = this.widget;
    return i ? Nh(e, t, i, s, (n, o, l) => n.coordsAt(o, l), (n, o) => Qh(s, n, o)) : Qh(s, e, t);
  }
  destroy() {
    var e;
    super.destroy(), (e = this.widget.topView) === null || e === void 0 || e.destroy();
  }
  get isEditable() {
    return !0;
  }
}
function Nh(a, e, t, i, s, n) {
  if (t instanceof Yi) {
    for (let o of t.children) {
      let l = Hn(o.dom, i), c = l ? i.nodeValue.length : o.length;
      if (a < c || a == c && o.getSide() <= 0)
        return l ? Nh(a, e, o, i, s, n) : s(o, a, e);
      a -= c;
    }
    return s(t, t.length, -1);
  } else
    return t.dom == i ? n(a, e) : s(t, a, e);
}
function Oy(a, e, t, i) {
  if (t instanceof Yi)
    for (let s of t.children) {
      let n = 0, o = Hn(s.dom, i);
      if (Hn(s.dom, a))
        return n + (o ? Oy(a, e, s, i) : s.localPosFromDOM(a, e));
      n += o ? i.nodeValue.length : s.length;
    }
  else if (t.dom == i)
    return Math.min(e, i.nodeValue.length);
  return t.localPosFromDOM(a, e);
}
class Gn extends rt {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof Gn && e.side == this.side;
  }
  split() {
    return new Gn(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return Et.before(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    let t = this.dom.getBoundingClientRect(), i = oI(this, this.side > 0 ? -1 : 1);
    return i && i.top < t.bottom && i.bottom > t.top ? { left: t.left, right: t.right, top: i.top, bottom: i.bottom } : t;
  }
  get overrideDOMText() {
    return We.empty;
  }
}
Ds.prototype.children = _s.prototype.children = Gn.prototype.children = Hd;
function oI(a, e) {
  let t = a.parent, i = t ? t.children.indexOf(a) : -1;
  for (; t && i >= 0; )
    if (e < 0 ? i > 0 : i < t.children.length) {
      let s = t.children[i + e];
      if (s instanceof Ds) {
        let n = s.coordsAt(e < 0 ? s.length : 0, e);
        if (n)
          return n;
      }
      i += e;
    } else if (t instanceof Yi && t.parent)
      i = t.parent.children.indexOf(t) + (e < 0 ? 0 : 1), t = t.parent;
    else {
      let s = t.dom.lastChild;
      if (s && s.nodeName == "BR")
        return s.getClientRects()[0];
      break;
    }
}
function xy(a, e, t) {
  let i = 0;
  for (let s = 0; i < e.length; i++) {
    let n = e[i], o = s + n.length;
    if (!(o == s && n.getSide() <= 0)) {
      if (t > s && t < o && n.dom.parentNode == a)
        return n.domAtPos(t - s);
      if (t <= s)
        break;
      s = o;
    }
  }
  for (; i > 0; i--) {
    let s = e[i - 1].dom;
    if (s.parentNode == a)
      return Et.after(s);
  }
  return new Et(a, 0);
}
function wy(a, e, t) {
  let i, { children: s } = a;
  t > 0 && e instanceof Yi && s.length && (i = s[s.length - 1]) instanceof Yi && i.mark.eq(e.mark) ? wy(i, e.children[0], t - 1) : (s.push(e), e.setParent(a)), a.length += e.length;
}
function Sy(a, e, t) {
  for (let n = 0, o = 0; o < a.children.length; o++) {
    let l = a.children[o], c = n + l.length, d;
    if ((t <= 0 || c == a.length || l.getSide() > 0 ? c >= e : c > e) && (e < c || o + 1 == a.children.length || (d = a.children[o + 1]).length || d.getSide() > 0)) {
      let f = 0;
      if (c == n) {
        if (l.getSide() <= 0)
          continue;
        f = t = -l.getSide();
      }
      let p = l.coordsAt(Math.max(0, e - n), t);
      return f && p ? _l(p, t < 0) : p;
    }
    n = c;
  }
  let i = a.dom.lastChild;
  if (!i)
    return a.dom.getBoundingClientRect();
  let s = Jr(i);
  return s[s.length - 1] || null;
}
function Fh(a, e) {
  for (let t in a)
    t == "class" && e.class ? e.class += " " + a.class : t == "style" && e.style ? e.style += ";" + a.style : e[t] = a[t];
  return e;
}
function Gd(a, e) {
  if (a == e)
    return !0;
  if (!a || !e)
    return !1;
  let t = Object.keys(a), i = Object.keys(e);
  if (t.length != i.length)
    return !1;
  for (let s of t)
    if (i.indexOf(s) == -1 || a[s] !== e[s])
      return !1;
  return !0;
}
function Wh(a, e, t) {
  if (e)
    for (let i in e)
      t && i in t || a.removeAttribute(i);
  if (t)
    for (let i in t)
      e && e[i] == t[i] || a.setAttribute(i, t[i]);
}
class hs {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  @internal
  */
  get customView() {
    return null;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var Ye = /* @__PURE__ */ function(a) {
  return a[a.Text = 0] = "Text", a[a.WidgetBefore = 1] = "WidgetBefore", a[a.WidgetAfter = 2] = "WidgetAfter", a[a.WidgetRange = 3] = "WidgetRange", a;
}(Ye || (Ye = {}));
class me extends an {
  /**
  @internal
  */
  constructor(e, t, i, s) {
    super(), this.startSide = e, this.endSide = t, this.widget = i, this.spec = s;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations) or
  (below the facet-provided decorations) [view
  plugin](https://codemirror.net/6/docs/ref/#view.PluginSpec.decorations). Such elements are split
  on line boundaries and on the boundaries of higher-precedence
  decorations.
  */
  static mark(e) {
    return new Tl(e);
  }
  /**
  Create a widget decoration, which adds an element at the given
  position.
  */
  static widget(e) {
    let t = e.side || 0, i = !!e.block;
    return t += i ? t > 0 ? 3e8 : -4e8 : t > 0 ? 1e8 : -1e8, new on(e, t, t, i, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let t = !!e.block, i, s;
    if (e.isBlockGap)
      i = -5e8, s = 4e8;
    else {
      let { start: n, end: o } = ky(e, t);
      i = (n ? t ? -3e8 : -1 : 5e8) - 1, s = (o ? t ? 2e8 : 1 : -6e8) + 1;
    }
    return new on(e, i, s, t, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new _a(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, t = !1) {
    return ze.of(e, t);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
me.none = ze.empty;
class Tl extends me {
  constructor(e) {
    let { start: t, end: i } = ky(e);
    super(t ? -1 : 5e8, i ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    return this == e || e instanceof Tl && this.tagName == e.tagName && this.class == e.class && Gd(this.attrs, e.attrs);
  }
  range(e, t = e) {
    if (e >= t)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, t);
  }
}
Tl.prototype.point = !1;
class _a extends me {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof _a && Gd(this.spec.attributes, e.spec.attributes);
  }
  range(e, t = e) {
    if (t != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, t);
  }
}
_a.prototype.mapMode = $t.TrackBefore;
_a.prototype.point = !0;
class on extends me {
  constructor(e, t, i, s, n, o) {
    super(t, i, n, e), this.block = s, this.isReplace = o, this.mapMode = s ? t <= 0 ? $t.TrackBefore : $t.TrackAfter : $t.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide < this.endSide ? Ye.WidgetRange : this.startSide <= 0 ? Ye.WidgetBefore : Ye.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && this.widget.estimatedHeight >= 5;
  }
  eq(e) {
    return e instanceof on && lI(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, t = e) {
    if (this.isReplace && (e > t || e == t && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && t != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, t);
  }
}
on.prototype.point = !0;
function ky(a, e = !1) {
  let { inclusiveStart: t, inclusiveEnd: i } = a;
  return t == null && (t = a.inclusive), i == null && (i = a.inclusive), { start: t ?? e, end: i ?? e };
}
function lI(a, e) {
  return a == e || !!(a && e && a.compare(e));
}
function Bh(a, e, t, i = 0) {
  let s = t.length - 1;
  s >= 0 && t[s] + i >= a ? t[s] = Math.max(t[s], e) : t.push(a, e);
}
class Bt extends rt {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, t, i, s, n, o) {
    if (i) {
      if (!(i instanceof Bt))
        return !1;
      this.dom || i.transferDOM(this);
    }
    return s && this.setDeco(i ? i.attrs : null), my(this, e, t, i ? i.children : [], n, o), !0;
  }
  split(e) {
    let t = new Bt();
    if (t.breakAfter = this.breakAfter, this.length == 0)
      return t;
    let { i, off: s } = this.childPos(e);
    s && (t.append(this.children[i].split(s), 0), this.children[i].merge(s, this.children[i].length, null, !1, 0, 0), i++);
    for (let n = i; n < this.children.length; n++)
      t.append(this.children[n], 0);
    for (; i > 0 && this.children[i - 1].length == 0; )
      this.children[--i].destroy();
    return this.children.length = i, this.markDirty(), this.length = e, t;
  }
  transferDOM(e) {
    this.dom && (e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    Gd(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, t) {
    wy(this, e, t);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let t = e.spec.attributes, i = e.spec.class;
    t && (this.attrs = Fh(t, this.attrs || {})), i && (this.attrs = Fh({ class: i }, this.attrs || {}));
  }
  domAtPos(e) {
    return xy(this.dom, this.children, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.dirty |= 6);
  }
  sync(e) {
    var t;
    this.dom ? this.dirty & 4 && (fy(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (Wh(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e);
    let i = this.dom.lastChild;
    for (; i && rt.get(i) instanceof Yi; )
      i = i.lastChild;
    if (!i || !this.length || i.nodeName != "BR" && ((t = rt.get(i)) === null || t === void 0 ? void 0 : t.isEditable) == !1 && (!we.ios || !this.children.some((s) => s instanceof Ds))) {
      let s = document.createElement("BR");
      s.cmIgnore = !0, this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0;
    for (let t of this.children) {
      if (!(t instanceof Ds))
        return null;
      let i = Jr(t.dom);
      if (i.length != 1)
        return null;
      e += i[0].width;
    }
    return {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length
    };
  }
  coordsAt(e, t) {
    return Sy(this, e, t);
  }
  become(e) {
    return !1;
  }
  get type() {
    return Ye.Text;
  }
  static find(e, t) {
    for (let i = 0, s = 0; i < e.children.length; i++) {
      let n = e.children[i], o = s + n.length;
      if (o >= t) {
        if (n instanceof Bt)
          return n;
        if (o > t)
          break;
      }
      s = o + n.breakAfter;
    }
    return null;
  }
}
class tn extends rt {
  constructor(e, t, i) {
    super(), this.widget = e, this.length = t, this.type = i, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, t, i, s, n, o) {
    return i && (!(i instanceof tn) || !this.widget.compare(i.widget) || e > 0 && n <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - t), !0);
  }
  domAtPos(e) {
    return e == 0 ? Et.before(this.dom) : Et.after(this.dom, e == this.length);
  }
  split(e) {
    let t = this.length - e;
    this.length = e;
    let i = new tn(this.widget, t, this.type);
    return i.breakAfter = this.breakAfter, i;
  }
  get children() {
    return Hd;
  }
  sync() {
    (!this.dom || !this.widget.updateDOM(this.dom)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(this.editorView)), this.dom.contentEditable = "false");
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : We.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof tn && e.type == this.type && e.widget.constructor == this.widget.constructor ? (e.widget.eq(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class jd {
  constructor(e, t, i, s) {
    this.doc = e, this.pos = t, this.end = i, this.disallowBlockEffectsBelow = s, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = t;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !e.breakAfter && !(e instanceof tn && e.type == Ye.WidgetBefore);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new Bt()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e) {
    this.pendingBuffer && (this.curLine.append(Ua(new Gn(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer([]), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    e ? this.pendingBuffer = 0 : this.flushBuffer([]), this.posCovered() || this.getLine();
  }
  buildText(e, t, i) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: n, lineBreak: o, done: l } = this.cursor.next(this.skip);
        if (this.skip = 0, l)
          throw new Error("Ran out of text content when drawing inline views");
        if (o) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer([]), this.curLine = null, e--;
          continue;
        } else
          this.text = n, this.textOff = 0;
      }
      let s = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* Chunk */
      );
      this.flushBuffer(t.slice(0, i)), this.getLine().append(Ua(new Ds(this.text.slice(this.textOff, this.textOff + s)), t), i), this.atCursorPos = !0, this.textOff += s, e -= s, i = 0;
    }
  }
  span(e, t, i, s) {
    this.buildText(t - e, i, s), this.pos = t, this.openStart < 0 && (this.openStart = s);
  }
  point(e, t, i, s, n) {
    let o = t - e;
    if (i instanceof on)
      if (i.block) {
        let { type: l } = i;
        l == Ye.WidgetAfter && !this.posCovered() && this.getLine(), this.addBlockWidget(new tn(i.widget || new Ep("div"), o, l));
      } else {
        let l = _s.create(i.widget || new Ep("span"), o, i.startSide), c = this.atCursorPos && !l.isEditable && n <= s.length && (e < t || i.startSide > 0), d = !l.isEditable && (e < t || i.startSide <= 0), f = this.getLine();
        this.pendingBuffer == 2 && !c && (this.pendingBuffer = 0), this.flushBuffer(s), c && (f.append(Ua(new Gn(1), s), n), n = s.length + Math.max(0, n - s.length)), f.append(Ua(l, s), n), this.atCursorPos = d, this.pendingBuffer = d ? e < t ? 1 : 2 : 0;
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i);
    o && (this.textOff + o <= this.text.length ? this.textOff += o : (this.skip += o - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = t), this.openStart < 0 && (this.openStart = n);
  }
  filterPoint(e, t, i, s) {
    if (s < this.disallowBlockEffectsBelow && i instanceof on) {
      if (i.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (t > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    return !0;
  }
  static build(e, t, i, s, n) {
    let o = new jd(e, t, i, n);
    return o.openEnd = ze.spans(s, t, i, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function Ua(a, e) {
  for (let t of e)
    a = new Yi(t, [a], a.length);
  return a;
}
class Ep extends hs {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
}
const cI = [], _y = /* @__PURE__ */ be.define(), Cy = /* @__PURE__ */ be.define(), Ty = /* @__PURE__ */ be.define(), Ay = /* @__PURE__ */ be.define(), zh = /* @__PURE__ */ be.define(), $y = /* @__PURE__ */ be.define(), Xh = /* @__PURE__ */ _e.define({
  map: (a, e) => a.map(e)
}), Ey = /* @__PURE__ */ _e.define({
  map: (a, e) => a.map(e)
});
class Pn {
  constructor(e, t = "nearest", i = "nearest", s = 5, n = 5) {
    this.range = e, this.y = t, this.x = i, this.yMargin = s, this.xMargin = n;
  }
  map(e) {
    return e.empty ? this : new Pn(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin);
  }
}
const Pp = /* @__PURE__ */ _e.define({ map: (a, e) => a.map(e) });
function bi(a, e, t) {
  let i = a.facet(Ay);
  i.length ? i[0](e) : window.onerror ? window.onerror(String(e), t, void 0, void 0, e) : t ? console.error(t + ":", e) : console.error(e);
}
const Ca = /* @__PURE__ */ be.define({ combine: (a) => a.length ? a[0] : !0 });
class hI {
  /**
  @internal
  */
  constructor(e, t) {
    this.field = e, this.get = t;
  }
}
class Qt {
  /**
  Create a [provider](https://codemirror.net/6/docs/ref/#view.PluginFieldProvider) for this field,
  to use with a plugin's [provide](https://codemirror.net/6/docs/ref/#view.PluginSpec.provide)
  option.
  */
  from(e) {
    return new hI(this, e);
  }
  /**
  Define a new plugin field.
  */
  static define() {
    return new Qt();
  }
}
Qt.decorations = /* @__PURE__ */ Qt.define();
Qt.atomicRanges = /* @__PURE__ */ Qt.define();
Qt.scrollMargins = /* @__PURE__ */ Qt.define();
let dI = 0;
const kr = /* @__PURE__ */ be.define();
class Ot {
  constructor(e, t, i) {
    this.id = e, this.create = t, this.fields = i, this.extension = kr.of(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, t) {
    let { eventHandlers: i, provide: s, decorations: n } = t || {}, o = [];
    if (s)
      for (let l of Array.isArray(s) ? s : [s])
        o.push(l);
    return i && o.push(Py.from((l) => ({ plugin: l, handlers: i }))), n && o.push(Qt.decorations.from(n)), new Ot(dI++, e, o);
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, t) {
    return Ot.define((i) => new e(i), t);
  }
}
const Py = /* @__PURE__ */ Qt.define();
class Sc {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  takeField(e, t) {
    if (this.spec)
      for (let { field: i, get: s } of this.spec.fields)
        i == e && t.push(s(this.value));
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let t = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(t);
          } catch (i) {
            if (bi(t.state, i, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (t) {
        bi(e.state, t, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var t;
    if (!((t = this.value) === null || t === void 0) && t.destroy)
      try {
        this.value.destroy();
      } catch (i) {
        bi(e.state, i, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const Ly = /* @__PURE__ */ be.define(), My = /* @__PURE__ */ be.define(), qs = /* @__PURE__ */ be.define(), _r = /* @__PURE__ */ be.define();
class is {
  constructor(e, t, i, s) {
    this.fromA = e, this.toA = t, this.fromB = i, this.toB = s;
  }
  join(e) {
    return new is(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let t = e.length, i = this;
    for (; t > 0; t--) {
      let s = e[t - 1];
      if (!(s.fromA > i.toA)) {
        if (s.toA < i.fromA)
          break;
        i = i.join(s), e.splice(t - 1, 1);
      }
    }
    return e.splice(t, 0, i), e;
  }
  static extendWithRanges(e, t) {
    if (t.length == 0)
      return e;
    let i = [];
    for (let s = 0, n = 0, o = 0, l = 0; ; s++) {
      let c = s == e.length ? null : e[s], d = o - l, f = c ? c.fromB : 1e9;
      for (; n < t.length && t[n] < f; ) {
        let p = t[n], m = t[n + 1], v = Math.max(l, p), r = Math.min(f, m);
        if (v <= r && new is(v + d, r + d, v, r).addToSet(i), m > f)
          break;
        n += 2;
      }
      if (!c)
        return i;
      new is(c.fromA, c.toA, c.fromB, c.toB).addToSet(i), o = c.toA, l = c.toB;
    }
  }
}
class Lp {
  /**
  @internal
  */
  constructor(e, t, i = cI) {
    this.view = e, this.state = t, this.transactions = i, this.flags = 0, this.startState = e.state, this.changes = xt.empty(this.startState.doc.length);
    for (let o of i)
      this.changes = this.changes.compose(o.changes);
    let s = [];
    this.changes.iterChangedRanges((o, l, c, d) => s.push(new is(o, l, c, d))), this.changedRanges = s;
    let n = e.hasFocus;
    n != e.inputState.notifiedFocused && (e.inputState.notifiedFocused = n, this.flags |= 1);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of an element in the editor changed
  in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
var Ne = /* @__PURE__ */ function(a) {
  return a[a.LTR = 0] = "LTR", a[a.RTL = 1] = "RTL", a;
}(Ne || (Ne = {}));
const Yh = Ne.LTR, uI = Ne.RTL;
function Dy(a) {
  let e = [];
  for (let t = 0; t < a.length; t++)
    e.push(1 << +a[t]);
  return e;
}
const fI = /* @__PURE__ */ Dy("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), pI = /* @__PURE__ */ Dy("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Vh = /* @__PURE__ */ Object.create(null), Li = [];
for (let a of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ a.charCodeAt(0), t = /* @__PURE__ */ a.charCodeAt(1);
  Vh[e] = t, Vh[t] = -e;
}
function gI(a) {
  return a <= 247 ? fI[a] : 1424 <= a && a <= 1524 ? 2 : 1536 <= a && a <= 1785 ? pI[a - 1536] : 1774 <= a && a <= 2220 ? 4 : 8192 <= a && a <= 8203 || a == 8204 ? 256 : 1;
}
const mI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
class Fn {
  /**
  @internal
  */
  constructor(e, t, i) {
    this.from = e, this.to = t, this.level = i;
  }
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? uI : Yh;
  }
  /**
  @internal
  */
  side(e, t) {
    return this.dir == t == e ? this.to : this.from;
  }
  /**
  @internal
  */
  static find(e, t, i, s) {
    let n = -1;
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (l.from <= t && l.to >= t) {
        if (l.level == i)
          return o;
        (n < 0 || (s != 0 ? s < 0 ? l.from < t : l.to > t : e[n].level > l.level)) && (n = o);
      }
    }
    if (n < 0)
      throw new RangeError("Index out of range");
    return n;
  }
}
const Ke = [];
function bI(a, e) {
  let t = a.length, i = e == Yh ? 1 : 2, s = e == Yh ? 2 : 1;
  if (!a || i == 1 && !mI.test(a))
    return Ry(t);
  for (let o = 0, l = i, c = i; o < t; o++) {
    let d = gI(a.charCodeAt(o));
    d == 512 ? d = l : d == 8 && c == 4 && (d = 16), Ke[o] = d == 4 ? 2 : d, d & 7 && (c = d), l = d;
  }
  for (let o = 0, l = i, c = i; o < t; o++) {
    let d = Ke[o];
    if (d == 128)
      o < t - 1 && l == Ke[o + 1] && l & 24 ? d = Ke[o] = l : Ke[o] = 256;
    else if (d == 64) {
      let f = o + 1;
      for (; f < t && Ke[f] == 64; )
        f++;
      let p = o && l == 8 || f < t && Ke[f] == 8 ? c == 1 ? 1 : 8 : 256;
      for (let m = o; m < f; m++)
        Ke[m] = p;
      o = f - 1;
    } else
      d == 8 && c == 1 && (Ke[o] = 1);
    l = d, d & 7 && (c = d);
  }
  for (let o = 0, l = 0, c = 0, d, f, p; o < t; o++)
    if (f = Vh[d = a.charCodeAt(o)])
      if (f < 0) {
        for (let m = l - 3; m >= 0; m -= 3)
          if (Li[m + 1] == -f) {
            let v = Li[m + 2], r = v & 2 ? i : v & 4 ? v & 1 ? s : i : 0;
            r && (Ke[o] = Ke[Li[m]] = r), l = m;
            break;
          }
      } else {
        if (Li.length == 189)
          break;
        Li[l++] = o, Li[l++] = d, Li[l++] = c;
      }
    else if ((p = Ke[o]) == 2 || p == 1) {
      let m = p == i;
      c = m ? 0 : 1;
      for (let v = l - 3; v >= 0; v -= 3) {
        let r = Li[v + 2];
        if (r & 2)
          break;
        if (m)
          Li[v + 2] |= 2;
        else {
          if (r & 4)
            break;
          Li[v + 2] |= 4;
        }
      }
    }
  for (let o = 0; o < t; o++)
    if (Ke[o] == 256) {
      let l = o + 1;
      for (; l < t && Ke[l] == 256; )
        l++;
      let c = (o ? Ke[o - 1] : i) == 1, d = (l < t ? Ke[l] : i) == 1, f = c == d ? c ? 1 : 2 : i;
      for (let p = o; p < l; p++)
        Ke[p] = f;
      o = l - 1;
    }
  let n = [];
  if (i == 1)
    for (let o = 0; o < t; ) {
      let l = o, c = Ke[o++] != 1;
      for (; o < t && c == (Ke[o] != 1); )
        o++;
      if (c)
        for (let d = o; d > l; ) {
          let f = d, p = Ke[--d] != 2;
          for (; d > l && p == (Ke[d - 1] != 2); )
            d--;
          n.push(new Fn(d, f, p ? 2 : 1));
        }
      else
        n.push(new Fn(l, o, 0));
    }
  else
    for (let o = 0; o < t; ) {
      let l = o, c = Ke[o++] == 2;
      for (; o < t && c == (Ke[o] == 2); )
        o++;
      n.push(new Fn(l, o, c ? 1 : 2));
    }
  return n;
}
function Ry(a) {
  return [new Fn(0, a, 0)];
}
let Iy = "";
function vI(a, e, t, i, s) {
  var n;
  let o = i.head - a.from, l = -1;
  if (o == 0) {
    if (!s || !a.length)
      return null;
    e[0].level != t && (o = e[0].side(!1, t), l = 0);
  } else if (o == a.length) {
    if (s)
      return null;
    let m = e[e.length - 1];
    m.level != t && (o = m.side(!0, t), l = e.length - 1);
  }
  l < 0 && (l = Fn.find(e, o, (n = i.bidiLevel) !== null && n !== void 0 ? n : -1, i.assoc));
  let c = e[l];
  o == c.side(s, t) && (c = e[l += s ? 1 : -1], o = c.side(!s, t));
  let d = s == (c.dir == t), f = ti(a.text, o, d);
  if (Iy = a.text.slice(Math.min(o, f), Math.max(o, f)), f != c.side(s, t))
    return ee.cursor(f + a.from, d ? -1 : 1, c.level);
  let p = l == (s ? e.length - 1 : 0) ? null : e[l + (s ? 1 : -1)];
  return !p && c.level != t ? ee.cursor(s ? a.to : a.from, s ? -1 : 1, t) : p && p.level < c.level ? ee.cursor(p.side(!s, t) + a.from, s ? 1 : -1, p.level) : ee.cursor(f + a.from, s ? -1 : 1, c.level);
}
const Cs = "￿";
class Qy {
  constructor(e, t) {
    this.points = e, this.text = "", this.lineSeparator = t.facet(Re.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += Cs;
  }
  readRange(e, t) {
    if (!e)
      return this;
    let i = e.parentNode;
    for (let s = e; ; ) {
      this.findPointBefore(i, s), this.readNode(s);
      let n = s.nextSibling;
      if (n == t)
        break;
      let o = rt.get(s), l = rt.get(n);
      (o && l ? o.breakAfter : (o ? o.breakAfter : Mp(s)) || Mp(n) && (s.nodeName != "BR" || s.cmIgnore)) && this.lineBreak(), s = n;
    }
    return this.findPointBefore(i, t), this;
  }
  readTextNode(e) {
    let t = e.nodeValue;
    for (let i of this.points)
      i.node == e && (i.pos = this.text.length + Math.min(i.offset, t.length));
    for (let i = 0, s = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let n = -1, o = 1, l;
      if (this.lineSeparator ? (n = t.indexOf(this.lineSeparator, i), o = this.lineSeparator.length) : (l = s.exec(t)) && (n = l.index, o = l[0].length), this.append(t.slice(i, n < 0 ? t.length : n)), n < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let c of this.points)
          c.node == e && c.pos > this.text.length && (c.pos -= o - 1);
      i = n + o;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let t = rt.get(e), i = t && t.overrideDOMText;
    if (i != null) {
      this.findPointInside(e, i.length);
      for (let s = i.iter(); !s.next().done; )
        s.lineBreak ? this.lineBreak() : this.append(s.value);
    } else
      e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, t) {
    for (let i of this.points)
      i.node == e && e.childNodes[i.offset] == t && (i.pos = this.text.length);
  }
  findPointInside(e, t) {
    for (let i of this.points)
      (e.nodeType == 3 ? i.node == e : e.contains(i.node)) && (i.pos = this.text.length + Math.min(t, i.offset));
  }
}
function Mp(a) {
  return a.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(a.nodeName);
}
class Dp {
  constructor(e, t) {
    this.node = e, this.offset = t, this.pos = -1;
  }
}
class Rp extends rt {
  constructor(e) {
    super(), this.view = e, this.compositionDeco = me.none, this.decorations = [], this.pluginDecorationLength = 0, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new Bt()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new is(0, 0, 0, e.state.doc.length)], 0);
  }
  get root() {
    return this.view.root;
  }
  get editorView() {
    return this.view;
  }
  get length() {
    return this.view.state.doc.length;
  }
  // Update the document view to a given state. scrollIntoView can be
  // used as a hint to compute a new viewport that includes that
  // position, if we know the editor is going to scroll that position
  // into view.
  update(e) {
    let t = e.changedRanges;
    this.minWidth > 0 && t.length && (t.every(({ fromA: o, toA: l }) => l < this.minWidthFrom || o > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.view.inputState.composing < 0 ? this.compositionDeco = me.none : (e.transactions.length || this.dirty) && (this.compositionDeco = OI(this.view, e.changes)), (we.ie || we.chrome) && !this.compositionDeco.size && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let i = this.decorations, s = this.updateDeco(), n = kI(i, s, e.changes);
    return t = is.extendWithRanges(t, n), this.dirty == 0 && t.length == 0 ? !1 : (this.updateInner(t, e.startState.doc.length), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, t) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, t);
    let { observer: i } = this.view;
    i.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight + "px", this.dom.style.minWidth = this.minWidth ? this.minWidth + "px" : "";
      let n = we.chrome || we.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(n), this.dirty = 0, n && (n.written || i.selectionRange.focusNode != n.node) && (this.forceSelection = !0), this.dom.style.height = "";
    });
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let n of this.children)
        n instanceof tn && n.widget instanceof Ip && s.push(n.dom);
    i.updateGaps(s);
  }
  updateChildren(e, t) {
    let i = this.childCursor(t);
    for (let s = e.length - 1; ; s--) {
      let n = s >= 0 ? e[s] : null;
      if (!n)
        break;
      let { fromA: o, toA: l, fromB: c, toB: d } = n, { content: f, breakAtStart: p, openStart: m, openEnd: v } = jd.build(this.view.state.doc, c, d, this.decorations, this.pluginDecorationLength), { i: r, off: h } = i.findPos(l, 1), { i: u, off: g } = i.findPos(o, -1);
      gy(this, u, g, r, h, f, p, m, v);
    }
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, t = !1) {
    if (e && this.view.observer.readSelectionRange(), !(t || this.mayControlSelection()) || we.ios && this.view.inputState.rapidCompositionStart)
      return;
    let i = this.forceSelection;
    this.forceSelection = !1;
    let s = this.view.state.selection.main, n = this.domAtPos(s.anchor), o = s.empty ? n : this.domAtPos(s.head);
    if (we.gecko && s.empty && yI(n)) {
      let c = document.createTextNode("");
      this.view.observer.ignore(() => n.node.insertBefore(c, n.node.childNodes[n.offset] || null)), n = o = new Et(c, 0), i = !0;
    }
    let l = this.view.observer.selectionRange;
    (i || !l.focusNode || !No(n.node, n.offset, l.anchorNode, l.anchorOffset) || !No(o.node, o.offset, l.focusNode, l.focusOffset)) && (this.view.observer.ignore(() => {
      we.android && we.chrome && this.dom.contains(l.focusNode) && _I(l.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let c = Qo(this.root);
      if (s.empty) {
        if (we.gecko) {
          let d = wI(n.node, n.offset);
          if (d && d != 3) {
            let f = Fy(n.node, n.offset, d == 1 ? 1 : -1);
            f && (n = new Et(f, d == 1 ? 0 : f.nodeValue.length));
          }
        }
        c.collapse(n.node, n.offset), s.bidiLevel != null && l.cursorBidiLevel != null && (l.cursorBidiLevel = s.bidiLevel);
      } else if (c.extend)
        c.collapse(n.node, n.offset), c.extend(o.node, o.offset);
      else {
        let d = document.createRange();
        s.anchor > s.head && ([n, o] = [o, n]), d.setEnd(o.node, o.offset), d.setStart(n.node, n.offset), c.removeAllRanges(), c.addRange(d);
      }
    }), this.view.observer.setSelectionRange(n, o)), this.impreciseAnchor = n.precise ? null : new Et(l.anchorNode, l.anchorOffset), this.impreciseHead = o.precise ? null : new Et(l.focusNode, l.focusOffset);
  }
  enforceCursorAssoc() {
    if (this.compositionDeco.size)
      return;
    let e = this.view.state.selection.main, t = Qo(this.root);
    if (!e.empty || !e.assoc || !t.modify)
      return;
    let i = Bt.find(this, e.head);
    if (!i)
      return;
    let s = i.posAtStart;
    if (e.head == s || e.head == s + i.length)
      return;
    let n = this.coordsAt(e.head, -1), o = this.coordsAt(e.head, 1);
    if (!n || !o || n.bottom > o.top)
      return;
    let l = this.domAtPos(e.head + e.assoc);
    t.collapse(l.node, l.offset), t.modify("move", e.assoc < 0 ? "forward" : "backward", "lineboundary");
  }
  mayControlSelection() {
    return this.view.state.facet(Ca) ? this.root.activeElement == this.dom : Lh(this.dom, this.view.observer.selectionRange);
  }
  nearest(e) {
    for (let t = e; t; ) {
      let i = rt.get(t);
      if (i && i.rootView == this)
        return i;
      t = t.parentNode;
    }
    return null;
  }
  posFromDOM(e, t) {
    let i = this.nearest(e);
    if (!i)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return i.localPosFromDOM(e, t) + i.posAtStart;
  }
  domAtPos(e) {
    let { i: t, off: i } = this.childCursor().findPos(e, -1);
    for (; t < this.children.length - 1; ) {
      let s = this.children[t];
      if (i < s.length || s instanceof Bt)
        break;
      t++, i = 0;
    }
    return this.children[t].domAtPos(i);
  }
  coordsAt(e, t) {
    for (let i = this.length, s = this.children.length - 1; ; s--) {
      let n = this.children[s], o = i - n.breakAfter - n.length;
      if (e > o || e == o && n.type != Ye.WidgetBefore && n.type != Ye.WidgetAfter && (!s || t == 2 || this.children[s - 1].breakAfter || this.children[s - 1].type == Ye.WidgetBefore && t > -2))
        return n.coordsAt(e - o, t);
      i = o;
    }
  }
  measureVisibleLineHeights() {
    let e = [], { from: t, to: i } = this.view.viewState.viewport, s = this.view.contentDOM.clientWidth, n = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, o = -1;
    for (let l = 0, c = 0; c < this.children.length; c++) {
      let d = this.children[c], f = l + d.length;
      if (f > i)
        break;
      if (l >= t) {
        let p = d.dom.getBoundingClientRect();
        if (e.push(p.height), n) {
          let m = d.dom.lastChild, v = m ? Jr(m) : [];
          if (v.length) {
            let r = v[v.length - 1], h = this.view.textDirection == Ne.LTR ? r.right - p.left : p.right - r.left;
            h > o && (o = h, this.minWidth = s, this.minWidthFrom = l, this.minWidthTo = f);
          }
        }
      }
      l = f + d.breakAfter;
    }
    return e;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof Bt) {
        let n = s.measureTextSize();
        if (n)
          return n;
      }
    let e = document.createElement("div"), t, i;
    return e.className = "cm-line", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let s = Jr(e.firstChild)[0];
      t = e.getBoundingClientRect().height, i = s ? s.width / 27 : 7, e.remove();
    }), { lineHeight: t, charWidth: i };
  }
  childCursor(e = this.length) {
    let t = this.children.length;
    return t && (e -= this.children[--t].length), new py(this.children, e, t);
  }
  computeBlockGapDeco() {
    let e = [], t = this.view.viewState;
    for (let i = 0, s = 0; ; s++) {
      let n = s == t.viewports.length ? null : t.viewports[s], o = n ? n.from - 1 : this.length;
      if (o > i) {
        let l = t.lineBlockAt(o).bottom - t.lineBlockAt(i).top;
        e.push(me.replace({
          widget: new Ip(l),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(i, o));
      }
      if (!n)
        break;
      i = n.to + 1;
    }
    return me.set(e);
  }
  updateDeco() {
    let e = this.view.pluginField(Qt.decorations);
    return this.pluginDecorationLength = e.length, this.decorations = [
      ...e,
      ...this.view.state.facet(qs),
      this.compositionDeco,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(e) {
    let { range: t } = e, i = this.coordsAt(t.head, t.empty ? t.assoc : t.head > t.anchor ? -1 : 1), s;
    if (!i)
      return;
    !t.empty && (s = this.coordsAt(t.anchor, t.anchor > t.head ? -1 : 1)) && (i = {
      left: Math.min(i.left, s.left),
      top: Math.min(i.top, s.top),
      right: Math.max(i.right, s.right),
      bottom: Math.max(i.bottom, s.bottom)
    });
    let n = 0, o = 0, l = 0, c = 0;
    for (let f of this.view.pluginField(Qt.scrollMargins))
      if (f) {
        let { left: p, right: m, top: v, bottom: r } = f;
        p != null && (n = Math.max(n, p)), m != null && (o = Math.max(o, m)), v != null && (l = Math.max(l, v)), r != null && (c = Math.max(c, r));
      }
    let d = {
      left: i.left - n,
      top: i.top - l,
      right: i.right + o,
      bottom: i.bottom + c
    };
    sI(this.view.scrollDOM, d, t.head < t.anchor ? -1 : 1, e.x, e.y, e.xMargin, e.yMargin, this.view.textDirection == Ne.LTR);
  }
}
function yI(a) {
  return a.node.nodeType == 1 && a.node.firstChild && (a.offset == 0 || a.node.childNodes[a.offset - 1].contentEditable == "false") && (a.offset == a.node.childNodes.length || a.node.childNodes[a.offset].contentEditable == "false");
}
class Ip extends hs {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get estimatedHeight() {
    return this.height;
  }
}
function Ny(a) {
  let e = a.observer.selectionRange, t = e.focusNode && Fy(e.focusNode, e.focusOffset, 0);
  if (!t)
    return null;
  let i = a.docView.nearest(t);
  if (!i)
    return null;
  if (i instanceof Bt) {
    let s = t;
    for (; s.parentNode != i.dom; )
      s = s.parentNode;
    let n = s.previousSibling;
    for (; n && !rt.get(n); )
      n = n.previousSibling;
    let o = n ? rt.get(n).posAtEnd : i.posAtStart;
    return { from: o, to: o, node: s, text: t };
  } else {
    for (; ; ) {
      let { parent: n } = i;
      if (!n)
        return null;
      if (n instanceof Bt)
        break;
      i = n;
    }
    let s = i.posAtStart;
    return { from: s, to: s + i.length, node: i.dom, text: t };
  }
}
function OI(a, e) {
  let t = Ny(a);
  if (!t)
    return me.none;
  let { from: i, to: s, node: n, text: o } = t, l = e.mapPos(i, 1), c = Math.max(l, e.mapPos(s, -1)), { state: d } = a, f = n.nodeType == 3 ? n.nodeValue : new Qy([], d).readRange(n.firstChild, null).text;
  if (c - l < f.length)
    if (d.doc.sliceString(l, Math.min(d.doc.length, l + f.length), Cs) == f)
      c = l + f.length;
    else if (d.doc.sliceString(Math.max(0, c - f.length), c, Cs) == f)
      l = c - f.length;
    else
      return me.none;
  else if (d.doc.sliceString(l, c, Cs) != f)
    return me.none;
  let p = rt.get(n);
  return p instanceof yy ? p = p.widget.topView : p && (p.parent = null), me.set(me.replace({ widget: new xI(n, o, p) }).range(l, c));
}
class xI extends hs {
  constructor(e, t, i) {
    super(), this.top = e, this.text = t, this.topView = i;
  }
  eq(e) {
    return this.top == e.top && this.text == e.text;
  }
  toDOM() {
    return this.top;
  }
  ignoreEvent() {
    return !1;
  }
  get customView() {
    return yy;
  }
}
function Fy(a, e, t) {
  for (; ; ) {
    if (a.nodeType == 3)
      return a;
    if (a.nodeType == 1 && e > 0 && t <= 0)
      a = a.childNodes[e - 1], e = Fo(a);
    else if (a.nodeType == 1 && e < a.childNodes.length && t >= 0)
      a = a.childNodes[e], e = 0;
    else
      return null;
  }
}
function wI(a, e) {
  return a.nodeType != 1 ? 0 : (e && a.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < a.childNodes.length && a.childNodes[e].contentEditable == "false" ? 2 : 0);
}
class SI {
  constructor() {
    this.changes = [];
  }
  compareRange(e, t) {
    Bh(e, t, this.changes);
  }
  comparePoint(e, t) {
    Bh(e, t, this.changes);
  }
}
function kI(a, e, t) {
  let i = new SI();
  return ze.compare(a, e, t, i), i.changes;
}
function _I(a, e) {
  for (let t = a; t && t != e; t = t.assignedSlot || t.parentNode)
    if (t.nodeType == 1 && t.contentEditable == "false")
      return !0;
  return !1;
}
function CI(a, e, t = 1) {
  let i = a.charCategorizer(e), s = a.doc.lineAt(e), n = e - s.from;
  if (s.length == 0)
    return ee.cursor(e);
  n == 0 ? t = 1 : n == s.length && (t = -1);
  let o = n, l = n;
  t < 0 ? o = ti(s.text, n, !1) : l = ti(s.text, n);
  let c = i(s.text.slice(o, l));
  for (; o > 0; ) {
    let d = ti(s.text, o, !1);
    if (i(s.text.slice(d, o)) != c)
      break;
    o = d;
  }
  for (; l < s.length; ) {
    let d = ti(s.text, l);
    if (i(s.text.slice(l, d)) != c)
      break;
    l = d;
  }
  return ee.range(o + s.from, l + s.from);
}
function TI(a, e) {
  return e.left > a ? e.left - a : Math.max(0, a - e.right);
}
function AI(a, e) {
  return e.top > a ? e.top - a : Math.max(0, a - e.bottom);
}
function kc(a, e) {
  return a.top < e.bottom - 1 && a.bottom > e.top + 1;
}
function Qp(a, e) {
  return e < a.top ? { top: e, left: a.left, right: a.right, bottom: a.bottom } : a;
}
function Np(a, e) {
  return e > a.bottom ? { top: a.top, left: a.left, right: a.right, bottom: e } : a;
}
function Hh(a, e, t) {
  let i, s, n, o, l, c, d, f;
  for (let v = a.firstChild; v; v = v.nextSibling) {
    let r = Jr(v);
    for (let h = 0; h < r.length; h++) {
      let u = r[h];
      s && kc(s, u) && (u = Qp(Np(u, s.bottom), s.top));
      let g = TI(e, u), b = AI(t, u);
      if (g == 0 && b == 0)
        return v.nodeType == 3 ? Fp(v, e, t) : Hh(v, e, t);
      (!i || o > b || o == b && n > g) && (i = v, s = u, n = g, o = b), g == 0 ? t > u.bottom && (!d || d.bottom < u.bottom) ? (l = v, d = u) : t < u.top && (!f || f.top > u.top) && (c = v, f = u) : d && kc(d, u) ? d = Np(d, u.bottom) : f && kc(f, u) && (f = Qp(f, u.top));
    }
  }
  if (d && d.bottom >= t ? (i = l, s = d) : f && f.top <= t && (i = c, s = f), !i)
    return { node: a, offset: 0 };
  let p = Math.max(s.left, Math.min(s.right, e));
  if (i.nodeType == 3)
    return Fp(i, p, t);
  if (!n && i.contentEditable == "true")
    return Hh(i, p, t);
  let m = Array.prototype.indexOf.call(a.childNodes, i) + (e >= (s.left + s.right) / 2 ? 1 : 0);
  return { node: a, offset: m };
}
function Fp(a, e, t) {
  let i = a.nodeValue.length, s = -1, n = 1e9, o = 0;
  for (let l = 0; l < i; l++) {
    let c = ea(a, l, l + 1).getClientRects();
    for (let d = 0; d < c.length; d++) {
      let f = c[d];
      if (f.top == f.bottom)
        continue;
      o || (o = e - f.left);
      let p = (f.top > t ? f.top - t : t - f.bottom) - 1;
      if (f.left - 1 <= e && f.right + 1 >= e && p < n) {
        let m = e >= (f.left + f.right) / 2, v = m;
        if ((we.chrome || we.gecko) && ea(a, l).getBoundingClientRect().left == f.right && (v = !m), p <= 0)
          return { node: a, offset: l + (v ? 1 : 0) };
        s = l + (v ? 1 : 0), n = p;
      }
    }
  }
  return { node: a, offset: s > -1 ? s : o > 0 ? a.nodeValue.length : 0 };
}
function Wy(a, { x: e, y: t }, i, s = -1) {
  var n;
  let o = a.contentDOM.getBoundingClientRect(), l = o.top + a.viewState.paddingTop, c, { docHeight: d } = a.viewState, f = t - l;
  if (f < 0)
    return 0;
  if (f > d)
    return a.state.doc.length;
  for (let g = a.defaultLineHeight / 2, b = !1; c = a.elementAtHeight(f), c.type != Ye.Text; )
    for (; f = s > 0 ? c.bottom + g : c.top - g, !(f >= 0 && f <= d); ) {
      if (b)
        return i ? null : 0;
      b = !0, s = -s;
    }
  t = l + f;
  let p = c.from;
  if (p < a.viewport.from)
    return a.viewport.from == 0 ? 0 : i ? null : Wp(a, o, c, e, t);
  if (p > a.viewport.to)
    return a.viewport.to == a.state.doc.length ? a.state.doc.length : i ? null : Wp(a, o, c, e, t);
  let m = a.dom.ownerDocument, v = a.root.elementFromPoint ? a.root : m, r = v.elementFromPoint(e, t);
  r && !a.contentDOM.contains(r) && (r = null), r || (e = Math.max(o.left + 1, Math.min(o.right - 1, e)), r = v.elementFromPoint(e, t), r && !a.contentDOM.contains(r) && (r = null));
  let h, u = -1;
  if (r && ((n = a.docView.nearest(r)) === null || n === void 0 ? void 0 : n.isEditable) != !1) {
    if (m.caretPositionFromPoint) {
      let g = m.caretPositionFromPoint(e, t);
      g && ({ offsetNode: h, offset: u } = g);
    } else if (m.caretRangeFromPoint) {
      let g = m.caretRangeFromPoint(e, t);
      g && ({ startContainer: h, startOffset: u } = g, we.safari && $I(h, u, e) && (h = void 0));
    }
  }
  if (!h || !a.docView.dom.contains(h)) {
    let g = Bt.find(a.docView, p);
    if (!g)
      return f > c.top + c.height / 2 ? c.to : c.from;
    ({ node: h, offset: u } = Hh(g.dom, e, t));
  }
  return a.docView.posFromDOM(h, u);
}
function Wp(a, e, t, i, s) {
  let n = Math.round((i - e.left) * a.defaultCharacterWidth);
  if (a.lineWrapping && t.height > a.defaultLineHeight * 1.5) {
    let l = Math.floor((s - t.top) / a.defaultLineHeight);
    n += l * a.viewState.heightOracle.lineLength;
  }
  let o = a.state.sliceDoc(t.from, t.to);
  return t.from + Oh(o, n, a.state.tabSize);
}
function $I(a, e, t) {
  let i;
  if (a.nodeType != 3 || e != (i = a.nodeValue.length))
    return !1;
  for (let s = a.nextSibling; s; s = s.nextSibling)
    if (s.nodeType != 1 || s.nodeName != "BR")
      return !1;
  return ea(a, i - 1, i).getBoundingClientRect().left > t;
}
function EI(a, e, t, i) {
  let s = a.state.doc.lineAt(e.head), n = !i || !a.lineWrapping ? null : a.coordsAtPos(e.assoc < 0 && e.head > s.from ? e.head - 1 : e.head);
  if (n) {
    let c = a.dom.getBoundingClientRect(), d = a.posAtCoords({
      x: t == (a.textDirection == Ne.LTR) ? c.right - 1 : c.left + 1,
      y: (n.top + n.bottom) / 2
    });
    if (d != null)
      return ee.cursor(d, t ? -1 : 1);
  }
  let o = Bt.find(a.docView, e.head), l = o ? t ? o.posAtEnd : o.posAtStart : t ? s.to : s.from;
  return ee.cursor(l, t ? -1 : 1);
}
function Bp(a, e, t, i) {
  let s = a.state.doc.lineAt(e.head), n = a.bidiSpans(s);
  for (let o = e, l = null; ; ) {
    let c = vI(s, n, a.textDirection, o, t), d = Iy;
    if (!c) {
      if (s.number == (t ? a.state.doc.lines : 1))
        return o;
      d = `
`, s = a.state.doc.line(s.number + (t ? 1 : -1)), n = a.bidiSpans(s), c = ee.cursor(t ? s.from : s.to);
    }
    if (l) {
      if (!l(d))
        return o;
    } else {
      if (!i)
        return c;
      l = i(d);
    }
    o = c;
  }
}
function PI(a, e, t) {
  let i = a.state.charCategorizer(e), s = i(t);
  return (n) => {
    let o = i(n);
    return s == Wt.Space && (s = o), s == o;
  };
}
function LI(a, e, t, i) {
  let s = e.head, n = t ? 1 : -1;
  if (s == (t ? a.state.doc.length : 0))
    return ee.cursor(s, e.assoc);
  let o = e.goalColumn, l, c = a.contentDOM.getBoundingClientRect(), d = a.coordsAtPos(s), f = a.documentTop;
  if (d)
    o == null && (o = d.left - c.left), l = n < 0 ? d.top : d.bottom;
  else {
    let v = a.viewState.lineBlockAt(s - f);
    o == null && (o = Math.min(c.right - c.left, a.defaultCharacterWidth * (s - v.from))), l = (n < 0 ? v.top : v.bottom) + f;
  }
  let p = c.left + o, m = i ?? a.defaultLineHeight >> 1;
  for (let v = 0; ; v += 10) {
    let r = l + (m + v) * n, h = Wy(a, { x: p, y: r }, !1, n);
    if (r < c.top || r > c.bottom || (n < 0 ? h < s : h > s))
      return ee.cursor(h, e.assoc, void 0, o);
  }
}
function _c(a, e, t) {
  let i = a.pluginField(Qt.atomicRanges);
  for (; ; ) {
    let s = !1;
    for (let n of i)
      n.between(t.from - 1, t.from + 1, (o, l, c) => {
        t.from > o && t.from < l && (t = e.from > t.from ? ee.cursor(o, 1) : ee.cursor(l, -1), s = !0);
      });
    if (!s)
      return t;
  }
}
class MI {
  constructor(e) {
    this.lastKeyCode = 0, this.lastKeyTime = 0, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.registeredEvents = [], this.customHandlers = [], this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.rapidCompositionStart = !1, this.mouseSelection = null;
    for (let t in kt) {
      let i = kt[t];
      e.contentDOM.addEventListener(t, (s) => {
        !zp(e, s) || this.ignoreDuringComposition(s) || t == "keydown" && this.keydown(e, s) || (this.mustFlushObserver(s) && e.observer.forceFlush(), this.runCustomHandlers(t, e, s) ? s.preventDefault() : i(e, s));
      }), this.registeredEvents.push(t);
    }
    this.notifiedFocused = e.hasFocus, this.ensureHandlers(e), we.safari && e.contentDOM.addEventListener("input", () => null);
  }
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  ensureHandlers(e) {
    let t = this.customHandlers = e.pluginField(Py);
    for (let i of t)
      for (let s in i.handlers)
        this.registeredEvents.indexOf(s) < 0 && s != "scroll" && (this.registeredEvents.push(s), e.contentDOM.addEventListener(s, (n) => {
          zp(e, n) && this.runCustomHandlers(s, e, n) && n.preventDefault();
        }));
  }
  runCustomHandlers(e, t, i) {
    for (let s of this.customHandlers) {
      let n = s.handlers[e];
      if (n)
        try {
          if (n.call(s.plugin, i, t) || i.defaultPrevented)
            return !0;
        } catch (o) {
          bi(t.state, o);
        }
    }
    return !1;
  }
  runScrollHandlers(e, t) {
    for (let i of this.customHandlers) {
      let s = i.handlers.scroll;
      if (s)
        try {
          s.call(i.plugin, t, e);
        } catch (n) {
          bi(e.state, n);
        }
    }
  }
  keydown(e, t) {
    if (this.lastKeyCode = t.keyCode, this.lastKeyTime = Date.now(), t.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return !0;
    if (we.android && we.chrome && !t.synthetic && (t.keyCode == 13 || t.keyCode == 8))
      return e.observer.delayAndroidKey(t.key, t.keyCode), !0;
    let i;
    return we.ios && (i = By.find((s) => s.keyCode == t.keyCode)) && !(t.ctrlKey || t.altKey || t.metaKey) && !t.synthetic ? (this.pendingIOSKey = i, setTimeout(() => this.flushIOSKey(e), 250), !0) : !1;
  }
  flushIOSKey(e) {
    let t = this.pendingIOSKey;
    return t ? (this.pendingIOSKey = void 0, Qr(e.contentDOM, t.key, t.keyCode)) : !1;
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : we.safari && Date.now() - this.compositionEndedAt < 500 ? (this.compositionEndedAt = 0, !0) : !1 : !1;
  }
  mustFlushObserver(e) {
    return e.type == "keydown" && e.keyCode != 229 || e.type == "compositionend" && !we.ios;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
const By = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], zy = [16, 17, 18, 20, 91, 92, 224, 225];
class DI {
  constructor(e, t, i, s) {
    this.view = e, this.style = i, this.mustSelect = s, this.lastEvent = t;
    let n = e.contentDOM.ownerDocument;
    n.addEventListener("mousemove", this.move = this.move.bind(this)), n.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet(Re.allowMultipleSelections) && RI(e, t), this.dragMove = II(e, t), this.dragging = QI(e, t) && Ud(t) == 1 ? null : !1, this.dragging === !1 && (t.preventDefault(), this.select(t));
  }
  move(e) {
    if (e.buttons == 0)
      return this.destroy();
    this.dragging === !1 && this.select(this.lastEvent = e);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = null;
  }
  select(e) {
    let t = this.style.get(e, this.extend, this.multiple);
    (this.mustSelect || !t.eq(this.view.state.selection) || t.main.assoc != this.view.state.selection.main.assoc) && this.view.dispatch({
      selection: t,
      userEvent: "select.pointer",
      scrollIntoView: !0
    }), this.mustSelect = !1;
  }
  update(e) {
    e.docChanged && this.dragging && (this.dragging = this.dragging.map(e.changes)), this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function RI(a, e) {
  let t = a.state.facet(_y);
  return t.length ? t[0](e) : we.mac ? e.metaKey : e.ctrlKey;
}
function II(a, e) {
  let t = a.state.facet(Cy);
  return t.length ? t[0](e) : we.mac ? !e.altKey : !e.ctrlKey;
}
function QI(a, e) {
  let { main: t } = a.state.selection;
  if (t.empty)
    return !1;
  let i = Qo(a.root);
  if (i.rangeCount == 0)
    return !0;
  let s = i.getRangeAt(0).getClientRects();
  for (let n = 0; n < s.length; n++) {
    let o = s[n];
    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function zp(a, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target, i; t != a.contentDOM; t = t.parentNode)
    if (!t || t.nodeType == 11 || (i = rt.get(t)) && i.ignoreEvent(e))
      return !1;
  return !0;
}
const kt = /* @__PURE__ */ Object.create(null), Xy = we.ie && we.ie_version < 15 || we.ios && we.webkit_version < 604;
function NI(a) {
  let e = a.dom.parentNode;
  if (!e)
    return;
  let t = e.appendChild(document.createElement("textarea"));
  t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => {
    a.focus(), t.remove(), Yy(a, t.value);
  }, 50);
}
function Yy(a, e) {
  let { state: t } = a, i, s = 1, n = t.toText(e), o = n.lines == t.selection.ranges.length;
  if (Gh != null && t.selection.ranges.every((c) => c.empty) && Gh == n.toString()) {
    let c = -1;
    i = t.changeByRange((d) => {
      let f = t.doc.lineAt(d.from);
      if (f.from == c)
        return { range: d };
      c = f.from;
      let p = t.toText((o ? n.line(s++).text : e) + t.lineBreak);
      return {
        changes: { from: f.from, insert: p },
        range: ee.cursor(d.from + p.length)
      };
    });
  } else
    o ? i = t.changeByRange((c) => {
      let d = n.line(s++);
      return {
        changes: { from: c.from, to: c.to, insert: d.text },
        range: ee.cursor(c.from + d.length)
      };
    }) : i = t.replaceSelection(n);
  a.dispatch(i, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
kt.keydown = (a, e) => {
  a.inputState.setSelectionOrigin("select"), e.keyCode == 27 ? a.inputState.lastEscPress = Date.now() : zy.indexOf(e.keyCode) < 0 && (a.inputState.lastEscPress = 0);
};
let Vy = 0;
kt.touchstart = (a, e) => {
  Vy = Date.now(), a.inputState.setSelectionOrigin("select.pointer");
};
kt.touchmove = (a) => {
  a.inputState.setSelectionOrigin("select.pointer");
};
kt.mousedown = (a, e) => {
  if (a.observer.flush(), Vy > Date.now() - 2e3 && Ud(e) == 1)
    return;
  let t = null;
  for (let i of a.state.facet(Ty))
    if (t = i(a, e), t)
      break;
  if (!t && e.button == 0 && (t = BI(a, e)), t) {
    let i = a.root.activeElement != a.contentDOM;
    i && a.observer.ignore(() => uy(a.contentDOM)), a.inputState.startMouseSelection(new DI(a, e, t, i));
  }
};
function Xp(a, e, t, i) {
  if (i == 1)
    return ee.cursor(e, t);
  if (i == 2)
    return CI(a.state, e, t);
  {
    let s = Bt.find(a.docView, e), n = a.state.doc.lineAt(s ? s.posAtEnd : e), o = s ? s.posAtStart : n.from, l = s ? s.posAtEnd : n.to;
    return l < a.state.doc.length && l == n.to && l++, ee.range(o, l);
  }
}
let Hy = (a, e) => a >= e.top && a <= e.bottom, Yp = (a, e, t) => Hy(e, t) && a >= t.left && a <= t.right;
function FI(a, e, t, i) {
  let s = Bt.find(a.docView, e);
  if (!s)
    return 1;
  let n = e - s.posAtStart;
  if (n == 0)
    return 1;
  if (n == s.length)
    return -1;
  let o = s.coordsAt(n, -1);
  if (o && Yp(t, i, o))
    return -1;
  let l = s.coordsAt(n, 1);
  return l && Yp(t, i, l) ? 1 : o && Hy(i, o) ? -1 : 1;
}
function Vp(a, e) {
  let t = a.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: t, bias: FI(a, t, e.clientX, e.clientY) };
}
const WI = we.ie && we.ie_version <= 11;
let Hp = null, Gp = 0, jp = 0;
function Ud(a) {
  if (!WI)
    return a.detail;
  let e = Hp, t = jp;
  return Hp = a, jp = Date.now(), Gp = !e || t > Date.now() - 400 && Math.abs(e.clientX - a.clientX) < 2 && Math.abs(e.clientY - a.clientY) < 2 ? (Gp + 1) % 3 : 1;
}
function BI(a, e) {
  let t = Vp(a, e), i = Ud(e), s = a.state.selection, n = t, o = e;
  return {
    update(l) {
      l.docChanged && (t && (t.pos = l.changes.mapPos(t.pos)), s = s.map(l.changes), o = null);
    },
    get(l, c, d) {
      let f;
      if (o && l.clientX == o.clientX && l.clientY == o.clientY ? f = n : (f = n = Vp(a, l), o = l), !f || !t)
        return s;
      let p = Xp(a, f.pos, f.bias, i);
      if (t.pos != f.pos && !c) {
        let m = Xp(a, t.pos, t.bias, i), v = Math.min(m.from, p.from), r = Math.max(m.to, p.to);
        p = v < p.from ? ee.range(v, r) : ee.range(r, v);
      }
      return c ? s.replaceRange(s.main.extend(p.from, p.to)) : d ? s.addRange(p) : ee.create([p]);
    }
  };
}
kt.dragstart = (a, e) => {
  let { selection: { main: t } } = a.state, { mouseSelection: i } = a.inputState;
  i && (i.dragging = t), e.dataTransfer && (e.dataTransfer.setData("Text", a.state.sliceDoc(t.from, t.to)), e.dataTransfer.effectAllowed = "copyMove");
};
function Up(a, e, t, i) {
  if (!t)
    return;
  let s = a.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  e.preventDefault();
  let { mouseSelection: n } = a.inputState, o = i && n && n.dragging && n.dragMove ? { from: n.dragging.from, to: n.dragging.to } : null, l = { from: s, insert: t }, c = a.state.changes(o ? [o, l] : l);
  a.focus(), a.dispatch({
    changes: c,
    selection: { anchor: c.mapPos(s, -1), head: c.mapPos(s, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  });
}
kt.drop = (a, e) => {
  if (!e.dataTransfer)
    return;
  if (a.state.readOnly)
    return e.preventDefault();
  let t = e.dataTransfer.files;
  if (t && t.length) {
    e.preventDefault();
    let i = Array(t.length), s = 0, n = () => {
      ++s == t.length && Up(a, e, i.filter((o) => o != null).join(a.state.lineBreak), !1);
    };
    for (let o = 0; o < t.length; o++) {
      let l = new FileReader();
      l.onerror = n, l.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(l.result) || (i[o] = l.result), n();
      }, l.readAsText(t[o]);
    }
  } else
    Up(a, e, e.dataTransfer.getData("Text"), !0);
};
kt.paste = (a, e) => {
  if (a.state.readOnly)
    return e.preventDefault();
  a.observer.flush();
  let t = Xy ? null : e.clipboardData;
  t ? (Yy(a, t.getData("text/plain")), e.preventDefault()) : NI(a);
};
function zI(a, e) {
  let t = a.dom.parentNode;
  if (!t)
    return;
  let i = t.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = e, i.focus(), i.selectionEnd = e.length, i.selectionStart = 0, setTimeout(() => {
    i.remove(), a.focus();
  }, 50);
}
function XI(a) {
  let e = [], t = [], i = !1;
  for (let s of a.selection.ranges)
    s.empty || (e.push(a.sliceDoc(s.from, s.to)), t.push(s));
  if (!e.length) {
    let s = -1;
    for (let { from: n } of a.selection.ranges) {
      let o = a.doc.lineAt(n);
      o.number > s && (e.push(o.text), t.push({ from: o.from, to: Math.min(a.doc.length, o.to + 1) })), s = o.number;
    }
    i = !0;
  }
  return { text: e.join(a.lineBreak), ranges: t, linewise: i };
}
let Gh = null;
kt.copy = kt.cut = (a, e) => {
  let { text: t, ranges: i, linewise: s } = XI(a.state);
  if (!t && !s)
    return;
  Gh = s ? t : null;
  let n = Xy ? null : e.clipboardData;
  n ? (e.preventDefault(), n.clearData(), n.setData("text/plain", t)) : zI(a, t), e.type == "cut" && !a.state.readOnly && a.dispatch({
    changes: i,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
};
kt.focus = kt.blur = (a) => {
  setTimeout(() => {
    a.hasFocus != a.inputState.notifiedFocused && a.update([]);
  }, 10);
};
function Gy(a, e) {
  if (a.docView.compositionDeco.size) {
    a.inputState.rapidCompositionStart = e;
    try {
      a.update([]);
    } finally {
      a.inputState.rapidCompositionStart = !1;
    }
  }
}
kt.compositionstart = kt.compositionupdate = (a) => {
  a.inputState.compositionFirstChange == null && (a.inputState.compositionFirstChange = !0), a.inputState.composing < 0 && (a.inputState.composing = 0, a.docView.compositionDeco.size && (a.observer.flush(), Gy(a, !0)));
};
kt.compositionend = (a) => {
  a.inputState.composing = -1, a.inputState.compositionEndedAt = Date.now(), a.inputState.compositionFirstChange = null, setTimeout(() => {
    a.inputState.composing < 0 && Gy(a, !1);
  }, 50);
};
kt.contextmenu = (a) => {
  a.inputState.lastContextMenu = Date.now();
};
kt.beforeinput = (a, e) => {
  var t;
  let i;
  if (we.chrome && we.android && (i = By.find((s) => s.inputType == e.inputType)) && (a.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
    let s = ((t = window.visualViewport) === null || t === void 0 ? void 0 : t.height) || 0;
    setTimeout(() => {
      var n;
      (((n = window.visualViewport) === null || n === void 0 ? void 0 : n.height) || 0) > s + 10 && a.hasFocus && (a.contentDOM.blur(), a.focus());
    }, 100);
  }
};
const Zp = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class YI {
  constructor() {
    this.doc = We.empty, this.lineWrapping = !1, this.direction = Ne.LTR, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.lineLength = 30, this.heightChanged = !1;
  }
  heightForGap(e, t) {
    let i = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (i += Math.ceil((t - e - i * this.lineLength * 0.5) / this.lineLength)), this.lineHeight * i;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForStyle(e, t) {
    return Zp.indexOf(e) > -1 != this.lineWrapping || this.direction != t;
  }
  mustRefreshForHeights(e) {
    let t = !1;
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      s < 0 ? i++ : this.heightSamples[Math.floor(s * 10)] || (t = !0, this.heightSamples[Math.floor(s * 10)] = !0);
    }
    return t;
  }
  refresh(e, t, i, s, n, o) {
    let l = Zp.indexOf(e) > -1, c = Math.round(i) != Math.round(this.lineHeight) || this.lineWrapping != l || this.direction != t;
    if (this.lineWrapping = l, this.direction = t, this.lineHeight = i, this.charWidth = s, this.lineLength = n, c) {
      this.heightSamples = {};
      for (let d = 0; d < o.length; d++) {
        let f = o[d];
        f < 0 ? d++ : this.heightSamples[Math.floor(f * 10)] = !0;
      }
    }
    return c;
  }
}
class VI {
  constructor(e, t) {
    this.from = e, this.heights = t, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class Ji {
  /**
  @internal
  */
  constructor(e, t, i, s, n) {
    this.from = e, this.length = t, this.top = i, this.height = s, this.type = n;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  @internal
  */
  join(e) {
    let t = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(e.type) ? e.type : [e]);
    return new Ji(this.from, this.length + e.length, this.top, this.height + e.height, t);
  }
  /**
  FIXME remove on next breaking release @internal
  */
  moveY(e) {
    return e ? new Ji(this.from, this.length, this.top + e, this.height, Array.isArray(this.type) ? this.type.map((t) => t.moveY(e)) : this.type) : this;
  }
}
var He = /* @__PURE__ */ function(a) {
  return a[a.ByPos = 0] = "ByPos", a[a.ByHeight = 1] = "ByHeight", a[a.ByPosNoHeight = 2] = "ByPosNoHeight", a;
}(He || (He = {}));
const go = 1e-3;
class jt {
  constructor(e, t, i = 2) {
    this.length = e, this.height = t, this.flags = i;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e, t) {
    this.height != t && (Math.abs(this.height - t) > go && (e.heightChanged = !0), this.height = t);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, t, i) {
    return jt.of(i);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, t) {
    t.push(this);
  }
  decomposeRight(e, t) {
    t.push(this);
  }
  applyChanges(e, t, i, s) {
    let n = this;
    for (let o = s.length - 1; o >= 0; o--) {
      let { fromA: l, toA: c, fromB: d, toB: f } = s[o], p = n.lineAt(l, He.ByPosNoHeight, t, 0, 0), m = p.to >= c ? p : n.lineAt(c, He.ByPosNoHeight, t, 0, 0);
      for (f += m.to - c, c = m.to; o > 0 && p.from <= s[o - 1].toA; )
        l = s[o - 1].fromA, d = s[o - 1].fromB, o--, l < p.from && (p = n.lineAt(l, He.ByPosNoHeight, t, 0, 0));
      d += p.from - l, l = p.from;
      let v = Zd.build(i, e, d, f);
      n = n.replace(l, c, v);
    }
    return n.updateHeight(i, 0);
  }
  static empty() {
    return new Jt(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let t = 0, i = e.length, s = 0, n = 0;
    for (; ; )
      if (t == i)
        if (s > n * 2) {
          let l = e[t - 1];
          l.break ? e.splice(--t, 1, l.left, null, l.right) : e.splice(--t, 1, l.left, l.right), i += 1 + l.break, s -= l.size;
        } else if (n > s * 2) {
          let l = e[i];
          l.break ? e.splice(i, 1, l.left, null, l.right) : e.splice(i, 1, l.left, l.right), i += 2 + l.break, n -= l.size;
        } else
          break;
      else if (s < n) {
        let l = e[t++];
        l && (s += l.size);
      } else {
        let l = e[--i];
        l && (n += l.size);
      }
    let o = 0;
    return e[t - 1] == null ? (o = 1, t--) : e[t] == null && (o = 1, i++), new HI(jt.of(e.slice(0, t)), o, jt.of(e.slice(i)));
  }
}
jt.prototype.size = 1;
class jy extends jt {
  constructor(e, t, i) {
    super(e, t), this.type = i;
  }
  blockAt(e, t, i, s) {
    return new Ji(s, this.length, i, this.height, this.type);
  }
  lineAt(e, t, i, s, n) {
    return this.blockAt(0, i, s, n);
  }
  forEachLine(e, t, i, s, n, o) {
    o(this.blockAt(0, i, s, n));
  }
  updateHeight(e, t = 0, i = !1, s) {
    return s && s.from <= t && s.more && this.setHeight(e, s.heights[s.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class Jt extends jy {
  constructor(e, t) {
    super(e, t, Ye.Text), this.collapsed = 0, this.widgetHeight = 0;
  }
  replace(e, t, i) {
    let s = i[0];
    return i.length == 1 && (s instanceof Jt || s instanceof _t && s.flags & 4) && Math.abs(this.length - s.length) < 10 ? (s instanceof _t ? s = new Jt(s.length, this.height) : s.height = this.height, this.outdated || (s.outdated = !1), s) : jt.of(i);
  }
  updateHeight(e, t = 0, i = !1, s) {
    return s && s.from <= t && s.more ? this.setHeight(e, s.heights[s.index++]) : (i || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed))), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class _t extends jt {
  constructor(e) {
    super(e, 0);
  }
  lines(e, t) {
    let i = e.lineAt(t).number, s = e.lineAt(t + this.length).number;
    return { firstLine: i, lastLine: s, lineHeight: this.height / (s - i + 1) };
  }
  blockAt(e, t, i, s) {
    let { firstLine: n, lastLine: o, lineHeight: l } = this.lines(t, s), c = Math.max(0, Math.min(o - n, Math.floor((e - i) / l))), { from: d, length: f } = t.line(n + c);
    return new Ji(d, f, i + l * c, l, Ye.Text);
  }
  lineAt(e, t, i, s, n) {
    if (t == He.ByHeight)
      return this.blockAt(e, i, s, n);
    if (t == He.ByPosNoHeight) {
      let { from: p, to: m } = i.lineAt(e);
      return new Ji(p, m - p, 0, 0, Ye.Text);
    }
    let { firstLine: o, lineHeight: l } = this.lines(i, n), { from: c, length: d, number: f } = i.lineAt(e);
    return new Ji(c, d, s + l * (f - o), l, Ye.Text);
  }
  forEachLine(e, t, i, s, n, o) {
    let { firstLine: l, lineHeight: c } = this.lines(i, n);
    for (let d = Math.max(e, n), f = Math.min(n + this.length, t); d <= f; ) {
      let p = i.lineAt(d);
      d == e && (s += c * (p.number - l)), o(new Ji(p.from, p.length, s, c, Ye.Text)), s += c, d = p.to + 1;
    }
  }
  replace(e, t, i) {
    let s = this.length - t;
    if (s > 0) {
      let n = i[i.length - 1];
      n instanceof _t ? i[i.length - 1] = new _t(n.length + s) : i.push(null, new _t(s - 1));
    }
    if (e > 0) {
      let n = i[0];
      n instanceof _t ? i[0] = new _t(e + n.length) : i.unshift(new _t(e - 1), null);
    }
    return jt.of(i);
  }
  decomposeLeft(e, t) {
    t.push(new _t(e - 1), null);
  }
  decomposeRight(e, t) {
    t.push(null, new _t(this.length - e - 1));
  }
  updateHeight(e, t = 0, i = !1, s) {
    let n = t + this.length;
    if (s && s.from <= t + this.length && s.more) {
      let o = [], l = Math.max(t, s.from), c = -1, d = e.heightChanged;
      for (s.from > t && o.push(new _t(s.from - t - 1).updateHeight(e, t)); l <= n && s.more; ) {
        let p = e.doc.lineAt(l).length;
        o.length && o.push(null);
        let m = s.heights[s.index++];
        c == -1 ? c = m : Math.abs(m - c) >= go && (c = -2);
        let v = new Jt(p, m);
        v.outdated = !1, o.push(v), l += p + 1;
      }
      l <= n && o.push(null, new _t(n - l).updateHeight(e, l));
      let f = jt.of(o);
      return e.heightChanged = d || c < 0 || Math.abs(f.height - this.height) >= go || Math.abs(c - this.lines(e.doc, t).lineHeight) >= go, f;
    } else
      (i || this.outdated) && (this.setHeight(e, e.heightForGap(t, t + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class HI extends jt {
  constructor(e, t, i) {
    super(e.length + t + i.length, e.height + i.height, t | (e.outdated || i.outdated ? 2 : 0)), this.left = e, this.right = i, this.size = e.size + i.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, t, i, s) {
    let n = i + this.left.height;
    return e < n ? this.left.blockAt(e, t, i, s) : this.right.blockAt(e, t, n, s + this.left.length + this.break);
  }
  lineAt(e, t, i, s, n) {
    let o = s + this.left.height, l = n + this.left.length + this.break, c = t == He.ByHeight ? e < o : e < l, d = c ? this.left.lineAt(e, t, i, s, n) : this.right.lineAt(e, t, i, o, l);
    if (this.break || (c ? d.to < l : d.from > l))
      return d;
    let f = t == He.ByPosNoHeight ? He.ByPosNoHeight : He.ByPos;
    return c ? d.join(this.right.lineAt(l, f, i, o, l)) : this.left.lineAt(l, f, i, s, n).join(d);
  }
  forEachLine(e, t, i, s, n, o) {
    let l = s + this.left.height, c = n + this.left.length + this.break;
    if (this.break)
      e < c && this.left.forEachLine(e, t, i, s, n, o), t >= c && this.right.forEachLine(e, t, i, l, c, o);
    else {
      let d = this.lineAt(c, He.ByPos, i, s, n);
      e < d.from && this.left.forEachLine(e, d.from - 1, i, s, n, o), d.to >= e && d.from <= t && o(d), t > d.to && this.right.forEachLine(d.to + 1, t, i, l, c, o);
    }
  }
  replace(e, t, i) {
    let s = this.left.length + this.break;
    if (t < s)
      return this.balanced(this.left.replace(e, t, i), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - s, t - s, i));
    let n = [];
    e > 0 && this.decomposeLeft(e, n);
    let o = n.length;
    for (let l of i)
      n.push(l);
    if (e > 0 && qp(n, o - 1), t < this.length) {
      let l = n.length;
      this.decomposeRight(t, n), qp(n, l);
    }
    return jt.of(n);
  }
  decomposeLeft(e, t) {
    let i = this.left.length;
    if (e <= i)
      return this.left.decomposeLeft(e, t);
    t.push(this.left), this.break && (i++, e >= i && t.push(null)), e > i && this.right.decomposeLeft(e - i, t);
  }
  decomposeRight(e, t) {
    let i = this.left.length, s = i + this.break;
    if (e >= s)
      return this.right.decomposeRight(e - s, t);
    e < i && this.left.decomposeRight(e, t), this.break && e < s && t.push(null), t.push(this.right);
  }
  balanced(e, t) {
    return e.size > 2 * t.size || t.size > 2 * e.size ? jt.of(this.break ? [e, null, t] : [e, t]) : (this.left = e, this.right = t, this.height = e.height + t.height, this.outdated = e.outdated || t.outdated, this.size = e.size + t.size, this.length = e.length + this.break + t.length, this);
  }
  updateHeight(e, t = 0, i = !1, s) {
    let { left: n, right: o } = this, l = t + n.length + this.break, c = null;
    return s && s.from <= t + n.length && s.more ? c = n = n.updateHeight(e, t, i, s) : n.updateHeight(e, t, i), s && s.from <= l + o.length && s.more ? c = o = o.updateHeight(e, l, i, s) : o.updateHeight(e, l, i), c ? this.balanced(n, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function qp(a, e) {
  let t, i;
  a[e] == null && (t = a[e - 1]) instanceof _t && (i = a[e + 1]) instanceof _t && a.splice(e - 1, 3, new _t(t.length + 1 + i.length));
}
const GI = 5;
class Zd {
  constructor(e, t) {
    this.pos = e, this.oracle = t, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, t) {
    if (this.lineStart > -1) {
      let i = Math.min(t, this.lineEnd), s = this.nodes[this.nodes.length - 1];
      s instanceof Jt ? s.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new Jt(i - this.pos, -1)), this.writtenTo = i, t > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = t;
  }
  point(e, t, i) {
    if (e < t || i.heightRelevant) {
      let s = i.widget ? i.widget.estimatedHeight : 0;
      s < 0 && (s = this.oracle.lineHeight);
      let n = t - e;
      i.block ? this.addBlock(new jy(n, s, i.type)) : (n || s >= GI) && this.addLineDeco(s, n);
    } else
      t > e && this.span(e, t);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: t } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = t, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new Jt(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, t) {
    let i = new _t(t - e);
    return this.oracle.doc.lineAt(e).to == t && (i.flags |= 4), i;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof Jt)
      return e;
    let t = new Jt(0, -1);
    return this.nodes.push(t), t;
  }
  addBlock(e) {
    this.enterLine(), e.type == Ye.WidgetAfter && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, e.type != Ye.WidgetBefore && (this.covering = e);
  }
  addLineDeco(e, t) {
    let i = this.ensureLine();
    i.length += t, i.collapsed += t, i.widgetHeight = Math.max(i.widgetHeight, e), this.writtenTo = this.pos = this.pos + t;
  }
  finish(e) {
    let t = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(t instanceof Jt) && !this.isCovered ? this.nodes.push(new Jt(0, -1)) : (this.writtenTo < this.pos || t == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let i = e;
    for (let s of this.nodes)
      s instanceof Jt && s.updateHeight(this.oracle, i), i += s ? s.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, t, i, s) {
    let n = new Zd(i, e);
    return ze.spans(t, i, s, n, 0), n.finish(i);
  }
}
function jI(a, e, t) {
  let i = new UI();
  return ze.compare(a, e, t, i, 0), i.changes;
}
class UI {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, t, i, s) {
    (e < t || i && i.heightRelevant || s && s.heightRelevant) && Bh(e, t, this.changes, 5);
  }
}
function ZI(a, e) {
  let t = a.getBoundingClientRect(), i = Math.max(0, t.left), s = Math.min(innerWidth, t.right), n = Math.max(0, t.top), o = Math.min(innerHeight, t.bottom), l = a.ownerDocument.body;
  for (let c = a.parentNode; c && c != l; )
    if (c.nodeType == 1) {
      let d = c, f = window.getComputedStyle(d);
      if ((d.scrollHeight > d.clientHeight || d.scrollWidth > d.clientWidth) && f.overflow != "visible") {
        let p = d.getBoundingClientRect();
        i = Math.max(i, p.left), s = Math.min(s, p.right), n = Math.max(n, p.top), o = Math.min(o, p.bottom);
      }
      c = f.position == "absolute" || f.position == "fixed" ? d.offsetParent : d.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: i - t.left,
    right: Math.max(i, s) - t.left,
    top: n - (t.top + e),
    bottom: Math.max(n, o) - (t.top + e)
  };
}
function qI(a, e) {
  let t = a.getBoundingClientRect();
  return {
    left: 0,
    right: t.right - t.left,
    top: e,
    bottom: t.bottom - (t.top + e)
  };
}
class Cc {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.size = i;
  }
  static same(e, t) {
    if (e.length != t.length)
      return !1;
    for (let i = 0; i < e.length; i++) {
      let s = e[i], n = t[i];
      if (s.from != n.from || s.to != n.to || s.size != n.size)
        return !1;
    }
    return !0;
  }
  draw(e) {
    return me.replace({ widget: new KI(this.size, e) }).range(this.from, this.to);
  }
}
class KI extends hs {
  constructor(e, t) {
    super(), this.size = e, this.vertical = t;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class Kp {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.heightOracle = new YI(), this.scaler = tg, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1, this.heightMap = jt.empty().applyChanges(e.facet(qs), We.empty, this.heightOracle.setDoc(e.doc), [new is(0, 0, 0, e.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = me.set(this.lineGaps.map((t) => t.draw(!1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: t } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let s = i ? t.head : t.anchor;
      if (!e.some(({ from: n, to: o }) => s >= n && s <= o)) {
        let { from: n, to: o } = this.lineBlockAt(s);
        e.push(new Za(n, o));
      }
    }
    this.viewports = e.sort((i, s) => i.from - s.from), this.scaler = this.heightMap.height <= 7e6 ? tg : new tQ(this.heightOracle.doc, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, (e) => {
      this.viewportLines.push(this.scaler.scale == 1 ? e : Cr(e, this.scaler));
    });
  }
  update(e, t = null) {
    let i = this.state;
    this.state = e.state;
    let s = this.state.facet(qs), n = e.changedRanges, o = is.extendWithRanges(n, jI(e.startState.facet(qs), s, e ? e.changes : xt.empty(this.state.doc.length))), l = this.heightMap.height;
    this.heightMap = this.heightMap.applyChanges(s, i.doc, this.heightOracle.setDoc(this.state.doc), o), this.heightMap.height != l && (e.flags |= 2);
    let c = o.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (t && (t.range.head < c.from || t.range.head > c.to) || !this.viewportIsAppropriate(c)) && (c = this.getViewport(0, t));
    let d = !e.changes.empty || e.flags & 2 || c.from != this.viewport.from || c.to != this.viewport.to;
    this.viewport = c, this.updateForViewport(), d && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), t && (this.scrollTarget = t), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let t = e.contentDOM, i = window.getComputedStyle(t), s = this.heightOracle, n = i.whiteSpace, o = i.direction == "rtl" ? Ne.RTL : Ne.LTR, l = this.heightOracle.mustRefreshForStyle(n, o), c = l || this.mustMeasureContent || this.contentDOMHeight != t.clientHeight, d = 0, f = 0;
    if (this.editorWidth != e.scrollDOM.clientWidth && (s.lineWrapping && (c = !0), this.editorWidth = e.scrollDOM.clientWidth, d |= 8), c) {
      this.mustMeasureContent = !1, this.contentDOMHeight = t.clientHeight;
      let g = parseInt(i.paddingTop) || 0, b = parseInt(i.paddingBottom) || 0;
      (this.paddingTop != g || this.paddingBottom != b) && (d |= 8, this.paddingTop = g, this.paddingBottom = b);
    }
    let p = (this.printing ? qI : ZI)(t, this.paddingTop), m = p.top - this.pixelViewport.top, v = p.bottom - this.pixelViewport.bottom;
    this.pixelViewport = p;
    let r = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (r != this.inView && (this.inView = r, r && (c = !0)), !this.inView)
      return 0;
    let h = t.clientWidth;
    if ((this.contentDOMWidth != h || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = h, this.editorHeight = e.scrollDOM.clientHeight, d |= 8), c) {
      let g = e.docView.measureVisibleLineHeights();
      if (s.mustRefreshForHeights(g) && (l = !0), l || s.lineWrapping && Math.abs(h - this.contentDOMWidth) > s.charWidth) {
        let { lineHeight: b, charWidth: O } = e.docView.measureTextSize();
        l = s.refresh(n, o, b, O, h / O, g), l && (e.docView.minWidth = 0, d |= 8);
      }
      m > 0 && v > 0 ? f = Math.max(m, v) : m < 0 && v < 0 && (f = Math.min(m, v)), s.heightChanged = !1, this.heightMap = this.heightMap.updateHeight(s, 0, l, new VI(this.viewport.from, g)), s.heightChanged && (d |= 2);
    }
    let u = !this.viewportIsAppropriate(this.viewport, f) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return u && (this.viewport = this.getViewport(f, this.scrollTarget)), this.updateForViewport(), (d & 2 || u) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(l ? [] : this.lineGaps)), d |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), d;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, t) {
    let i = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), s = this.heightMap, n = this.state.doc, { visibleTop: o, visibleBottom: l } = this, c = new Za(s.lineAt(o - i * 1e3, He.ByHeight, n, 0, 0).from, s.lineAt(l + (1 - i) * 1e3, He.ByHeight, n, 0, 0).to);
    if (t) {
      let { head: d } = t.range;
      if (d < c.from || d > c.to) {
        let f = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), p = s.lineAt(d, He.ByPos, n, 0, 0), m;
        t.y == "center" ? m = (p.top + p.bottom) / 2 - f / 2 : t.y == "start" || t.y == "nearest" && d < c.from ? m = p.top : m = p.bottom - f, c = new Za(s.lineAt(m - 1e3 / 2, He.ByHeight, n, 0, 0).from, s.lineAt(m + f + 1e3 / 2, He.ByHeight, n, 0, 0).to);
      }
    }
    return c;
  }
  mapViewport(e, t) {
    let i = t.mapPos(e.from, -1), s = t.mapPos(e.to, 1);
    return new Za(this.heightMap.lineAt(i, He.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(s, He.ByPos, this.state.doc, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: t }, i = 0) {
    if (!this.inView)
      return !0;
    let { top: s } = this.heightMap.lineAt(e, He.ByPos, this.state.doc, 0, 0), { bottom: n } = this.heightMap.lineAt(t, He.ByPos, this.state.doc, 0, 0), { visibleTop: o, visibleBottom: l } = this;
    return (e == 0 || s <= o - Math.max(10, Math.min(
      -i,
      250
      /* MaxCoverMargin */
    ))) && (t == this.state.doc.length || n >= l + Math.max(10, Math.min(
      i,
      250
      /* MaxCoverMargin */
    ))) && s > o - 2 * 1e3 && n < l + 2 * 1e3;
  }
  mapLineGaps(e, t) {
    if (!e.length || t.empty)
      return e;
    let i = [];
    for (let s of e)
      t.touchesRange(s.from, s.to) || i.push(new Cc(t.mapPos(s.from), t.mapPos(s.to), s.size));
    return i;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e) {
    let t = [];
    if (this.heightOracle.direction != Ne.LTR)
      return t;
    for (let i of this.viewportLines) {
      if (i.length < 4e3)
        continue;
      let s = JI(i.from, i.to, this.state);
      if (s.total < 4e3)
        continue;
      let n, o;
      if (this.heightOracle.lineWrapping) {
        let d = 2e3 / this.heightOracle.lineLength * this.heightOracle.lineHeight;
        n = qa(s, (this.visibleTop - i.top - d) / i.height), o = qa(s, (this.visibleBottom - i.top + d) / i.height);
      } else {
        let d = s.total * this.heightOracle.charWidth, f = 2e3 * this.heightOracle.charWidth;
        n = qa(s, (this.pixelViewport.left - f) / d), o = qa(s, (this.pixelViewport.right + f) / d);
      }
      let l = [];
      n > i.from && l.push({ from: i.from, to: n }), o < i.to && l.push({ from: o, to: i.to });
      let c = this.state.selection.main;
      c.from >= i.from && c.from <= i.to && eg(
        l,
        c.from - 10,
        c.from + 10
        /* SelectionMargin */
      ), !c.empty && c.to >= i.from && c.to <= i.to && eg(
        l,
        c.to - 10,
        c.to + 10
        /* SelectionMargin */
      );
      for (let { from: d, to: f } of l)
        f - d > 1e3 && t.push(eQ(
          e,
          (p) => p.from >= i.from && p.to <= i.to && Math.abs(p.from - d) < 1e3 && Math.abs(p.to - f) < 1e3
          /* HalfMargin */
        ) || new Cc(d, f, this.gapSize(i, d, f, s)));
    }
    return t;
  }
  gapSize(e, t, i, s) {
    let n = Jp(s, i) - Jp(s, t);
    return this.heightOracle.lineWrapping ? e.height * n : s.total * this.heightOracle.charWidth * n;
  }
  updateLineGaps(e) {
    Cc.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = me.set(e.map((t) => t.draw(this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.state.facet(qs);
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let t = [];
    ze.spans(e, this.viewport.from, this.viewport.to, {
      span(s, n) {
        t.push({ from: s, to: n });
      },
      point() {
      }
    }, 20);
    let i = t.length != this.visibleRanges.length || this.visibleRanges.some((s, n) => s.from != t[n].from || s.to != t[n].to);
    return this.visibleRanges = t, i ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((t) => t.from <= e && t.to >= e) || Cr(this.heightMap.lineAt(e, He.ByPos, this.state.doc, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return Cr(this.heightMap.lineAt(this.scaler.fromDOM(e), He.ByHeight, this.state.doc, 0, 0), this.scaler);
  }
  elementAtHeight(e) {
    return Cr(this.heightMap.blockAt(this.scaler.fromDOM(e), this.state.doc, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Za {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
function JI(a, e, t) {
  let i = [], s = a, n = 0;
  return ze.spans(t.facet(qs), a, e, {
    span() {
    },
    point(o, l) {
      o > s && (i.push({ from: s, to: o }), n += o - s), s = l;
    }
  }, 20), s < e && (i.push({ from: s, to: e }), n += e - s), { total: n, ranges: i };
}
function qa({ total: a, ranges: e }, t) {
  if (t <= 0)
    return e[0].from;
  if (t >= 1)
    return e[e.length - 1].to;
  let i = Math.floor(a * t);
  for (let s = 0; ; s++) {
    let { from: n, to: o } = e[s], l = o - n;
    if (i <= l)
      return n + i;
    i -= l;
  }
}
function Jp(a, e) {
  let t = 0;
  for (let { from: i, to: s } of a.ranges) {
    if (e <= s) {
      t += e - i;
      break;
    }
    t += s - i;
  }
  return t / a.total;
}
function eg(a, e, t) {
  for (let i = 0; i < a.length; i++) {
    let s = a[i];
    if (s.from < t && s.to > e) {
      let n = [];
      s.from < e && n.push({ from: s.from, to: e }), s.to > t && n.push({ from: t, to: s.to }), a.splice(i, 1, ...n), i += n.length - 1;
    }
  }
}
function eQ(a, e) {
  for (let t of a)
    if (e(t))
      return t;
}
const tg = {
  toDOM(a) {
    return a;
  },
  fromDOM(a) {
    return a;
  },
  scale: 1
};
class tQ {
  constructor(e, t, i) {
    let s = 0, n = 0, o = 0;
    this.viewports = i.map(({ from: l, to: c }) => {
      let d = t.lineAt(l, He.ByPos, e, 0, 0).top, f = t.lineAt(c, He.ByPos, e, 0, 0).bottom;
      return s += f - d, { from: l, to: c, top: d, bottom: f, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - s) / (t.height - s);
    for (let l of this.viewports)
      l.domTop = o + (l.top - n) * this.scale, o = l.domBottom = l.domTop + (l.bottom - l.top), n = l.bottom;
  }
  toDOM(e) {
    for (let t = 0, i = 0, s = 0; ; t++) {
      let n = t < this.viewports.length ? this.viewports[t] : null;
      if (!n || e < n.top)
        return s + (e - i) * this.scale;
      if (e <= n.bottom)
        return n.domTop + (e - n.top);
      i = n.bottom, s = n.domBottom;
    }
  }
  fromDOM(e) {
    for (let t = 0, i = 0, s = 0; ; t++) {
      let n = t < this.viewports.length ? this.viewports[t] : null;
      if (!n || e < n.domTop)
        return i + (e - s) / this.scale;
      if (e <= n.domBottom)
        return n.top + (e - n.domTop);
      i = n.bottom, s = n.domBottom;
    }
  }
}
function Cr(a, e) {
  if (e.scale == 1)
    return a;
  let t = e.toDOM(a.top), i = e.toDOM(a.bottom);
  return new Ji(a.from, a.length, t, i - t, Array.isArray(a.type) ? a.type.map((s) => Cr(s, e)) : a.type);
}
const Ka = /* @__PURE__ */ be.define({ combine: (a) => a.join(" ") }), jh = /* @__PURE__ */ be.define({ combine: (a) => a.indexOf(!0) > -1 }), Uh = /* @__PURE__ */ Ps.newName(), Uy = /* @__PURE__ */ Ps.newName(), Zy = /* @__PURE__ */ Ps.newName(), qy = { "&light": "." + Uy, "&dark": "." + Zy };
function Zh(a, e, t) {
  return new Ps(e, {
    finish(i) {
      return /&/.test(i) ? i.replace(/&\w*/, (s) => {
        if (s == "&")
          return a;
        if (!t || !t[s])
          throw new RangeError(`Unsupported selector: ${s}`);
        return t[s];
      }) : a + " " + i;
    }
  });
}
const iQ = /* @__PURE__ */ Zh("." + Uh, {
  "&.cm-editor": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    minHeight: "100%",
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    boxSizing: "border-box",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    overflowWrap: "anywhere"
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 4px"
  },
  ".cm-selectionLayer": {
    zIndex: -1,
    contain: "size style"
  },
  ".cm-selectionBackground": {
    position: "absolute"
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    zIndex: 100,
    contain: "size style",
    pointerEvents: "none"
  },
  "&.cm-focused .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { visibility: "hidden" }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { visibility: "hidden" }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    position: "absolute",
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  "&.cm-focused .cm-cursor": {
    display: "block"
  },
  "&light .cm-activeLine": { backgroundColor: "#f3f9ff" },
  "&dark .cm-activeLine": { backgroundColor: "#223039" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, qy), sQ = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, Tc = we.ie && we.ie_version <= 11;
class nQ {
  constructor(e, t, i) {
    this.view = e, this.onChange = t, this.onScrollChanged = i, this.active = !1, this.selectionRange = new nI(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.scrollTargets = [], this.intersection = null, this.resize = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((s) => {
      for (let n of s)
        this.queue.push(n);
      (we.ie && we.ie_version <= 11 || we.ios && e.composing) && s.some((n) => n.type == "childList" && n.removedNodes.length || n.type == "characterData" && n.oldValue.length > n.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), Tc && (this.onCharData = (s) => {
      this.queue.push({
        target: s.target,
        type: "characterData",
        oldValue: s.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), window.addEventListener("resize", this.onResize = this.onResize.bind(this)), typeof ResizeObserver == "function" && (this.resize = new ResizeObserver(() => {
      this.view.docView.lastUpdate < Date.now() - 75 && this.onResize();
    }), this.resize.observe(e.scrollDOM)), window.addEventListener("beforeprint", this.onPrint = this.onPrint.bind(this)), this.start(), window.addEventListener("scroll", this.onScroll = this.onScroll.bind(this)), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((s) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), s.length > 0 && s[s.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, {}), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((s) => {
      s.length > 0 && s[s.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange(), this.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint() {
    this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500);
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((t, i) => t != e[i]))) {
      this.gapIntersection.disconnect();
      for (let t of e)
        this.gapIntersection.observe(t);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: t } = this, i = this.selectionRange;
    if (t.state.facet(Ca) ? t.root.activeElement != this.dom : !Lh(t.dom, i))
      return;
    let s = i.anchorNode && t.docView.nearest(i.anchorNode);
    s && s.ignoreEvent(e) || ((we.ie && we.ie_version <= 11 || we.android && we.chrome) && !t.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    i.focusNode && No(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1));
  }
  readSelectionRange() {
    let { root: e } = this.view, t = Qo(e), i = we.safari && e.nodeType == 11 && tI() == this.view.contentDOM && rQ(this.view) || t;
    return this.selectionRange.eq(i) ? !1 : (this.selectionRange.setRange(i), this.selectionChanged = !0);
  }
  setSelectionRange(e, t) {
    this.selectionRange.set(e.node, e.offset, t.node, t.offset), this.selectionChanged = !1;
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, t = null;
    for (let i = this.dom; i; )
      if (i.nodeType == 1)
        !t && e < this.scrollTargets.length && this.scrollTargets[e] == i ? e++ : t || (t = this.scrollTargets.slice(0, e)), t && t.push(i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    if (e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)), t) {
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      for (let i of this.scrollTargets = t)
        i.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, sQ), Tc && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), Tc && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then dispatches the
  // key event, throwing away the DOM changes if it gets handled.
  delayAndroidKey(e, t) {
    this.delayedAndroidKey || requestAnimationFrame(() => {
      let i = this.delayedAndroidKey;
      this.delayedAndroidKey = null;
      let s = this.view.state;
      Qr(this.view.contentDOM, i.key, i.keyCode) ? this.processRecords() : this.flush(), this.view.state == s && this.view.update([]);
    }), (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = { key: e, keyCode: t });
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = window.setTimeout(() => {
      this.delayedFlush = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (window.clearTimeout(this.delayedFlush), this.delayedFlush = -1, this.flush());
  }
  processRecords() {
    let e = this.queue;
    for (let n of this.observer.takeRecords())
      e.push(n);
    e.length && (this.queue = []);
    let t = -1, i = -1, s = !1;
    for (let n of e) {
      let o = this.readMutation(n);
      o && (o.typeOver && (s = !0), t == -1 ? { from: t, to: i } = o : (t = Math.min(o.from, t), i = Math.max(o.to, i)));
    }
    return { from: t, to: i, typeOver: s };
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return;
    e && this.readSelectionRange();
    let { from: t, to: i, typeOver: s } = this.processRecords(), n = this.selectionChanged && Lh(this.dom, this.selectionRange);
    if (t < 0 && !n)
      return;
    this.selectionChanged = !1;
    let o = this.view.state;
    this.onChange(t, i, s), this.view.state == o && this.view.update([]);
  }
  readMutation(e) {
    let t = this.view.docView.nearest(e.target);
    if (!t || t.ignoreMutation(e))
      return null;
    if (t.markDirty(e.type == "attributes"), e.type == "attributes" && (t.dirty |= 4), e.type == "childList") {
      let i = ig(t, e.previousSibling || e.target.previousSibling, -1), s = ig(t, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: i ? t.posAfter(i) : t.posAtStart,
        to: s ? t.posBefore(s) : t.posAtEnd,
        typeOver: !1
      };
    } else
      return e.type == "characterData" ? { from: t.posAtStart, to: t.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  destroy() {
    var e, t, i;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (t = this.gapIntersection) === null || t === void 0 || t.disconnect(), (i = this.resize) === null || i === void 0 || i.disconnect();
    for (let s of this.scrollTargets)
      s.removeEventListener("scroll", this.onScroll);
    window.removeEventListener("scroll", this.onScroll), window.removeEventListener("resize", this.onResize), window.removeEventListener("beforeprint", this.onPrint), this.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout);
  }
}
function ig(a, e, t) {
  for (; e; ) {
    let i = rt.get(e);
    if (i && i.parent == a)
      return i;
    let s = e.parentNode;
    e = s != a.dom ? s : t > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function rQ(a) {
  let e = null;
  function t(c) {
    c.preventDefault(), c.stopImmediatePropagation(), e = c.getTargetRanges()[0];
  }
  if (a.contentDOM.addEventListener("beforeinput", t, !0), document.execCommand("indent"), a.contentDOM.removeEventListener("beforeinput", t, !0), !e)
    return null;
  let i = e.startContainer, s = e.startOffset, n = e.endContainer, o = e.endOffset, l = a.docView.domAtPos(a.state.selection.main.anchor);
  return No(l.node, l.offset, n, o) && ([i, s, n, o] = [n, o, i, s]), { anchorNode: i, anchorOffset: s, focusNode: n, focusOffset: o };
}
function aQ(a, e, t, i) {
  let s, n, o = a.state.selection.main;
  if (e > -1) {
    let l = a.docView.domBoundsAround(e, t, 0);
    if (!l || a.state.readOnly)
      return;
    let { from: c, to: d } = l, f = a.docView.impreciseHead || a.docView.impreciseAnchor ? [] : lQ(a), p = new Qy(f, a.state);
    p.readRange(l.startDOM, l.endDOM);
    let m = o.from, v = null;
    (a.inputState.lastKeyCode === 8 && a.inputState.lastKeyTime > Date.now() - 100 || we.android && p.text.length < d - c) && (m = o.to, v = "end");
    let r = oQ(a.state.doc.sliceString(c, d, Cs), p.text, m - c, v);
    r && (we.chrome && a.inputState.lastKeyCode == 13 && r.toB == r.from + 2 && p.text.slice(r.from, r.toB) == Cs + Cs && r.toB--, s = {
      from: c + r.from,
      to: c + r.toA,
      insert: We.of(p.text.slice(r.from, r.toB).split(Cs))
    }), n = cQ(f, c);
  } else if (a.hasFocus || !a.state.facet(Ca)) {
    let l = a.observer.selectionRange, { impreciseHead: c, impreciseAnchor: d } = a.docView, f = c && c.node == l.focusNode && c.offset == l.focusOffset || !Hn(a.contentDOM, l.focusNode) ? a.state.selection.main.head : a.docView.posFromDOM(l.focusNode, l.focusOffset), p = d && d.node == l.anchorNode && d.offset == l.anchorOffset || !Hn(a.contentDOM, l.anchorNode) ? a.state.selection.main.anchor : a.docView.posFromDOM(l.anchorNode, l.anchorOffset);
    (f != o.head || p != o.anchor) && (n = ee.single(p, f));
  }
  if (!(!s && !n)) {
    if (!s && i && !o.empty && n && n.main.empty ? s = { from: o.from, to: o.to, insert: a.state.doc.slice(o.from, o.to) } : s && s.from >= o.from && s.to <= o.to && (s.from != o.from || s.to != o.to) && o.to - o.from - (s.to - s.from) <= 4 && (s = {
      from: o.from,
      to: o.to,
      insert: a.state.doc.slice(o.from, s.from).append(s.insert).append(a.state.doc.slice(s.to, o.to))
    }), s) {
      let l = a.state;
      if (we.ios && a.inputState.flushIOSKey(a) || we.android && (s.from == o.from && s.to == o.to && s.insert.length == 1 && s.insert.lines == 2 && Qr(a.contentDOM, "Enter", 13) || s.from == o.from - 1 && s.to == o.to && s.insert.length == 0 && Qr(a.contentDOM, "Backspace", 8) || s.from == o.from && s.to == o.to + 1 && s.insert.length == 0 && Qr(a.contentDOM, "Delete", 46)))
        return;
      let c = s.insert.toString();
      if (a.state.facet($y).some((p) => p(a, s.from, s.to, c)))
        return;
      a.inputState.composing >= 0 && a.inputState.composing++;
      let d;
      if (s.from >= o.from && s.to <= o.to && s.to - s.from >= (o.to - o.from) / 3 && (!n || n.main.empty && n.main.from == s.from + s.insert.length) && a.inputState.composing < 0) {
        let p = o.from < s.from ? l.sliceDoc(o.from, s.from) : "", m = o.to > s.to ? l.sliceDoc(s.to, o.to) : "";
        d = l.replaceSelection(a.state.toText(p + s.insert.sliceString(0, void 0, a.state.lineBreak) + m));
      } else {
        let p = l.changes(s), m = n && !l.selection.main.eq(n.main) && n.main.to <= p.newLength ? n.main : void 0;
        if (l.selection.ranges.length > 1 && a.inputState.composing >= 0 && s.to <= o.to && s.to >= o.to - 10) {
          let v = a.state.sliceDoc(s.from, s.to), r = Ny(a) || a.state.doc.lineAt(o.head), h = o.to - s.to, u = o.to - o.from;
          d = l.changeByRange((g) => {
            if (g.from == o.from && g.to == o.to)
              return { changes: p, range: m || g.map(p) };
            let b = g.to - h, O = b - v.length;
            if (g.to - g.from != u || a.state.sliceDoc(O, b) != v || // Unfortunately, there's no way to make multiple
            // changes in the same node work without aborting
            // composition, so cursors in the composition range are
            // ignored.
            r && g.to >= r.from && g.from <= r.to)
              return { range: g };
            let x = l.changes({ from: O, to: b, insert: s.insert }), S = g.to - o.to;
            return {
              changes: x,
              range: m ? ee.range(Math.max(0, m.anchor + S), Math.max(0, m.head + S)) : g.map(x)
            };
          });
        } else
          d = {
            changes: p,
            selection: m && l.selection.replaceRange(m)
          };
      }
      let f = "input.type";
      a.composing && (f += ".compose", a.inputState.compositionFirstChange && (f += ".start", a.inputState.compositionFirstChange = !1)), a.dispatch(d, { scrollIntoView: !0, userEvent: f });
    } else if (n && !n.main.eq(o)) {
      let l = !1, c = "select";
      a.inputState.lastSelectionTime > Date.now() - 50 && (a.inputState.lastSelectionOrigin == "select" && (l = !0), c = a.inputState.lastSelectionOrigin), a.dispatch({ selection: n, scrollIntoView: l, userEvent: c });
    }
  }
}
function oQ(a, e, t, i) {
  let s = Math.min(a.length, e.length), n = 0;
  for (; n < s && a.charCodeAt(n) == e.charCodeAt(n); )
    n++;
  if (n == s && a.length == e.length)
    return null;
  let o = a.length, l = e.length;
  for (; o > 0 && l > 0 && a.charCodeAt(o - 1) == e.charCodeAt(l - 1); )
    o--, l--;
  if (i == "end") {
    let c = Math.max(0, n - Math.min(o, l));
    t -= o + c - n;
  }
  if (o < n && a.length < e.length) {
    let c = t <= n && t >= o ? n - t : 0;
    n -= c, l = n + (l - o), o = n;
  } else if (l < n) {
    let c = t <= n && t >= l ? n - t : 0;
    n -= c, o = n + (o - l), l = n;
  }
  return { from: n, toA: o, toB: l };
}
function lQ(a) {
  let e = [];
  if (a.root.activeElement != a.contentDOM)
    return e;
  let { anchorNode: t, anchorOffset: i, focusNode: s, focusOffset: n } = a.observer.selectionRange;
  return t && (e.push(new Dp(t, i)), (s != t || n != i) && e.push(new Dp(s, n))), e;
}
function cQ(a, e) {
  if (a.length == 0)
    return null;
  let t = a[0].pos, i = a.length == 2 ? a[1].pos : t;
  return t > -1 && i > -1 ? ee.single(t + e, i + e) : null;
}
class Oe {
  /**
  Construct a new view. You'll usually want to put `view.dom` into
  your document after creating a view, so that the user can see
  it.
  */
  constructor(e = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.style.cssText = "position: absolute; top: -10000px", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), this._dispatch = e.dispatch || ((t) => this.update([t])), this.dispatch = this.dispatch.bind(this), this.root = e.root || rI(e.parent) || document, this.viewState = new Kp(e.state || Re.create()), this.plugins = this.state.facet(kr).map((t) => new Sc(t));
    for (let t of this.plugins)
      t.update(this);
    this.observer = new nQ(this, (t, i, s) => {
      aQ(this, t, i, s);
    }, (t) => {
      this.inputState.runScrollHandlers(this, t), this.observer.intersecting && this.measure();
    }), this.inputState = new MI(this), this.docView = new Rp(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), e.parent && e.parent.appendChild(this.dom);
  }
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  dispatch(...e) {
    this._dispatch(e.length == 1 && e[0] instanceof St ? e[0] : this.state.update(...e));
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let t = !1, i, s = this.state;
    for (let o of e) {
      if (o.startState != s)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = o.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    if (s.facet(Re.phrases) != this.state.facet(Re.phrases))
      return this.setState(s);
    i = new Lp(this, s, e);
    let n = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let o of e) {
        if (n && (n = n.map(o.changes)), o.scrollIntoView) {
          let { main: l } = o.state.selection;
          n = new Pn(l.empty ? l : ee.cursor(l.head, l.head > l.anchor ? -1 : 1));
        }
        for (let l of o.effects)
          l.is(Xh) ? n = new Pn(l.value) : l.is(Ey) ? n = new Pn(l.value, "center") : l.is(Pp) && (n = l.value);
      }
      this.viewState.update(i, n), this.bidiCache = Wo.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), t = this.docView.update(i), this.state.facet(_r) != this.styleModules && this.mountStyles(), this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(t, e.some((o) => o.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (i.startState.facet(Ka) != i.state.facet(Ka) && (this.viewState.mustMeasureContent = !0), (t || n || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !i.empty)
      for (let o of this.state.facet(zh))
        o(i);
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let t = this.hasFocus;
    try {
      for (let i of this.plugins)
        i.destroy(this);
      this.viewState = new Kp(e), this.plugins = e.facet(kr).map((i) => new Sc(i)), this.pluginMap.clear();
      for (let i of this.plugins)
        i.update(this);
      this.docView = new Rp(this), this.inputState.ensureHandlers(this), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    t && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let t = e.startState.facet(kr), i = e.state.facet(kr);
    if (t != i) {
      let s = [];
      for (let n of i) {
        let o = t.indexOf(n);
        if (o < 0)
          s.push(new Sc(n));
        else {
          let l = this.plugins[o];
          l.mustUpdate = e, s.push(l);
        }
      }
      for (let n of this.plugins)
        n.mustUpdate != e && n.destroy(this);
      this.plugins = s, this.pluginMap.clear(), this.inputState.ensureHandlers(this);
    } else
      for (let s of this.plugins)
        s.mustUpdate = e;
    for (let s = 0; s < this.plugins.length; s++)
      this.plugins[s].update(this);
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    this.measureScheduled > -1 && cancelAnimationFrame(this.measureScheduled), this.measureScheduled = 0, e && this.observer.flush();
    let t = null;
    try {
      for (let i = 0; ; i++) {
        this.updateState = 1;
        let s = this.viewport, n = this.viewState.measure(this);
        if (!n && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (i > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let o = [];
        n & 4 || ([this.measureRequests, o] = [o, this.measureRequests]);
        let l = o.map((p) => {
          try {
            return p.read(this);
          } catch (m) {
            return bi(this.state, m), sg;
          }
        }), c = new Lp(this, this.state), d = !1, f = !1;
        c.flags |= n, t ? t.flags |= n : t = c, this.updateState = 2, c.empty || (this.updatePlugins(c), this.inputState.update(c), this.updateAttrs(), d = this.docView.update(c));
        for (let p = 0; p < o.length; p++)
          if (l[p] != sg)
            try {
              let m = o[p];
              m.write && m.write(l[p], this);
            } catch (m) {
              bi(this.state, m);
            }
        if (this.viewState.scrollTarget && (this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, f = !0), d && this.docView.updateSelection(!0), this.viewport.from == s.from && this.viewport.to == s.to && !f && this.measureRequests.length == 0)
          break;
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (t && !t.empty)
      for (let i of this.state.facet(zh))
        i(t);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return Uh + " " + (this.state.facet(jh) ? Zy : Uy) + " " + this.state.facet(Ka);
  }
  updateAttrs() {
    let e = ng(this, Ly, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), t = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(Ca) ? "true" : "false",
      class: "cm-content",
      style: `${we.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (t["aria-readonly"] = "true"), ng(this, My, t), this.observer.ignore(() => {
      Wh(this.contentDOM, this.contentAttrs, t), Wh(this.dom, this.editorAttrs, e);
    }), this.editorAttrs = e, this.contentAttrs = t;
  }
  showAnnouncements(e) {
    let t = !0;
    for (let i of e)
      for (let s of i.effects)
        if (s.is(Oe.announce)) {
          t && (this.announceDOM.textContent = ""), t = !1;
          let n = this.announceDOM.appendChild(document.createElement("div"));
          n.textContent = s.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(_r), Ps.mount(this.root, this.styleModules.concat(iQ).reverse());
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = requestAnimationFrame(() => this.measure())), e) {
      if (e.key != null) {
        for (let t = 0; t < this.measureRequests.length; t++)
          if (this.measureRequests[t].key === e.key) {
            this.measureRequests[t] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Collect all values provided by the active plugins for a given
  field.
  */
  pluginField(e) {
    let t = [];
    for (let i of this.plugins)
      i.update(this).takeField(e, t);
    return t;
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let t = this.pluginMap.get(e);
    return (t === void 0 || t && t.spec != e) && this.pluginMap.set(e, t = this.plugins.find((i) => i.spec == e) || null), t && t.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  Find the line or block widget at the given vertical position.
  
  By default, this position is interpreted as a screen position,
  meaning `docTop` is set to the DOM top position of the editor
  content (forcing a layout). You can pass a different `docTop`
  value—for example 0 to interpret `height` as a document-relative
  position, or a precomputed document top
  (`view.contentDOM.getBoundingClientRect().top`) to limit layout
  queries.
  
  *Deprecated: use `elementAtHeight` instead.*
  */
  blockAtHeight(e, t) {
    let i = Ac(t, this);
    return this.elementAtHeight(e - i).moveY(i);
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find information for the visual line (see
  [`visualLineAt`](https://codemirror.net/6/docs/ref/#view.EditorView.visualLineAt)) at the given
  vertical position. The resulting block info might hold another
  array of block info structs in its `type` field if this line
  consists of more than one block.
  
  Defaults to treating `height` as a screen position. See
  [`blockAtHeight`](https://codemirror.net/6/docs/ref/#view.EditorView.blockAtHeight) for the
  interpretation of the `docTop` parameter.
  
  *Deprecated: use `lineBlockAtHeight` instead.*
  */
  visualLineAtHeight(e, t) {
    let i = Ac(t, this);
    return this.lineBlockAtHeight(e - i).moveY(i);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height.
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Iterate over the height information of the visual lines in the
  viewport. The heights of lines are reported relative to the
  given document top, which defaults to the screen position of the
  document (forcing a layout).
  
  *Deprecated: use `viewportLineBlocks` instead.*
  */
  viewportLines(e, t) {
    let i = Ac(t, this);
    for (let s of this.viewportLineBlocks)
      e(s.moveY(i));
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the extent and height of the visual line (a range delimited
  on both sides by either non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^range)
  line breaks, or the start/end of the document) at the given position.
  
  Vertical positions are computed relative to the `docTop`
  argument, which defaults to 0 for this method. You can pass
  `view.contentDOM.getBoundingClientRect().top` here to get screen
  coordinates.
  
  *Deprecated: use `lineBlockAt` instead.*
  */
  visualLineAt(e, t = 0) {
    return this.lineBlockAt(e).moveY(t + this.viewState.paddingTop);
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^range) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#text.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. Motion in
  bidirectional text is in visual order, in the editor's [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). When the start
  position was the last one on the line, the returned position
  will be across the line break. If there is no further line, the
  original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, t, i) {
    return _c(this, e, Bp(this, e, t, i));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, t) {
    return _c(this, e, Bp(this, e, t, (i) => PI(this, e.head, i)));
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, t, i = !0) {
    return EI(this, e, t, i);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, t, i) {
    return _c(this, e, LI(this, e, t, i));
  }
  // FIXME remove on next major version
  scrollPosIntoView(e) {
    this.dispatch({ effects: Xh.of(ee.cursor(e)) });
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, t = 0) {
    return this.docView.posFromDOM(e, t);
  }
  posAtCoords(e, t = !0) {
    return this.readMeasured(), Wy(this, e, t);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, t = 1) {
    this.readMeasured();
    let i = this.docView.coordsAt(e, t);
    if (!i || i.left == i.right)
      return i;
    let s = this.state.doc.lineAt(e), n = this.bidiSpans(s), o = n[Fn.find(n, e - s.from, -1, t)];
    return _l(i, o.dir == Ne.LTR == t > 0);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor.
  */
  get textDirection() {
    return this.viewState.heightOracle.direction;
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > hQ)
      return Ry(e.length);
    let t = this.textDirection;
    for (let s of this.bidiCache)
      if (s.from == e.from && s.dir == t)
        return s.order;
    let i = bI(e.text, this.textDirection);
    return this.bidiCache.push(new Wo(e.from, e.to, t, i)), i;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (document.hasFocus() || we.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      uy(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, t = {}) {
    return Pp.of(new Pn(typeof e == "number" ? ee.cursor(e) : e, t.y, t.x, t.yMargin, t.xMargin));
  }
  /**
  Facet that can be used to add DOM event handlers. The value
  should be an object mapping event names to handler functions. The
  first such function to return true will be assumed to have handled
  that event, and no other handlers or built-in behavior will be
  activated for it.
  These are registered on the [content
  element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except for `scroll`
  handlers, which will be called any time the editor's [scroll
  element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of its parent nodes
  is scrolled.
  */
  static domEventHandlers(e) {
    return Ot.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, t) {
    let i = Ps.newName(), s = [Ka.of(i), _r.of(Zh(`.${i}`, e))];
    return t && t.dark && s.push(jh.of(!0)), s;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return dr.lowest(_r.of(Zh("." + Uh, e, qy)));
  }
}
Oe.scrollTo = Xh;
Oe.centerOn = Ey;
Oe.styleModule = _r;
Oe.inputHandler = $y;
Oe.exceptionSink = Ay;
Oe.updateListener = zh;
Oe.editable = Ca;
Oe.mouseSelectionStyle = Ty;
Oe.dragMovesSelection = Cy;
Oe.clickAddsSelectionRange = _y;
Oe.decorations = qs;
Oe.darkTheme = jh;
Oe.contentAttributes = My;
Oe.editorAttributes = Ly;
Oe.lineWrapping = /* @__PURE__ */ Oe.contentAttributes.of({ class: "cm-lineWrapping" });
Oe.announce = /* @__PURE__ */ _e.define();
const hQ = 4096;
function Ac(a, e) {
  return (a ?? e.contentDOM.getBoundingClientRect().top) + e.viewState.paddingTop;
}
const sg = {};
class Wo {
  constructor(e, t, i, s) {
    this.from = e, this.to = t, this.dir = i, this.order = s;
  }
  static update(e, t) {
    if (t.empty)
      return e;
    let i = [], s = e.length ? e[e.length - 1].dir : Ne.LTR;
    for (let n = Math.max(0, e.length - 10); n < e.length; n++) {
      let o = e[n];
      o.dir == s && !t.touchesRange(o.from, o.to) && i.push(new Wo(t.mapPos(o.from, 1), t.mapPos(o.to, -1), o.dir, o.order));
    }
    return i;
  }
}
function ng(a, e, t) {
  for (let i = a.state.facet(e), s = i.length - 1; s >= 0; s--) {
    let n = i[s], o = typeof n == "function" ? n(a) : n;
    o && Fh(o, t);
  }
  return t;
}
const dQ = we.mac ? "mac" : we.windows ? "win" : we.linux ? "linux" : "key";
function uQ(a, e) {
  const t = a.split(/-(?!$)/);
  let i = t[t.length - 1];
  i == "Space" && (i = " ");
  let s, n, o, l;
  for (let c = 0; c < t.length - 1; ++c) {
    const d = t[c];
    if (/^(cmd|meta|m)$/i.test(d))
      l = !0;
    else if (/^a(lt)?$/i.test(d))
      s = !0;
    else if (/^(c|ctrl|control)$/i.test(d))
      n = !0;
    else if (/^s(hift)?$/i.test(d))
      o = !0;
    else if (/^mod$/i.test(d))
      e == "mac" ? l = !0 : n = !0;
    else
      throw new Error("Unrecognized modifier name: " + d);
  }
  return s && (i = "Alt-" + i), n && (i = "Ctrl-" + i), l && (i = "Meta-" + i), o && (i = "Shift-" + i), i;
}
function $c(a, e, t) {
  return e.altKey && (a = "Alt-" + a), e.ctrlKey && (a = "Ctrl-" + a), e.metaKey && (a = "Meta-" + a), t !== !1 && e.shiftKey && (a = "Shift-" + a), a;
}
const fQ = /* @__PURE__ */ Oe.domEventHandlers({
  keydown(a, e) {
    return Jy(Ky(e.state), a, e, "editor");
  }
}), Ta = /* @__PURE__ */ be.define({ enables: fQ }), rg = /* @__PURE__ */ new WeakMap();
function Ky(a) {
  let e = a.facet(Ta), t = rg.get(e);
  return t || rg.set(e, t = mQ(e.reduce((i, s) => i.concat(s), []))), t;
}
function pQ(a, e, t) {
  return Jy(Ky(a.state), e, a, t);
}
let ws = null;
const gQ = 4e3;
function mQ(a, e = dQ) {
  let t = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), s = (o, l) => {
    let c = i[o];
    if (c == null)
      i[o] = l;
    else if (c != l)
      throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
  }, n = (o, l, c, d) => {
    let f = t[o] || (t[o] = /* @__PURE__ */ Object.create(null)), p = l.split(/ (?!$)/).map((r) => uQ(r, e));
    for (let r = 1; r < p.length; r++) {
      let h = p.slice(0, r).join(" ");
      s(h, !0), f[h] || (f[h] = {
        preventDefault: !0,
        commands: [(u) => {
          let g = ws = { view: u, prefix: h, scope: o };
          return setTimeout(() => {
            ws == g && (ws = null);
          }, gQ), !0;
        }]
      });
    }
    let m = p.join(" ");
    s(m, !1);
    let v = f[m] || (f[m] = { preventDefault: !1, commands: [] });
    v.commands.push(c), d && (v.preventDefault = !0);
  };
  for (let o of a) {
    let l = o[e] || o.key;
    if (l)
      for (let c of o.scope ? o.scope.split(" ") : ["editor"])
        n(c, l, o.run, o.preventDefault), o.shift && n(c, "Shift-" + l, o.shift, o.preventDefault);
  }
  return t;
}
function Jy(a, e, t, i) {
  let s = eI(e), n = s.length == 1 && s != " ", o = "", l = !1;
  ws && ws.view == t && ws.scope == i && (o = ws.prefix + " ", (l = zy.indexOf(e.keyCode) < 0) && (ws = null));
  let c = (p) => {
    if (p) {
      for (let m of p.commands)
        if (m(t))
          return !0;
      p.preventDefault && (l = !0);
    }
    return !1;
  }, d = a[i], f;
  if (d) {
    if (c(d[o + $c(s, e, !n)]))
      return !0;
    if (n && (e.shiftKey || e.altKey || e.metaKey) && (f = Ms[e.keyCode]) && f != s) {
      if (c(d[o + $c(f, e, !0)]))
        return !0;
    } else if (n && e.shiftKey && c(d[o + $c(s, e, !0)]))
      return !0;
  }
  return l;
}
const eO = !we.ios, Tr = /* @__PURE__ */ be.define({
  combine(a) {
    return Ns(a, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, t) => Math.min(e, t),
      drawRangeCursor: (e, t) => e || t
    });
  }
});
function bQ(a = {}) {
  return [
    Tr.of(a),
    vQ,
    yQ
  ];
}
class tO {
  constructor(e, t, i, s, n) {
    this.left = e, this.top = t, this.width = i, this.height = s, this.className = n;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width >= 0 && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
}
const vQ = /* @__PURE__ */ Ot.fromClass(class {
  constructor(a) {
    this.view = a, this.rangePieces = [], this.cursors = [], this.measureReq = { read: this.readPos.bind(this), write: this.drawSel.bind(this) }, this.selectionLayer = a.scrollDOM.appendChild(document.createElement("div")), this.selectionLayer.className = "cm-selectionLayer", this.selectionLayer.setAttribute("aria-hidden", "true"), this.cursorLayer = a.scrollDOM.appendChild(document.createElement("div")), this.cursorLayer.className = "cm-cursorLayer", this.cursorLayer.setAttribute("aria-hidden", "true"), a.requestMeasure(this.measureReq), this.setBlinkRate();
  }
  setBlinkRate() {
    this.cursorLayer.style.animationDuration = this.view.state.facet(Tr).cursorBlinkRate + "ms";
  }
  update(a) {
    let e = a.startState.facet(Tr) != a.state.facet(Tr);
    (e || a.selectionSet || a.geometryChanged || a.viewportChanged) && this.view.requestMeasure(this.measureReq), a.transactions.some((t) => t.scrollIntoView) && (this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink"), e && this.setBlinkRate();
  }
  readPos() {
    let { state: a } = this.view, e = a.facet(Tr), t = a.selection.ranges.map((s) => s.empty ? [] : OQ(this.view, s)).reduce((s, n) => s.concat(n)), i = [];
    for (let s of a.selection.ranges) {
      let n = s == a.selection.main;
      if (s.empty ? !n || eO : e.drawRangeCursor) {
        let o = xQ(this.view, s, n);
        o && i.push(o);
      }
    }
    return { rangePieces: t, cursors: i };
  }
  drawSel({ rangePieces: a, cursors: e }) {
    if (a.length != this.rangePieces.length || a.some((t, i) => !t.eq(this.rangePieces[i]))) {
      this.selectionLayer.textContent = "";
      for (let t of a)
        this.selectionLayer.appendChild(t.draw());
      this.rangePieces = a;
    }
    if (e.length != this.cursors.length || e.some((t, i) => !t.eq(this.cursors[i]))) {
      let t = this.cursorLayer.children;
      if (t.length !== e.length) {
        this.cursorLayer.textContent = "";
        for (const i of e)
          this.cursorLayer.appendChild(i.draw());
      } else
        e.forEach((i, s) => i.adjust(t[s]));
      this.cursors = e;
    }
  }
  destroy() {
    this.selectionLayer.remove(), this.cursorLayer.remove();
  }
}), iO = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
eO && (iO[".cm-line"].caretColor = "transparent !important");
const yQ = /* @__PURE__ */ dr.highest(/* @__PURE__ */ Oe.theme(iO));
function sO(a) {
  let e = a.scrollDOM.getBoundingClientRect();
  return { left: (a.textDirection == Ne.LTR ? e.left : e.right - a.scrollDOM.clientWidth) - a.scrollDOM.scrollLeft, top: e.top - a.scrollDOM.scrollTop };
}
function ag(a, e, t) {
  let i = ee.cursor(e);
  return {
    from: Math.max(t.from, a.moveToLineBoundary(i, !1, !0).from),
    to: Math.min(t.to, a.moveToLineBoundary(i, !0, !0).from),
    type: Ye.Text
  };
}
function og(a, e) {
  let t = a.lineBlockAt(e);
  if (Array.isArray(t.type)) {
    for (let i of t.type)
      if (i.to > e || i.to == e && (i.to == t.to || i.type == Ye.Text))
        return i;
  }
  return t;
}
function OQ(a, e) {
  if (e.to <= a.viewport.from || e.from >= a.viewport.to)
    return [];
  let t = Math.max(e.from, a.viewport.from), i = Math.min(e.to, a.viewport.to), s = a.textDirection == Ne.LTR, n = a.contentDOM, o = n.getBoundingClientRect(), l = sO(a), c = window.getComputedStyle(n.firstChild), d = o.left + parseInt(c.paddingLeft) + Math.min(0, parseInt(c.textIndent)), f = o.right - parseInt(c.paddingRight), p = og(a, t), m = og(a, i), v = p.type == Ye.Text ? p : null, r = m.type == Ye.Text ? m : null;
  if (a.lineWrapping && (v && (v = ag(a, t, v)), r && (r = ag(a, i, r))), v && r && v.from == r.from)
    return u(g(e.from, e.to, v));
  {
    let O = v ? g(e.from, null, v) : b(p, !1), x = r ? g(null, e.to, r) : b(m, !0), S = [];
    return (v || p).to < (r || m).from - 1 ? S.push(h(d, O.bottom, f, x.top)) : O.bottom < x.top && a.elementAtHeight((O.bottom + x.top) / 2).type == Ye.Text && (O.bottom = x.top = (O.bottom + x.top) / 2), u(O).concat(S).concat(u(x));
  }
  function h(O, x, S, k) {
    return new tO(O - l.left, x - l.top - 0.01, S - O, k - x + 0.01, "cm-selectionBackground");
  }
  function u({ top: O, bottom: x, horizontal: S }) {
    let k = [];
    for (let C = 0; C < S.length; C += 2)
      k.push(h(S[C], O, S[C + 1], x));
    return k;
  }
  function g(O, x, S) {
    let k = 1e9, C = -1e9, _ = [];
    function $(A, y, w, T, P) {
      let R = a.coordsAtPos(A, A == S.to ? -2 : 2), Q = a.coordsAtPos(w, w == S.from ? 2 : -2);
      k = Math.min(R.top, Q.top, k), C = Math.max(R.bottom, Q.bottom, C), P == Ne.LTR ? _.push(s && y ? d : R.left, s && T ? f : Q.right) : _.push(!s && T ? d : Q.left, !s && y ? f : R.right);
    }
    let L = O ?? S.from, E = x ?? S.to;
    for (let A of a.visibleRanges)
      if (A.to > L && A.from < E)
        for (let y = Math.max(A.from, L), w = Math.min(A.to, E); ; ) {
          let T = a.state.doc.lineAt(y);
          for (let P of a.bidiSpans(T)) {
            let R = P.from + T.from, Q = P.to + T.from;
            if (R >= w)
              break;
            Q > y && $(Math.max(R, y), O == null && R <= L, Math.min(Q, w), x == null && Q >= E, P.dir);
          }
          if (y = T.to + 1, y >= w)
            break;
        }
    return _.length == 0 && $(L, O == null, E, x == null, a.textDirection), { top: k, bottom: C, horizontal: _ };
  }
  function b(O, x) {
    let S = o.top + (x ? O.top : O.bottom);
    return { top: S, bottom: S, horizontal: [] };
  }
}
function xQ(a, e, t) {
  let i = a.coordsAtPos(e.head, e.assoc || 1);
  if (!i)
    return null;
  let s = sO(a);
  return new tO(i.left - s.left, i.top - s.top, -1, i.bottom - i.top, t ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary");
}
const nO = /* @__PURE__ */ _e.define({
  map(a, e) {
    return a == null ? null : e.mapPos(a);
  }
}), Ar = /* @__PURE__ */ Mt.define({
  create() {
    return null;
  },
  update(a, e) {
    return a != null && (a = e.changes.mapPos(a)), e.effects.reduce((t, i) => i.is(nO) ? i.value : t, a);
  }
}), wQ = /* @__PURE__ */ Ot.fromClass(class {
  constructor(a) {
    this.view = a, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(a) {
    var e;
    let t = a.state.field(Ar);
    t == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (a.startState.field(Ar) != t || a.docChanged || a.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let a = this.view.state.field(Ar), e = a != null && this.view.coordsAtPos(a);
    if (!e)
      return null;
    let t = this.view.scrollDOM.getBoundingClientRect();
    return {
      left: e.left - t.left + this.view.scrollDOM.scrollLeft,
      top: e.top - t.top + this.view.scrollDOM.scrollTop,
      height: e.bottom - e.top
    };
  }
  drawCursor(a) {
    this.cursor && (a ? (this.cursor.style.left = a.left + "px", this.cursor.style.top = a.top + "px", this.cursor.style.height = a.height + "px") : this.cursor.style.left = "-100000px");
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(a) {
    this.view.state.field(Ar) != a && this.view.dispatch({ effects: nO.of(a) });
  }
}, {
  eventHandlers: {
    dragover(a) {
      this.setDropPos(this.view.posAtCoords({ x: a.clientX, y: a.clientY }));
    },
    dragleave(a) {
      (a.target == this.view.contentDOM || !this.view.contentDOM.contains(a.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function SQ() {
  return [Ar, wQ];
}
function lg(a, e, t, i, s) {
  e.lastIndex = 0;
  for (let n = a.iterRange(t, i), o = t, l; !n.next().done; o += n.value.length)
    if (!n.lineBreak)
      for (; l = e.exec(n.value); )
        s(o + l.index, o + l.index + l[0].length, l);
}
function kQ(a, e) {
  let t = a.visibleRanges;
  if (t.length == 1 && t[0].from == a.viewport.from && t[0].to == a.viewport.to)
    return t;
  let i = [];
  for (let { from: s, to: n } of t)
    s = Math.max(a.state.doc.lineAt(s).from, s - e), n = Math.min(a.state.doc.lineAt(n).to, n + e), i.length && i[i.length - 1].to >= s ? i[i.length - 1].to = n : i.push({ from: s, to: n });
  return i;
}
class _Q {
  /**
  Create a decorator.
  */
  constructor(e) {
    let { regexp: t, decoration: i, boundary: s, maxLength: n = 1e3 } = e;
    if (!t.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    this.regexp = t, this.getDeco = typeof i == "function" ? i : () => i, this.boundary = s, this.maxLength = n;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let t = new Ls();
    for (let { from: i, to: s } of kQ(e, this.maxLength))
      lg(e.state.doc, this.regexp, i, s, (n, o, l) => t.add(n, o, this.getDeco(l, e, n)));
    return t.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, t) {
    let i = 1e9, s = -1;
    return e.docChanged && e.changes.iterChanges((n, o, l, c) => {
      c > e.view.viewport.from && l < e.view.viewport.to && (i = Math.min(l, i), s = Math.max(c, s));
    }), e.viewportChanged || s - i > 1e3 ? this.createDeco(e.view) : s > -1 ? this.updateRange(e.view, t.map(e.changes), i, s) : t;
  }
  updateRange(e, t, i, s) {
    for (let n of e.visibleRanges) {
      let o = Math.max(n.from, i), l = Math.min(n.to, s);
      if (l > o) {
        let c = e.state.doc.lineAt(o), d = c.to < l ? e.state.doc.lineAt(l) : c, f = Math.max(n.from, c.from), p = Math.min(n.to, d.to);
        if (this.boundary) {
          for (; o > c.from; o--)
            if (this.boundary.test(c.text[o - 1 - c.from])) {
              f = o;
              break;
            }
          for (; l < d.to; l++)
            if (this.boundary.test(d.text[l - d.from])) {
              p = l;
              break;
            }
        }
        let m = [], v;
        if (c == d)
          for (this.regexp.lastIndex = f - c.from; (v = this.regexp.exec(c.text)) && v.index < p - c.from; ) {
            let r = v.index + c.from;
            m.push(this.getDeco(v, e, r).range(r, r + v[0].length));
          }
        else
          lg(e.state.doc, this.regexp, f, p, (r, h, u) => m.push(this.getDeco(u, e, r).range(r, h)));
        t = t.update({ filterFrom: f, filterTo: p, filter: (r, h) => r < f || h > p, add: m });
      }
    }
    return t;
  }
}
const qh = /x/.unicode != null ? "gu" : "g", CQ = /* @__PURE__ */ new RegExp(`[\0-\b
--­؜​‎‏\u2028\u2029‭‮\uFEFF￹-￼]`, qh), TQ = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let Ec = null;
function AQ() {
  var a;
  if (Ec == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    Ec = ((a = e.tabSize) !== null && a !== void 0 ? a : e.MozTabSize) != null;
  }
  return Ec || !1;
}
const mo = /* @__PURE__ */ be.define({
  combine(a) {
    let e = Ns(a, {
      render: null,
      specialChars: CQ,
      addSpecialChars: null
    });
    return (e.replaceTabs = !AQ()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, qh)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, qh)), e;
  }
});
function $Q(a = {}) {
  return [mo.of(a), EQ()];
}
let cg = null;
function EQ() {
  return cg || (cg = Ot.fromClass(class {
    constructor(a) {
      this.view = a, this.decorations = me.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(a.state.facet(mo)), this.decorations = this.decorator.createDeco(a);
    }
    makeDecorator(a) {
      return new _Q({
        regexp: a.specialChars,
        decoration: (e, t, i) => {
          let { doc: s } = t.state, n = Dt(e[0], 0);
          if (n == 9) {
            let o = s.lineAt(i), l = t.state.tabSize, c = Sa(o.text, l, i - o.from);
            return me.replace({ widget: new DQ((l - c % l) * this.view.defaultCharacterWidth) });
          }
          return this.decorationCache[n] || (this.decorationCache[n] = me.replace({ widget: new MQ(a, n) }));
        },
        boundary: a.replaceTabs ? void 0 : /[^]/
      });
    }
    update(a) {
      let e = a.state.facet(mo);
      a.startState.facet(mo) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(a.view)) : this.decorations = this.decorator.updateDeco(a, this.decorations);
    }
  }, {
    decorations: (a) => a.decorations
  }));
}
const PQ = "•";
function LQ(a) {
  return a >= 32 ? PQ : a == 10 ? "␤" : String.fromCharCode(9216 + a);
}
class MQ extends hs {
  constructor(e, t) {
    super(), this.options = e, this.code = t;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let t = LQ(this.code), i = e.state.phrase("Control character") + " " + (TQ[this.code] || "0x" + this.code.toString(16)), s = this.options.render && this.options.render(this.code, i, t);
    if (s)
      return s;
    let n = document.createElement("span");
    return n.textContent = t, n.title = i, n.setAttribute("aria-label", i), n.className = "cm-specialChar", n;
  }
  ignoreEvent() {
    return !1;
  }
}
class DQ extends hs {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function RQ() {
  return QQ;
}
const IQ = /* @__PURE__ */ me.line({ class: "cm-activeLine" }), QQ = /* @__PURE__ */ Ot.fromClass(class {
  constructor(a) {
    this.decorations = this.getDeco(a);
  }
  update(a) {
    (a.docChanged || a.selectionSet) && (this.decorations = this.getDeco(a.view));
  }
  getDeco(a) {
    let e = -1, t = [];
    for (let i of a.state.selection.ranges) {
      if (!i.empty)
        return me.none;
      let s = a.lineBlockAt(i.head);
      s.from > e && (t.push(IQ.range(s.from)), e = s.from);
    }
    return me.set(t);
  }
}, {
  decorations: (a) => a.decorations
}), Kh = /* @__PURE__ */ Qs.define(), NQ = /* @__PURE__ */ Qs.define(), FQ = /* @__PURE__ */ be.define(), rO = /* @__PURE__ */ be.define({
  combine(a) {
    return Ns(a, {
      minDepth: 100,
      newGroupDelay: 500
    }, { minDepth: Math.max, newGroupDelay: Math.min });
  }
});
function WQ(a) {
  let e = 0;
  return a.iterChangedRanges((t, i) => e = i), e;
}
const aO = /* @__PURE__ */ Mt.define({
  create() {
    return Fi.empty;
  },
  update(a, e) {
    let t = e.state.facet(rO), i = e.annotation(Kh);
    if (i) {
      let c = e.docChanged ? ee.single(WQ(e.changes)) : void 0, d = Gt.fromTransaction(e, c), f = i.side, p = f == 0 ? a.undone : a.done;
      return d ? p = Bo(p, p.length, t.minDepth, d) : p = dO(p, e.startState.selection), new Fi(f == 0 ? i.rest : p, f == 0 ? p : i.rest);
    }
    let s = e.annotation(NQ);
    if ((s == "full" || s == "before") && (a = a.isolate()), e.annotation(St.addToHistory) === !1)
      return e.changes.empty ? a : a.addMapping(e.changes.desc);
    let n = Gt.fromTransaction(e), o = e.annotation(St.time), l = e.annotation(St.userEvent);
    return n ? a = a.addChanges(n, o, l, t.newGroupDelay, t.minDepth) : e.selection && (a = a.addSelection(e.startState.selection, o, l, t.newGroupDelay)), (s == "full" || s == "after") && (a = a.isolate()), a;
  },
  toJSON(a) {
    return { done: a.done.map((e) => e.toJSON()), undone: a.undone.map((e) => e.toJSON()) };
  },
  fromJSON(a) {
    return new Fi(a.done.map(Gt.fromJSON), a.undone.map(Gt.fromJSON));
  }
});
function oO(a = {}) {
  return [
    aO,
    rO.of(a),
    Oe.domEventHandlers({
      beforeinput(e, t) {
        let i = e.inputType == "historyUndo" ? lO : e.inputType == "historyRedo" ? cO : null;
        return i ? (e.preventDefault(), i(t)) : !1;
      }
    })
  ];
}
function Al(a, e) {
  return function({ state: t, dispatch: i }) {
    if (!e && t.readOnly)
      return !1;
    let s = t.field(aO, !1);
    if (!s)
      return !1;
    let n = s.pop(a, t, e);
    return n ? (i(n), !0) : !1;
  };
}
const lO = /* @__PURE__ */ Al(0, !1), cO = /* @__PURE__ */ Al(1, !1), BQ = /* @__PURE__ */ Al(0, !0), zQ = /* @__PURE__ */ Al(1, !0);
class Gt {
  constructor(e, t, i, s, n) {
    this.changes = e, this.effects = t, this.mapped = i, this.startSelection = s, this.selectionsAfter = n;
  }
  setSelAfter(e) {
    return new Gt(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, t, i;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (t = this.mapped) === null || t === void 0 ? void 0 : t.toJSON(),
      startSelection: (i = this.startSelection) === null || i === void 0 ? void 0 : i.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
    };
  }
  static fromJSON(e) {
    return new Gt(e.changes && xt.fromJSON(e.changes), [], e.mapped && ts.fromJSON(e.mapped), e.startSelection && ee.fromJSON(e.startSelection), e.selectionsAfter.map(ee.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, t) {
    let i = fi;
    for (let s of e.startState.facet(FQ)) {
      let n = s(e);
      n.length && (i = i.concat(n));
    }
    return !i.length && e.changes.empty ? null : new Gt(e.changes.invert(e.startState.doc), i, void 0, t || e.startState.selection, fi);
  }
  static selection(e) {
    return new Gt(void 0, fi, void 0, void 0, e);
  }
}
function Bo(a, e, t, i) {
  let s = e + 1 > t + 20 ? e - t - 1 : 0, n = a.slice(s, e);
  return n.push(i), n;
}
function XQ(a, e) {
  let t = [], i = !1;
  return a.iterChangedRanges((s, n) => t.push(s, n)), e.iterChangedRanges((s, n, o, l) => {
    for (let c = 0; c < t.length; ) {
      let d = t[c++], f = t[c++];
      l >= d && o <= f && (i = !0);
    }
  }), i;
}
function YQ(a, e) {
  return a.ranges.length == e.ranges.length && a.ranges.filter((t, i) => t.empty != e.ranges[i].empty).length === 0;
}
function hO(a, e) {
  return a.length ? e.length ? a.concat(e) : a : e;
}
const fi = [], VQ = 200;
function dO(a, e) {
  if (a.length) {
    let t = a[a.length - 1], i = t.selectionsAfter.slice(Math.max(0, t.selectionsAfter.length - VQ));
    return i.length && i[i.length - 1].eq(e) ? a : (i.push(e), Bo(a, a.length - 1, 1e9, t.setSelAfter(i)));
  } else
    return [Gt.selection([e])];
}
function HQ(a) {
  let e = a[a.length - 1], t = a.slice();
  return t[a.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), t;
}
function Pc(a, e) {
  if (!a.length)
    return a;
  let t = a.length, i = fi;
  for (; t; ) {
    let s = GQ(a[t - 1], e, i);
    if (s.changes && !s.changes.empty || s.effects.length) {
      let n = a.slice(0, t);
      return n[t - 1] = s, n;
    } else
      e = s.mapped, t--, i = s.selectionsAfter;
  }
  return i.length ? [Gt.selection(i)] : fi;
}
function GQ(a, e, t) {
  let i = hO(a.selectionsAfter.length ? a.selectionsAfter.map((l) => l.map(e)) : fi, t);
  if (!a.changes)
    return Gt.selection(i);
  let s = a.changes.map(e), n = e.mapDesc(a.changes, !0), o = a.mapped ? a.mapped.composeDesc(n) : n;
  return new Gt(s, _e.mapEffects(a.effects, e), o, a.startSelection.map(n), i);
}
const jQ = /^(input\.type|delete)($|\.)/;
class Fi {
  constructor(e, t, i = 0, s = void 0) {
    this.done = e, this.undone = t, this.prevTime = i, this.prevUserEvent = s;
  }
  isolate() {
    return this.prevTime ? new Fi(this.done, this.undone) : this;
  }
  addChanges(e, t, i, s, n) {
    let o = this.done, l = o[o.length - 1];
    return l && l.changes && !l.changes.empty && e.changes && (!i || jQ.test(i)) && (!l.selectionsAfter.length && t - this.prevTime < s && XQ(l.changes, e.changes) || // For compose (but not compose.start) events, always join with previous event
    i == "input.type.compose") ? o = Bo(o, o.length - 1, n, new Gt(e.changes.compose(l.changes), hO(e.effects, l.effects), l.mapped, l.startSelection, fi)) : o = Bo(o, o.length, n, e), new Fi(o, fi, t, i);
  }
  addSelection(e, t, i, s) {
    let n = this.done.length ? this.done[this.done.length - 1].selectionsAfter : fi;
    return n.length > 0 && t - this.prevTime < s && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && YQ(n[n.length - 1], e) ? this : new Fi(dO(this.done, e), this.undone, t, i);
  }
  addMapping(e) {
    return new Fi(Pc(this.done, e), Pc(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, t, i) {
    let s = e == 0 ? this.done : this.undone;
    if (s.length == 0)
      return null;
    let n = s[s.length - 1];
    if (i && n.selectionsAfter.length)
      return t.update({
        selection: n.selectionsAfter[n.selectionsAfter.length - 1],
        annotations: Kh.of({ side: e, rest: HQ(s) }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (n.changes) {
      let o = s.length == 1 ? fi : s.slice(0, s.length - 1);
      return n.mapped && (o = Pc(o, n.mapped)), t.update({
        changes: n.changes,
        selection: n.startSelection,
        effects: n.effects,
        annotations: Kh.of({ side: e, rest: o }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
Fi.empty = /* @__PURE__ */ new Fi(fi, fi);
const uO = [
  { key: "Mod-z", run: lO, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: cO, preventDefault: !0 },
  { key: "Mod-u", run: BQ, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: zQ, preventDefault: !0 }
], fO = 1024;
let UQ = 0;
class pi {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
class Ce {
  /// Create a new node prop type.
  constructor(e = {}) {
    this.id = UQ++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /// This is meant to be used with
  /// [`NodeSet.extend`](#common.NodeSet.extend) or
  /// [`LRParser.configure`](#lr.ParserConfig.props) to compute
  /// prop values for each node type in the set. Takes a [match
  /// object](#common.NodeType^match) or function that returns undefined
  /// if the node type doesn't get this prop, and the prop's value if
  /// it does.
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = Zt.match(e)), (t) => {
      let i = e(t);
      return i === void 0 ? null : [this, i];
    };
  }
}
Ce.closedBy = new Ce({ deserialize: (a) => a.split(" ") });
Ce.openedBy = new Ce({ deserialize: (a) => a.split(" ") });
Ce.group = new Ce({ deserialize: (a) => a.split(" ") });
Ce.contextHash = new Ce({ perNode: !0 });
Ce.lookAhead = new Ce({ perNode: !0 });
Ce.mounted = new Ce({ perNode: !0 });
class ZQ {
  constructor(e, t, i) {
    this.tree = e, this.overlay = t, this.parser = i;
  }
}
const qQ = /* @__PURE__ */ Object.create(null);
class Zt {
  /// @internal
  constructor(e, t, i, s = 0) {
    this.name = e, this.props = t, this.id = i, this.flags = s;
  }
  static define(e) {
    let t = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : qQ, i = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), s = new Zt(e.name || "", t, e.id, i);
    if (e.props) {
      for (let n of e.props)
        if (Array.isArray(n) || (n = n(s)), n) {
          if (n[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          t[n[0].id] = n[1];
        }
    }
    return s;
  }
  /// Retrieves a node prop for this type. Will return `undefined` if
  /// the prop isn't present on this node.
  prop(e) {
    return this.props[e.id];
  }
  /// True when this is the top node of a grammar.
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /// True when this node is produced by a skip rule.
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /// Indicates whether this is an error node.
  get isError() {
    return (this.flags & 4) > 0;
  }
  /// When true, this node type doesn't correspond to a user-declared
  /// named node, for example because it is used to cache repetition.
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /// Returns true when this node's name or one of its
  /// [groups](#common.NodeProp^group) matches the given string.
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let t = this.prop(Ce.group);
      return t ? t.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /// Create a function from node types to arbitrary values by
  /// specifying an object whose property names are node or
  /// [group](#common.NodeProp^group) names. Often useful with
  /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  /// names, separated by spaces, in a single property name to map
  /// multiple node names to a single value.
  static match(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let i in e)
      for (let s of i.split(" "))
        t[s] = e[i];
    return (i) => {
      for (let s = i.prop(Ce.group), n = -1; n < (s ? s.length : 0); n++) {
        let o = t[n < 0 ? i.name : s[n]];
        if (o)
          return o;
      }
    };
  }
}
Zt.none = new Zt(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* Anonymous */
);
class qd {
  /// Create a set with the given types. The `id` property of each
  /// type should correspond to its position within the array.
  constructor(e) {
    this.types = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].id != t)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /// Create a copy of this set with some node properties added. The
  /// arguments to this method should be created with
  /// [`NodeProp.add`](#common.NodeProp.add).
  extend(...e) {
    let t = [];
    for (let i of this.types) {
      let s = null;
      for (let n of e) {
        let o = n(i);
        o && (s || (s = Object.assign({}, i.props)), s[o[0].id] = o[1]);
      }
      t.push(s ? new Zt(i.name, s, i.id, i.flags) : i);
    }
    return new qd(t);
  }
}
const Ja = /* @__PURE__ */ new WeakMap(), hg = /* @__PURE__ */ new WeakMap();
class it {
  /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  constructor(e, t, i, s, n) {
    if (this.type = e, this.children = t, this.positions = i, this.length = s, this.props = null, n && n.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [o, l] of n)
        this.props[typeof o == "number" ? o : o.id] = l;
    }
  }
  /// @internal
  toString() {
    let e = this.prop(Ce.mounted);
    if (e && !e.overlay)
      return e.tree.toString();
    let t = "";
    for (let i of this.children) {
      let s = i.toString();
      s && (t && (t += ","), t += s);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (t.length ? "(" + t + ")" : "") : t;
  }
  /// Get a [tree cursor](#common.TreeCursor) rooted at this tree. When
  /// `pos` is given, the cursor is [moved](#common.TreeCursor.moveTo)
  /// to the given position and side.
  cursor(e, t = 0) {
    let i = e != null && Ja.get(this) || this.topNode, s = new ta(i);
    return e != null && (s.moveTo(e, t), Ja.set(this, s._tree)), s;
  }
  /// Get a [tree cursor](#common.TreeCursor) that, unlike regular
  /// cursors, doesn't skip through
  /// [anonymous](#common.NodeType.isAnonymous) nodes and doesn't
  /// automatically enter mounted nodes.
  fullCursor() {
    return new ta(
      this.topNode,
      1
      /* Full */
    );
  }
  /// Get a [syntax node](#common.SyntaxNode) object for the top of the
  /// tree.
  get topNode() {
    return new Xi(this, 0, 0, null);
  }
  /// Get the [syntax node](#common.SyntaxNode) at the given position.
  /// If `side` is -1, this will move into nodes that end at the
  /// position. If 1, it'll move into nodes that start at the
  /// position. With 0, it'll only enter nodes that cover the position
  /// from both sides.
  resolve(e, t = 0) {
    let i = jn(Ja.get(this) || this.topNode, e, t, !1);
    return Ja.set(this, i), i;
  }
  /// Like [`resolve`](#common.Tree.resolve), but will enter
  /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  /// pointing into the innermost overlaid tree at the given position
  /// (with parent links going through all parent structure, including
  /// the host trees).
  resolveInner(e, t = 0) {
    let i = jn(hg.get(this) || this.topNode, e, t, !0);
    return hg.set(this, i), i;
  }
  /// Iterate over the tree and its children, calling `enter` for any
  /// node that touches the `from`/`to` region (if given) before
  /// running over such a node's children, and `leave` (if given) when
  /// leaving the node. When `enter` returns `false`, that node will
  /// not have its children iterated over (or `leave` called).
  iterate(e) {
    let { enter: t, leave: i, from: s = 0, to: n = this.length } = e;
    for (let o = this.cursor(), l = () => o.node; ; ) {
      let c = !1;
      if (o.from <= n && o.to >= s && (o.type.isAnonymous || t(o.type, o.from, o.to, l) !== !1)) {
        if (o.firstChild())
          continue;
        o.type.isAnonymous || (c = !0);
      }
      for (; c && i && i(o.type, o.from, o.to, l), c = o.type.isAnonymous, !o.nextSibling(); ) {
        if (!o.parent())
          return;
        c = !0;
      }
    }
  }
  /// Get the value of the given [node prop](#common.NodeProp) for this
  /// node. Works with both per-node and per-type props.
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /// Returns the node's [per-node props](#common.NodeProp.perNode) in a
  /// format that can be passed to the [`Tree`](#common.Tree)
  /// constructor.
  get propValues() {
    let e = [];
    if (this.props)
      for (let t in this.props)
        e.push([+t, this.props[t]]);
    return e;
  }
  /// Balance the direct children of this tree, producing a copy of
  /// which may have children grouped into subtrees with type
  /// [`NodeType.none`](#common.NodeType^none).
  balance(e = {}) {
    return this.children.length <= 8 ? this : eu(Zt.none, this.children, this.positions, 0, this.children.length, 0, this.length, (t, i, s) => new it(this.type, t, i, s, this.propValues), e.makeTree || ((t, i, s) => new it(Zt.none, t, i, s)));
  }
  /// Build a tree from a postfix-ordered buffer of node information,
  /// or a cursor over such a buffer.
  static build(e) {
    return JQ(e);
  }
}
it.empty = new it(Zt.none, [], [], 0);
class Kd {
  constructor(e, t) {
    this.buffer = e, this.index = t;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new Kd(this.buffer, this.index);
  }
}
class gn {
  /// Create a tree buffer.
  constructor(e, t, i) {
    this.buffer = e, this.length = t, this.set = i;
  }
  /// @internal
  get type() {
    return Zt.none;
  }
  /// @internal
  toString() {
    let e = [];
    for (let t = 0; t < this.buffer.length; )
      e.push(this.childString(t)), t = this.buffer[t + 3];
    return e.join(",");
  }
  /// @internal
  childString(e) {
    let t = this.buffer[e], i = this.buffer[e + 3], s = this.set.types[t], n = s.name;
    if (/\W/.test(n) && !s.isError && (n = JSON.stringify(n)), e += 4, i == e)
      return n;
    let o = [];
    for (; e < i; )
      o.push(this.childString(e)), e = this.buffer[e + 3];
    return n + "(" + o.join(",") + ")";
  }
  /// @internal
  findChild(e, t, i, s, n) {
    let { buffer: o } = this, l = -1;
    for (let c = e; c != t && !(pO(n, s, o[c + 1], o[c + 2]) && (l = c, i > 0)); c = o[c + 3])
      ;
    return l;
  }
  /// @internal
  slice(e, t, i, s) {
    let n = this.buffer, o = new Uint16Array(t - e);
    for (let l = e, c = 0; l < t; )
      o[c++] = n[l++], o[c++] = n[l++] - i, o[c++] = n[l++] - i, o[c++] = n[l++] - e;
    return new gn(o, s - i, this.set);
  }
}
function pO(a, e, t, i) {
  switch (a) {
    case -2:
      return t < e;
    case -1:
      return i >= e && t < e;
    case 0:
      return t < e && i > e;
    case 1:
      return t <= e && i > e;
    case 2:
      return i > e;
    case 4:
      return !0;
  }
}
function gO(a, e) {
  let t = a.childBefore(e);
  for (; t; ) {
    let i = t.lastChild;
    if (!i || i.to != t.to)
      break;
    i.type.isError && i.from == i.to ? (a = t, t = i.prevSibling) : t = i;
  }
  return a;
}
function jn(a, e, t, i) {
  for (var s; a.from == a.to || (t < 1 ? a.from >= e : a.from > e) || (t > -1 ? a.to <= e : a.to < e); ) {
    let n = !i && a instanceof Xi && a.index < 0 ? null : a.parent;
    if (!n)
      return a;
    a = n;
  }
  if (i)
    for (let n = a, o = n.parent; o; n = o, o = n.parent)
      n instanceof Xi && n.index < 0 && ((s = o.enter(e, t, !0)) === null || s === void 0 ? void 0 : s.from) != n.from && (a = o);
  for (; ; ) {
    let n = a.enter(e, t, i);
    if (!n)
      return a;
    a = n;
  }
}
class Xi {
  constructor(e, t, i, s) {
    this.node = e, this._from = t, this.index = i, this._parent = s;
  }
  get type() {
    return this.node.type;
  }
  get name() {
    return this.node.type.name;
  }
  get from() {
    return this._from;
  }
  get to() {
    return this._from + this.node.length;
  }
  nextChild(e, t, i, s, n = 0) {
    for (let o = this; ; ) {
      for (let { children: l, positions: c } = o.node, d = t > 0 ? l.length : -1; e != d; e += t) {
        let f = l[e], p = c[e] + o._from;
        if (pO(s, i, p, p + f.length)) {
          if (f instanceof gn) {
            if (n & 2)
              continue;
            let m = f.findChild(0, f.buffer.length, t, i - p, s);
            if (m > -1)
              return new Ts(new KQ(o, f, e, p), null, m);
          } else if (n & 1 || !f.type.isAnonymous || Jd(f)) {
            let m;
            if (!(n & 1) && f.props && (m = f.prop(Ce.mounted)) && !m.overlay)
              return new Xi(m.tree, p, e, o);
            let v = new Xi(f, p, e, o);
            return n & 1 || !v.type.isAnonymous ? v : v.nextChild(t < 0 ? f.children.length - 1 : 0, t, i, s);
          }
        }
      }
      if (n & 1 || !o.type.isAnonymous || (o.index >= 0 ? e = o.index + t : e = t < 0 ? -1 : o._parent.node.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this.node.children.length - 1,
      -1,
      0,
      4
      /* DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this.node.children.length - 1,
      -1,
      e,
      -2
      /* Before */
    );
  }
  enter(e, t, i = !0, s = !0) {
    let n;
    if (i && (n = this.node.prop(Ce.mounted)) && n.overlay) {
      let o = e - this.from;
      for (let { from: l, to: c } of n.overlay)
        if ((t > 0 ? l <= o : l < o) && (t < 0 ? c >= o : c > o))
          return new Xi(n.tree, n.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(
      0,
      1,
      e,
      t,
      s ? 0 : 2
      /* NoEnterBuffer */
    );
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* DontCare */
    ) : null;
  }
  get cursor() {
    return new ta(this);
  }
  get tree() {
    return this.node;
  }
  toTree() {
    return this.node;
  }
  resolve(e, t = 0) {
    return jn(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return jn(this, e, t, !0);
  }
  enterUnfinishedNodesBefore(e) {
    return gO(this, e);
  }
  getChild(e, t = null, i = null) {
    let s = zo(this, e, t, i);
    return s.length ? s[0] : null;
  }
  getChildren(e, t = null, i = null) {
    return zo(this, e, t, i);
  }
  /// @internal
  toString() {
    return this.node.toString();
  }
}
function zo(a, e, t, i) {
  let s = a.cursor, n = [];
  if (!s.firstChild())
    return n;
  if (t != null) {
    for (; !s.type.is(t); )
      if (!s.nextSibling())
        return n;
  }
  for (; ; ) {
    if (i != null && s.type.is(i))
      return n;
    if (s.type.is(e) && n.push(s.node), !s.nextSibling())
      return i == null ? n : [];
  }
}
class KQ {
  constructor(e, t, i, s) {
    this.parent = e, this.buffer = t, this.index = i, this.start = s;
  }
}
class Ts {
  constructor(e, t, i) {
    this.context = e, this._parent = t, this.index = i, this.type = e.buffer.set.types[e.buffer.buffer[i]];
  }
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  child(e, t, i) {
    let { buffer: s } = this.context, n = s.findChild(this.index + 4, s.buffer[this.index + 3], e, t - this.context.start, i);
    return n < 0 ? null : new Ts(this.context, this, n);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Before */
    );
  }
  enter(e, t, i, s = !0) {
    if (!s)
      return null;
    let { buffer: n } = this.context, o = n.findChild(this.index + 4, n.buffer[this.index + 3], t > 0 ? 1 : -1, e - this.context.start, t);
    return o < 0 ? null : new Ts(this.context, this, o);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, t = e.buffer[this.index + 3];
    return t < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Ts(this.context, this._parent, t) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, t = this._parent ? this._parent.index + 4 : 0;
    return this.index == t ? this.externalSibling(-1) : new Ts(this.context, this._parent, e.findChild(
      t,
      this.index,
      -1,
      0,
      4
      /* DontCare */
    ));
  }
  get cursor() {
    return new ta(this);
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], t = [], { buffer: i } = this.context, s = this.index + 4, n = i.buffer[this.index + 3];
    if (n > s) {
      let o = i.buffer[this.index + 1], l = i.buffer[this.index + 2];
      e.push(i.slice(s, n, o, l)), t.push(0);
    }
    return new it(this.type, e, t, this.to - this.from);
  }
  resolve(e, t = 0) {
    return jn(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return jn(this, e, t, !0);
  }
  enterUnfinishedNodesBefore(e) {
    return gO(this, e);
  }
  /// @internal
  toString() {
    return this.context.buffer.childString(this.index);
  }
  getChild(e, t = null, i = null) {
    let s = zo(this, e, t, i);
    return s.length ? s[0] : null;
  }
  getChildren(e, t = null, i = null) {
    return zo(this, e, t, i);
  }
}
class ta {
  /// @internal
  constructor(e, t = 0) {
    if (this.mode = t, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof Xi)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let i = e._parent; i; i = i._parent)
        this.stack.unshift(i.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  /// Shorthand for `.type.name`.
  get name() {
    return this.type.name;
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, t) {
    this.index = e;
    let { start: i, buffer: s } = this.buffer;
    return this.type = t || s.set.types[s.buffer[e]], this.from = i + s.buffer[e + 1], this.to = i + s.buffer[e + 2], !0;
  }
  yield(e) {
    return e ? e instanceof Xi ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /// @internal
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /// @internal
  enterChild(e, t, i) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree.node.children.length - 1 : 0, e, t, i, this.mode));
    let { buffer: s } = this.buffer, n = s.findChild(this.index + 4, s.buffer[this.index + 3], e, t - this.buffer.start, i);
    return n < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(n));
  }
  /// Move the cursor to this node's first child. When this returns
  /// false, the node has no child, and the cursor has not been moved.
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* DontCare */
    );
  }
  /// Move the cursor to this node's last child.
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* DontCare */
    );
  }
  /// Move the cursor to the first child that ends after `pos`.
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* After */
    );
  }
  /// Move to the last child that starts before `pos`.
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Before */
    );
  }
  /// Move the cursor to the child around `pos`. If side is -1 the
  /// child may end at that position, when 1 it may start there. This
  /// will also enter [overlaid](#common.MountedTree.overlay)
  /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  /// set to false.
  enter(e, t, i = !0, s = !0) {
    return this.buffer ? s ? this.enterChild(1, e, t) : !1 : this.yield(this._tree.enter(e, t, i && !(this.mode & 1), s));
  }
  /// Move to the node's parent node, if this isn't the top node.
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & 1 ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & 1 ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /// @internal
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: t } = this.buffer, i = this.stack.length - 1;
    if (e < 0) {
      let s = i < 0 ? 0 : this.stack[i] + 4;
      if (this.index != s)
        return this.yieldBuf(t.findChild(
          s,
          this.index,
          -1,
          0,
          4
          /* DontCare */
        ));
    } else {
      let s = t.buffer[this.index + 3];
      if (s < (i < 0 ? t.buffer.length : t.buffer[this.stack[i] + 3]))
        return this.yieldBuf(s);
    }
    return i < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /// Move to this node's next sibling, if any.
  nextSibling() {
    return this.sibling(1);
  }
  /// Move to this node's previous sibling, if any.
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let t, i, { buffer: s } = this;
    if (s) {
      if (e > 0) {
        if (this.index < s.buffer.buffer.length)
          return !1;
      } else
        for (let n = 0; n < this.index; n++)
          if (s.buffer.buffer[n + 3] < this.index)
            return !1;
      ({ index: t, parent: i } = s);
    } else
      ({ index: t, _parent: i } = this._tree);
    for (; i; { index: t, _parent: i } = i)
      if (t > -1)
        for (let n = t + e, o = e < 0 ? -1 : i.node.children.length; n != o; n += e) {
          let l = i.node.children[n];
          if (this.mode & 1 || l instanceof gn || !l.type.isAnonymous || Jd(l))
            return !1;
        }
    return !0;
  }
  move(e, t) {
    if (t && this.enterChild(
      e,
      0,
      4
      /* DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /// Move to the next node in a
  /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))
  /// traversal, going from a node to its first child or, if the
  /// current node is empty or `enter` is false, its next sibling or
  /// the next sibling of the first parent node that has one.
  next(e = !0) {
    return this.move(1, e);
  }
  /// Move to the next node in a last-to-first pre-order traveral. A
  /// node is followed by its last child or, if it has none, its
  /// previous sibling or the previous sibling of the first parent
  /// node that has one.
  prev(e = !0) {
    return this.move(-1, e);
  }
  /// Move the cursor to the innermost node that covers `pos`. If
  /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  /// it will enter nodes that start at `pos`.
  moveTo(e, t = 0) {
    for (; (this.from == this.to || (t < 1 ? this.from >= e : this.from > e) || (t > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, t); )
      ;
    return this;
  }
  /// Get a [syntax node](#common.SyntaxNode) at the cursor's current
  /// position.
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, t = null, i = 0;
    if (e && e.context == this.buffer)
      e:
        for (let s = this.index, n = this.stack.length; n >= 0; ) {
          for (let o = e; o; o = o._parent)
            if (o.index == s) {
              if (s == this.index)
                return o;
              t = o, i = n + 1;
              break e;
            }
          s = this.stack[--n];
        }
    for (let s = i; s < this.stack.length; s++)
      t = new Ts(this.buffer, t, this.stack[s]);
    return this.bufferNode = new Ts(this.buffer, t, this.index);
  }
  /// Get the [tree](#common.Tree) that represents the current node, if
  /// any. Will return null when the node is in a [tree
  /// buffer](#common.TreeBuffer).
  get tree() {
    return this.buffer ? null : this._tree.node;
  }
}
function Jd(a) {
  return a.children.some((e) => e instanceof gn || !e.type.isAnonymous || Jd(e));
}
function JQ(a) {
  var e;
  let { buffer: t, nodeSet: i, maxBufferLength: s = fO, reused: n = [], minRepeatType: o = i.types.length } = a, l = Array.isArray(t) ? new Kd(t, t.length) : t, c = i.types, d = 0, f = 0;
  function p(x, S, k, C, _) {
    let { id: $, start: L, end: E, size: A } = l, y = f;
    for (; A < 0; )
      if (l.next(), A == -1) {
        let Q = n[$];
        k.push(Q), C.push(L - x);
        return;
      } else if (A == -3) {
        d = $;
        return;
      } else if (A == -4) {
        f = $;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${A}`);
    let w = c[$], T, P, R = L - x;
    if (E - L <= s && (P = h(l.pos - S, _))) {
      let Q = new Uint16Array(P.size - P.skip), z = l.pos - P.size, W = Q.length;
      for (; l.pos > z; )
        W = u(P.start, Q, W);
      T = new gn(Q, E - P.start, i), R = P.start - x;
    } else {
      let Q = l.pos - A;
      l.next();
      let z = [], W = [], G = $ >= o ? $ : -1, de = 0, xe = E;
      for (; l.pos > Q; )
        G >= 0 && l.id == G && l.size >= 0 ? (l.end <= xe - s && (v(z, W, L, de, l.end, xe, G, y), de = z.length, xe = l.end), l.next()) : p(L, Q, z, W, G);
      if (G >= 0 && de > 0 && de < z.length && v(z, W, L, de, L, xe, G, y), z.reverse(), W.reverse(), G > -1 && de > 0) {
        let ie = m(w);
        T = eu(w, z, W, 0, z.length, 0, E - L, ie, ie);
      } else
        T = r(w, z, W, E - L, y - E);
    }
    k.push(T), C.push(R);
  }
  function m(x) {
    return (S, k, C) => {
      let _ = 0, $ = S.length - 1, L, E;
      if ($ >= 0 && (L = S[$]) instanceof it) {
        if (!$ && L.type == x && L.length == C)
          return L;
        (E = L.prop(Ce.lookAhead)) && (_ = k[$] + L.length + E);
      }
      return r(x, S, k, C, _);
    };
  }
  function v(x, S, k, C, _, $, L, E) {
    let A = [], y = [];
    for (; x.length > C; )
      A.push(x.pop()), y.push(S.pop() + k - _);
    x.push(r(i.types[L], A, y, $ - _, E - $)), S.push(_ - k);
  }
  function r(x, S, k, C, _ = 0, $) {
    if (d) {
      let L = [Ce.contextHash, d];
      $ = $ ? [L].concat($) : [L];
    }
    if (_ > 25) {
      let L = [Ce.lookAhead, _];
      $ = $ ? [L].concat($) : [L];
    }
    return new it(x, S, k, C, $);
  }
  function h(x, S) {
    let k = l.fork(), C = 0, _ = 0, $ = 0, L = k.end - s, E = { size: 0, start: 0, skip: 0 };
    e:
      for (let A = k.pos - x; k.pos > A; ) {
        let y = k.size;
        if (k.id == S && y >= 0) {
          E.size = C, E.start = _, E.skip = $, $ += 4, C += 4, k.next();
          continue;
        }
        let w = k.pos - y;
        if (y < 0 || w < A || k.start < L)
          break;
        let T = k.id >= o ? 4 : 0, P = k.start;
        for (k.next(); k.pos > w; ) {
          if (k.size < 0)
            if (k.size == -3)
              T += 4;
            else
              break e;
          else
            k.id >= o && (T += 4);
          k.next();
        }
        _ = P, C += y, $ += T;
      }
    return (S < 0 || C == x) && (E.size = C, E.start = _, E.skip = $), E.size > 4 ? E : void 0;
  }
  function u(x, S, k) {
    let { id: C, start: _, end: $, size: L } = l;
    if (l.next(), L >= 0 && C < o) {
      let E = k;
      if (L > 4) {
        let A = l.pos - (L - 4);
        for (; l.pos > A; )
          k = u(x, S, k);
      }
      S[--k] = E, S[--k] = $ - x, S[--k] = _ - x, S[--k] = C;
    } else
      L == -3 ? d = C : L == -4 && (f = C);
    return k;
  }
  let g = [], b = [];
  for (; l.pos > 0; )
    p(a.start || 0, a.bufferStart || 0, g, b, -1);
  let O = (e = a.length) !== null && e !== void 0 ? e : g.length ? b[0] + g[0].length : 0;
  return new it(c[a.topID], g.reverse(), b.reverse(), O);
}
const dg = /* @__PURE__ */ new WeakMap();
function bo(a, e) {
  if (!a.isAnonymous || e instanceof gn || e.type != a)
    return 1;
  let t = dg.get(e);
  if (t == null) {
    t = 1;
    for (let i of e.children) {
      if (i.type != a || !(i instanceof it)) {
        t = 1;
        break;
      }
      t += bo(a, i);
    }
    dg.set(e, t);
  }
  return t;
}
function eu(a, e, t, i, s, n, o, l, c) {
  let d = 0;
  for (let r = i; r < s; r++)
    d += bo(a, e[r]);
  let f = Math.ceil(
    d * 1.5 / 8
    /* BranchFactor */
  ), p = [], m = [];
  function v(r, h, u, g, b) {
    for (let O = u; O < g; ) {
      let x = O, S = h[O], k = bo(a, r[O]);
      for (O++; O < g; O++) {
        let C = bo(a, r[O]);
        if (k + C >= f)
          break;
        k += C;
      }
      if (O == x + 1) {
        if (k > f) {
          let C = r[x];
          v(C.children, C.positions, 0, C.children.length, h[x] + b);
          continue;
        }
        p.push(r[x]);
      } else {
        let C = h[O - 1] + r[O - 1].length - S;
        p.push(eu(a, r, h, x, O, S, C, null, c));
      }
      m.push(S + b - n);
    }
  }
  return v(e, t, i, s, 0), (l || c)(p, m, o);
}
class ss {
  /// Construct a tree fragment.
  constructor(e, t, i, s, n = !1, o = !1) {
    this.from = e, this.to = t, this.tree = i, this.offset = s, this.open = (n ? 1 : 0) | (o ? 2 : 0);
  }
  /// Whether the start of the fragment represents the start of a
  /// parse, or the end of a change. (In the second case, it may not
  /// be safe to reuse some nodes at the start, depending on the
  /// parsing algorithm.)
  get openStart() {
    return (this.open & 1) > 0;
  }
  /// Whether the end of the fragment represents the end of a
  /// full-document parse, or the start of a change.
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /// Create a set of fragments from a freshly parsed tree, or update
  /// an existing set of fragments by replacing the ones that overlap
  /// with a tree with content from the new tree. When `partial` is
  /// true, the parse is treated as incomplete, and the resulting
  /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  /// true.
  static addTree(e, t = [], i = !1) {
    let s = [new ss(0, e.length, e, 0, !1, i)];
    for (let n of t)
      n.to > e.length && s.push(n);
    return s;
  }
  /// Apply a set of edits to an array of fragments, removing or
  /// splitting fragments as necessary to remove edited ranges, and
  /// adjusting offsets for fragments that moved.
  static applyChanges(e, t, i = 128) {
    if (!t.length)
      return e;
    let s = [], n = 1, o = e.length ? e[0] : null;
    for (let l = 0, c = 0, d = 0; ; l++) {
      let f = l < t.length ? t[l] : null, p = f ? f.fromA : 1e9;
      if (p - c >= i)
        for (; o && o.from < p; ) {
          let m = o;
          if (c >= m.from || p <= m.to || d) {
            let v = Math.max(m.from, c) - d, r = Math.min(m.to, p) - d;
            m = v >= r ? null : new ss(v, r, m.tree, m.offset + d, l > 0, !!f);
          }
          if (m && s.push(m), o.to > p)
            break;
          o = n < e.length ? e[n++] : null;
        }
      if (!f)
        break;
      c = f.toA, d = f.toA - f.toB;
    }
    return s;
  }
}
class mO {
  /// Start a parse, returning a [partial parse](#common.PartialParse)
  /// object. [`fragments`](#common.TreeFragment) can be passed in to
  /// make the parse incremental.
  ///
  /// By default, the entire input is parsed. You can pass `ranges`,
  /// which should be a sorted array of non-empty, non-overlapping
  /// ranges, to parse only those ranges. The tree returned in that
  /// case will start at `ranges[0].from`.
  startParse(e, t, i) {
    return typeof e == "string" && (e = new eN(e)), i = i ? i.length ? i.map((s) => new pi(s.from, s.to)) : [new pi(0, 0)] : [new pi(0, e.length)], this.createParse(e, t || [], i);
  }
  /// Run a full parse, returning the resulting tree.
  parse(e, t, i) {
    let s = this.startParse(e, t, i);
    for (; ; ) {
      let n = s.advance();
      if (n)
        return n;
    }
  }
}
class eN {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, t) {
    return this.string.slice(e, t);
  }
}
function tN(a) {
  return (e, t, i, s) => new sN(e, a, t, i, s);
}
class ug {
  constructor(e, t, i, s, n) {
    this.parser = e, this.parse = t, this.overlay = i, this.target = s, this.ranges = n;
  }
}
class iN {
  constructor(e, t, i, s, n, o, l) {
    this.parser = e, this.predicate = t, this.mounts = i, this.index = s, this.start = n, this.target = o, this.prev = l, this.depth = 0, this.ranges = [];
  }
}
const Jh = new Ce({ perNode: !0 });
class sN {
  constructor(e, t, i, s, n) {
    this.nest = t, this.input = i, this.fragments = s, this.ranges = n, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let i = this.baseParse.advance();
      if (!i)
        return null;
      if (this.baseParse = null, this.baseTree = i, this.startInner(), this.stoppedAt != null)
        for (let s of this.inner)
          s.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let i = this.baseTree;
      return this.stoppedAt != null && (i = new it(i.type, i.children, i.positions, i.length, i.propValues.concat([[Jh, this.stoppedAt]]))), i;
    }
    let e = this.inner[this.innerDone], t = e.parse.advance();
    if (t) {
      this.innerDone++;
      let i = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      i[Ce.mounted.id] = new ZQ(t, e.overlay, e.parser), e.target.props = i;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let t = this.innerDone; t < this.inner.length; t++)
      this.inner[t].ranges[0].from < e && (e = Math.min(e, this.inner[t].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let t = this.innerDone; t < this.inner.length; t++)
        this.inner[t].parse.stopAt(e);
  }
  startInner() {
    let e = new aN(this.fragments), t = null, i = null, s = new ta(
      new Xi(this.baseTree, this.ranges[0].from, 0, null),
      1
      /* Full */
    );
    e:
      for (let n, o; this.stoppedAt == null || s.from < this.stoppedAt; ) {
        let l = !0, c;
        if (e.hasNode(s)) {
          if (t) {
            let d = t.mounts.find((f) => f.frag.from <= s.from && f.frag.to >= s.to && f.mount.overlay);
            if (d)
              for (let f of d.mount.overlay) {
                let p = f.from + d.pos, m = f.to + d.pos;
                p >= s.from && m <= s.to && !t.ranges.some((v) => v.from < m && v.to > p) && t.ranges.push({ from: p, to: m });
              }
          }
          l = !1;
        } else if (i && (o = nN(i.ranges, s.from, s.to)))
          l = o != 2;
        else if (!s.type.isAnonymous && s.from < s.to && (n = this.nest(s, this.input))) {
          s.tree || rN(s);
          let d = e.findMounts(s.from, n.parser);
          if (typeof n.overlay == "function")
            t = new iN(n.parser, n.overlay, d, this.inner.length, s.from, s.tree, t);
          else {
            let f = gg(this.ranges, n.overlay || [new pi(s.from, s.to)]);
            f.length && this.inner.push(new ug(n.parser, n.parser.startParse(this.input, mg(d, f), f), n.overlay ? n.overlay.map((p) => new pi(p.from - s.from, p.to - s.from)) : null, s.tree, f)), n.overlay ? f.length && (i = { ranges: f, depth: 0, prev: i }) : l = !1;
          }
        } else
          t && (c = t.predicate(s)) && (c === !0 && (c = new pi(s.from, s.to)), c.from < c.to && t.ranges.push(c));
        if (l && s.firstChild())
          t && t.depth++, i && i.depth++;
        else
          for (; !s.nextSibling(); ) {
            if (!s.parent())
              break e;
            if (t && !--t.depth) {
              let d = gg(this.ranges, t.ranges);
              d.length && this.inner.splice(t.index, 0, new ug(t.parser, t.parser.startParse(this.input, mg(t.mounts, d), d), t.ranges.map((f) => new pi(f.from - t.start, f.to - t.start)), t.target, d)), t = t.prev;
            }
            i && !--i.depth && (i = i.prev);
          }
      }
  }
}
function nN(a, e, t) {
  for (let i of a) {
    if (i.from >= t)
      break;
    if (i.to > e)
      return i.from <= e && i.to >= t ? 2 : 1;
  }
  return 0;
}
function fg(a, e, t, i, s, n) {
  if (e < t) {
    let o = a.buffer[e + 1], l = a.buffer[t - 2];
    i.push(a.slice(e, t, o, l)), s.push(o - n);
  }
}
function rN(a) {
  let { node: e } = a, t = 0;
  do
    a.parent(), t++;
  while (!a.tree);
  let i = 0, s = a.tree, n = 0;
  for (; n = s.positions[i] + a.from, !(n <= e.from && n + s.children[i].length >= e.to); i++)
    ;
  let o = s.children[i], l = o.buffer;
  function c(d, f, p, m, v) {
    let r = d;
    for (; l[r + 2] + n <= e.from; )
      r = l[r + 3];
    let h = [], u = [];
    fg(o, d, r, h, u, m);
    let g = l[r + 1], b = l[r + 2], O = g + n == e.from && b + n == e.to && l[r] == e.type.id;
    return h.push(O ? e.toTree() : c(r + 4, l[r + 3], o.set.types[l[r]], g, b - g)), u.push(g - m), fg(o, l[r + 3], f, h, u, m), new it(p, h, u, v);
  }
  s.children[i] = c(0, l.length, Zt.none, 0, o.length);
  for (let d = 0; d <= t; d++)
    a.childAfter(e.from);
}
class pg {
  constructor(e, t) {
    this.offset = t, this.done = !1, this.cursor = e.fullCursor();
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: t } = this, i = e - this.offset;
    for (; !this.done && t.from < i; )
      t.to >= e && t.enter(i, 1, !1, !1) || t.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let t = this.cursor.tree; ; ) {
        if (t == e.tree)
          return !0;
        if (t.children.length && t.positions[0] == 0 && t.children[0] instanceof it)
          t = t.children[0];
        else
          break;
      }
    return !1;
  }
}
let aN = class {
  constructor(e) {
    var t;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let i = this.curFrag = e[0];
      this.curTo = (t = i.tree.prop(Jh)) !== null && t !== void 0 ? t : i.to, this.inner = new pg(i.tree, -i.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let t = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = t.tree.prop(Jh)) !== null && e !== void 0 ? e : t.to, this.inner = new pg(t.tree, -t.offset);
    }
  }
  findMounts(e, t) {
    var i;
    let s = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let n = this.inner.cursor.node; n; n = n.parent) {
        let o = (i = n.tree) === null || i === void 0 ? void 0 : i.prop(Ce.mounted);
        if (o && o.parser == t)
          for (let l = this.fragI; l < this.fragments.length; l++) {
            let c = this.fragments[l];
            if (c.from >= n.to)
              break;
            c.tree == this.curFrag.tree && s.push({
              frag: c,
              pos: n.from - c.offset,
              mount: o
            });
          }
      }
    }
    return s;
  }
};
function gg(a, e) {
  let t = null, i = e;
  for (let s = 1, n = 0; s < a.length; s++) {
    let o = a[s - 1].to, l = a[s].from;
    for (; n < i.length; n++) {
      let c = i[n];
      if (c.from >= l)
        break;
      c.to <= o || (t || (i = t = e.slice()), c.from < o ? (t[n] = new pi(c.from, o), c.to > l && t.splice(n + 1, 0, new pi(l, c.to))) : c.to > l ? t[n--] = new pi(l, c.to) : t.splice(n--, 1));
    }
  }
  return i;
}
function oN(a, e, t, i) {
  let s = 0, n = 0, o = !1, l = !1, c = -1e9, d = [];
  for (; ; ) {
    let f = s == a.length ? 1e9 : o ? a[s].to : a[s].from, p = n == e.length ? 1e9 : l ? e[n].to : e[n].from;
    if (o != l) {
      let m = Math.max(c, t), v = Math.min(f, p, i);
      m < v && d.push(new pi(m, v));
    }
    if (c = Math.min(f, p), c == 1e9)
      break;
    f == c && (o ? (o = !1, s++) : o = !0), p == c && (l ? (l = !1, n++) : l = !0);
  }
  return d;
}
function mg(a, e) {
  let t = [];
  for (let { pos: i, mount: s, frag: n } of a) {
    let o = i + (s.overlay ? s.overlay[0].from : 0), l = o + s.tree.length, c = Math.max(n.from, o), d = Math.min(n.to, l);
    if (s.overlay) {
      let f = s.overlay.map((m) => new pi(m.from + i, m.to + i)), p = oN(e, f, c, d);
      for (let m = 0, v = c; ; m++) {
        let r = m == p.length, h = r ? d : p[m].from;
        if (h > v && t.push(new ss(v, h, s.tree, -o, n.from >= v, n.to <= h)), r)
          break;
        v = p[m].to;
      }
    } else
      t.push(new ss(c, d, s.tree, -o, n.from >= o, n.to <= l));
  }
  return t;
}
var Lc;
const Xo = /* @__PURE__ */ new Ce();
function lN(a) {
  return be.define({
    combine: a ? (e) => e.concat(a) : void 0
  });
}
class Wi {
  /**
  Construct a language object. You usually don't need to invoke
  this directly. But when you do, make sure you use
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet) to create
  the first argument.
  */
  constructor(e, t, i, s = []) {
    this.data = e, this.topNode = i, Re.prototype.hasOwnProperty("tree") || Object.defineProperty(Re.prototype, "tree", { get() {
      return pt(this);
    } }), this.parser = t, this.extension = [
      as.of(this),
      Re.languageData.of((n, o, l) => n.facet(bg(n, o, l)))
    ].concat(s);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, t, i = -1) {
    return bg(e, t, i) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let t = e.facet(as);
    if ((t == null ? void 0 : t.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!t || !t.allowsNesting)
      return [];
    let i = [], s = (n, o) => {
      if (n.prop(Xo) == this.data) {
        i.push({ from: o, to: o + n.length });
        return;
      }
      let l = n.prop(Ce.mounted);
      if (l) {
        if (l.tree.prop(Xo) == this.data) {
          if (l.overlay)
            for (let c of l.overlay)
              i.push({ from: c.from + o, to: c.to + o });
          else
            i.push({ from: o, to: o + n.length });
          return;
        } else if (l.overlay) {
          let c = i.length;
          if (s(l.tree, l.overlay[0].from + o), i.length > c)
            return;
        }
      }
      for (let c = 0; c < n.children.length; c++) {
        let d = n.children[c];
        d instanceof it && s(d, n.positions[c] + o);
      }
    };
    return s(pt(e), 0), i;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
Wi.setState = /* @__PURE__ */ _e.define();
function bg(a, e, t) {
  let i = a.facet(as);
  if (!i)
    return null;
  let s = i.data;
  if (i.allowsNesting)
    for (let n = pt(a).topNode; n; n = n.enter(e, t, !0, !1))
      s = n.type.prop(Xo) || s;
  return s;
}
class Un extends Wi {
  constructor(e, t) {
    super(e, t, t.topNode), this.parser = t;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let t = lN(e.languageData);
    return new Un(t, e.parser.configure({
      props: [Xo.add((i) => i.isTop ? t : void 0)]
    }));
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser.
  */
  configure(e) {
    return new Un(this.data, this.parser.configure(e));
  }
  get allowsNesting() {
    return this.parser.wrappers.length > 0;
  }
  // FIXME
}
function pt(a) {
  let e = a.field(Wi.state, !1);
  return e ? e.tree : it.empty;
}
class cN {
  constructor(e, t = e.length) {
    this.doc = e, this.length = t, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, t) {
    let i = this.cursorPos - this.string.length;
    return e < i || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - i, t - i);
  }
}
let vr = null;
class tu {
  /**
  @internal
  */
  constructor(e, t, i = [], s, n, o, l, c) {
    this.parser = e, this.state = t, this.fragments = i, this.tree = s, this.treeLen = n, this.viewport = o, this.skipped = l, this.scheduleOn = c, this.parse = null, this.tempSkipped = [];
  }
  startParse() {
    return this.parser.startParse(new cN(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, t) {
    return t != null && t >= this.state.doc.length && (t = void 0), this.tree != it.empty && this.isDone(t ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var i;
      if (typeof e == "number") {
        let s = Date.now() + e;
        e = () => Date.now() > s;
      }
      for (this.parse || (this.parse = this.startParse()), t != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t); ; ) {
        let s = this.parse.advance();
        if (s)
          if (this.fragments = this.withoutTempSkipped(ss.addTree(s, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (i = this.parse.stoppedAt) !== null && i !== void 0 ? i : this.state.doc.length, this.tree = s, this.parse = null, this.treeLen < (t ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, t;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(t = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = t, this.fragments = this.withoutTempSkipped(ss.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let t = vr;
    vr = this;
    try {
      return e();
    } finally {
      vr = t;
    }
  }
  withoutTempSkipped(e) {
    for (let t; t = this.tempSkipped.pop(); )
      e = vg(e, t.from, t.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, t) {
    let { fragments: i, tree: s, treeLen: n, viewport: o, skipped: l } = this;
    if (this.takeTree(), !e.empty) {
      let c = [];
      if (e.iterChangedRanges((d, f, p, m) => c.push({ fromA: d, toA: f, fromB: p, toB: m })), i = ss.applyChanges(i, c), s = it.empty, n = 0, o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }, this.skipped.length) {
        l = [];
        for (let d of this.skipped) {
          let f = e.mapPos(d.from, 1), p = e.mapPos(d.to, -1);
          f < p && l.push({ from: f, to: p });
        }
      }
    }
    return new tu(this.parser, t, i, s, n, o, l, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let t = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from: s, to: n } = this.skipped[i];
      s < e.to && n > e.from && (this.fragments = vg(this.fragments, s, n), this.skipped.splice(i--, 1));
    }
    return this.skipped.length >= t ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, t) {
    this.skipped.push({ from: e, to: t });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends mO {
      createParse(t, i, s) {
        let n = s[0].from, o = s[s.length - 1].to;
        return {
          parsedPos: n,
          advance() {
            let c = vr;
            if (c) {
              for (let d of s)
                c.tempSkipped.push(d);
              e && (c.scheduleOn = c.scheduleOn ? Promise.all([c.scheduleOn, e]) : e);
            }
            return this.parsedPos = o, new it(Zt.none, [], [], o - n);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let t = this.fragments;
    return this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return vr;
  }
}
function vg(a, e, t) {
  return ss.applyChanges(a, [{ fromA: e, toA: t, fromB: e, toB: t }]);
}
class Zn {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let t = this.context.changes(e.changes, e.state), i = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
    return t.work(20, i) || t.takeTree(), new Zn(t);
  }
  static init(e) {
    let t = Math.min(3e3, e.doc.length), i = new tu(e.facet(as).parser, e, [], it.empty, 0, { from: 0, to: t }, [], null);
    return i.work(20, t) || i.takeTree(), new Zn(i);
  }
}
Wi.state = /* @__PURE__ */ Mt.define({
  create: Zn.init,
  update(a, e) {
    for (let t of e.effects)
      if (t.is(Wi.setState))
        return t.value;
    return e.startState.facet(as) != e.state.facet(as) ? Zn.init(e.state) : a.apply(e);
  }
});
let bO = (a) => {
  let e = setTimeout(
    () => a(),
    500
    /* MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (bO = (a) => {
  let e = -1, t = setTimeout(
    () => {
      e = requestIdleCallback(a, {
        timeout: 500 - 100
        /* MinPause */
      });
    },
    100
    /* MinPause */
  );
  return () => e < 0 ? clearTimeout(t) : cancelIdleCallback(e);
});
const Mc = typeof navigator < "u" && (!((Lc = navigator.scheduling) === null || Lc === void 0) && Lc.isInputPending) ? () => navigator.scheduling.isInputPending() : null, hN = /* @__PURE__ */ Ot.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let t = this.view.state.field(Wi.state).context;
    (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(), e.docChanged && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(t);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, t = e.field(Wi.state);
    (t.tree != t.context.tree || !t.context.isDone(e.doc.length)) && (this.working = bO(this.work));
  }
  work(e) {
    this.working = null;
    let t = Date.now();
    if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: i, viewport: { to: s } } = this.view, n = i.field(Wi.state);
    if (n.tree == n.context.tree && n.context.isDone(
      s + 1e5
      /* MaxParseAhead */
    ))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, e && !Mc ? Math.max(25, e.timeRemaining() - 5) : 1e9), l = n.context.treeLen < s && i.doc.length > s + 1e3, c = n.context.work(() => Mc && Mc() || Date.now() > o, s + (l ? 0 : 1e5));
    this.chunkBudget -= Date.now() - t, (c || this.chunkBudget <= 0) && (n.context.takeTree(), this.view.dispatch({ effects: Wi.setState.of(new Zn(n.context)) })), this.chunkBudget > 0 && !(c && !l) && this.scheduleWork(), this.checkAsyncSchedule(n.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((t) => bi(this.view.state, t)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), as = /* @__PURE__ */ be.define({
  combine(a) {
    return a.length ? a[0] : null;
  },
  enables: [Wi.state, hN]
});
class iu {
  /**
  Create a support object.
  */
  constructor(e, t = []) {
    this.language = e, this.support = t, this.extension = [e, t];
  }
}
const dN = /* @__PURE__ */ be.define(), $l = /* @__PURE__ */ be.define({
  combine: (a) => {
    if (!a.length)
      return "  ";
    if (!/^(?: +|\t+)$/.test(a[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(a[0]));
    return a[0];
  }
});
function Yo(a) {
  let e = a.facet($l);
  return e.charCodeAt(0) == 9 ? a.tabSize * e.length : e.length;
}
function ia(a, e) {
  let t = "", i = a.tabSize;
  if (a.facet($l).charCodeAt(0) == 9)
    for (; e >= i; )
      t += "	", e -= i;
  for (let s = 0; s < e; s++)
    t += " ";
  return t;
}
function su(a, e) {
  a instanceof Re && (a = new El(a));
  for (let i of a.state.facet(dN)) {
    let s = i(a, e);
    if (s != null)
      return s;
  }
  let t = pt(a.state);
  return t ? uN(a, t, e) : null;
}
class El {
  /**
  Create an indent context.
  */
  constructor(e, t = {}) {
    this.state = e, this.options = t, this.unit = Yo(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, t = 1) {
    let i = this.state.doc.lineAt(e), { simulateBreak: s, simulateDoubleBreak: n } = this.options;
    return s != null && s >= i.from && s <= i.to ? n && s == e ? { text: "", from: e } : (t < 0 ? s < e : s <= e) ? { text: i.text.slice(s - i.from), from: s } : { text: i.text.slice(0, s - i.from), from: i.from } : i;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, t = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: i, from: s } = this.lineAt(e, t);
    return i.slice(e - s, Math.min(i.length, e + 100 - s));
  }
  /**
  Find the column for the given position.
  */
  column(e, t = 1) {
    let { text: i, from: s } = this.lineAt(e, t), n = this.countColumn(i, e - s), o = this.options.overrideIndentation ? this.options.overrideIndentation(s) : -1;
    return o > -1 && (n += o - this.countColumn(i, i.search(/\S|$/))), n;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, t = e.length) {
    return Sa(e, this.state.tabSize, t);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, t = 1) {
    let { text: i, from: s } = this.lineAt(e, t), n = this.options.overrideIndentation;
    if (n) {
      let o = n(s);
      if (o > -1)
        return o;
    }
    return this.countColumn(i, i.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const Pl = /* @__PURE__ */ new Ce();
function uN(a, e, t) {
  return vO(e.resolveInner(t).enterUnfinishedNodesBefore(t), t, a);
}
function fN(a) {
  return a.pos == a.options.simulateBreak && a.options.simulateDoubleBreak;
}
function pN(a) {
  let e = a.type.prop(Pl);
  if (e)
    return e;
  let t = a.firstChild, i;
  if (t && (i = t.type.prop(Ce.closedBy))) {
    let s = a.lastChild, n = s && i.indexOf(s.name) > -1;
    return (o) => yO(o, !0, 1, void 0, n && !fN(o) ? s.from : void 0);
  }
  return a.parent == null ? gN : null;
}
function vO(a, e, t) {
  for (; a; a = a.parent) {
    let i = pN(a);
    if (i)
      return i(new mN(t, e, a));
  }
  return null;
}
function gN() {
  return 0;
}
class mN extends El {
  /**
  @internal
  */
  constructor(e, t, i) {
    super(e.state, e.options), this.base = e, this.pos = t, this.node = i;
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    let e = this.state.doc.lineAt(this.node.from);
    for (; ; ) {
      let t = this.node.resolve(e.from);
      for (; t.parent && t.parent.from == t.from; )
        t = t.parent;
      if (bN(t, this.node))
        break;
      e = this.state.doc.lineAt(t.from);
    }
    return this.lineIndent(e.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    let e = this.node.parent;
    return e ? vO(e, this.pos, this.base) : 0;
  }
}
function bN(a, e) {
  for (let t = e; t; t = t.parent)
    if (a == t)
      return !0;
  return !1;
}
function vN(a) {
  let e = a.node, t = e.childAfter(e.from), i = e.lastChild;
  if (!t)
    return null;
  let s = a.options.simulateBreak, n = a.state.doc.lineAt(t.from), o = s == null || s <= n.from ? n.to : Math.min(n.to, s);
  for (let l = t.to; ; ) {
    let c = e.childAfter(l);
    if (!c || c == i)
      return null;
    if (!c.type.isSkipped)
      return c.from < o ? t : null;
    l = c.to;
  }
}
function yN({ closing: a, align: e = !0, units: t = 1 }) {
  return (i) => yO(i, e, t, a);
}
function yO(a, e, t, i, s) {
  let n = a.textAfter, o = n.match(/^\s*/)[0].length, l = i && n.slice(o, o + i.length) == i || s == a.pos + o, c = e ? vN(a) : null;
  return c ? l ? a.column(c.from) : a.column(c.to) : a.baseIndent + (l ? 0 : a.unit * t);
}
const ON = (a) => a.baseIndent;
function vo({ except: a, units: e = 1 } = {}) {
  return (t) => {
    let i = a && a.test(t.textAfter);
    return t.baseIndent + (i ? 0 : e * t.unit);
  };
}
const xN = 200;
function wN() {
  return Re.transactionFilter.of((a) => {
    if (!a.docChanged || !a.isUserEvent("input.type") && !a.isUserEvent("input.complete"))
      return a;
    let e = a.startState.languageDataAt("indentOnInput", a.startState.selection.main.head);
    if (!e.length)
      return a;
    let t = a.newDoc, { head: i } = a.newSelection.main, s = t.lineAt(i);
    if (i > s.from + xN)
      return a;
    let n = t.sliceString(s.from, i);
    if (!e.some((d) => d.test(n)))
      return a;
    let { state: o } = a, l = -1, c = [];
    for (let { head: d } of o.selection.ranges) {
      let f = o.doc.lineAt(d);
      if (f.from == l)
        continue;
      l = f.from;
      let p = su(o, f.from);
      if (p == null)
        continue;
      let m = /^\s*/.exec(f.text)[0], v = ia(o, p);
      m != v && c.push({ from: f.from, to: f.from + m.length, insert: v });
    }
    return c.length ? [a, { changes: c, sequential: !0 }] : a;
  });
}
const SN = /* @__PURE__ */ be.define(), Ll = /* @__PURE__ */ new Ce();
function OO(a) {
  let e = a.firstChild, t = a.lastChild;
  return e && e.to < t.from ? { from: e.to, to: t.type.isError ? a.to : t.from } : null;
}
function kN(a, e, t) {
  let i = pt(a);
  if (i.length == 0)
    return null;
  let s = i.resolveInner(t), n = null;
  for (let o = s; o; o = o.parent) {
    if (o.to <= t || o.from > t)
      continue;
    if (n && o.from < e)
      break;
    let l = o.type.prop(Ll);
    if (l && (o.to < i.length - 50 || i.length == a.doc.length || !_N(o))) {
      let c = l(o, a);
      c && c.from <= t && c.from >= e && c.to > t && (n = c);
    }
  }
  return n;
}
function _N(a) {
  let e = a.lastChild;
  return e && e.to == a.to && e.type.isError;
}
function Vo(a, e, t) {
  for (let i of a.facet(SN)) {
    let s = i(a, e, t);
    if (s)
      return s;
  }
  return kN(a, e, t);
}
class os extends an {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
os.prototype.elementClass = "";
os.prototype.toDOM = void 0;
os.prototype.mapMode = $t.TrackBefore;
os.prototype.startSide = os.prototype.endSide = -1;
os.prototype.point = !0;
const yo = /* @__PURE__ */ be.define(), CN = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => ze.empty,
  lineMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, Nr = /* @__PURE__ */ be.define();
function TN(a) {
  return [xO(), Nr.of(Object.assign(Object.assign({}, CN), a))];
}
const AN = /* @__PURE__ */ Oe.baseTheme({
  ".cm-gutters": {
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    left: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#999",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  }
}), ed = /* @__PURE__ */ be.define({
  combine: (a) => a.some((e) => e)
});
function xO(a) {
  let e = [
    $N,
    AN
  ];
  return a && a.fixed === !1 && e.push(ed.of(!0)), e;
}
const $N = /* @__PURE__ */ Ot.fromClass(class {
  constructor(a) {
    this.view = a, this.prevViewport = a.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight + "px", this.gutters = a.state.facet(Nr).map((e) => new Og(a, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !a.state.facet(ed), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), a.scrollDOM.insertBefore(this.dom, a.contentDOM);
  }
  update(a) {
    if (this.updateGutters(a)) {
      let e = this.prevViewport, t = a.view.viewport, i = Math.min(e.to, t.to) - Math.max(e.from, t.from);
      this.syncGutters(i < (t.to - t.from) * 0.8);
    }
    a.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(ed) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = a.view.viewport;
  }
  syncGutters(a) {
    let e = this.dom.nextSibling;
    a && this.dom.remove();
    let t = ze.iter(this.view.state.facet(yo), this.view.viewport.from), i = [], s = this.gutters.map((n) => new EN(n, this.view.viewport, -this.view.documentPadding.top));
    for (let n of this.view.viewportLineBlocks) {
      let o;
      if (Array.isArray(n.type)) {
        for (let l of n.type)
          if (l.type == Ye.Text) {
            o = l;
            break;
          }
      } else
        o = n.type == Ye.Text ? n : void 0;
      if (o) {
        i.length && (i = []), wO(t, i, n.from);
        for (let l of s)
          l.line(this.view, o, i);
      }
    }
    for (let n of s)
      n.finish();
    a && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(a) {
    let e = a.startState.facet(Nr), t = a.state.facet(Nr), i = a.docChanged || a.heightChanged || a.viewportChanged || !ze.eq(a.startState.facet(yo), a.state.facet(yo), a.view.viewport.from, a.view.viewport.to);
    if (e == t)
      for (let s of this.gutters)
        s.update(a) && (i = !0);
    else {
      i = !0;
      let s = [];
      for (let n of t) {
        let o = e.indexOf(n);
        o < 0 ? s.push(new Og(this.view, n)) : (this.gutters[o].update(a), s.push(this.gutters[o]));
      }
      for (let n of this.gutters)
        n.dom.remove(), s.indexOf(n) < 0 && n.destroy();
      for (let n of s)
        this.dom.appendChild(n.dom);
      this.gutters = s;
    }
    return i;
  }
  destroy() {
    for (let a of this.gutters)
      a.destroy();
    this.dom.remove();
  }
}, {
  provide: /* @__PURE__ */ Qt.scrollMargins.from((a) => a.gutters.length == 0 || !a.fixed ? null : a.view.textDirection == Ne.LTR ? { left: a.dom.offsetWidth } : { right: a.dom.offsetWidth })
});
function yg(a) {
  return Array.isArray(a) ? a : [a];
}
function wO(a, e, t) {
  for (; a.value && a.from <= t; )
    a.from == t && e.push(a.value), a.next();
}
class EN {
  constructor(e, t, i) {
    this.gutter = e, this.height = i, this.localMarkers = [], this.i = 0, this.cursor = ze.iter(e.markers, t.from);
  }
  line(e, t, i) {
    this.localMarkers.length && (this.localMarkers = []), wO(this.cursor, this.localMarkers, t.from);
    let s = i.length ? this.localMarkers.concat(i) : this.localMarkers, n = this.gutter.config.lineMarker(e, t, s);
    n && s.unshift(n);
    let o = this.gutter;
    if (s.length == 0 && !o.config.renderEmptyElements)
      return;
    let l = t.top - this.height;
    if (this.i == o.elements.length) {
      let c = new SO(e, t.height, l, s);
      o.elements.push(c), o.dom.appendChild(c.dom);
    } else
      o.elements[this.i].update(e, t.height, l, s);
    this.height = t.bottom, this.i++;
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let t = e.elements.pop();
      e.dom.removeChild(t.dom), t.destroy();
    }
  }
}
class Og {
  constructor(e, t) {
    this.view = e, this.config = t, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let i in t.domEventHandlers)
      this.dom.addEventListener(i, (s) => {
        let n = e.lineBlockAtHeight(s.clientY - e.documentTop);
        t.domEventHandlers[i](e, n, s) && s.preventDefault();
      });
    this.markers = yg(t.markers(e)), t.initialSpacer && (this.spacer = new SO(e, 0, 0, [t.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let t = this.markers;
    if (this.markers = yg(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let s = this.config.updateSpacer(this.spacer.markers[0], e);
      s != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [s]);
    }
    let i = e.view.viewport;
    return !ze.eq(this.markers, t, i.from, i.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class SO {
  constructor(e, t, i, s) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.update(e, t, i, s);
  }
  update(e, t, i, s) {
    this.height != t && (this.dom.style.height = (this.height = t) + "px"), this.above != i && (this.dom.style.marginTop = (this.above = i) ? i + "px" : ""), PN(this.markers, s) || this.setMarkers(e, s);
  }
  setMarkers(e, t) {
    let i = "cm-gutterElement", s = this.dom.firstChild;
    for (let n = 0, o = 0; ; ) {
      let l = o, c = n < t.length ? t[n++] : null, d = !1;
      if (c) {
        let f = c.elementClass;
        f && (i += " " + f);
        for (let p = o; p < this.markers.length; p++)
          if (this.markers[p].compare(c)) {
            l = p, d = !0;
            break;
          }
      } else
        l = this.markers.length;
      for (; o < l; ) {
        let f = this.markers[o++];
        if (f.toDOM) {
          f.destroy(s);
          let p = s.nextSibling;
          s.remove(), s = p;
        }
      }
      if (!c)
        break;
      c.toDOM && (d ? s = s.nextSibling : this.dom.insertBefore(c.toDOM(e), s)), d && o++;
    }
    this.dom.className = i, this.markers = t;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function PN(a, e) {
  if (a.length != e.length)
    return !1;
  for (let t = 0; t < a.length; t++)
    if (!a[t].compare(e[t]))
      return !1;
  return !0;
}
const LN = /* @__PURE__ */ be.define(), Ln = /* @__PURE__ */ be.define({
  combine(a) {
    return Ns(a, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, t) {
        let i = Object.assign({}, e);
        for (let s in t) {
          let n = i[s], o = t[s];
          i[s] = n ? (l, c, d) => n(l, c, d) || o(l, c, d) : o;
        }
        return i;
      }
    });
  }
});
class Dc extends os {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function Rc(a, e) {
  return a.state.facet(Ln).formatNumber(e, a.state);
}
const MN = /* @__PURE__ */ Nr.compute([Ln], (a) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(LN);
  },
  lineMarker(e, t, i) {
    return i.some((s) => s.toDOM) ? null : new Dc(Rc(e, e.state.doc.lineAt(t.from).number));
  },
  lineMarkerChange: (e) => e.startState.facet(Ln) != e.state.facet(Ln),
  initialSpacer(e) {
    return new Dc(Rc(e, xg(e.state.doc.lines)));
  },
  updateSpacer(e, t) {
    let i = Rc(t.view, xg(t.view.state.doc.lines));
    return i == e.number ? e : new Dc(i);
  },
  domEventHandlers: a.facet(Ln).domEventHandlers
}));
function DN(a = {}) {
  return [
    Ln.of(a),
    xO(),
    MN
  ];
}
function xg(a) {
  let e = 9;
  for (; e < a; )
    e = e * 10 + 9;
  return e;
}
const RN = /* @__PURE__ */ new class extends os {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), IN = /* @__PURE__ */ yo.compute(["selection"], (a) => {
  let e = [], t = -1;
  for (let i of a.selection.ranges)
    if (i.empty) {
      let s = a.doc.lineAt(i.head).from;
      s > t && (t = s, e.push(RN.range(s)));
    }
  return ze.of(e);
});
function QN() {
  return IN;
}
function kO(a, e) {
  let t = e.mapPos(a.from, 1), i = e.mapPos(a.to, -1);
  return t >= i ? void 0 : { from: t, to: i };
}
const Ml = /* @__PURE__ */ _e.define({ map: kO }), Aa = /* @__PURE__ */ _e.define({ map: kO });
function _O(a) {
  let e = [];
  for (let { head: t } of a.state.selection.ranges)
    e.some((i) => i.from <= t && i.to >= t) || e.push(a.lineBlockAt(t));
  return e;
}
const ln = /* @__PURE__ */ Mt.define({
  create() {
    return me.none;
  },
  update(a, e) {
    a = a.map(e.changes);
    for (let t of e.effects)
      t.is(Ml) && !NN(a, t.value.from, t.value.to) ? a = a.update({ add: [VN.range(t.value.from, t.value.to)] }) : t.is(Aa) && (a = a.update({
        filter: (i, s) => t.value.from != i || t.value.to != s,
        filterFrom: t.value.from,
        filterTo: t.value.to
      }));
    if (e.selection) {
      let t = !1, { head: i } = e.selection.main;
      a.between(i, i, (s, n) => {
        s < i && n > i && (t = !0);
      }), t && (a = a.update({
        filterFrom: i,
        filterTo: i,
        filter: (s, n) => n <= i || s >= i
      }));
    }
    return a;
  },
  provide: (a) => Oe.decorations.from(a)
});
function Ho(a, e, t) {
  var i;
  let s = null;
  return (i = a.field(ln, !1)) === null || i === void 0 || i.between(e, t, (n, o) => {
    (!s || s.from > n) && (s = { from: n, to: o });
  }), s;
}
function NN(a, e, t) {
  let i = !1;
  return a.between(e, e, (s, n) => {
    s == e && n == t && (i = !0);
  }), i;
}
function CO(a, e) {
  return a.field(ln, !1) ? e : e.concat(_e.appendConfig.of($O()));
}
const FN = (a) => {
  for (let e of _O(a)) {
    let t = Vo(a.state, e.from, e.to);
    if (t)
      return a.dispatch({ effects: CO(a.state, [Ml.of(t), TO(a, t)]) }), !0;
  }
  return !1;
}, WN = (a) => {
  if (!a.state.field(ln, !1))
    return !1;
  let e = [];
  for (let t of _O(a)) {
    let i = Ho(a.state, t.from, t.to);
    i && e.push(Aa.of(i), TO(a, i, !1));
  }
  return e.length && a.dispatch({ effects: e }), e.length > 0;
};
function TO(a, e, t = !0) {
  let i = a.state.doc.lineAt(e.from).number, s = a.state.doc.lineAt(e.to).number;
  return Oe.announce.of(`${a.state.phrase(t ? "Folded lines" : "Unfolded lines")} ${i} ${a.state.phrase("to")} ${s}.`);
}
const BN = (a) => {
  let { state: e } = a, t = [];
  for (let i = 0; i < e.doc.length; ) {
    let s = a.lineBlockAt(i), n = Vo(e, s.from, s.to);
    n && t.push(Ml.of(n)), i = (n ? a.lineBlockAt(n.to) : s).to + 1;
  }
  return t.length && a.dispatch({ effects: CO(a.state, t) }), !!t.length;
}, zN = (a) => {
  let e = a.state.field(ln, !1);
  if (!e || !e.size)
    return !1;
  let t = [];
  return e.between(0, a.state.doc.length, (i, s) => {
    t.push(Aa.of({ from: i, to: s }));
  }), a.dispatch({ effects: t }), !0;
}, XN = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: FN },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: WN },
  { key: "Ctrl-Alt-[", run: BN },
  { key: "Ctrl-Alt-]", run: zN }
], YN = {
  placeholderDOM: null,
  placeholderText: "…"
}, AO = /* @__PURE__ */ be.define({
  combine(a) {
    return Ns(a, YN);
  }
});
function $O(a) {
  let e = [ln, jN];
  return a && e.push(AO.of(a)), e;
}
const VN = /* @__PURE__ */ me.replace({ widget: /* @__PURE__ */ new class extends hs {
  toDOM(a) {
    let { state: e } = a, t = e.facet(AO), i = (n) => {
      let o = a.lineBlockAt(a.posAtDOM(n.target)), l = Ho(a.state, o.from, o.to);
      l && a.dispatch({ effects: Aa.of(l) }), n.preventDefault();
    };
    if (t.placeholderDOM)
      return t.placeholderDOM(a, i);
    let s = document.createElement("span");
    return s.textContent = t.placeholderText, s.setAttribute("aria-label", e.phrase("folded code")), s.title = e.phrase("unfold"), s.className = "cm-foldPlaceholder", s.onclick = i, s;
  }
}() }), HN = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {}
};
class Ic extends os {
  constructor(e, t) {
    super(), this.config = e, this.open = t;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let t = document.createElement("span");
    return t.textContent = this.open ? this.config.openText : this.config.closedText, t.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), t;
  }
}
function GN(a = {}) {
  let e = Object.assign(Object.assign({}, HN), a), t = new Ic(e, !0), i = new Ic(e, !1), s = Ot.fromClass(class {
    constructor(o) {
      this.from = o.viewport.from, this.markers = this.buildMarkers(o);
    }
    update(o) {
      (o.docChanged || o.viewportChanged || o.startState.facet(as) != o.state.facet(as) || o.startState.field(ln, !1) != o.state.field(ln, !1) || pt(o.startState) != pt(o.state)) && (this.markers = this.buildMarkers(o.view));
    }
    buildMarkers(o) {
      let l = new Ls();
      for (let c of o.viewportLineBlocks) {
        let d = Ho(o.state, c.from, c.to) ? i : Vo(o.state, c.from, c.to) ? t : null;
        d && l.add(c.from, c.from, d);
      }
      return l.finish();
    }
  }), { domEventHandlers: n } = e;
  return [
    s,
    TN({
      class: "cm-foldGutter",
      markers(o) {
        var l;
        return ((l = o.plugin(s)) === null || l === void 0 ? void 0 : l.markers) || ze.empty;
      },
      initialSpacer() {
        return new Ic(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, n), { click: (o, l, c) => {
        if (n.click && n.click(o, l, c))
          return !0;
        let d = Ho(o.state, l.from, l.to);
        if (d)
          return o.dispatch({ effects: Aa.of(d) }), !0;
        let f = Vo(o.state, l.from, l.to);
        return f ? (o.dispatch({ effects: Ml.of(f) }), !0) : !1;
      } })
    }),
    $O()
  ];
}
const jN = /* @__PURE__ */ Oe.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
}), UN = /* @__PURE__ */ Oe.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), EO = 1e4, PO = "()[]{}", LO = /* @__PURE__ */ be.define({
  combine(a) {
    return Ns(a, {
      afterCursor: !0,
      brackets: PO,
      maxScanDistance: EO
    });
  }
}), ZN = /* @__PURE__ */ me.mark({ class: "cm-matchingBracket" }), qN = /* @__PURE__ */ me.mark({ class: "cm-nonmatchingBracket" }), KN = /* @__PURE__ */ Mt.define({
  create() {
    return me.none;
  },
  update(a, e) {
    if (!e.docChanged && !e.selection)
      return a;
    let t = [], i = e.state.facet(LO);
    for (let s of e.state.selection.ranges) {
      if (!s.empty)
        continue;
      let n = Bi(e.state, s.head, -1, i) || s.head > 0 && Bi(e.state, s.head - 1, 1, i) || i.afterCursor && (Bi(e.state, s.head, 1, i) || s.head < e.state.doc.length && Bi(e.state, s.head + 1, -1, i));
      if (!n)
        continue;
      let o = n.matched ? ZN : qN;
      t.push(o.range(n.start.from, n.start.to)), n.end && t.push(o.range(n.end.from, n.end.to));
    }
    return me.set(t, !0);
  },
  provide: (a) => Oe.decorations.from(a)
}), JN = [
  KN,
  UN
];
function eF(a = {}) {
  return [LO.of(a), JN];
}
function td(a, e, t) {
  let i = a.prop(e < 0 ? Ce.openedBy : Ce.closedBy);
  if (i)
    return i;
  if (a.name.length == 1) {
    let s = t.indexOf(a.name);
    if (s > -1 && s % 2 == (e < 0 ? 1 : 0))
      return [t[s + e]];
  }
  return null;
}
function Bi(a, e, t, i = {}) {
  let s = i.maxScanDistance || EO, n = i.brackets || PO, o = pt(a), l = o.resolveInner(e, t);
  for (let c = l; c; c = c.parent) {
    let d = td(c.type, t, n);
    if (d && c.from < c.to)
      return tF(a, e, t, c, d, n);
  }
  return iF(a, e, t, o, l.type, s, n);
}
function tF(a, e, t, i, s, n) {
  let o = i.parent, l = { from: i.from, to: i.to }, c = 0, d = o == null ? void 0 : o.cursor;
  if (d && (t < 0 ? d.childBefore(i.from) : d.childAfter(i.to)))
    do
      if (t < 0 ? d.to <= i.from : d.from >= i.to) {
        if (c == 0 && s.indexOf(d.type.name) > -1 && d.from < d.to)
          return { start: l, end: { from: d.from, to: d.to }, matched: !0 };
        if (td(d.type, t, n))
          c++;
        else if (td(d.type, -t, n) && (c--, c == 0))
          return {
            start: l,
            end: d.from == d.to ? void 0 : { from: d.from, to: d.to },
            matched: !1
          };
      }
    while (t < 0 ? d.prevSibling() : d.nextSibling());
  return { start: l, matched: !1 };
}
function iF(a, e, t, i, s, n, o) {
  let l = t < 0 ? a.sliceDoc(e - 1, e) : a.sliceDoc(e, e + 1), c = o.indexOf(l);
  if (c < 0 || c % 2 == 0 != t > 0)
    return null;
  let d = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e }, f = a.doc.iterRange(e, t > 0 ? a.doc.length : 0), p = 0;
  for (let m = 0; !f.next().done && m <= n; ) {
    let v = f.value;
    t < 0 && (m += v.length);
    let r = e + m * t;
    for (let h = t > 0 ? 0 : v.length - 1, u = t > 0 ? v.length : -1; h != u; h += t) {
      let g = o.indexOf(v[h]);
      if (!(g < 0 || i.resolve(r + h, 1).type != s))
        if (g % 2 == 0 == t > 0)
          p++;
        else {
          if (p == 1)
            return { start: d, end: { from: r + h, to: r + h + 1 }, matched: g >> 1 == c >> 1 };
          p--;
        }
    }
    t > 0 && (m += v.length);
  }
  return f.done ? { start: d, matched: !1 } : null;
}
function ur(a, e) {
  return ee.create(a.ranges.map(e), a.mainIndex);
}
function Hi(a, e) {
  return a.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function ds({ state: a, dispatch: e }, t) {
  let i = ur(a.selection, t);
  return i.eq(a.selection) ? !1 : (e(Hi(a, i)), !0);
}
function Dl(a, e) {
  return ee.cursor(e ? a.to : a.from);
}
function MO(a, e) {
  return ds(a, (t) => t.empty ? a.moveByChar(t, e) : Dl(t, e));
}
const DO = (a) => MO(a, a.textDirection != Ne.LTR), RO = (a) => MO(a, a.textDirection == Ne.LTR);
function IO(a, e) {
  return ds(a, (t) => t.empty ? a.moveByGroup(t, e) : Dl(t, e));
}
const sF = (a) => IO(a, a.textDirection != Ne.LTR), nF = (a) => IO(a, a.textDirection == Ne.LTR);
function rF(a, e, t) {
  if (e.type.prop(t))
    return !0;
  let i = e.to - e.from;
  return i && (i > 2 || /[^\s,.;:]/.test(a.sliceDoc(e.from, e.to))) || e.firstChild;
}
function Rl(a, e, t) {
  let i = pt(a).resolveInner(e.head), s = t ? Ce.closedBy : Ce.openedBy;
  for (let c = e.head; ; ) {
    let d = t ? i.childAfter(c) : i.childBefore(c);
    if (!d)
      break;
    rF(a, d, s) ? i = d : c = t ? d.to : d.from;
  }
  let n = i.type.prop(s), o, l;
  return n && (o = t ? Bi(a, i.from, 1) : Bi(a, i.to, -1)) && o.matched ? l = t ? o.end.to : o.end.from : l = t ? i.to : i.from, ee.cursor(l, t ? -1 : 1);
}
const aF = (a) => ds(a, (e) => Rl(a.state, e, a.textDirection != Ne.LTR)), oF = (a) => ds(a, (e) => Rl(a.state, e, a.textDirection == Ne.LTR));
function QO(a, e) {
  return ds(a, (t) => {
    if (!t.empty)
      return Dl(t, e);
    let i = a.moveVertically(t, e);
    return i.head != t.head ? i : a.moveToLineBoundary(t, e);
  });
}
const NO = (a) => QO(a, !1), FO = (a) => QO(a, !0);
function WO(a, e) {
  let { state: t } = a, i = ur(t.selection, (o) => o.empty ? a.moveVertically(o, e, a.dom.clientHeight) : Dl(o, e));
  if (i.eq(t.selection))
    return !1;
  let s = a.coordsAtPos(t.selection.main.head), n = a.scrollDOM.getBoundingClientRect();
  return a.dispatch(Hi(t, i), {
    effects: s && s.top > n.top && s.bottom < n.bottom ? Oe.scrollIntoView(i.main.head, { y: "start", yMargin: s.top - n.top }) : void 0
  }), !0;
}
const wg = (a) => WO(a, !1), id = (a) => WO(a, !0);
function Il(a, e, t) {
  let i = a.lineBlockAt(e.head), s = a.moveToLineBoundary(e, t);
  if (s.head == e.head && s.head != (t ? i.to : i.from) && (s = a.moveToLineBoundary(e, t, !1)), !t && s.head == i.from && i.length) {
    let n = /^\s*/.exec(a.state.sliceDoc(i.from, Math.min(i.from + 100, i.to)))[0].length;
    n && e.head != i.from + n && (s = ee.cursor(i.from + n));
  }
  return s;
}
const Sg = (a) => ds(a, (e) => Il(a, e, !0)), kg = (a) => ds(a, (e) => Il(a, e, !1)), lF = (a) => ds(a, (e) => ee.cursor(a.lineBlockAt(e.head).from, 1)), cF = (a) => ds(a, (e) => ee.cursor(a.lineBlockAt(e.head).to, -1));
function hF(a, e, t) {
  let i = !1, s = ur(a.selection, (n) => {
    let o = Bi(a, n.head, -1) || Bi(a, n.head, 1) || n.head > 0 && Bi(a, n.head - 1, 1) || n.head < a.doc.length && Bi(a, n.head + 1, -1);
    if (!o || !o.end)
      return n;
    i = !0;
    let l = o.start.from == n.head ? o.end.to : o.end.from;
    return t ? ee.range(n.anchor, l) : ee.cursor(l);
  });
  return i ? (e(Hi(a, s)), !0) : !1;
}
const dF = ({ state: a, dispatch: e }) => hF(a, e, !1);
function Gi(a, e) {
  let t = ur(a.state.selection, (i) => {
    let s = e(i);
    return ee.range(i.anchor, s.head, s.goalColumn);
  });
  return t.eq(a.state.selection) ? !1 : (a.dispatch(Hi(a.state, t)), !0);
}
function BO(a, e) {
  return Gi(a, (t) => a.moveByChar(t, e));
}
const zO = (a) => BO(a, a.textDirection != Ne.LTR), XO = (a) => BO(a, a.textDirection == Ne.LTR);
function YO(a, e) {
  return Gi(a, (t) => a.moveByGroup(t, e));
}
const uF = (a) => YO(a, a.textDirection != Ne.LTR), fF = (a) => YO(a, a.textDirection == Ne.LTR), pF = (a) => Gi(a, (e) => Rl(a.state, e, a.textDirection != Ne.LTR)), gF = (a) => Gi(a, (e) => Rl(a.state, e, a.textDirection == Ne.LTR));
function VO(a, e) {
  return Gi(a, (t) => a.moveVertically(t, e));
}
const HO = (a) => VO(a, !1), GO = (a) => VO(a, !0);
function jO(a, e) {
  return Gi(a, (t) => a.moveVertically(t, e, a.dom.clientHeight));
}
const _g = (a) => jO(a, !1), Cg = (a) => jO(a, !0), Tg = (a) => Gi(a, (e) => Il(a, e, !0)), Ag = (a) => Gi(a, (e) => Il(a, e, !1)), mF = (a) => Gi(a, (e) => ee.cursor(a.lineBlockAt(e.head).from)), bF = (a) => Gi(a, (e) => ee.cursor(a.lineBlockAt(e.head).to)), $g = ({ state: a, dispatch: e }) => (e(Hi(a, { anchor: 0 })), !0), Eg = ({ state: a, dispatch: e }) => (e(Hi(a, { anchor: a.doc.length })), !0), Pg = ({ state: a, dispatch: e }) => (e(Hi(a, { anchor: a.selection.main.anchor, head: 0 })), !0), Lg = ({ state: a, dispatch: e }) => (e(Hi(a, { anchor: a.selection.main.anchor, head: a.doc.length })), !0), vF = ({ state: a, dispatch: e }) => (e(a.update({ selection: { anchor: 0, head: a.doc.length }, userEvent: "select" })), !0), yF = ({ state: a, dispatch: e }) => {
  let t = Fl(a).map(({ from: i, to: s }) => ee.range(i, Math.min(s + 1, a.doc.length)));
  return e(a.update({ selection: ee.create(t), userEvent: "select" })), !0;
}, OF = ({ state: a, dispatch: e }) => {
  let t = ur(a.selection, (i) => {
    var s;
    let n = pt(a).resolveInner(i.head, 1);
    for (; !(n.from < i.from && n.to >= i.to || n.to > i.to && n.from <= i.from || !(!((s = n.parent) === null || s === void 0) && s.parent)); )
      n = n.parent;
    return ee.range(n.to, n.from);
  });
  return e(Hi(a, t)), !0;
}, xF = ({ state: a, dispatch: e }) => {
  let t = a.selection, i = null;
  return t.ranges.length > 1 ? i = ee.create([t.main]) : t.main.empty || (i = ee.create([ee.cursor(t.main.head)])), i ? (e(Hi(a, i)), !0) : !1;
};
function Ql({ state: a, dispatch: e }, t) {
  if (a.readOnly)
    return !1;
  let i = "delete.selection", s = a.changeByRange((n) => {
    let { from: o, to: l } = n;
    if (o == l) {
      let c = t(o);
      c < o ? i = "delete.backward" : c > o && (i = "delete.forward"), o = Math.min(o, c), l = Math.max(l, c);
    }
    return o == l ? { range: n } : { changes: { from: o, to: l }, range: ee.cursor(o) };
  });
  return s.changes.empty ? !1 : (e(a.update(s, { scrollIntoView: !0, userEvent: i })), !0);
}
function Nl(a, e, t) {
  if (a instanceof Oe)
    for (let i of a.pluginField(Qt.atomicRanges))
      i.between(e, e, (s, n) => {
        s < e && n > e && (e = t ? n : s);
      });
  return e;
}
const UO = (a, e) => Ql(a, (t) => {
  let { state: i } = a, s = i.doc.lineAt(t), n, o;
  if (!e && t > s.from && t < s.from + 200 && !/[^ \t]/.test(n = s.text.slice(0, t - s.from))) {
    if (n[n.length - 1] == "	")
      return t - 1;
    let l = Sa(n, i.tabSize), c = l % Yo(i) || Yo(i);
    for (let d = 0; d < c && n[n.length - 1 - d] == " "; d++)
      t--;
    o = t;
  } else
    o = ti(s.text, t - s.from, e, e) + s.from, o == t && s.number != (e ? i.doc.lines : 1) && (o += e ? 1 : -1);
  return Nl(a, o, e);
}), sd = (a) => UO(a, !1), ZO = (a) => UO(a, !0), qO = (a, e) => Ql(a, (t) => {
  let i = t, { state: s } = a, n = s.doc.lineAt(i), o = s.charCategorizer(i);
  for (let l = null; ; ) {
    if (i == (e ? n.to : n.from)) {
      i == t && n.number != (e ? s.doc.lines : 1) && (i += e ? 1 : -1);
      break;
    }
    let c = ti(n.text, i - n.from, e) + n.from, d = n.text.slice(Math.min(i, c) - n.from, Math.max(i, c) - n.from), f = o(d);
    if (l != null && f != l)
      break;
    (d != " " || i != t) && (l = f), i = c;
  }
  return Nl(a, i, e);
}), KO = (a) => qO(a, !1), wF = (a) => qO(a, !0), JO = (a) => Ql(a, (e) => {
  let t = a.lineBlockAt(e).to;
  return Nl(a, e < t ? t : Math.min(a.state.doc.length, e + 1), !0);
}), SF = (a) => Ql(a, (e) => {
  let t = a.lineBlockAt(e).from;
  return Nl(a, e > t ? t : Math.max(0, e - 1), !1);
}), kF = ({ state: a, dispatch: e }) => {
  if (a.readOnly)
    return !1;
  let t = a.changeByRange((i) => ({
    changes: { from: i.from, to: i.to, insert: We.of(["", ""]) },
    range: ee.cursor(i.from)
  }));
  return e(a.update(t, { scrollIntoView: !0, userEvent: "input" })), !0;
}, _F = ({ state: a, dispatch: e }) => {
  if (a.readOnly)
    return !1;
  let t = a.changeByRange((i) => {
    if (!i.empty || i.from == 0 || i.from == a.doc.length)
      return { range: i };
    let s = i.from, n = a.doc.lineAt(s), o = s == n.from ? s - 1 : ti(n.text, s - n.from, !1) + n.from, l = s == n.to ? s + 1 : ti(n.text, s - n.from, !0) + n.from;
    return {
      changes: { from: o, to: l, insert: a.doc.slice(s, l).append(a.doc.slice(o, s)) },
      range: ee.cursor(l)
    };
  });
  return t.changes.empty ? !1 : (e(a.update(t, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function Fl(a) {
  let e = [], t = -1;
  for (let i of a.selection.ranges) {
    let s = a.doc.lineAt(i.from), n = a.doc.lineAt(i.to);
    if (!i.empty && i.to == n.from && (n = a.doc.lineAt(i.to - 1)), t >= s.number) {
      let o = e[e.length - 1];
      o.to = n.to, o.ranges.push(i);
    } else
      e.push({ from: s.from, to: n.to, ranges: [i] });
    t = n.number + 1;
  }
  return e;
}
function ex(a, e, t) {
  if (a.readOnly)
    return !1;
  let i = [], s = [];
  for (let n of Fl(a)) {
    if (t ? n.to == a.doc.length : n.from == 0)
      continue;
    let o = a.doc.lineAt(t ? n.to + 1 : n.from - 1), l = o.length + 1;
    if (t) {
      i.push({ from: n.to, to: o.to }, { from: n.from, insert: o.text + a.lineBreak });
      for (let c of n.ranges)
        s.push(ee.range(Math.min(a.doc.length, c.anchor + l), Math.min(a.doc.length, c.head + l)));
    } else {
      i.push({ from: o.from, to: n.from }, { from: n.to, insert: a.lineBreak + o.text });
      for (let c of n.ranges)
        s.push(ee.range(c.anchor - l, c.head - l));
    }
  }
  return i.length ? (e(a.update({
    changes: i,
    scrollIntoView: !0,
    selection: ee.create(s, a.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const CF = ({ state: a, dispatch: e }) => ex(a, e, !1), TF = ({ state: a, dispatch: e }) => ex(a, e, !0);
function tx(a, e, t) {
  if (a.readOnly)
    return !1;
  let i = [];
  for (let s of Fl(a))
    t ? i.push({ from: s.from, insert: a.doc.slice(s.from, s.to) + a.lineBreak }) : i.push({ from: s.to, insert: a.lineBreak + a.doc.slice(s.from, s.to) });
  return e(a.update({ changes: i, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const AF = ({ state: a, dispatch: e }) => tx(a, e, !1), $F = ({ state: a, dispatch: e }) => tx(a, e, !0), EF = (a) => {
  if (a.state.readOnly)
    return !1;
  let { state: e } = a, t = e.changes(Fl(e).map(({ from: s, to: n }) => (s > 0 ? s-- : n < e.doc.length && n++, { from: s, to: n }))), i = ur(e.selection, (s) => a.moveVertically(s, !0)).map(t);
  return a.dispatch({ changes: t, selection: i, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function PF(a, e) {
  if (/\(\)|\[\]|\{\}/.test(a.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let t = pt(a).resolveInner(e), i = t.childBefore(e), s = t.childAfter(e), n;
  return i && s && i.to <= e && s.from >= e && (n = i.type.prop(Ce.closedBy)) && n.indexOf(s.name) > -1 && a.doc.lineAt(i.to).from == a.doc.lineAt(s.from).from ? { from: i.to, to: s.from } : null;
}
const LF = /* @__PURE__ */ ix(!1), MF = /* @__PURE__ */ ix(!0);
function ix(a) {
  return ({ state: e, dispatch: t }) => {
    if (e.readOnly)
      return !1;
    let i = e.changeByRange((s) => {
      let { from: n, to: o } = s, l = e.doc.lineAt(n), c = !a && n == o && PF(e, n);
      a && (n = o = (o <= l.to ? l : e.doc.lineAt(o)).to);
      let d = new El(e, { simulateBreak: n, simulateDoubleBreak: !!c }), f = su(d, n);
      for (f == null && (f = /^\s*/.exec(e.doc.lineAt(n).text)[0].length); o < l.to && /\s/.test(l.text[o - l.from]); )
        o++;
      c ? { from: n, to: o } = c : n > l.from && n < l.from + 100 && !/\S/.test(l.text.slice(0, n)) && (n = l.from);
      let p = ["", ia(e, f)];
      return c && p.push(ia(e, d.lineIndent(l.from, -1))), {
        changes: { from: n, to: o, insert: We.of(p) },
        range: ee.cursor(n + 1 + p[1].length)
      };
    });
    return t(e.update(i, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function nu(a, e) {
  let t = -1;
  return a.changeByRange((i) => {
    let s = [];
    for (let o = i.from; o <= i.to; ) {
      let l = a.doc.lineAt(o);
      l.number > t && (i.empty || i.to > l.from) && (e(l, s, i), t = l.number), o = l.to + 1;
    }
    let n = a.changes(s);
    return {
      changes: s,
      range: ee.range(n.mapPos(i.anchor, 1), n.mapPos(i.head, 1))
    };
  });
}
const DF = ({ state: a, dispatch: e }) => {
  if (a.readOnly)
    return !1;
  let t = /* @__PURE__ */ Object.create(null), i = new El(a, { overrideIndentation: (n) => {
    let o = t[n];
    return o ?? -1;
  } }), s = nu(a, (n, o, l) => {
    let c = su(i, n.from);
    if (c == null)
      return;
    /\S/.test(n.text) || (c = 0);
    let d = /^\s*/.exec(n.text)[0], f = ia(a, c);
    (d != f || l.from < n.from + d.length) && (t[n.from] = c, o.push({ from: n.from, to: n.from + d.length, insert: f }));
  });
  return s.changes.empty || e(a.update(s, { userEvent: "indent" })), !0;
}, sx = ({ state: a, dispatch: e }) => a.readOnly ? !1 : (e(a.update(nu(a, (t, i) => {
  i.push({ from: t.from, insert: a.facet($l) });
}), { userEvent: "input.indent" })), !0), nx = ({ state: a, dispatch: e }) => a.readOnly ? !1 : (e(a.update(nu(a, (t, i) => {
  let s = /^\s*/.exec(t.text)[0];
  if (!s)
    return;
  let n = Sa(s, a.tabSize), o = 0, l = ia(a, Math.max(0, n - Yo(a)));
  for (; o < s.length && o < l.length && s.charCodeAt(o) == l.charCodeAt(o); )
    o++;
  i.push({ from: t.from + o, to: t.from + s.length, insert: l.slice(o) });
}), { userEvent: "delete.dedent" })), !0), RF = [
  { key: "Ctrl-b", run: DO, shift: zO, preventDefault: !0 },
  { key: "Ctrl-f", run: RO, shift: XO },
  { key: "Ctrl-p", run: NO, shift: HO },
  { key: "Ctrl-n", run: FO, shift: GO },
  { key: "Ctrl-a", run: lF, shift: mF },
  { key: "Ctrl-e", run: cF, shift: bF },
  { key: "Ctrl-d", run: ZO },
  { key: "Ctrl-h", run: sd },
  { key: "Ctrl-k", run: JO },
  { key: "Ctrl-Alt-h", run: KO },
  { key: "Ctrl-o", run: kF },
  { key: "Ctrl-t", run: _F },
  { key: "Ctrl-v", run: id }
], IF = /* @__PURE__ */ [
  { key: "ArrowLeft", run: DO, shift: zO, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: sF, shift: uF },
  { mac: "Cmd-ArrowLeft", run: kg, shift: Ag },
  { key: "ArrowRight", run: RO, shift: XO, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: nF, shift: fF },
  { mac: "Cmd-ArrowRight", run: Sg, shift: Tg },
  { key: "ArrowUp", run: NO, shift: HO, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: $g, shift: Pg },
  { mac: "Ctrl-ArrowUp", run: wg, shift: _g },
  { key: "ArrowDown", run: FO, shift: GO, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: Eg, shift: Lg },
  { mac: "Ctrl-ArrowDown", run: id, shift: Cg },
  { key: "PageUp", run: wg, shift: _g },
  { key: "PageDown", run: id, shift: Cg },
  { key: "Home", run: kg, shift: Ag },
  { key: "Mod-Home", run: $g, shift: Pg },
  { key: "End", run: Sg, shift: Tg },
  { key: "Mod-End", run: Eg, shift: Lg },
  { key: "Enter", run: LF },
  { key: "Mod-a", run: vF },
  { key: "Backspace", run: sd, shift: sd },
  { key: "Delete", run: ZO },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: KO },
  { key: "Mod-Delete", mac: "Alt-Delete", run: wF },
  { mac: "Mod-Backspace", run: SF },
  { mac: "Mod-Delete", run: JO }
].concat(/* @__PURE__ */ RF.map((a) => ({ mac: a.key, run: a.run, shift: a.shift }))), rx = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: aF, shift: pF },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: oF, shift: gF },
  { key: "Alt-ArrowUp", run: CF },
  { key: "Shift-Alt-ArrowUp", run: AF },
  { key: "Alt-ArrowDown", run: TF },
  { key: "Shift-Alt-ArrowDown", run: $F },
  { key: "Escape", run: xF },
  { key: "Mod-Enter", run: MF },
  { key: "Alt-l", mac: "Ctrl-l", run: yF },
  { key: "Mod-i", run: OF, preventDefault: !0 },
  { key: "Mod-[", run: nx },
  { key: "Mod-]", run: sx },
  { key: "Mod-Alt-\\", run: DF },
  { key: "Shift-Mod-k", run: EF },
  { key: "Shift-Mod-\\", run: dF }
].concat(IF), QF = { key: "Tab", run: sx, shift: nx }, Go = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>"
}, Ks = /* @__PURE__ */ _e.define({
  map(a, e) {
    let t = e.mapPos(a, -1, $t.TrackAfter);
    return t ?? void 0;
  }
}), ru = /* @__PURE__ */ _e.define({
  map(a, e) {
    return e.mapPos(a);
  }
}), au = /* @__PURE__ */ new class extends an {
}();
au.startSide = 1;
au.endSide = -1;
const ax = /* @__PURE__ */ Mt.define({
  create() {
    return ze.empty;
  },
  update(a, e) {
    if (e.selection) {
      let t = e.state.doc.lineAt(e.selection.main.head).from, i = e.startState.doc.lineAt(e.startState.selection.main.head).from;
      t != e.changes.mapPos(i, -1) && (a = ze.empty);
    }
    a = a.map(e.changes);
    for (let t of e.effects)
      t.is(Ks) ? a = a.update({ add: [au.range(t.value, t.value + 1)] }) : t.is(ru) && (a = a.update({ filter: (i) => i != t.value }));
    return a;
  }
});
function NF() {
  return [WF, ax];
}
const Qc = "()[]{}<>";
function ox(a) {
  for (let e = 0; e < Qc.length; e += 2)
    if (Qc.charCodeAt(e) == a)
      return Qc.charAt(e + 1);
  return zd(a < 128 ? a : a + 1);
}
function lx(a, e) {
  return a.languageDataAt("closeBrackets", e)[0] || Go;
}
const FF = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), WF = /* @__PURE__ */ Oe.inputHandler.of((a, e, t, i) => {
  if ((FF ? a.composing : a.compositionStarted) || a.state.readOnly)
    return !1;
  let s = a.state.selection.main;
  if (i.length > 2 || i.length == 2 && ci(Dt(i, 0)) == 1 || e != s.from || t != s.to)
    return !1;
  let n = XF(a.state, i);
  return n ? (a.dispatch(n), !0) : !1;
}), BF = ({ state: a, dispatch: e }) => {
  if (a.readOnly)
    return !1;
  let i = lx(a, a.selection.main.head).brackets || Go.brackets, s = null, n = a.changeByRange((o) => {
    if (o.empty) {
      let l = YF(a.doc, o.head);
      for (let c of i)
        if (c == l && Wl(a.doc, o.head) == ox(Dt(c, 0)))
          return {
            changes: { from: o.head - c.length, to: o.head + c.length },
            range: ee.cursor(o.head - c.length),
            userEvent: "delete.backward"
          };
    }
    return { range: s = o };
  });
  return s || e(a.update(n, { scrollIntoView: !0 })), !s;
}, zF = [
  { key: "Backspace", run: BF }
];
function XF(a, e) {
  let t = lx(a, a.selection.main.head), i = t.brackets || Go.brackets;
  for (let s of i) {
    let n = ox(Dt(s, 0));
    if (e == s)
      return n == s ? GF(a, s, i.indexOf(s + s + s) > -1) : VF(a, s, n, t.before || Go.before);
    if (e == n && cx(a, a.selection.main.from))
      return HF(a, s, n);
  }
  return null;
}
function cx(a, e) {
  let t = !1;
  return a.field(ax).between(0, a.doc.length, (i) => {
    i == e && (t = !0);
  }), t;
}
function Wl(a, e) {
  let t = a.sliceString(e, e + 2);
  return t.slice(0, ci(Dt(t, 0)));
}
function YF(a, e) {
  let t = a.sliceString(e - 2, e);
  return ci(Dt(t, 0)) == t.length ? t : t.slice(1);
}
function VF(a, e, t, i) {
  let s = null, n = a.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: t, from: o.to }],
        effects: Ks.of(o.to + e.length),
        range: ee.range(o.anchor + e.length, o.head + e.length)
      };
    let l = Wl(a.doc, o.head);
    return !l || /\s/.test(l) || i.indexOf(l) > -1 ? {
      changes: { insert: e + t, from: o.head },
      effects: Ks.of(o.head + e.length),
      range: ee.cursor(o.head + e.length)
    } : { range: s = o };
  });
  return s ? null : a.update(n, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function HF(a, e, t) {
  let i = null, s = a.selection.ranges.map((n) => n.empty && Wl(a.doc, n.head) == t ? ee.cursor(n.head + t.length) : i = n);
  return i ? null : a.update({
    selection: ee.create(s, a.selection.mainIndex),
    scrollIntoView: !0,
    effects: a.selection.ranges.map(({ from: n }) => ru.of(n))
  });
}
function GF(a, e, t) {
  let i = null, s = a.changeByRange((n) => {
    if (!n.empty)
      return {
        changes: [{ insert: e, from: n.from }, { insert: e, from: n.to }],
        effects: Ks.of(n.to + e.length),
        range: ee.range(n.anchor + e.length, n.head + e.length)
      };
    let o = n.head, l = Wl(a.doc, o);
    if (l == e) {
      if (Mg(a, o))
        return {
          changes: { insert: e + e, from: o },
          effects: Ks.of(o + e.length),
          range: ee.cursor(o + e.length)
        };
      if (cx(a, o)) {
        let c = t && a.sliceDoc(o, o + e.length * 3) == e + e + e;
        return {
          range: ee.cursor(o + e.length * (c ? 3 : 1)),
          effects: ru.of(o)
        };
      }
    } else {
      if (t && a.sliceDoc(o - 2 * e.length, o) == e + e && Mg(a, o - 2 * e.length))
        return {
          changes: { insert: e + e + e + e, from: o },
          effects: Ks.of(o + e.length),
          range: ee.cursor(o + e.length)
        };
      if (a.charCategorizer(o)(l) != Wt.Word) {
        let c = a.sliceDoc(o - 1, o);
        if (c != e && a.charCategorizer(o)(c) != Wt.Word && !jF(a, o, e))
          return {
            changes: { insert: e + e, from: o },
            effects: Ks.of(o + e.length),
            range: ee.cursor(o + e.length)
          };
      }
    }
    return { range: i = n };
  });
  return i ? null : a.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Mg(a, e) {
  let t = pt(a).resolveInner(e + 1);
  return t.parent && t.from == e;
}
function jF(a, e, t) {
  let i = pt(a).resolveInner(e, -1);
  for (let s = 0; s < 5; s++) {
    if (a.sliceDoc(i.from, i.from + t.length) == t)
      return !0;
    let n = i.to == e && i.parent;
    if (!n)
      break;
    i = n;
  }
  return !1;
}
const Dg = /* @__PURE__ */ be.define({
  combine(a) {
    let e, t;
    for (let i of a)
      e = e || i.topContainer, t = t || i.bottomContainer;
    return { topContainer: e, bottomContainer: t };
  }
});
function sa(a, e) {
  let t = a.plugin(hx), i = t ? t.specs.indexOf(e) : -1;
  return i > -1 ? t.panels[i] : null;
}
const hx = /* @__PURE__ */ Ot.fromClass(class {
  constructor(a) {
    this.input = a.state.facet(na), this.specs = this.input.filter((t) => t), this.panels = this.specs.map((t) => t(a));
    let e = a.state.facet(Dg);
    this.top = new eo(a, !0, e.topContainer), this.bottom = new eo(a, !1, e.bottomContainer), this.top.sync(this.panels.filter((t) => t.top)), this.bottom.sync(this.panels.filter((t) => !t.top));
    for (let t of this.panels)
      t.dom.classList.add("cm-panel"), t.mount && t.mount();
  }
  update(a) {
    let e = a.state.facet(Dg);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new eo(a.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new eo(a.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let t = a.state.facet(na);
    if (t != this.input) {
      let i = t.filter((c) => c), s = [], n = [], o = [], l = [];
      for (let c of i) {
        let d = this.specs.indexOf(c), f;
        d < 0 ? (f = c(a.view), l.push(f)) : (f = this.panels[d], f.update && f.update(a)), s.push(f), (f.top ? n : o).push(f);
      }
      this.specs = i, this.panels = s, this.top.sync(n), this.bottom.sync(o);
      for (let c of l)
        c.dom.classList.add("cm-panel"), c.mount && c.mount();
    } else
      for (let i of this.panels)
        i.update && i.update(a);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: /* @__PURE__ */ Qt.scrollMargins.from((a) => ({ top: a.top.scrollMargin(), bottom: a.bottom.scrollMargin() }))
});
class eo {
  constructor(e, t, i) {
    this.view = e, this.top = t, this.container = i, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let t of this.panels)
      t.destroy && e.indexOf(t) < 0 && t.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let t = this.container || this.view.dom;
      t.insertBefore(this.dom, this.top ? t.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let t of this.panels)
      if (t.dom.parentNode == this.dom) {
        for (; e != t.dom; )
          e = Rg(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(t.dom, e);
    for (; e; )
      e = Rg(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function Rg(a) {
  let e = a.nextSibling;
  return a.remove(), e;
}
const UF = /* @__PURE__ */ Oe.baseTheme({
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  }
}), na = /* @__PURE__ */ be.define({
  enables: [hx, UF]
});
function Ue() {
  var a = arguments[0];
  typeof a == "string" && (a = document.createElement(a));
  var e = 1, t = arguments[1];
  if (t && typeof t == "object" && t.nodeType == null && !Array.isArray(t)) {
    for (var i in t)
      if (Object.prototype.hasOwnProperty.call(t, i)) {
        var s = t[i];
        typeof s == "string" ? a.setAttribute(i, s) : s != null && (a[i] = s);
      }
    e++;
  }
  for (; e < arguments.length; e++)
    dx(a, arguments[e]);
  return a;
}
function dx(a, e) {
  if (typeof e == "string")
    a.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null)
      a.appendChild(e);
    else if (Array.isArray(e))
      for (var t = 0; t < e.length; t++)
        dx(a, e[t]);
    else
      throw new RangeError("Unsupported child node: " + e);
}
const Ig = typeof String.prototype.normalize == "function" ? (a) => a.normalize("NFKD") : (a) => a;
class qn {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, t, i = 0, s = e.length, n) {
    this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(i, s), this.bufferStart = i, this.normalize = n ? (o) => n(Ig(o)) : Ig, this.query = this.normalize(t);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return Dt(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let t = zd(e), i = this.bufferStart + this.bufferPos;
      this.bufferPos += ci(e);
      let s = this.normalize(t);
      for (let n = 0, o = i; ; n++) {
        let l = s.charCodeAt(n), c = this.match(l, o);
        if (c)
          return this.value = c, this;
        if (n == s.length - 1)
          break;
        o == i && n < t.length && t.charCodeAt(n) == l && o++;
      }
    }
  }
  match(e, t) {
    let i = null;
    for (let s = 0; s < this.matches.length; s += 2) {
      let n = this.matches[s], o = !1;
      this.query.charCodeAt(n) == e && (n == this.query.length - 1 ? i = { from: this.matches[s + 1], to: t + 1 } : (this.matches[s]++, o = !0)), o || (this.matches.splice(s, 2), s -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = { from: t, to: t + 1 } : this.matches.push(1, t)), i;
  }
}
typeof Symbol < "u" && (qn.prototype[Symbol.iterator] = function() {
  return this;
});
const ux = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, ou = "gm" + (/x/.unicode == null ? "" : "u");
class fx {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, t, i, s = 0, n = e.length) {
    if (this.to = n, this.curLine = "", this.done = !1, this.value = ux, /\\[sWDnr]|\n|\r|\[\^/.test(t))
      return new px(e, t, i, s, n);
    this.re = new RegExp(t, ou + (i != null && i.ignoreCase ? "i" : "")), this.iter = e.iter();
    let o = e.lineAt(s);
    this.curLineStart = o.from, this.matchPos = s, this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let t = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (t) {
        let i = this.curLineStart + t.index, s = i + t[0].length;
        if (this.matchPos = s + (i == s ? 1 : 0), i == this.curLine.length && this.nextLine(), i < s || i > this.value.to)
          return this.value = { from: i, to: s, match: t }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const Nc = /* @__PURE__ */ new WeakMap();
class Wn {
  constructor(e, t) {
    this.from = e, this.text = t;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, t, i) {
    let s = Nc.get(e);
    if (!s || s.from >= i || s.to <= t) {
      let l = new Wn(t, e.sliceString(t, i));
      return Nc.set(e, l), l;
    }
    if (s.from == t && s.to == i)
      return s;
    let { text: n, from: o } = s;
    return o > t && (n = e.sliceString(t, o) + n, o = t), s.to < i && (n += e.sliceString(s.to, i)), Nc.set(e, new Wn(o, n)), new Wn(t, n.slice(t - o, i - o));
  }
}
class px {
  constructor(e, t, i, s, n) {
    this.text = e, this.to = n, this.done = !1, this.value = ux, this.matchPos = s, this.re = new RegExp(t, ou + (i != null && i.ignoreCase ? "i" : "")), this.flat = Wn.get(e, s, this.chunkEnd(
      s + 5e3
      /* Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, t = this.re.exec(this.flat.text);
      if (t && !t[0] && t.index == e && (this.re.lastIndex = e + 1, t = this.re.exec(this.flat.text)), t && this.flat.to < this.to && t.index + t[0].length > this.flat.text.length - 10 && (t = null), t) {
        let i = this.flat.from + t.index, s = i + t[0].length;
        return this.value = { from: i, to: s, match: t }, this.matchPos = s + (i == s ? 1 : 0), this;
      } else {
        if (this.flat.to == this.to)
          return this.done = !0, this;
        this.flat = Wn.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
      }
    }
  }
}
typeof Symbol < "u" && (fx.prototype[Symbol.iterator] = px.prototype[Symbol.iterator] = function() {
  return this;
});
function ZF(a) {
  try {
    return new RegExp(a, ou), !0;
  } catch {
    return !1;
  }
}
function nd(a) {
  let e = Ue("input", { class: "cm-textfield", name: "line" }), t = Ue("form", {
    class: "cm-gotoLine",
    onkeydown: (s) => {
      s.keyCode == 27 ? (s.preventDefault(), a.dispatch({ effects: jo.of(!1) }), a.focus()) : s.keyCode == 13 && (s.preventDefault(), i());
    },
    onsubmit: (s) => {
      s.preventDefault(), i();
    }
  }, Ue("label", a.state.phrase("Go to line"), ": ", e), " ", Ue("button", { class: "cm-button", type: "submit" }, a.state.phrase("go")));
  function i() {
    let s = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(e.value);
    if (!s)
      return;
    let { state: n } = a, o = n.doc.lineAt(n.selection.main.head), [, l, c, d, f] = s, p = d ? +d.slice(1) : 0, m = c ? +c : o.number;
    if (c && f) {
      let r = m / 100;
      l && (r = r * (l == "-" ? -1 : 1) + o.number / n.doc.lines), m = Math.round(n.doc.lines * r);
    } else
      c && l && (m = m * (l == "-" ? -1 : 1) + o.number);
    let v = n.doc.line(Math.max(1, Math.min(n.doc.lines, m)));
    a.dispatch({
      effects: jo.of(!1),
      selection: ee.cursor(v.from + Math.max(0, Math.min(p, v.length))),
      scrollIntoView: !0
    }), a.focus();
  }
  return { dom: t, pos: -10 };
}
const jo = /* @__PURE__ */ _e.define(), Qg = /* @__PURE__ */ Mt.define({
  create() {
    return !0;
  },
  update(a, e) {
    for (let t of e.effects)
      t.is(jo) && (a = t.value);
    return a;
  },
  provide: (a) => na.from(a, (e) => e ? nd : null)
}), qF = (a) => {
  let e = sa(a, nd);
  if (!e) {
    let t = [jo.of(!0)];
    a.state.field(Qg, !1) == null && t.push(_e.appendConfig.of([Qg, KF])), a.dispatch({ effects: t }), e = sa(a, nd);
  }
  return e && e.dom.querySelector("input").focus(), !0;
}, KF = /* @__PURE__ */ Oe.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
}), JF = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !0
}, gx = /* @__PURE__ */ be.define({
  combine(a) {
    return Ns(a, JF, {
      highlightWordAroundCursor: (e, t) => e || t,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function eW(a) {
  let e = [rW, nW];
  return a && e.push(gx.of(a)), e;
}
const tW = /* @__PURE__ */ me.mark({ class: "cm-selectionMatch" }), iW = /* @__PURE__ */ me.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function Ng(a, e, t, i) {
  return (t == 0 || a(e.sliceDoc(t - 1, t)) != Wt.Word) && (i == e.doc.length || a(e.sliceDoc(i, i + 1)) != Wt.Word);
}
function sW(a, e, t, i) {
  return a(e.sliceDoc(t, t + 1)) == Wt.Word && a(e.sliceDoc(i - 1, i)) == Wt.Word;
}
const nW = /* @__PURE__ */ Ot.fromClass(class {
  constructor(a) {
    this.decorations = this.getDeco(a);
  }
  update(a) {
    (a.selectionSet || a.docChanged || a.viewportChanged) && (this.decorations = this.getDeco(a.view));
  }
  getDeco(a) {
    let e = a.state.facet(gx), { state: t } = a, i = t.selection;
    if (i.ranges.length > 1)
      return me.none;
    let s = i.main, n, o = null;
    if (s.empty) {
      if (!e.highlightWordAroundCursor)
        return me.none;
      let c = t.wordAt(s.head);
      if (!c)
        return me.none;
      o = t.charCategorizer(s.head), n = t.sliceDoc(c.from, c.to);
    } else {
      let c = s.to - s.from;
      if (c < e.minSelectionLength || c > 200)
        return me.none;
      if (e.wholeWords) {
        if (n = t.sliceDoc(s.from, s.to), o = t.charCategorizer(s.head), !(Ng(o, t, s.from, s.to) && sW(o, t, s.from, s.to)))
          return me.none;
      } else if (n = t.sliceDoc(s.from, s.to).trim(), !n)
        return me.none;
    }
    let l = [];
    for (let c of a.visibleRanges) {
      let d = new qn(t.doc, n, c.from, c.to);
      for (; !d.next().done; ) {
        let { from: f, to: p } = d.value;
        if ((!o || Ng(o, t, f, p)) && (s.empty && f <= s.from && p >= s.to ? l.push(iW.range(f, p)) : (f >= s.to || p <= s.from) && l.push(tW.range(f, p)), l.length > e.maxMatches))
          return me.none;
      }
    }
    return me.set(l);
  }
}, {
  decorations: (a) => a.decorations
}), rW = /* @__PURE__ */ Oe.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), aW = ({ state: a, dispatch: e }) => {
  let { selection: t } = a, i = ee.create(t.ranges.map((s) => a.wordAt(s.head) || ee.cursor(s.head)), t.mainIndex);
  return i.eq(t) ? !1 : (e(a.update({ selection: i })), !0);
};
function oW(a, e) {
  let { main: t, ranges: i } = a.selection, s = a.wordAt(t.head), n = s && s.from == t.from && s.to == t.to;
  for (let o = !1, l = new qn(a.doc, e, i[i.length - 1].to); ; )
    if (l.next(), l.done) {
      if (o)
        return null;
      l = new qn(a.doc, e, 0, Math.max(0, i[i.length - 1].from - 1)), o = !0;
    } else {
      if (o && i.some((c) => c.from == l.value.from))
        continue;
      if (n) {
        let c = a.wordAt(l.value.from);
        if (!c || c.from != l.value.from || c.to != l.value.to)
          continue;
      }
      return l.value;
    }
}
const lW = ({ state: a, dispatch: e }) => {
  let { ranges: t } = a.selection;
  if (t.some((n) => n.from === n.to))
    return aW({ state: a, dispatch: e });
  let i = a.sliceDoc(t[0].from, t[0].to);
  if (a.selection.ranges.some((n) => a.sliceDoc(n.from, n.to) != i))
    return !1;
  let s = oW(a, i);
  return s ? (e(a.update({
    selection: a.selection.addRange(ee.range(s.from, s.to), !1),
    effects: Oe.scrollIntoView(s.to)
  })), !0) : !1;
}, lu = /* @__PURE__ */ be.define({
  combine(a) {
    var e;
    return {
      top: a.reduce((t, i) => t ?? i.top, void 0) || !1,
      caseSensitive: a.reduce((t, i) => t ?? (i.caseSensitive || i.matchCase), void 0) || !1,
      createPanel: ((e = a.find((t) => t.createPanel)) === null || e === void 0 ? void 0 : e.createPanel) || ((t) => new vW(t))
    };
  }
});
class mx {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || ZF(this.search)), this.unquoted = this.search.replace(/\\([nrt\\])/g, (t, i) => i == "n" ? `
` : i == "r" ? "\r" : i == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new hW(this) : new cW(this);
  }
  getCursor(e, t = 0, i = e.length) {
    return this.regexp ? Cn(this, e, t, i) : _n(this, e, t, i);
  }
}
class bx {
  constructor(e) {
    this.spec = e;
  }
}
function _n(a, e, t, i) {
  return new qn(e, a.unquoted, t, i, a.caseSensitive ? void 0 : (s) => s.toLowerCase());
}
class cW extends bx {
  constructor(e) {
    super(e);
  }
  nextMatch(e, t, i) {
    let s = _n(this.spec, e, i, e.length).nextOverlapping();
    return s.done && (s = _n(this.spec, e, 0, t).nextOverlapping()), s.done ? null : s.value;
  }
  // Searching in reverse is, rather than implementing inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, t, i) {
    for (let s = i; ; ) {
      let n = Math.max(t, s - 1e4 - this.spec.unquoted.length), o = _n(this.spec, e, n, s), l = null;
      for (; !o.nextOverlapping().done; )
        l = o.value;
      if (l)
        return l;
      if (n == t)
        return null;
      s -= 1e4;
    }
  }
  prevMatch(e, t, i) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, i, e.length);
  }
  getReplacement(e) {
    return this.spec.replace;
  }
  matchAll(e, t) {
    let i = _n(this.spec, e, 0, e.length), s = [];
    for (; !i.next().done; ) {
      if (s.length >= t)
        return null;
      s.push(i.value);
    }
    return s;
  }
  highlight(e, t, i, s) {
    let n = _n(this.spec, e, Math.max(0, t - this.spec.unquoted.length), Math.min(i + this.spec.unquoted.length, e.length));
    for (; !n.next().done; )
      s(n.value.from, n.value.to);
  }
}
function Cn(a, e, t, i) {
  return new fx(e, a.search, a.caseSensitive ? void 0 : { ignoreCase: !0 }, t, i);
}
class hW extends bx {
  nextMatch(e, t, i) {
    let s = Cn(this.spec, e, i, e.length).next();
    return s.done && (s = Cn(this.spec, e, 0, t).next()), s.done ? null : s.value;
  }
  prevMatchInRange(e, t, i) {
    for (let s = 1; ; s++) {
      let n = Math.max(
        t,
        i - s * 1e4
        /* ChunkSize */
      ), o = Cn(this.spec, e, n, i), l = null;
      for (; !o.next().done; )
        l = o.value;
      if (l && (n == t || l.from > n + 10))
        return l;
      if (n == t)
        return null;
    }
  }
  prevMatch(e, t, i) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, i, e.length);
  }
  getReplacement(e) {
    return this.spec.replace.replace(/\$([$&\d+])/g, (t, i) => i == "$" ? "$" : i == "&" ? e.match[0] : i != "0" && +i < e.match.length ? e.match[i] : t);
  }
  matchAll(e, t) {
    let i = Cn(this.spec, e, 0, e.length), s = [];
    for (; !i.next().done; ) {
      if (s.length >= t)
        return null;
      s.push(i.value);
    }
    return s;
  }
  highlight(e, t, i, s) {
    let n = Cn(this.spec, e, Math.max(
      0,
      t - 250
      /* HighlightMargin */
    ), Math.min(i + 250, e.length));
    for (; !n.next().done; )
      s(n.value.from, n.value.to);
  }
}
const ra = /* @__PURE__ */ _e.define(), cu = /* @__PURE__ */ _e.define(), As = /* @__PURE__ */ Mt.define({
  create(a) {
    return new Fc(rd(a).create(), null);
  },
  update(a, e) {
    for (let t of e.effects)
      t.is(ra) ? a = new Fc(t.value.create(), a.panel) : t.is(cu) && (a = new Fc(a.query, t.value ? hu : null));
    return a;
  },
  provide: (a) => na.from(a, (e) => e.panel)
});
class Fc {
  constructor(e, t) {
    this.query = e, this.panel = t;
  }
}
const dW = /* @__PURE__ */ me.mark({ class: "cm-searchMatch" }), uW = /* @__PURE__ */ me.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), fW = /* @__PURE__ */ Ot.fromClass(class {
  constructor(a) {
    this.view = a, this.decorations = this.highlight(a.state.field(As));
  }
  update(a) {
    let e = a.state.field(As);
    (e != a.startState.field(As) || a.docChanged || a.selectionSet || a.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: a, panel: e }) {
    if (!e || !a.spec.valid)
      return me.none;
    let { view: t } = this, i = new Ls();
    for (let s = 0, n = t.visibleRanges, o = n.length; s < o; s++) {
      let { from: l, to: c } = n[s];
      for (; s < o - 1 && c > n[s + 1].from - 2 * 250; )
        c = n[++s].to;
      a.highlight(t.state.doc, l, c, (d, f) => {
        let p = t.state.selection.ranges.some((m) => m.from == d && m.to == f);
        i.add(d, f, p ? uW : dW);
      });
    }
    return i.finish();
  }
}, {
  decorations: (a) => a.decorations
});
function $a(a) {
  return (e) => {
    let t = e.state.field(As, !1);
    return t && t.query.spec.valid ? a(e, t) : vx(e);
  };
}
const Uo = /* @__PURE__ */ $a((a, { query: e }) => {
  let { from: t, to: i } = a.state.selection.main, s = e.nextMatch(a.state.doc, t, i);
  return !s || s.from == t && s.to == i ? !1 : (a.dispatch({
    selection: { anchor: s.from, head: s.to },
    scrollIntoView: !0,
    effects: du(a, s),
    userEvent: "select.search"
  }), !0);
}), Zo = /* @__PURE__ */ $a((a, { query: e }) => {
  let { state: t } = a, { from: i, to: s } = t.selection.main, n = e.prevMatch(t.doc, i, s);
  return n ? (a.dispatch({
    selection: { anchor: n.from, head: n.to },
    scrollIntoView: !0,
    effects: du(a, n),
    userEvent: "select.search"
  }), !0) : !1;
}), pW = /* @__PURE__ */ $a((a, { query: e }) => {
  let t = e.matchAll(a.state.doc, 1e3);
  return !t || !t.length ? !1 : (a.dispatch({
    selection: ee.create(t.map((i) => ee.range(i.from, i.to))),
    userEvent: "select.search.matches"
  }), !0);
}), gW = ({ state: a, dispatch: e }) => {
  let t = a.selection;
  if (t.ranges.length > 1 || t.main.empty)
    return !1;
  let { from: i, to: s } = t.main, n = [], o = 0;
  for (let l = new qn(a.doc, a.sliceDoc(i, s)); !l.next().done; ) {
    if (n.length > 1e3)
      return !1;
    l.value.from == i && (o = n.length), n.push(ee.range(l.value.from, l.value.to));
  }
  return e(a.update({
    selection: ee.create(n, o),
    userEvent: "select.search.matches"
  })), !0;
}, Fg = /* @__PURE__ */ $a((a, { query: e }) => {
  let { state: t } = a, { from: i, to: s } = t.selection.main;
  if (t.readOnly)
    return !1;
  let n = e.nextMatch(t.doc, i, i);
  if (!n)
    return !1;
  let o = [], l, c;
  if (n.from == i && n.to == s && (c = t.toText(e.getReplacement(n)), o.push({ from: n.from, to: n.to, insert: c }), n = e.nextMatch(t.doc, n.from, n.to)), n) {
    let d = o.length == 0 || o[0].from >= n.to ? 0 : n.to - n.from - c.length;
    l = { anchor: n.from - d, head: n.to - d };
  }
  return a.dispatch({
    changes: o,
    selection: l,
    scrollIntoView: !!l,
    effects: n ? du(a, n) : void 0,
    userEvent: "input.replace"
  }), !0;
}), mW = /* @__PURE__ */ $a((a, { query: e }) => {
  if (a.state.readOnly)
    return !1;
  let t = e.matchAll(a.state.doc, 1e9).map((i) => {
    let { from: s, to: n } = i;
    return { from: s, to: n, insert: e.getReplacement(i) };
  });
  return t.length ? (a.dispatch({
    changes: t,
    userEvent: "input.replace.all"
  }), !0) : !1;
});
function hu(a) {
  return a.state.facet(lu).createPanel(a);
}
function rd(a, e) {
  var t;
  let i = a.selection.main, s = i.empty || i.to > i.from + 100 ? "" : a.sliceDoc(i.from, i.to), n = (t = e == null ? void 0 : e.caseSensitive) !== null && t !== void 0 ? t : a.facet(lu).caseSensitive;
  return e && !s ? e : new mx({ search: s.replace(/\n/g, "\\n"), caseSensitive: n });
}
const vx = (a) => {
  let e = a.state.field(As, !1);
  if (e && e.panel) {
    let t = sa(a, hu);
    if (!t)
      return !1;
    let i = t.dom.querySelector("[name=search]");
    if (i != a.root.activeElement) {
      let s = rd(a.state, e.query.spec);
      s.valid && a.dispatch({ effects: ra.of(s) }), i.focus(), i.select();
    }
  } else
    a.dispatch({ effects: [
      cu.of(!0),
      e ? ra.of(rd(a.state, e.query.spec)) : _e.appendConfig.of(OW)
    ] });
  return !0;
}, yx = (a) => {
  let e = a.state.field(As, !1);
  if (!e || !e.panel)
    return !1;
  let t = sa(a, hu);
  return t && t.dom.contains(a.root.activeElement) && a.focus(), a.dispatch({ effects: cu.of(!1) }), !0;
}, bW = [
  { key: "Mod-f", run: vx, scope: "editor search-panel" },
  { key: "F3", run: Uo, shift: Zo, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: Uo, shift: Zo, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: yx, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: gW },
  { key: "Alt-g", run: qF },
  { key: "Mod-d", run: lW, preventDefault: !0 }
];
class vW {
  constructor(e) {
    this.view = e;
    let t = this.query = e.state.field(As).query.spec;
    this.commit = this.commit.bind(this), this.searchField = Ue("input", {
      value: t.search,
      placeholder: li(e, "Find"),
      "aria-label": li(e, "Find"),
      class: "cm-textfield",
      name: "search",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = Ue("input", {
      value: t.replace,
      placeholder: li(e, "Replace"),
      "aria-label": li(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = Ue("input", {
      type: "checkbox",
      name: "case",
      checked: t.caseSensitive,
      onchange: this.commit
    }), this.reField = Ue("input", {
      type: "checkbox",
      name: "re",
      checked: t.regexp,
      onchange: this.commit
    });
    function i(s, n, o) {
      return Ue("button", { class: "cm-button", name: s, onclick: n, type: "button" }, o);
    }
    this.dom = Ue("div", { onkeydown: (s) => this.keydown(s), class: "cm-search" }, [
      this.searchField,
      i("next", () => Uo(e), [li(e, "next")]),
      i("prev", () => Zo(e), [li(e, "previous")]),
      i("select", () => pW(e), [li(e, "all")]),
      Ue("label", null, [this.caseField, li(e, "match case")]),
      Ue("label", null, [this.reField, li(e, "regexp")]),
      ...e.state.readOnly ? [] : [
        Ue("br"),
        this.replaceField,
        i("replace", () => Fg(e), [li(e, "replace")]),
        i("replaceAll", () => mW(e), [li(e, "replace all")]),
        Ue("button", {
          name: "close",
          onclick: () => yx(e),
          "aria-label": li(e, "close"),
          type: "button"
        }, ["×"])
      ]
    ]);
  }
  commit() {
    let e = new mx({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: ra.of(e) }));
  }
  keydown(e) {
    pQ(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? Zo : Uo)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), Fg(this.view));
  }
  update(e) {
    for (let t of e.transactions)
      for (let i of t.effects)
        i.is(ra) && !i.value.eq(this.query) && this.setQuery(i.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(lu).top;
  }
}
function li(a, e) {
  return a.state.phrase(e);
}
const to = 30, io = /[\s\.,:;?!]/;
function du(a, { from: e, to: t }) {
  let i = a.state.doc.lineAt(e).from, s = a.state.doc.lineAt(t).to, n = Math.max(i, e - to), o = Math.min(s, t + to), l = a.state.sliceDoc(n, o);
  if (n != i) {
    for (let c = 0; c < to; c++)
      if (!io.test(l[c + 1]) && io.test(l[c])) {
        l = l.slice(c);
        break;
      }
  }
  if (o != s) {
    for (let c = l.length - 1; c > l.length - to; c--)
      if (!io.test(l[c - 1]) && io.test(l[c])) {
        l = l.slice(0, c);
        break;
      }
  }
  return Oe.announce.of(`${a.state.phrase("current match")}. ${l} ${a.state.phrase("on line")} ${a.state.doc.lineAt(e).number}`);
}
const yW = /* @__PURE__ */ Oe.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), OW = [
  As,
  /* @__PURE__ */ dr.lowest(fW),
  yW
], xW = typeof navigator < "u" && !/* @__PURE__ */ /Edge\/(\d+)/.exec(navigator.userAgent) && /* @__PURE__ */ /Apple Computer/.test(navigator.vendor) && (/* @__PURE__ */ /Mobile\/\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2), Wc = "-10000px";
class Ox {
  constructor(e, t, i) {
    this.facet = t, this.createTooltipView = i, this.input = e.state.facet(t), this.tooltips = this.input.filter((s) => s), this.tooltipViews = this.tooltips.map(i);
  }
  update(e) {
    let t = e.state.facet(this.facet), i = t.filter((n) => n);
    if (t === this.input) {
      for (let n of this.tooltipViews)
        n.update && n.update(e);
      return !1;
    }
    let s = [];
    for (let n = 0; n < i.length; n++) {
      let o = i[n], l = -1;
      if (o) {
        for (let c = 0; c < this.tooltips.length; c++) {
          let d = this.tooltips[c];
          d && d.create == o.create && (l = c);
        }
        if (l < 0)
          s[n] = this.createTooltipView(o);
        else {
          let c = s[n] = this.tooltipViews[l];
          c.update && c.update(e);
        }
      }
    }
    for (let n of this.tooltipViews)
      s.indexOf(n) < 0 && n.dom.remove();
    return this.input = t, this.tooltips = i, this.tooltipViews = s, !0;
  }
}
function wW() {
  return { top: 0, left: 0, bottom: innerHeight, right: innerWidth };
}
const Bc = /* @__PURE__ */ be.define({
  combine: (a) => {
    var e, t, i;
    return {
      position: xW ? "absolute" : ((e = a.find((s) => s.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((t = a.find((s) => s.parent)) === null || t === void 0 ? void 0 : t.parent) || null,
      tooltipSpace: ((i = a.find((s) => s.tooltipSpace)) === null || i === void 0 ? void 0 : i.tooltipSpace) || wW
    };
  }
}), xx = /* @__PURE__ */ Ot.fromClass(class {
  constructor(a) {
    var e;
    this.view = a, this.inView = !0, this.lastTransaction = 0, this.measureTimeout = -1;
    let t = a.state.facet(Bc);
    this.position = t.position, this.parent = t.parent, this.classes = a.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.manager = new Ox(a, uu, (i) => this.createTooltip(i)), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((i) => {
      Date.now() > this.lastTransaction - 50 && i.length > 0 && i[i.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), (e = a.dom.ownerDocument.defaultView) === null || e === void 0 || e.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let a of this.manager.tooltipViews)
        this.intersectionObserver.observe(a.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(a) {
    a.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(a);
    e && this.observeIntersection();
    let t = e || a.geometryChanged, i = a.state.facet(Bc);
    if (i.position != this.position) {
      this.position = i.position;
      for (let s of this.manager.tooltipViews)
        s.dom.style.position = this.position;
      t = !0;
    }
    if (i.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = i.parent, this.createContainer();
      for (let s of this.manager.tooltipViews)
        this.container.appendChild(s.dom);
      t = !0;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    t && this.maybeMeasure();
  }
  createTooltip(a) {
    let e = a.create(this.view);
    if (e.dom.classList.add("cm-tooltip"), a.arrow && !e.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let t = document.createElement("div");
      t.className = "cm-tooltip-arrow", e.dom.appendChild(t);
    }
    return e.dom.style.position = this.position, e.dom.style.top = Wc, this.container.appendChild(e.dom), e.mount && e.mount(this.view), e;
  }
  destroy() {
    var a, e;
    (a = this.view.dom.ownerDocument.defaultView) === null || a === void 0 || a.removeEventListener("resize", this.measureSoon);
    for (let { dom: t } of this.manager.tooltipViews)
      t.remove();
    (e = this.intersectionObserver) === null || e === void 0 || e.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let a = this.view.dom.getBoundingClientRect();
    return {
      editor: a,
      parent: this.parent ? this.container.getBoundingClientRect() : a,
      pos: this.manager.tooltips.map((e, t) => {
        let i = this.manager.tooltipViews[t];
        return i.getCoords ? i.getCoords(e.pos) : this.view.coordsAtPos(e.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: e }) => e.getBoundingClientRect()),
      space: this.view.state.facet(Bc).tooltipSpace(this.view)
    };
  }
  writeMeasure(a) {
    let { editor: e, space: t } = a, i = [];
    for (let s = 0; s < this.manager.tooltips.length; s++) {
      let n = this.manager.tooltips[s], o = this.manager.tooltipViews[s], { dom: l } = o, c = a.pos[s], d = a.size[s];
      if (!c || c.bottom <= Math.max(e.top, t.top) || c.top >= Math.min(e.bottom, t.bottom) || c.right < Math.max(e.left, t.left) - 0.1 || c.left > Math.min(e.right, t.right) + 0.1) {
        l.style.top = Wc;
        continue;
      }
      let f = n.arrow ? o.dom.querySelector(".cm-tooltip-arrow") : null, p = f ? 7 : 0, m = d.right - d.left, v = d.bottom - d.top, r = o.offset || kW, h = this.view.textDirection == Ne.LTR, u = d.width > t.right - t.left ? h ? t.left : t.right - d.width : h ? Math.min(c.left - (f ? 14 : 0) + r.x, t.right - m) : Math.max(t.left, c.left - m + (f ? 14 : 0) - r.x), g = !!n.above;
      !n.strictSide && (g ? c.top - (d.bottom - d.top) - r.y < t.top : c.bottom + (d.bottom - d.top) + r.y > t.bottom) && g == t.bottom - c.bottom > c.top - t.top && (g = !g);
      let b = g ? c.top - v - p - r.y : c.bottom + p + r.y, O = u + m;
      if (o.overlap !== !0)
        for (let x of i)
          x.left < O && x.right > u && x.top < b + v && x.bottom > b && (b = g ? x.top - v - 2 - p : x.bottom + p + 2);
      this.position == "absolute" ? (l.style.top = b - a.parent.top + "px", l.style.left = u - a.parent.left + "px") : (l.style.top = b + "px", l.style.left = u + "px"), f && (f.style.left = `${c.left + (h ? r.x : -r.x) - (u + 14 - 7)}px`), o.overlap !== !0 && i.push({ left: u, top: b, right: O, bottom: b + v }), l.classList.toggle("cm-tooltip-above", g), l.classList.toggle("cm-tooltip-below", !g), o.positioned && o.positioned();
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let a of this.manager.tooltipViews)
        a.dom.style.top = Wc;
  }
}, {
  eventHandlers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), SW = /* @__PURE__ */ Oe.baseTheme({
  ".cm-tooltip": {
    zIndex: 100
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), kW = { x: 0, y: 0 }, uu = /* @__PURE__ */ be.define({
  enables: [xx, SW]
}), qo = /* @__PURE__ */ be.define();
class fu {
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new Ox(e, qo, (t) => this.createHostedView(t));
  }
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new fu(e);
  }
  createHostedView(e) {
    let t = e.create(this.view);
    return t.dom.classList.add("cm-tooltip-section"), this.dom.appendChild(t.dom), this.mounted && t.mount && t.mount(this.view), t;
  }
  mount(e) {
    for (let t of this.manager.tooltipViews)
      t.mount && t.mount(e);
    this.mounted = !0;
  }
  positioned() {
    for (let e of this.manager.tooltipViews)
      e.positioned && e.positioned();
  }
  update(e) {
    this.manager.update(e);
  }
}
const _W = /* @__PURE__ */ uu.compute([qo], (a) => {
  let e = a.facet(qo).filter((t) => t);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((t) => t.pos)),
    end: Math.max(...e.filter((t) => t.end != null).map((t) => t.end)),
    create: fu.create,
    above: e[0].above,
    arrow: e.some((t) => t.arrow)
  };
});
class CW {
  constructor(e, t, i, s, n) {
    this.view = e, this.source = t, this.field = i, this.setHover = s, this.hoverTime = n, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    var e;
    clearTimeout(this.restartTimeout);
    let { lastMove: t } = this, i = this.view.contentDOM.contains(t.target) ? this.view.posAtCoords(t) : null;
    if (i == null)
      return;
    let s = this.view.coordsAtPos(i);
    if (s == null || t.y < s.top || t.y > s.bottom || t.x < s.left - this.view.defaultCharacterWidth || t.x > s.right + this.view.defaultCharacterWidth)
      return;
    let n = this.view.bidiSpans(this.view.state.doc.lineAt(i)).find((c) => c.from <= i && c.to >= i), o = n && n.dir == Ne.RTL ? -1 : 1, l = this.source(this.view, i, t.x < s.left ? -o : o);
    if (!((e = l) === null || e === void 0) && e.then) {
      let c = this.pending = { pos: i };
      l.then((d) => {
        this.pending == c && (this.pending = null, d && this.view.dispatch({ effects: this.setHover.of(d) }));
      }, (d) => bi(this.view.state, d, "hover tooltip"));
    } else
      l && this.view.dispatch({ effects: this.setHover.of(l) });
  }
  mousemove(e) {
    var t;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let i = this.active;
    if (i && !TW(this.lastMove.target) || this.pending) {
      let { pos: s } = i || this.pending, n = (t = i == null ? void 0 : i.end) !== null && t !== void 0 ? t : s;
      (s == n ? this.view.posAtCoords(this.lastMove) != s : !AW(
        this.view,
        s,
        n,
        e.clientX,
        e.clientY,
        6
        /* MaxDist */
      )) && (this.view.dispatch({ effects: this.setHover.of(null) }), this.pending = null);
    }
  }
  mouseleave() {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1, this.active && this.view.dispatch({ effects: this.setHover.of(null) });
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
function TW(a) {
  for (let e = a; e; e = e.parentNode)
    if (e.nodeType == 1 && e.classList.contains("cm-tooltip"))
      return !0;
  return !1;
}
function AW(a, e, t, i, s, n) {
  let o = document.createRange(), l = a.domAtPos(e), c = a.domAtPos(t);
  o.setEnd(c.node, c.offset), o.setStart(l.node, l.offset);
  let d = o.getClientRects();
  o.detach();
  for (let f = 0; f < d.length; f++) {
    let p = d[f];
    if (Math.max(p.top - s, s - p.bottom, p.left - i, i - p.right) <= n)
      return !0;
  }
  return !1;
}
function $W(a, e = {}) {
  let t = _e.define(), i = Mt.define({
    create() {
      return null;
    },
    update(s, n) {
      if (s && e.hideOnChange && (n.docChanged || n.selection))
        return null;
      for (let o of n.effects) {
        if (o.is(t))
          return o.value;
        if (o.is(PW))
          return null;
      }
      if (s && n.docChanged) {
        let o = n.changes.mapPos(s.pos, -1, $t.TrackDel);
        if (o == null)
          return null;
        let l = Object.assign(/* @__PURE__ */ Object.create(null), s);
        return l.pos = o, s.end != null && (l.end = n.changes.mapPos(s.end)), l;
      }
      return s;
    },
    provide: (s) => qo.from(s)
  });
  return [
    i,
    Ot.define((s) => new CW(
      s,
      a,
      i,
      t,
      e.hoverTime || 300
      /* Time */
    )),
    _W
  ];
}
function EW(a, e) {
  let t = a.plugin(xx);
  if (!t)
    return null;
  let i = t.manager.tooltips.indexOf(e);
  return i < 0 ? null : t.manager.tooltipViews[i];
}
const PW = /* @__PURE__ */ _e.define();
class LW {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(e, t, i) {
    this.state = e, this.pos = t, this.explicit = i, this.abortListeners = [];
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let t = pt(this.state).resolveInner(this.pos, -1);
    for (; t && e.indexOf(t.name) < 0; )
      t = t.parent;
    return t ? {
      from: t.from,
      to: this.pos,
      text: this.state.sliceDoc(t.from, this.pos),
      type: t.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let t = this.state.doc.lineAt(this.pos), i = Math.max(t.from, this.pos - 250), s = t.text.slice(i - t.from, this.pos - t.from), n = s.search(Sx(e, !1));
    return n < 0 ? null : { from: i + n, to: this.pos, text: s.slice(n) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  */
  addEventListener(e, t) {
    e == "abort" && this.abortListeners && this.abortListeners.push(t);
  }
}
function Wg(a) {
  let e = Object.keys(a).join(""), t = /\w/.test(e);
  return t && (e = e.replace(/\w/g, "")), `[${t ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function MW(a) {
  let e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null);
  for (let { label: s } of a) {
    e[s[0]] = !0;
    for (let n = 1; n < s.length; n++)
      t[s[n]] = !0;
  }
  let i = Wg(e) + Wg(t) + "*$";
  return [new RegExp("^" + i), new RegExp(i)];
}
function wx(a) {
  let e = a.map((s) => typeof s == "string" ? { label: s } : s), [t, i] = e.every((s) => /^\w+$/.test(s.label)) ? [/\w*$/, /\w+$/] : MW(e);
  return (s) => {
    let n = s.matchBefore(i);
    return n || s.explicit ? { from: n ? n.from : s.pos, options: e, span: t } : null;
  };
}
function DW(a, e) {
  return (t) => {
    for (let i = pt(t.state).resolveInner(t.pos, -1); i; i = i.parent)
      if (a.indexOf(i.name) > -1)
        return null;
    return e(t);
  };
}
let Bg = class {
  constructor(e, t, i) {
    this.completion = e, this.source = t, this.match = i;
  }
};
function cn(a) {
  return a.selection.main.head;
}
function Sx(a, e) {
  var t;
  let { source: i } = a, s = e && i[0] != "^", n = i[i.length - 1] != "$";
  return !s && !n ? a : new RegExp(`${s ? "^" : ""}(?:${i})${n ? "$" : ""}`, (t = a.flags) !== null && t !== void 0 ? t : a.ignoreCase ? "i" : "");
}
const RW = /* @__PURE__ */ Qs.define();
function kx(a, e) {
  let t = e.completion.apply || e.completion.label, i = e.source;
  typeof t == "string" ? a.dispatch({
    changes: { from: i.from, to: i.to, insert: t },
    selection: { anchor: i.from + t.length },
    userEvent: "input.complete",
    annotations: RW.of(e.completion)
  }) : t(a, e.completion, i.from, i.to);
}
const zg = /* @__PURE__ */ new WeakMap();
function IW(a) {
  if (!Array.isArray(a))
    return a;
  let e = zg.get(a);
  return e || zg.set(a, e = wx(a)), e;
}
class QW {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [];
    for (let t = 0; t < e.length; ) {
      let i = Dt(e, t), s = ci(i);
      this.chars.push(i);
      let n = e.slice(t, t + s), o = n.toUpperCase();
      this.folded.push(Dt(o == n ? n.toLowerCase() : o, 0)), t += s;
    }
    this.astral = e.length != this.chars.length;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return null for no match, and otherwise an array that starts
  // with the match score, followed by any number of `from, to` pairs
  // indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return [0];
    if (e.length < this.pattern.length)
      return null;
    let { chars: t, folded: i, any: s, precise: n, byWord: o } = this;
    if (t.length == 1) {
      let b = Dt(e, 0);
      return b == t[0] ? [0, 0, ci(b)] : b == i[0] ? [-200, 0, ci(b)] : null;
    }
    let l = e.indexOf(this.pattern);
    if (l == 0)
      return [0, 0, this.pattern.length];
    let c = t.length, d = 0;
    if (l < 0) {
      for (let b = 0, O = Math.min(e.length, 200); b < O && d < c; ) {
        let x = Dt(e, b);
        (x == t[d] || x == i[d]) && (s[d++] = b), b += ci(x);
      }
      if (d < c)
        return null;
    }
    let f = 0, p = 0, m = !1, v = 0, r = -1, h = -1, u = /[a-z]/.test(e), g = !0;
    for (let b = 0, O = Math.min(e.length, 200), x = 0; b < O && p < c; ) {
      let S = Dt(e, b);
      l < 0 && (f < c && S == t[f] && (n[f++] = b), v < c && (S == t[v] || S == i[v] ? (v == 0 && (r = b), h = b + 1, v++) : v = 0));
      let k, C = S < 255 ? S >= 48 && S <= 57 || S >= 97 && S <= 122 ? 2 : S >= 65 && S <= 90 ? 1 : 0 : (k = zd(S)) != k.toLowerCase() ? 1 : k != k.toUpperCase() ? 2 : 0;
      (!b || C == 1 && u || x == 0 && C != 0) && (t[p] == S || i[p] == S && (m = !0) ? o[p++] = b : o.length && (g = !1)), x = C, b += ci(S);
    }
    return p == c && o[0] == 0 && g ? this.result(-100 + (m ? -200 : 0), o, e) : v == c && r == 0 ? [-200 - e.length, 0, h] : l > -1 ? [-700 - e.length, l, l + this.pattern.length] : v == c ? [-200 + -700 - e.length, r, h] : p == c ? this.result(-100 + (m ? -200 : 0) + -700 + (g ? 0 : -1100), o, e) : t.length == 2 ? null : this.result((s[0] ? -700 : 0) + -200 + -1100, s, e);
  }
  result(e, t, i) {
    let s = [e - i.length], n = 1;
    for (let o of t) {
      let l = o + (this.astral ? ci(Dt(i, o)) : 1);
      n > 1 && s[n - 1] == o ? s[n - 1] = l : (s[n++] = o, s[n++] = l);
    }
    return s;
  }
}
const hn = /* @__PURE__ */ be.define({
  combine(a) {
    return Ns(a, {
      activateOnTyping: !0,
      override: null,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: []
    }, {
      defaultKeymap: (e, t) => e && t,
      icons: (e, t) => e && t,
      optionClass: (e, t) => (i) => NW(e(i), t(i)),
      addToOptions: (e, t) => e.concat(t)
    });
  }
});
function NW(a, e) {
  return a ? e ? a + " " + e : a : e;
}
function FW(a) {
  let e = a.addToOptions.slice();
  return a.icons && e.push({
    render(t) {
      let i = document.createElement("div");
      return i.classList.add("cm-completionIcon"), t.type && i.classList.add(...t.type.split(/\s+/g).map((s) => "cm-completionIcon-" + s)), i.setAttribute("aria-hidden", "true"), i;
    },
    position: 20
  }), e.push({
    render(t, i, s) {
      let n = document.createElement("span");
      n.className = "cm-completionLabel";
      let { label: o } = t, l = 0;
      for (let c = 1; c < s.length; ) {
        let d = s[c++], f = s[c++];
        d > l && n.appendChild(document.createTextNode(o.slice(l, d)));
        let p = n.appendChild(document.createElement("span"));
        p.appendChild(document.createTextNode(o.slice(d, f))), p.className = "cm-completionMatchedText", l = f;
      }
      return l < o.length && n.appendChild(document.createTextNode(o.slice(l))), n;
    },
    position: 50
  }, {
    render(t) {
      if (!t.detail)
        return null;
      let i = document.createElement("span");
      return i.className = "cm-completionDetail", i.textContent = t.detail, i;
    },
    position: 80
  }), e.sort((t, i) => t.position - i.position).map((t) => t.render);
}
function Xg(a, e, t) {
  if (a <= t)
    return { from: 0, to: a };
  if (e <= a >> 1) {
    let s = Math.floor(e / t);
    return { from: s * t, to: (s + 1) * t };
  }
  let i = Math.floor((a - e) / t);
  return { from: a - (i + 1) * t, to: a - i * t };
}
class WW {
  constructor(e, t) {
    this.view = e, this.stateField = t, this.info = null, this.placeInfo = {
      read: () => this.measureInfo(),
      write: (l) => this.positionInfo(l),
      key: this
    };
    let i = e.state.field(t), { options: s, selected: n } = i.open, o = e.state.facet(hn);
    this.optionContent = FW(o), this.optionClass = o.optionClass, this.range = Xg(s.length, n, o.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.dom.addEventListener("mousedown", (l) => {
      for (let c = l.target, d; c && c != this.dom; c = c.parentNode)
        if (c.nodeName == "LI" && (d = /-(\d+)$/.exec(c.id)) && +d[1] < s.length) {
          kx(e, s[+d[1]]), l.preventDefault();
          return;
        }
    }), this.list = this.dom.appendChild(this.createListBox(s, i.id, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfo);
    });
  }
  mount() {
    this.updateSel();
  }
  update(e) {
    e.state.field(this.stateField) != e.startState.field(this.stateField) && this.updateSel();
  }
  positioned() {
    this.info && this.view.requestMeasure(this.placeInfo);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), t = e.open;
    if ((t.selected < this.range.from || t.selected >= this.range.to) && (this.range = Xg(t.options.length, t.selected, this.view.state.facet(hn).maxRenderedOptions), this.list.remove(), this.list = this.dom.appendChild(this.createListBox(t.options, e.id, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfo);
    })), this.updateSelectedOption(t.selected)) {
      this.info && (this.info.remove(), this.info = null);
      let { completion: i } = t.options[t.selected], { info: s } = i;
      if (!s)
        return;
      let n = typeof s == "string" ? document.createTextNode(s) : s(i);
      if (!n)
        return;
      "then" in n ? n.then((o) => {
        o && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(o);
      }).catch((o) => bi(this.view.state, o, "completion info")) : this.addInfoPane(n);
    }
  }
  addInfoPane(e) {
    let t = this.info = document.createElement("div");
    t.className = "cm-tooltip cm-completionInfo", t.appendChild(e), this.dom.appendChild(t), this.view.requestMeasure(this.placeInfo);
  }
  updateSelectedOption(e) {
    let t = null;
    for (let i = this.list.firstChild, s = this.range.from; i; i = i.nextSibling, s++)
      s == e ? i.hasAttribute("aria-selected") || (i.setAttribute("aria-selected", "true"), t = i) : i.hasAttribute("aria-selected") && i.removeAttribute("aria-selected");
    return t && zW(this.list, t), t;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let t = this.dom.getBoundingClientRect(), i = this.info.getBoundingClientRect(), s = e.getBoundingClientRect();
    if (s.top > Math.min(innerHeight, t.bottom) - 10 || s.bottom < Math.max(0, t.top) + 10)
      return null;
    let n = Math.max(0, Math.min(s.top, innerHeight - i.height)) - t.top, o = this.view.textDirection == Ne.RTL, l = t.left, c = innerWidth - t.right;
    return o && l < Math.min(i.width, c) ? o = !1 : !o && c < Math.min(i.width, l) && (o = !0), { top: n, left: o };
  }
  positionInfo(e) {
    this.info && (this.info.style.top = (e ? e.top : -1e6) + "px", e && (this.info.classList.toggle("cm-completionInfo-left", e.left), this.info.classList.toggle("cm-completionInfo-right", !e.left)));
  }
  createListBox(e, t, i) {
    const s = document.createElement("ul");
    s.id = t, s.setAttribute("role", "listbox"), s.setAttribute("aria-expanded", "true");
    for (let n = i.from; n < i.to; n++) {
      let { completion: o, match: l } = e[n];
      const c = s.appendChild(document.createElement("li"));
      c.id = t + "-" + n, c.setAttribute("role", "option");
      let d = this.optionClass(o);
      d && (c.className = d);
      for (let f of this.optionContent) {
        let p = f(o, this.view.state, l);
        p && c.appendChild(p);
      }
    }
    return i.from && s.classList.add("cm-completionListIncompleteTop"), i.to < e.length && s.classList.add("cm-completionListIncompleteBottom"), s;
  }
}
function BW(a) {
  return (e) => new WW(e, a);
}
function zW(a, e) {
  let t = a.getBoundingClientRect(), i = e.getBoundingClientRect();
  i.top < t.top ? a.scrollTop -= t.top - i.top : i.bottom > t.bottom && (a.scrollTop += i.bottom - t.bottom);
}
const XW = 300;
function Yg(a) {
  return (a.boost || 0) * 100 + (a.apply ? 10 : 0) + (a.info ? 5 : 0) + (a.type ? 1 : 0);
}
function YW(a, e) {
  let t = [], i = 0;
  for (let o of a)
    if (o.hasResult())
      if (o.result.filter === !1)
        for (let l of o.result.options)
          t.push(new Bg(l, o, [1e9 - i++]));
      else {
        let l = new QW(e.sliceDoc(o.from, o.to)), c;
        for (let d of o.result.options)
          (c = l.match(d.label)) && (d.boost != null && (c[0] += d.boost), t.push(new Bg(d, o, c)));
      }
  let s = [], n = null;
  for (let o of t.sort(jW)) {
    if (s.length == XW)
      break;
    !n || n.label != o.completion.label || n.detail != o.completion.detail || n.type != o.completion.type || n.apply != o.completion.apply ? s.push(o) : Yg(o.completion) > Yg(n) && (s[s.length - 1] = o), n = o.completion;
  }
  return s;
}
class Fr {
  constructor(e, t, i, s, n) {
    this.options = e, this.attrs = t, this.tooltip = i, this.timestamp = s, this.selected = n;
  }
  setSelected(e, t) {
    return e == this.selected || e >= this.options.length ? this : new Fr(this.options, Vg(t, e), this.tooltip, this.timestamp, e);
  }
  static build(e, t, i, s, n) {
    let o = YW(e, t);
    if (!o.length)
      return null;
    let l = 0;
    if (s && s.selected) {
      let c = s.options[s.selected].completion;
      for (let d = 0; d < o.length; d++)
        if (o[d].completion == c) {
          l = d;
          break;
        }
    }
    return new Fr(o, Vg(i, l), {
      pos: e.reduce((c, d) => d.hasResult() ? Math.min(c, d.from) : c, 1e8),
      create: BW(Si),
      above: n.aboveCursor
    }, s ? s.timestamp : Date.now(), l);
  }
  map(e) {
    return new Fr(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected);
  }
}
class Ko {
  constructor(e, t, i) {
    this.active = e, this.id = t, this.open = i;
  }
  static start() {
    return new Ko(GW, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: t } = e, i = t.facet(hn), n = (i.override || t.languageDataAt("autocomplete", cn(t)).map(IW)).map((l) => (this.active.find((d) => d.source == l) || new Ht(
      l,
      this.active.some(
        (d) => d.state != 0
        /* Inactive */
      ) ? 1 : 0
      /* Inactive */
    )).update(e, i));
    n.length == this.active.length && n.every((l, c) => l == this.active[c]) && (n = this.active);
    let o = e.selection || n.some((l) => l.hasResult() && e.changes.touchesRange(l.from, l.to)) || !VW(n, this.active) ? Fr.build(n, t, this.id, this.open, i) : this.open && e.docChanged ? this.open.map(e.changes) : this.open;
    !o && n.every(
      (l) => l.state != 1
      /* Pending */
    ) && n.some((l) => l.hasResult()) && (n = n.map((l) => l.hasResult() ? new Ht(
      l.source,
      0
      /* Inactive */
    ) : l));
    for (let l of e.effects)
      l.is(Cx) && (o = o && o.setSelected(l.value, this.id));
    return n == this.active && o == this.open ? this : new Ko(n, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : HW;
  }
}
function VW(a, e) {
  if (a == e)
    return !0;
  for (let t = 0, i = 0; ; ) {
    for (; t < a.length && !a[t].hasResult; )
      t++;
    for (; i < e.length && !e[i].hasResult; )
      i++;
    let s = t == a.length, n = i == e.length;
    if (s || n)
      return s == n;
    if (a[t++].result != e[i++].result)
      return !1;
  }
}
const HW = {
  "aria-autocomplete": "list"
};
function Vg(a, e) {
  return {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-activedescendant": a + "-" + e,
    "aria-controls": a
  };
}
const GW = [];
function jW(a, e) {
  let t = e.match[0] - a.match[0];
  return t || a.completion.label.localeCompare(e.completion.label);
}
function ad(a) {
  return a.isUserEvent("input.type") ? "input" : a.isUserEvent("delete.backward") ? "delete" : null;
}
class Ht {
  constructor(e, t, i = -1) {
    this.source = e, this.state = t, this.explicitPos = i;
  }
  hasResult() {
    return !1;
  }
  update(e, t) {
    let i = ad(e), s = this;
    i ? s = s.handleUserEvent(e, i, t) : e.docChanged ? s = s.handleChange(e) : e.selection && s.state != 0 && (s = new Ht(
      s.source,
      0
      /* Inactive */
    ));
    for (let n of e.effects)
      if (n.is(pu))
        s = new Ht(s.source, 1, n.value ? cn(e.state) : -1);
      else if (n.is(gu))
        s = new Ht(
          s.source,
          0
          /* Inactive */
        );
      else if (n.is(_x))
        for (let o of n.value)
          o.source == s.source && (s = o);
    return s;
  }
  handleUserEvent(e, t, i) {
    return t == "delete" || !i.activateOnTyping ? this.map(e.changes) : new Ht(
      this.source,
      1
      /* Pending */
    );
  }
  handleChange(e) {
    return e.changes.touchesRange(cn(e.startState)) ? new Ht(
      this.source,
      0
      /* Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new Ht(this.source, this.state, e.mapPos(this.explicitPos));
  }
}
class Jo extends Ht {
  constructor(e, t, i, s, n, o) {
    super(e, 2, t), this.result = i, this.from = s, this.to = n, this.span = o;
  }
  hasResult() {
    return !0;
  }
  handleUserEvent(e, t, i) {
    let s = e.changes.mapPos(this.from), n = e.changes.mapPos(this.to, 1), o = cn(e.state);
    if ((this.explicitPos < 0 ? o <= s : o < this.from) || o > n || t == "delete" && cn(e.startState) == this.from)
      return new Ht(
        this.source,
        t == "input" && i.activateOnTyping ? 1 : 0
        /* Inactive */
      );
    let l = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos);
    return this.span && (s == n || this.span.test(e.state.sliceDoc(s, n))) ? new Jo(this.source, l, this.result, s, n, this.span) : new Ht(this.source, 1, l);
  }
  handleChange(e) {
    return e.changes.touchesRange(this.from, this.to) ? new Ht(
      this.source,
      0
      /* Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty ? this : new Jo(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1), this.span);
  }
}
const pu = /* @__PURE__ */ _e.define(), gu = /* @__PURE__ */ _e.define(), _x = /* @__PURE__ */ _e.define({
  map(a, e) {
    return a.map((t) => t.map(e));
  }
}), Cx = /* @__PURE__ */ _e.define(), Si = /* @__PURE__ */ Mt.define({
  create() {
    return Ko.start();
  },
  update(a, e) {
    return a.update(e);
  },
  provide: (a) => [
    uu.from(a, (e) => e.tooltip),
    Oe.contentAttributes.from(a, (e) => e.attrs)
  ]
}), Tx = 75;
function so(a, e = "option") {
  return (t) => {
    let i = t.state.field(Si, !1);
    if (!i || !i.open || Date.now() - i.open.timestamp < Tx)
      return !1;
    let s = 1, n;
    e == "page" && (n = EW(t, i.open.tooltip)) && (s = Math.max(2, Math.floor(n.dom.offsetHeight / n.dom.querySelector("li").offsetHeight) - 1));
    let o = i.open.selected + s * (a ? 1 : -1), { length: l } = i.open.options;
    return o < 0 ? o = e == "page" ? 0 : l - 1 : o >= l && (o = e == "page" ? l - 1 : 0), t.dispatch({ effects: Cx.of(o) }), !0;
  };
}
const UW = (a) => {
  let e = a.state.field(Si, !1);
  return a.state.readOnly || !e || !e.open || Date.now() - e.open.timestamp < Tx ? !1 : (kx(a, e.open.options[e.open.selected]), !0);
}, ZW = (a) => a.state.field(Si, !1) ? (a.dispatch({ effects: pu.of(!0) }), !0) : !1, qW = (a) => {
  let e = a.state.field(Si, !1);
  return !e || !e.active.some(
    (t) => t.state != 0
    /* Inactive */
  ) ? !1 : (a.dispatch({ effects: gu.of(null) }), !0);
};
class KW {
  constructor(e, t) {
    this.active = e, this.context = t, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const Hg = 50, JW = 50, eB = 1e3, tB = /* @__PURE__ */ Ot.fromClass(class {
  constructor(a) {
    this.view = a, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.composing = 0;
    for (let e of a.state.field(Si).active)
      e.state == 1 && this.startQuery(e);
  }
  update(a) {
    let e = a.state.field(Si);
    if (!a.selectionSet && !a.docChanged && a.startState.field(Si) == e)
      return;
    let t = a.transactions.some((i) => (i.selection || i.docChanged) && !ad(i));
    for (let i = 0; i < this.running.length; i++) {
      let s = this.running[i];
      if (t || s.updates.length + a.transactions.length > JW && Date.now() - s.time > eB) {
        for (let n of s.context.abortListeners)
          try {
            n();
          } catch (o) {
            bi(this.view.state, o);
          }
        s.context.abortListeners = null, this.running.splice(i--, 1);
      } else
        s.updates.push(...a.transactions);
    }
    if (this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), this.debounceUpdate = e.active.some((i) => i.state == 1 && !this.running.some((s) => s.active.source == i.source)) ? setTimeout(() => this.startUpdate(), Hg) : -1, this.composing != 0)
      for (let i of a.transactions)
        ad(i) == "input" ? this.composing = 2 : this.composing == 2 && i.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1;
    let { state: a } = this.view, e = a.field(Si);
    for (let t of e.active)
      t.state == 1 && !this.running.some((i) => i.active.source == t.source) && this.startQuery(t);
  }
  startQuery(a) {
    let { state: e } = this.view, t = cn(e), i = new LW(e, t, a.explicitPos == t), s = new KW(a, i);
    this.running.push(s), Promise.resolve(a.source(i)).then((n) => {
      s.context.aborted || (s.done = n || null, this.scheduleAccept());
    }, (n) => {
      this.view.dispatch({ effects: gu.of(null) }), bi(this.view.state, n);
    });
  }
  scheduleAccept() {
    this.running.every((a) => a.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), Hg));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var a;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], t = this.view.state.facet(hn);
    for (let i = 0; i < this.running.length; i++) {
      let s = this.running[i];
      if (s.done === void 0)
        continue;
      if (this.running.splice(i--, 1), s.done) {
        let o = new Jo(s.active.source, s.active.explicitPos, s.done, s.done.from, (a = s.done.to) !== null && a !== void 0 ? a : cn(s.updates.length ? s.updates[0].startState : this.view.state), s.done.span && s.done.filter !== !1 ? Sx(s.done.span, !0) : null);
        for (let l of s.updates)
          o = o.update(l, t);
        if (o.hasResult()) {
          e.push(o);
          continue;
        }
      }
      let n = this.view.state.field(Si).active.find((o) => o.source == s.active.source);
      if (n && n.state == 1)
        if (s.done == null) {
          let o = new Ht(
            s.active.source,
            0
            /* Inactive */
          );
          for (let l of s.updates)
            o = o.update(l, t);
          o.state != 1 && e.push(o);
        } else
          this.startQuery(n);
    }
    e.length && this.view.dispatch({ effects: _x.of(e) });
  }
}, {
  eventHandlers: {
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: pu.of(!1) }), 20), this.composing = 0;
    }
  }
}), Ax = /* @__PURE__ */ Oe.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer",
        padding: "1px 3px",
        lineHeight: 1.2
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "300px"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class iB {
  constructor(e, t, i, s) {
    this.field = e, this.line = t, this.from = i, this.to = s;
  }
}
class mu {
  constructor(e, t, i) {
    this.field = e, this.from = t, this.to = i;
  }
  map(e) {
    let t = e.mapPos(this.from, -1, $t.TrackDel), i = e.mapPos(this.to, 1, $t.TrackDel);
    return t == null || i == null ? null : new mu(this.field, t, i);
  }
}
class bu {
  constructor(e, t) {
    this.lines = e, this.fieldPositions = t;
  }
  instantiate(e, t) {
    let i = [], s = [t], n = e.doc.lineAt(t), o = /^\s*/.exec(n.text)[0];
    for (let c of this.lines) {
      if (i.length) {
        let d = o, f = /^\t*/.exec(c)[0].length;
        for (let p = 0; p < f; p++)
          d += e.facet($l);
        s.push(t + d.length - f), c = d + c.slice(f);
      }
      i.push(c), t += c.length + 1;
    }
    let l = this.fieldPositions.map((c) => new mu(c.field, s[c.line] + c.from, s[c.line] + c.to));
    return { text: i, ranges: l };
  }
  static parse(e) {
    let t = [], i = [], s = [], n;
    for (let o of e.split(/\r\n?|\n/)) {
      for (; n = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(o); ) {
        let l = n[1] ? +n[1] : null, c = n[2] || n[3] || "", d = -1;
        for (let f = 0; f < t.length; f++)
          (l != null ? t[f].seq == l : c && t[f].name == c) && (d = f);
        if (d < 0) {
          let f = 0;
          for (; f < t.length && (l == null || t[f].seq != null && t[f].seq < l); )
            f++;
          t.splice(f, 0, { seq: l, name: c }), d = f;
          for (let p of s)
            p.field >= d && p.field++;
        }
        s.push(new iB(d, i.length, n.index, n.index + c.length)), o = o.slice(0, n.index) + c + o.slice(n.index + n[0].length);
      }
      i.push(o);
    }
    return new bu(i, s);
  }
}
let sB = /* @__PURE__ */ me.widget({ widget: /* @__PURE__ */ new class extends hs {
  toDOM() {
    let a = document.createElement("span");
    return a.className = "cm-snippetFieldPosition", a;
  }
  ignoreEvent() {
    return !1;
  }
}() }), nB = /* @__PURE__ */ me.mark({ class: "cm-snippetField" });
class fr {
  constructor(e, t) {
    this.ranges = e, this.active = t, this.deco = me.set(e.map((i) => (i.from == i.to ? sB : nB).range(i.from, i.to)));
  }
  map(e) {
    let t = [];
    for (let i of this.ranges) {
      let s = i.map(e);
      if (!s)
        return null;
      t.push(s);
    }
    return new fr(t, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((t) => this.ranges.some((i) => i.field == this.active && i.from <= t.from && i.to >= t.to));
  }
}
const Ea = /* @__PURE__ */ _e.define({
  map(a, e) {
    return a && a.map(e);
  }
}), rB = /* @__PURE__ */ _e.define(), aa = /* @__PURE__ */ Mt.define({
  create() {
    return null;
  },
  update(a, e) {
    for (let t of e.effects) {
      if (t.is(Ea))
        return t.value;
      if (t.is(rB) && a)
        return new fr(a.ranges, t.value);
    }
    return a && e.docChanged && (a = a.map(e.changes)), a && e.selection && !a.selectionInsideField(e.selection) && (a = null), a;
  },
  provide: (a) => Oe.decorations.from(a, (e) => e ? e.deco : me.none)
});
function vu(a, e) {
  return ee.create(a.filter((t) => t.field == e).map((t) => ee.range(t.from, t.to)));
}
function aB(a) {
  let e = bu.parse(a);
  return (t, i, s, n) => {
    let { text: o, ranges: l } = e.instantiate(t.state, s), c = { changes: { from: s, to: n, insert: We.of(o) } };
    if (l.length && (c.selection = vu(l, 0)), l.length > 1) {
      let d = new fr(l, 0), f = c.effects = [Ea.of(d)];
      t.state.field(aa, !1) === void 0 && f.push(_e.appendConfig.of([aa, dB, uB, Ax]));
    }
    t.dispatch(t.state.update(c));
  };
}
function $x(a) {
  return ({ state: e, dispatch: t }) => {
    let i = e.field(aa, !1);
    if (!i || a < 0 && i.active == 0)
      return !1;
    let s = i.active + a, n = a > 0 && !i.ranges.some((o) => o.field == s + a);
    return t(e.update({
      selection: vu(i.ranges, s),
      effects: Ea.of(n ? null : new fr(i.ranges, s))
    })), !0;
  };
}
const oB = ({ state: a, dispatch: e }) => a.field(aa, !1) ? (e(a.update({ effects: Ea.of(null) })), !0) : !1, lB = /* @__PURE__ */ $x(1), cB = /* @__PURE__ */ $x(-1), hB = [
  { key: "Tab", run: lB, shift: cB },
  { key: "Escape", run: oB }
], Gg = /* @__PURE__ */ be.define({
  combine(a) {
    return a.length ? a[0] : hB;
  }
}), dB = /* @__PURE__ */ dr.highest(/* @__PURE__ */ Ta.compute([Gg], (a) => a.facet(Gg)));
function Xs(a, e) {
  return Object.assign(Object.assign({}, e), { apply: aB(a) });
}
const uB = /* @__PURE__ */ Oe.domEventHandlers({
  mousedown(a, e) {
    let t = e.state.field(aa, !1), i;
    if (!t || (i = e.posAtCoords({ x: a.clientX, y: a.clientY })) == null)
      return !1;
    let s = t.ranges.find((n) => n.from <= i && n.to >= i);
    return !s || s.field == t.active ? !1 : (e.dispatch({
      selection: vu(t.ranges, s.field),
      effects: Ea.of(t.ranges.some((n) => n.field > s.field) ? new fr(t.ranges, s.field) : null)
    }), !0);
  }
});
function fB(a = {}) {
  return [
    Si,
    hn.of(a),
    tB,
    pB,
    Ax
  ];
}
const Ex = [
  { key: "Ctrl-Space", run: ZW },
  { key: "Escape", run: qW },
  { key: "ArrowDown", run: /* @__PURE__ */ so(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ so(!1) },
  { key: "PageDown", run: /* @__PURE__ */ so(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ so(!1, "page") },
  { key: "Enter", run: UW }
], pB = /* @__PURE__ */ dr.highest(/* @__PURE__ */ Ta.computeN([hn], (a) => a.facet(hn).defaultKeymap ? [Ex] : [])), gB = (a) => {
  let e = Ou(a.state);
  return e.line ? mB(a) : e.block ? vB(a) : !1;
};
function yu(a, e) {
  return ({ state: t, dispatch: i }) => {
    if (t.readOnly)
      return !1;
    let s = a(e, t);
    return s ? (i(t.update(s)), !0) : !1;
  };
}
const mB = /* @__PURE__ */ yu(
  wB,
  0
  /* Toggle */
), bB = /* @__PURE__ */ yu(
  Px,
  0
  /* Toggle */
), vB = /* @__PURE__ */ yu(
  (a, e) => Px(a, e, xB(e)),
  0
  /* Toggle */
), yB = [
  { key: "Mod-/", run: gB },
  { key: "Alt-A", run: bB }
];
function Ou(a, e = a.selection.main.head) {
  let t = a.languageDataAt("commentTokens", e);
  return t.length ? t[0] : {};
}
const yr = 50;
function OB(a, { open: e, close: t }, i, s) {
  let n = a.sliceDoc(i - yr, i), o = a.sliceDoc(s, s + yr), l = /\s*$/.exec(n)[0].length, c = /^\s*/.exec(o)[0].length, d = n.length - l;
  if (n.slice(d - e.length, d) == e && o.slice(c, c + t.length) == t)
    return {
      open: { pos: i - l, margin: l && 1 },
      close: { pos: s + c, margin: c && 1 }
    };
  let f, p;
  s - i <= 2 * yr ? f = p = a.sliceDoc(i, s) : (f = a.sliceDoc(i, i + yr), p = a.sliceDoc(s - yr, s));
  let m = /^\s*/.exec(f)[0].length, v = /\s*$/.exec(p)[0].length, r = p.length - v - t.length;
  return f.slice(m, m + e.length) == e && p.slice(r, r + t.length) == t ? {
    open: {
      pos: i + m + e.length,
      margin: /\s/.test(f.charAt(m + e.length)) ? 1 : 0
    },
    close: {
      pos: s - v - t.length,
      margin: /\s/.test(p.charAt(r - 1)) ? 1 : 0
    }
  } : null;
}
function xB(a) {
  let e = [];
  for (let t of a.selection.ranges) {
    let i = a.doc.lineAt(t.from), s = t.to <= i.to ? i : a.doc.lineAt(t.to), n = e.length - 1;
    n >= 0 && e[n].to > i.from ? e[n].to = s.to : e.push({ from: i.from, to: s.to });
  }
  return e;
}
function Px(a, e, t = e.selection.ranges) {
  let i = t.map((n) => Ou(e, n.from).block);
  if (!i.every((n) => n))
    return null;
  let s = t.map((n, o) => OB(e, i[o], n.from, n.to));
  if (a != 2 && !s.every((n) => n))
    return { changes: e.changes(t.map((n, o) => s[o] ? [] : [{ from: n.from, insert: i[o].open + " " }, { from: n.to, insert: " " + i[o].close }])) };
  if (a != 1 && s.some((n) => n)) {
    let n = [];
    for (let o = 0, l; o < s.length; o++)
      if (l = s[o]) {
        let c = i[o], { open: d, close: f } = l;
        n.push({ from: d.pos - c.open.length, to: d.pos + d.margin }, { from: f.pos - f.margin, to: f.pos + c.close.length });
      }
    return { changes: n };
  }
  return null;
}
function wB(a, e, t = e.selection.ranges) {
  let i = [], s = -1;
  for (let { from: n, to: o } of t) {
    let l = i.length, c = 1e9;
    for (let d = n; d <= o; ) {
      let f = e.doc.lineAt(d);
      if (f.from > s && (n == o || o > f.from)) {
        s = f.from;
        let p = Ou(e, d).line;
        if (!p)
          continue;
        let m = /^\s*/.exec(f.text)[0].length, v = m == f.length, r = f.text.slice(m, m + p.length) == p ? m : -1;
        m < f.text.length && m < c && (c = m), i.push({ line: f, comment: r, token: p, indent: m, empty: v, single: !1 });
      }
      d = f.to + 1;
    }
    if (c < 1e9)
      for (let d = l; d < i.length; d++)
        i[d].indent < i[d].line.text.length && (i[d].indent = c);
    i.length == l + 1 && (i[l].single = !0);
  }
  if (a != 2 && i.some((n) => n.comment < 0 && (!n.empty || n.single))) {
    let n = [];
    for (let { line: l, token: c, indent: d, empty: f, single: p } of i)
      (p || !f) && n.push({ from: l.from + d, insert: c + " " });
    let o = e.changes(n);
    return { changes: o, selection: e.selection.map(o, 1) };
  } else if (a != 1 && i.some((n) => n.comment >= 0)) {
    let n = [];
    for (let { line: o, comment: l, token: c } of i)
      if (l >= 0) {
        let d = o.from + l, f = d + c.length;
        o.text[f - o.from] == " " && f++, n.push({ from: d, to: f });
      }
    return { changes: n };
  }
  return null;
}
const od = 2e3;
function SB(a, e, t) {
  let i = Math.min(e.line, t.line), s = Math.max(e.line, t.line), n = [];
  if (e.off > od || t.off > od || e.col < 0 || t.col < 0) {
    let o = Math.min(e.off, t.off), l = Math.max(e.off, t.off);
    for (let c = i; c <= s; c++) {
      let d = a.doc.line(c);
      d.length <= l && n.push(ee.range(d.from + o, d.to + l));
    }
  } else {
    let o = Math.min(e.col, t.col), l = Math.max(e.col, t.col);
    for (let c = i; c <= s; c++) {
      let d = a.doc.line(c), f = Oh(d.text, o, a.tabSize, !0);
      if (f > -1) {
        let p = Oh(d.text, l, a.tabSize);
        n.push(ee.range(d.from + f, d.from + p));
      }
    }
  }
  return n;
}
function kB(a, e) {
  let t = a.coordsAtPos(a.viewport.from);
  return t ? Math.round(Math.abs((t.left - e) / a.defaultCharacterWidth)) : -1;
}
function jg(a, e) {
  let t = a.posAtCoords({ x: e.clientX, y: e.clientY }, !1), i = a.state.doc.lineAt(t), s = t - i.from, n = s > od ? -1 : s == i.length ? kB(a, e.clientX) : Sa(i.text, a.state.tabSize, t - i.from);
  return { line: i.number, col: n, off: s };
}
function _B(a, e) {
  let t = jg(a, e), i = a.state.selection;
  return t ? {
    update(s) {
      if (s.docChanged) {
        let n = s.changes.mapPos(s.startState.doc.line(t.line).from), o = s.state.doc.lineAt(n);
        t = { line: o.number, col: t.col, off: Math.min(t.off, o.length) }, i = i.map(s.changes);
      }
    },
    get(s, n, o) {
      let l = jg(a, s);
      if (!l)
        return i;
      let c = SB(a.state, t, l);
      return c.length ? o ? ee.create(c.concat(i.ranges)) : ee.create(c) : i;
    }
  } : null;
}
function CB(a) {
  let e = (a == null ? void 0 : a.eventFilter) || ((t) => t.altKey && t.button == 0);
  return Oe.mouseSelectionStyle.of((t, i) => e(i) ? _B(t, i) : null);
}
const TB = {
  Alt: [18, (a) => a.altKey],
  Control: [17, (a) => a.ctrlKey],
  Shift: [16, (a) => a.shiftKey],
  Meta: [91, (a) => a.metaKey]
}, AB = { style: "cursor: crosshair" };
function $B(a = {}) {
  let [e, t] = TB[a.key || "Alt"], i = Ot.fromClass(class {
    constructor(s) {
      this.view = s, this.isDown = !1;
    }
    set(s) {
      this.isDown != s && (this.isDown = s, this.view.update([]));
    }
  }, {
    eventHandlers: {
      keydown(s) {
        this.set(s.keyCode == e || t(s));
      },
      keyup(s) {
        (s.keyCode == e || !t(s)) && this.set(!1);
      }
    }
  });
  return [
    i,
    Oe.contentAttributes.of((s) => {
      var n;
      return !((n = s.plugin(i)) === null || n === void 0) && n.isDown ? AB : null;
    })
  ];
}
let EB = 0;
class Ii {
  /**
  @internal
  */
  constructor(e, t, i) {
    this.set = e, this.base = t, this.modified = i, this.id = EB++;
  }
  /**
  Define a new tag. If `parent` is given, the tag is treated as a
  sub-tag of that parent, and [highlight
  styles](https://codemirror.net/6/docs/ref/#highlight.HighlightStyle) that don't mention this tag
  will try to fall back to the parent tag (or grandparent tag,
  etc).
  */
  static define(e) {
    if (e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let t = new Ii([], null, []);
    if (t.set.push(t), e)
      for (let i of e.set)
        t.set.push(i);
    return t;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier() {
    let e = new el();
    return (t) => t.modified.indexOf(e) > -1 ? t : el.get(t.base || t, t.modified.concat(e).sort((i, s) => i.id - s.id));
  }
}
let PB = 0;
class el {
  constructor() {
    this.instances = [], this.id = PB++;
  }
  static get(e, t) {
    if (!t.length)
      return e;
    let i = t[0].instances.find((l) => l.base == e && LB(t, l.modified));
    if (i)
      return i;
    let s = [], n = new Ii(s, e, t);
    for (let l of t)
      l.instances.push(n);
    let o = Lx(t);
    for (let l of e.set)
      for (let c of o)
        s.push(el.get(l, c));
    return n;
  }
}
function LB(a, e) {
  return a.length == e.length && a.every((t, i) => t == e[i]);
}
function Lx(a) {
  let e = [a];
  for (let t = 0; t < a.length; t++)
    for (let i of Lx(a.slice(0, t).concat(a.slice(t + 1))))
      e.push(i);
  return e;
}
function xu(a) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in a) {
    let i = a[t];
    Array.isArray(i) || (i = [i]);
    for (let s of t.split(" "))
      if (s) {
        let n = [], o = 2, l = s;
        for (let p = 0; ; ) {
          if (l == "..." && p > 0 && p + 3 == s.length) {
            o = 1;
            break;
          }
          let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(l);
          if (!m)
            throw new RangeError("Invalid path: " + s);
          if (n.push(m[0] == "*" ? null : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]), p += m[0].length, p == s.length)
            break;
          let v = s[p++];
          if (p == s.length && v == "!") {
            o = 0;
            break;
          }
          if (v != "/")
            throw new RangeError("Invalid path: " + s);
          l = s.slice(p);
        }
        let c = n.length - 1, d = n[c];
        if (!d)
          throw new RangeError("Invalid path: " + s);
        let f = new MB(i, o, c > 0 ? n.slice(0, c) : null);
        e[d] = f.sort(e[d]);
      }
  }
  return Mx.add(e);
}
const Mx = /* @__PURE__ */ new Ce(), tl = /* @__PURE__ */ be.define({
  combine(a) {
    return a.length ? Bl.combinedMatch(a) : null;
  }
}), Dx = /* @__PURE__ */ be.define({
  combine(a) {
    return a.length ? a[0].match : null;
  }
});
function ld(a) {
  return a.facet(tl) || a.facet(Dx);
}
class MB {
  constructor(e, t, i, s) {
    this.tags = e, this.mode = t, this.context = i, this.next = s;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
class Bl {
  constructor(e, t) {
    this.map = /* @__PURE__ */ Object.create(null);
    let i;
    function s(o) {
      let l = Ps.newName();
      return (i || (i = /* @__PURE__ */ Object.create(null)))["." + l] = o, l;
    }
    this.all = typeof t.all == "string" ? t.all : t.all ? s(t.all) : null;
    for (let o of e) {
      let l = (o.class || s(Object.assign({}, o, { tag: null }))) + (this.all ? " " + this.all : ""), c = o.tag;
      if (!Array.isArray(c))
        this.map[c.id] = l;
      else
        for (let d of c)
          this.map[d.id] = l;
    }
    this.module = i ? new Ps(i) : null, this.scope = t.scope || null, this.match = this.match.bind(this);
    let n = [RB];
    this.module && n.push(Oe.styleModule.of(this.module)), this.extension = n.concat(t.themeType == null ? tl.of(this) : tl.computeN([Oe.darkTheme], (o) => o.facet(Oe.darkTheme) == (t.themeType == "dark") ? [this] : [])), this.fallback = n.concat(Dx.of(this));
  }
  /**
  Returns the CSS class associated with the given tag, if any.
  This method is bound to the instance by the constructor.
  */
  match(e, t) {
    if (this.scope && t != this.scope)
      return null;
    for (let i of e.set) {
      let s = this.map[i.id];
      if (s !== void 0)
        return i != e && (this.map[e.id] = s), s;
    }
    return this.map[e.id] = this.all;
  }
  /**
  Combines an array of highlight styles into a single match
  function that returns all of the classes assigned by the styles
  for a given tag.
  */
  static combinedMatch(e) {
    if (e.length == 1)
      return e[0].match;
    let t = e.some((i) => i.scope) ? void 0 : /* @__PURE__ */ Object.create(null);
    return (i, s) => {
      let n = t && t[i.id];
      if (n !== void 0)
        return n;
      let o = null;
      for (let l of e) {
        let c = l.match(i, s);
        c && (o = o ? o + " " + c : c);
      }
      return t && (t[i.id] = o), o;
    };
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The spec must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighters
  like [`classHighlightStyle`](https://codemirror.net/6/docs/ref/#highlight.classHighlightStyle)
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, t) {
    return new Bl(e, t || {});
  }
  /**
  Returns the CSS classes (if any) that the highlight styles
  active in the given state would assign to the given a style
  [tag](https://codemirror.net/6/docs/ref/#highlight.Tag) and (optional) language
  [scope](https://codemirror.net/6/docs/ref/#highlight.HighlightStyle^define^options.scope).
  */
  static get(e, t, i) {
    let s = ld(e);
    return s && s(t, i || Zt.none);
  }
}
class DB {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = pt(e.state), this.decorations = this.buildDeco(e, ld(e.state));
  }
  update(e) {
    let t = pt(e.state), i = ld(e.state), s = i != e.startState.facet(tl);
    t.length < e.view.viewport.to && !s && t.type == this.tree.type ? this.decorations = this.decorations.map(e.changes) : (t != this.tree || e.viewportChanged || s) && (this.tree = t, this.decorations = this.buildDeco(e.view, i));
  }
  buildDeco(e, t) {
    if (!t || !this.tree.length)
      return me.none;
    let i = new Ls();
    for (let { from: s, to: n } of e.visibleRanges)
      QB(this.tree, s, n, t, (o, l, c) => {
        i.add(o, l, this.markCache[c] || (this.markCache[c] = me.mark({ class: c })));
      });
    return i.finish();
  }
}
const RB = /* @__PURE__ */ dr.high(/* @__PURE__ */ Ot.fromClass(DB, {
  decorations: (a) => a.decorations
})), Ug = [""];
class IB {
  constructor(e, t, i) {
    this.at = e, this.style = t, this.span = i, this.class = "";
  }
  startSpan(e, t) {
    t != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = t);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, t, i, s, n, o) {
    let { type: l, from: c, to: d } = e;
    if (c >= i || d <= t)
      return;
    Ug[n] = l.name, l.isTop && (o = l);
    let f = s, p = l.prop(Mx), m = !1;
    for (; p; ) {
      if (!p.context || NB(p.context, Ug, n)) {
        for (let r of p.tags) {
          let h = this.style(r, o);
          h && (f && (f += " "), f += h, p.mode == 1 ? s += (s ? " " : "") + h : p.mode == 0 && (m = !0));
        }
        break;
      }
      p = p.next;
    }
    if (this.startSpan(e.from, f), m)
      return;
    let v = e.tree && e.tree.prop(Ce.mounted);
    if (v && v.overlay) {
      let r = e.node.enter(v.overlay[0].from + c, 1), h = e.firstChild();
      for (let u = 0, g = c; ; u++) {
        let b = u < v.overlay.length ? v.overlay[u] : null, O = b ? b.from + c : d, x = Math.max(t, g), S = Math.min(i, O);
        if (x < S && h)
          for (; e.from < S && (this.highlightRange(e, x, S, s, n + 1, o), this.startSpan(Math.min(i, e.to), f), !(e.to >= O || !e.nextSibling())); )
            ;
        if (!b || O > i)
          break;
        g = b.to + c, g > t && (this.highlightRange(r.cursor, Math.max(t, b.from + c), Math.min(i, g), s, n, v.tree.type), this.startSpan(g, f));
      }
      h && e.parent();
    } else if (e.firstChild()) {
      do
        if (!(e.to <= t)) {
          if (e.from >= i)
            break;
          this.highlightRange(e, t, i, s, n + 1, o), this.startSpan(Math.min(i, e.to), f);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function QB(a, e, t, i, s) {
  let n = new IB(e, i, s);
  n.highlightRange(a.cursor(), e, t, "", 0, a.type), n.flush(t);
}
function NB(a, e, t) {
  if (a.length > t - 1)
    return !1;
  for (let i = t - 1, s = a.length - 1; s >= 0; s--, i--) {
    let n = a[s];
    if (n && n != e[i])
      return !1;
  }
  return !0;
}
const oe = Ii.define, no = /* @__PURE__ */ oe(), ys = /* @__PURE__ */ oe(), Zg = /* @__PURE__ */ oe(ys), qg = /* @__PURE__ */ oe(ys), Os = /* @__PURE__ */ oe(), ro = /* @__PURE__ */ oe(Os), zc = /* @__PURE__ */ oe(Os), Ri = /* @__PURE__ */ oe(), Ys = /* @__PURE__ */ oe(Ri), Mi = /* @__PURE__ */ oe(), Di = /* @__PURE__ */ oe(), cd = /* @__PURE__ */ oe(), Or = /* @__PURE__ */ oe(cd), ao = /* @__PURE__ */ oe(), Y = {
  /**
  A comment.
  */
  comment: no,
  /**
  A line [comment](https://codemirror.net/6/docs/ref/#highlight.tags.comment).
  */
  lineComment: /* @__PURE__ */ oe(no),
  /**
  A block [comment](https://codemirror.net/6/docs/ref/#highlight.tags.comment).
  */
  blockComment: /* @__PURE__ */ oe(no),
  /**
  A documentation [comment](https://codemirror.net/6/docs/ref/#highlight.tags.comment).
  */
  docComment: /* @__PURE__ */ oe(no),
  /**
  Any kind of identifier.
  */
  name: ys,
  /**
  The [name](https://codemirror.net/6/docs/ref/#highlight.tags.name) of a variable.
  */
  variableName: /* @__PURE__ */ oe(ys),
  /**
  A type [name](https://codemirror.net/6/docs/ref/#highlight.tags.name).
  */
  typeName: Zg,
  /**
  A tag name (subtag of [`typeName`](https://codemirror.net/6/docs/ref/#highlight.tags.typeName)).
  */
  tagName: /* @__PURE__ */ oe(Zg),
  /**
  A property or field [name](https://codemirror.net/6/docs/ref/#highlight.tags.name).
  */
  propertyName: qg,
  /**
  An attribute name (subtag of [`propertyName`](https://codemirror.net/6/docs/ref/#highlight.tags.propertyName)).
  */
  attributeName: /* @__PURE__ */ oe(qg),
  /**
  The [name](https://codemirror.net/6/docs/ref/#highlight.tags.name) of a class.
  */
  className: /* @__PURE__ */ oe(ys),
  /**
  A label [name](https://codemirror.net/6/docs/ref/#highlight.tags.name).
  */
  labelName: /* @__PURE__ */ oe(ys),
  /**
  A namespace [name](https://codemirror.net/6/docs/ref/#highlight.tags.name).
  */
  namespace: /* @__PURE__ */ oe(ys),
  /**
  The [name](https://codemirror.net/6/docs/ref/#highlight.tags.name) of a macro.
  */
  macroName: /* @__PURE__ */ oe(ys),
  /**
  A literal value.
  */
  literal: Os,
  /**
  A string [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).
  */
  string: ro,
  /**
  A documentation [string](https://codemirror.net/6/docs/ref/#highlight.tags.string).
  */
  docString: /* @__PURE__ */ oe(ro),
  /**
  A character literal (subtag of [string](https://codemirror.net/6/docs/ref/#highlight.tags.string)).
  */
  character: /* @__PURE__ */ oe(ro),
  /**
  An attribute value (subtag of [string](https://codemirror.net/6/docs/ref/#highlight.tags.string)).
  */
  attributeValue: /* @__PURE__ */ oe(ro),
  /**
  A number [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).
  */
  number: zc,
  /**
  An integer [number](https://codemirror.net/6/docs/ref/#highlight.tags.number) literal.
  */
  integer: /* @__PURE__ */ oe(zc),
  /**
  A floating-point [number](https://codemirror.net/6/docs/ref/#highlight.tags.number) literal.
  */
  float: /* @__PURE__ */ oe(zc),
  /**
  A boolean [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).
  */
  bool: /* @__PURE__ */ oe(Os),
  /**
  Regular expression [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).
  */
  regexp: /* @__PURE__ */ oe(Os),
  /**
  An escape [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: /* @__PURE__ */ oe(Os),
  /**
  A color [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).
  */
  color: /* @__PURE__ */ oe(Os),
  /**
  A URL [literal](https://codemirror.net/6/docs/ref/#highlight.tags.literal).
  */
  url: /* @__PURE__ */ oe(Os),
  /**
  A language keyword.
  */
  keyword: Mi,
  /**
  The [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) for the self or this
  object.
  */
  self: /* @__PURE__ */ oe(Mi),
  /**
  The [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) for null.
  */
  null: /* @__PURE__ */ oe(Mi),
  /**
  A [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) denoting some atomic value.
  */
  atom: /* @__PURE__ */ oe(Mi),
  /**
  A [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) that represents a unit.
  */
  unit: /* @__PURE__ */ oe(Mi),
  /**
  A modifier [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword).
  */
  modifier: /* @__PURE__ */ oe(Mi),
  /**
  A [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: /* @__PURE__ */ oe(Mi),
  /**
  A control-flow related [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword).
  */
  controlKeyword: /* @__PURE__ */ oe(Mi),
  /**
  A [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: /* @__PURE__ */ oe(Mi),
  /**
  A [keyword](https://codemirror.net/6/docs/ref/#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: /* @__PURE__ */ oe(Mi),
  /**
  An operator.
  */
  operator: Di,
  /**
  An [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator) that defines something.
  */
  derefOperator: /* @__PURE__ */ oe(Di),
  /**
  Arithmetic-related [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).
  */
  arithmeticOperator: /* @__PURE__ */ oe(Di),
  /**
  Logical [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).
  */
  logicOperator: /* @__PURE__ */ oe(Di),
  /**
  Bit [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).
  */
  bitwiseOperator: /* @__PURE__ */ oe(Di),
  /**
  Comparison [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).
  */
  compareOperator: /* @__PURE__ */ oe(Di),
  /**
  [Operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator) that updates its operand.
  */
  updateOperator: /* @__PURE__ */ oe(Di),
  /**
  [Operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator) that defines something.
  */
  definitionOperator: /* @__PURE__ */ oe(Di),
  /**
  Type-related [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).
  */
  typeOperator: /* @__PURE__ */ oe(Di),
  /**
  Control-flow [operator](https://codemirror.net/6/docs/ref/#highlight.tags.operator).
  */
  controlOperator: /* @__PURE__ */ oe(Di),
  /**
  Program or markup punctuation.
  */
  punctuation: cd,
  /**
  [Punctuation](https://codemirror.net/6/docs/ref/#highlight.tags.punctuation) that separates
  things.
  */
  separator: /* @__PURE__ */ oe(cd),
  /**
  Bracket-style [punctuation](https://codemirror.net/6/docs/ref/#highlight.tags.punctuation).
  */
  bracket: Or,
  /**
  Angle [brackets](https://codemirror.net/6/docs/ref/#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: /* @__PURE__ */ oe(Or),
  /**
  Square [brackets](https://codemirror.net/6/docs/ref/#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: /* @__PURE__ */ oe(Or),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](https://codemirror.net/6/docs/ref/#highlight.tags.bracket).
  */
  paren: /* @__PURE__ */ oe(Or),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](https://codemirror.net/6/docs/ref/#highlight.tags.bracket).
  */
  brace: /* @__PURE__ */ oe(Or),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Ri,
  /**
  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that represents a heading.
  */
  heading: Ys,
  /**
  A level 1 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).
  */
  heading1: /* @__PURE__ */ oe(Ys),
  /**
  A level 2 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).
  */
  heading2: /* @__PURE__ */ oe(Ys),
  /**
  A level 3 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).
  */
  heading3: /* @__PURE__ */ oe(Ys),
  /**
  A level 4 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).
  */
  heading4: /* @__PURE__ */ oe(Ys),
  /**
  A level 5 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).
  */
  heading5: /* @__PURE__ */ oe(Ys),
  /**
  A level 6 [heading](https://codemirror.net/6/docs/ref/#highlight.tags.heading).
  */
  heading6: /* @__PURE__ */ oe(Ys),
  /**
  A prose separator (such as a horizontal rule).
  */
  contentSeparator: /* @__PURE__ */ oe(Ri),
  /**
  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that represents a list.
  */
  list: /* @__PURE__ */ oe(Ri),
  /**
  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that represents a quote.
  */
  quote: /* @__PURE__ */ oe(Ri),
  /**
  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that is emphasized.
  */
  emphasis: /* @__PURE__ */ oe(Ri),
  /**
  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that is styled strong.
  */
  strong: /* @__PURE__ */ oe(Ri),
  /**
  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that is part of a link.
  */
  link: /* @__PURE__ */ oe(Ri),
  /**
  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: /* @__PURE__ */ oe(Ri),
  /**
  [Content](https://codemirror.net/6/docs/ref/#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: /* @__PURE__ */ oe(Ri),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: /* @__PURE__ */ oe(),
  /**
  Deleted text.
  */
  deleted: /* @__PURE__ */ oe(),
  /**
  Changed text.
  */
  changed: /* @__PURE__ */ oe(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: /* @__PURE__ */ oe(),
  /**
  Metadata or meta-instruction.
  */
  meta: ao,
  /**
  [Metadata](https://codemirror.net/6/docs/ref/#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: /* @__PURE__ */ oe(ao),
  /**
  [Metadata](https://codemirror.net/6/docs/ref/#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: /* @__PURE__ */ oe(ao),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](https://codemirror.net/6/docs/ref/#highlight.tags.meta).
  */
  processingInstruction: /* @__PURE__ */ oe(ao),
  /**
  [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](https://codemirror.net/6/docs/ref/#highlight.tags.name) tags.
  */
  definition: /* @__PURE__ */ Ii.defineModifier(),
  /**
  [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](https://codemirror.net/6/docs/ref/#highlight.tags.variableName).
  */
  constant: /* @__PURE__ */ Ii.defineModifier(),
  /**
  [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) used to indicate that
  a [variable](https://codemirror.net/6/docs/ref/#highlight.tags.variableName) or [property
  name](https://codemirror.net/6/docs/ref/#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: /* @__PURE__ */ Ii.defineModifier(),
  /**
  [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that can be applied to
  [names](https://codemirror.net/6/docs/ref/#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: /* @__PURE__ */ Ii.defineModifier(),
  /**
  [Modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that indicates a given
  [names](https://codemirror.net/6/docs/ref/#highlight.tags.name) is local to some scope.
  */
  local: /* @__PURE__ */ Ii.defineModifier(),
  /**
  A generic variant [modifier](https://codemirror.net/6/docs/ref/#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](https://codemirror.net/6/docs/ref/#highlight.tags.string) and
  [variable name](https://codemirror.net/6/docs/ref/#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: /* @__PURE__ */ Ii.defineModifier()
}, Rx = /* @__PURE__ */ Bl.define([
  {
    tag: Y.link,
    textDecoration: "underline"
  },
  {
    tag: Y.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: Y.emphasis,
    fontStyle: "italic"
  },
  {
    tag: Y.strong,
    fontWeight: "bold"
  },
  {
    tag: Y.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: Y.keyword,
    color: "#708"
  },
  {
    tag: [Y.atom, Y.bool, Y.url, Y.contentSeparator, Y.labelName],
    color: "#219"
  },
  {
    tag: [Y.literal, Y.inserted],
    color: "#164"
  },
  {
    tag: [Y.string, Y.deleted],
    color: "#a11"
  },
  {
    tag: [Y.regexp, Y.escape, /* @__PURE__ */ Y.special(Y.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ Y.definition(Y.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ Y.local(Y.variableName),
    color: "#30a"
  },
  {
    tag: [Y.typeName, Y.namespace],
    color: "#085"
  },
  {
    tag: Y.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ Y.special(Y.variableName), Y.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ Y.definition(Y.propertyName),
    color: "#00c"
  },
  {
    tag: Y.comment,
    color: "#940"
  },
  {
    tag: Y.meta,
    color: "#7a757a"
  },
  {
    tag: Y.invalid,
    color: "#f00"
  }
]);
class FB {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.diagnostic = i;
  }
}
class js {
  constructor(e, t, i) {
    this.diagnostics = e, this.panel = t, this.selected = i;
  }
  static init(e, t, i) {
    let s = me.set(e.map((n) => n.from == n.to || n.from == n.to - 1 && i.doc.lineAt(n.from).to == n.from ? me.widget({
      widget: new jB(n),
      diagnostic: n
    }).range(n.from) : me.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + n.severity },
      diagnostic: n
    }).range(n.from, n.to)), !0);
    return new js(s, t, Kn(s));
  }
}
function Kn(a, e = null, t = 0) {
  let i = null;
  return a.between(t, 1e9, (s, n, { spec: o }) => {
    if (!(e && o.diagnostic != e))
      return i = new FB(s, n, o.diagnostic), !1;
  }), i;
}
function WB(a, e) {
  return a.field(ii, !1) ? e : e.concat(_e.appendConfig.of([
    ii,
    Oe.decorations.compute([ii], (t) => {
      let { selected: i, panel: s } = t.field(ii);
      return !i || !s || i.from == i.to ? me.none : me.set([
        zB.range(i.from, i.to)
      ]);
    }),
    $W(XB),
    ZB
  ]));
}
const BB = /* @__PURE__ */ _e.define(), wu = /* @__PURE__ */ _e.define(), Ix = /* @__PURE__ */ _e.define(), ii = /* @__PURE__ */ Mt.define({
  create() {
    return new js(me.none, null, null);
  },
  update(a, e) {
    if (e.docChanged) {
      let t = a.diagnostics.map(e.changes), i = null;
      if (a.selected) {
        let s = e.changes.mapPos(a.selected.from, 1);
        i = Kn(t, a.selected.diagnostic, s) || Kn(t, null, s);
      }
      a = new js(t, a.panel, i);
    }
    for (let t of e.effects)
      t.is(BB) ? a = js.init(t.value, a.panel, e.state) : t.is(wu) ? a = new js(a.diagnostics, t.value ? zl.open : null, a.selected) : t.is(Ix) && (a = new js(a.diagnostics, a.panel, t.value));
    return a;
  },
  provide: (a) => [
    na.from(a, (e) => e.panel),
    Oe.decorations.from(a, (e) => e.diagnostics)
  ]
}), zB = /* @__PURE__ */ me.mark({ class: "cm-lintRange cm-lintRange-active" });
function XB(a, e, t) {
  let { diagnostics: i } = a.state.field(ii), s = [], n = 2e8, o = 0;
  return i.between(e - (t < 0 ? 1 : 0), e + (t > 0 ? 1 : 0), (l, c, { spec: d }) => {
    e >= l && e <= c && (l == c || (e > l || t > 0) && (e < c || t < 0)) && (s.push(d.diagnostic), n = Math.min(l, n), o = Math.max(c, o));
  }), s.length ? {
    pos: n,
    end: o,
    above: a.state.doc.lineAt(n).to < o,
    create() {
      return { dom: YB(a, s) };
    }
  } : null;
}
function YB(a, e) {
  return Ue("ul", { class: "cm-tooltip-lint" }, e.map((t) => Nx(a, t, !1)));
}
const VB = (a) => {
  let e = a.state.field(ii, !1);
  (!e || !e.panel) && a.dispatch({ effects: WB(a.state, [wu.of(!0)]) });
  let t = sa(a, zl.open);
  return t && t.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, Kg = (a) => {
  let e = a.state.field(ii, !1);
  return !e || !e.panel ? !1 : (a.dispatch({ effects: wu.of(!1) }), !0);
}, HB = (a) => {
  let e = a.state.field(ii, !1);
  if (!e)
    return !1;
  let t = a.state.selection.main, i = e.diagnostics.iter(t.to + 1);
  return !i.value && (i = e.diagnostics.iter(0), !i.value || i.from == t.from && i.to == t.to) ? !1 : (a.dispatch({ selection: { anchor: i.from, head: i.to }, scrollIntoView: !0 }), !0);
}, GB = [
  { key: "Mod-Shift-m", run: VB },
  { key: "F8", run: HB }
];
function Qx(a) {
  let e = [];
  if (a)
    e:
      for (let { name: t } of a) {
        for (let i = 0; i < t.length; i++) {
          let s = t[i];
          if (/[a-zA-Z]/.test(s) && !e.some((n) => n.toLowerCase() == s.toLowerCase())) {
            e.push(s);
            continue e;
          }
        }
        e.push("");
      }
  return e;
}
function Nx(a, e, t) {
  var i;
  let s = t ? Qx(e.actions) : [];
  return Ue("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, Ue("span", { class: "cm-diagnosticText" }, e.message), (i = e.actions) === null || i === void 0 ? void 0 : i.map((n, o) => {
    let l = (p) => {
      p.preventDefault();
      let m = Kn(a.state.field(ii).diagnostics, e);
      m && n.apply(a, m.from, m.to);
    }, { name: c } = n, d = s[o] ? c.indexOf(s[o]) : -1, f = d < 0 ? c : [
      c.slice(0, d),
      Ue("u", c.slice(d, d + 1)),
      c.slice(d + 1)
    ];
    return Ue("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: l,
      onmousedown: l,
      "aria-label": ` Action: ${c}${d < 0 ? "" : ` (access key "${s[o]})"`}.`
    }, f);
  }), e.source && Ue("div", { class: "cm-diagnosticSource" }, e.source));
}
class jB extends hs {
  constructor(e) {
    super(), this.diagnostic = e;
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return Ue("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class Jg {
  constructor(e, t) {
    this.diagnostic = t, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = Nx(e, t, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class zl {
  constructor(e) {
    this.view = e, this.items = [];
    let t = (s) => {
      if (s.keyCode == 27)
        Kg(this.view), this.view.focus();
      else if (s.keyCode == 38 || s.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (s.keyCode == 40 || s.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (s.keyCode == 36)
        this.moveSelection(0);
      else if (s.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (s.keyCode == 13)
        this.view.focus();
      else if (s.keyCode >= 65 && s.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: n } = this.items[this.selectedIndex], o = Qx(n.actions);
        for (let l = 0; l < o.length; l++)
          if (o[l].toUpperCase().charCodeAt(0) == s.keyCode) {
            let c = Kn(this.view.state.field(ii).diagnostics, n);
            c && n.actions[l].apply(e, c.from, c.to);
          }
      } else
        return;
      s.preventDefault();
    }, i = (s) => {
      for (let n = 0; n < this.items.length; n++)
        this.items[n].dom.contains(s.target) && this.moveSelection(n);
    };
    this.list = Ue("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: t,
      onclick: i
    }), this.dom = Ue("div", { class: "cm-panel-lint" }, this.list, Ue("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => Kg(this.view)
    }, "×")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(ii).selected;
    if (!e)
      return -1;
    for (let t = 0; t < this.items.length; t++)
      if (this.items[t].diagnostic == e.diagnostic)
        return t;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: t } = this.view.state.field(ii), i = 0, s = !1, n = null;
    for (e.between(0, this.view.state.doc.length, (o, l, { spec: c }) => {
      let d = -1, f;
      for (let p = i; p < this.items.length; p++)
        if (this.items[p].diagnostic == c.diagnostic) {
          d = p;
          break;
        }
      d < 0 ? (f = new Jg(this.view, c.diagnostic), this.items.splice(i, 0, f), s = !0) : (f = this.items[d], d > i && (this.items.splice(i, d - i), s = !0)), t && f.diagnostic == t.diagnostic ? f.dom.hasAttribute("aria-selected") || (f.dom.setAttribute("aria-selected", "true"), n = f) : f.dom.hasAttribute("aria-selected") && f.dom.removeAttribute("aria-selected"), i++;
    }); i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      s = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new Jg(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), s = !0), n ? (this.list.setAttribute("aria-activedescendant", n.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: n.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: o, panel: l }) => {
        o.top < l.top ? this.list.scrollTop -= l.top - o.top : o.bottom > l.bottom && (this.list.scrollTop += o.bottom - l.bottom);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), s && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function t() {
      let i = e;
      e = i.nextSibling, i.remove();
    }
    for (let i of this.items)
      if (i.dom.parentNode == this.list) {
        for (; e != i.dom; )
          t();
        e = i.dom.nextSibling;
      } else
        this.list.insertBefore(i.dom, e);
    for (; e; )
      t();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let t = this.view.state.field(ii), i = Kn(t.diagnostics, this.items[e].diagnostic);
    i && this.view.dispatch({
      selection: { anchor: i.from, head: i.to },
      scrollIntoView: !0,
      effects: Ix.of(i)
    });
  }
  static open(e) {
    return new zl(e);
  }
}
function UB(a, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(a)}</svg>')`;
}
function Xc(a) {
  return UB(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${a}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const ZB = /* @__PURE__ */ Oe.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ Xc("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ Xc("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ Xc("#999") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
}), qB = [
  /* @__PURE__ */ DN(),
  /* @__PURE__ */ QN(),
  /* @__PURE__ */ $Q(),
  /* @__PURE__ */ oO(),
  /* @__PURE__ */ GN(),
  /* @__PURE__ */ bQ(),
  /* @__PURE__ */ SQ(),
  /* @__PURE__ */ Re.allowMultipleSelections.of(!0),
  /* @__PURE__ */ wN(),
  Rx.fallback,
  /* @__PURE__ */ eF(),
  /* @__PURE__ */ NF(),
  /* @__PURE__ */ fB(),
  /* @__PURE__ */ CB(),
  /* @__PURE__ */ $B(),
  /* @__PURE__ */ RQ(),
  /* @__PURE__ */ eW(),
  /* @__PURE__ */ Ta.of([
    ...zF,
    ...rx,
    ...bW,
    ...uO,
    ...XN,
    ...yB,
    ...Ex,
    ...GB
  ])
];
class il {
  /// @internal
  constructor(e, t, i, s, n, o, l, c, d, f = 0, p) {
    this.p = e, this.stack = t, this.state = i, this.reducePos = s, this.pos = n, this.score = o, this.buffer = l, this.bufferBase = c, this.curContext = d, this.lookAhead = f, this.parent = p;
  }
  /// @internal
  toString() {
    return `[${this.stack.filter((e, t) => t % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /// @internal
  static start(e, t, i = 0) {
    let s = e.parser.context;
    return new il(e, [], t, i, i, 0, [], 0, s ? new em(s, s.start) : null, 0, null);
  }
  /// The stack's current [context](#lr.ContextTracker) value, if
  /// any. Its type will depend on the context tracker's type
  /// parameter, or it will be `null` if there is no context
  /// tracker.
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /// @internal
  pushState(e, t) {
    this.stack.push(this.state, t, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /// @internal
  reduce(e) {
    let t = e >> 19, i = e & 65535, { parser: s } = this.p, n = s.dynamicPrecedence(i);
    if (n && (this.score += n), t == 0) {
      this.pushState(s.getGoto(this.state, i, !0), this.reducePos), i < s.minRepeatTerm && this.storeNode(i, this.reducePos, this.reducePos, 4, !0), this.reduceContext(i, this.reducePos);
      return;
    }
    let o = this.stack.length - (t - 1) * 3 - (e & 262144 ? 6 : 0), l = this.stack[o - 2], c = this.stack[o - 1], d = this.bufferBase + this.buffer.length - c;
    if (i < s.minRepeatTerm || e & 131072) {
      let f = s.stateFlag(
        this.state,
        1
        /* Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(i, l, f, d + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[o];
    else {
      let f = this.stack[o - 3];
      this.state = s.getGoto(f, i, !0);
    }
    for (; this.stack.length > o; )
      this.stack.pop();
    this.reduceContext(i, l);
  }
  // Shift a value into the buffer
  /// @internal
  storeNode(e, t, i, s = 4, n = !1) {
    if (e == 0) {
      let o = this, l = this.buffer.length;
      if (l == 0 && o.parent && (l = o.bufferBase - o.parent.bufferBase, o = o.parent), l > 0 && o.buffer[l - 4] == 0 && o.buffer[l - 1] > -1) {
        if (t == i)
          return;
        if (o.buffer[l - 2] >= t) {
          o.buffer[l - 2] = i;
          return;
        }
      }
    }
    if (!n || this.pos == i)
      this.buffer.push(e, t, i, s);
    else {
      let o = this.buffer.length;
      if (o > 0 && this.buffer[o - 4] != 0)
        for (; o > 0 && this.buffer[o - 2] > i; )
          this.buffer[o] = this.buffer[o - 4], this.buffer[o + 1] = this.buffer[o - 3], this.buffer[o + 2] = this.buffer[o - 2], this.buffer[o + 3] = this.buffer[o - 1], o -= 4, s > 4 && (s -= 4);
      this.buffer[o] = e, this.buffer[o + 1] = t, this.buffer[o + 2] = i, this.buffer[o + 3] = s;
    }
  }
  // Apply a shift action
  /// @internal
  shift(e, t, i) {
    let s = this.pos;
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if (e & 262144)
      this.pos = i, this.shiftContext(t, s), t <= this.p.parser.maxNode && this.buffer.push(t, s, i, 4);
    else {
      let n = e, { parser: o } = this.p;
      (i > this.pos || t <= o.maxNode) && (this.pos = i, o.stateFlag(
        n,
        1
        /* Skipped */
      ) || (this.reducePos = i)), this.pushState(n, s), this.shiftContext(t, s), t <= o.maxNode && this.buffer.push(t, s, i, 4);
    }
  }
  // Apply an action
  /// @internal
  apply(e, t, i) {
    e & 65536 ? this.reduce(e) : this.shift(e, t, i);
  }
  // Add a prebuilt (reused) node into the buffer.
  /// @internal
  useNode(e, t) {
    let i = this.p.reused.length - 1;
    (i < 0 || this.p.reused[i] != e) && (this.p.reused.push(e), i++);
    let s = this.pos;
    this.reducePos = this.pos = s + e.length, this.pushState(t, s), this.buffer.push(
      i,
      s,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /// @internal
  split() {
    let e = this, t = e.buffer.length;
    for (; t > 0 && e.buffer[t - 2] > e.reducePos; )
      t -= 4;
    let i = e.buffer.slice(t), s = e.bufferBase + t;
    for (; e && s == e.bufferBase; )
      e = e.parent;
    return new il(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, s, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /// @internal
  recoverByDelete(e, t) {
    let i = e <= this.p.parser.maxNode;
    i && this.storeNode(e, this.pos, t, 4), this.storeNode(0, this.pos, t, i ? 8 : 4), this.pos = this.reducePos = t, this.score -= 190;
  }
  /// Check if the given term would be able to be shifted (optionally
  /// after some reductions) on this stack. This can be useful for
  /// external tokenizers that want to make sure they only provide a
  /// given token when it applies.
  canShift(e) {
    for (let t = new KB(this); ; ) {
      let i = this.p.parser.stateSlot(
        t.state,
        4
        /* DefaultReduce */
      ) || this.p.parser.hasAction(t.state, e);
      if (!(i & 65536))
        return !0;
      if (i == 0)
        return !1;
      t.reduce(i);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /// @internal
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let t = this.p.parser.nextStates(this.state);
    if (t.length > 8 || this.stack.length >= 120) {
      let s = [];
      for (let n = 0, o; n < t.length; n += 2)
        (o = t[n + 1]) != this.state && this.p.parser.hasAction(o, e) && s.push(t[n], o);
      if (this.stack.length < 120)
        for (let n = 0; s.length < 8 && n < t.length; n += 2) {
          let o = t[n + 1];
          s.some((l, c) => c & 1 && l == o) || s.push(t[n], o);
        }
      t = s;
    }
    let i = [];
    for (let s = 0; s < t.length && i.length < 4; s += 2) {
      let n = t[s + 1];
      if (n == this.state)
        continue;
      let o = this.split();
      o.storeNode(0, o.pos, o.pos, 4, !0), o.pushState(n, this.pos), o.shiftContext(t[s], this.pos), o.score -= 200, i.push(o);
    }
    return i;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /// @internal
  forceReduce() {
    let e = this.p.parser.stateSlot(
      this.state,
      5
      /* ForcedReduce */
    );
    if (!(e & 65536))
      return !1;
    let { parser: t } = this.p;
    if (!t.validAction(this.state, e)) {
      let i = e >> 19, s = e & 65535, n = this.stack.length - i * 3;
      if (n < 0 || t.getGoto(this.stack[n], s, !1) < 0)
        return !1;
      this.storeNode(0, this.reducePos, this.reducePos, 4, !0), this.score -= 100;
    }
    return this.reduce(e), !0;
  }
  /// @internal
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /// Check whether this state has no further actions (assumed to be a direct descendant of the
  /// top state, since any other states must be able to continue
  /// somehow). @internal
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* DefaultReduce */
    );
  }
  /// Restart the stack (put it back in its start state). Only safe
  /// when this.stack.length == 3 (state is directly below the top
  /// state). @internal
  restart() {
    this.state = this.stack[0], this.stack.length = 0;
  }
  /// @internal
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let t = 0; t < this.stack.length; t += 3)
      if (this.stack[t] != e.stack[t])
        return !1;
    return !0;
  }
  /// Get the parser used by this stack.
  get parser() {
    return this.p.parser;
  }
  /// Test whether a given dialect (by numeric ID, as exported from
  /// the terms file) is enabled.
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  reduceContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  /// @internal
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
  }
  /// @internal
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let t = new em(this.curContext.tracker, e);
      t.hash != this.curContext.hash && this.emitContext(), this.curContext = t;
    }
  }
  /// @internal
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /// @internal
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class em {
  constructor(e, t) {
    this.tracker = e, this.context = t, this.hash = e.strict ? e.hash(t) : 0;
  }
}
var tm;
(function(a) {
  a[a.Insert = 200] = "Insert", a[a.Delete = 190] = "Delete", a[a.Reduce = 100] = "Reduce", a[a.MaxNext = 4] = "MaxNext", a[a.MaxInsertStackDepth = 300] = "MaxInsertStackDepth", a[a.DampenInsertStackDepth = 120] = "DampenInsertStackDepth";
})(tm || (tm = {}));
class KB {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let t = e & 65535, i = e >> 19;
    i == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (i - 1) * 3;
    let s = this.start.p.parser.getGoto(this.stack[this.base - 3], t, !0);
    this.state = s;
  }
}
class sl {
  constructor(e, t, i) {
    this.stack = e, this.pos = t, this.index = i, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, t = e.bufferBase + e.buffer.length) {
    return new sl(e, t, t - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new sl(this.stack, this.pos, this.index);
  }
}
class Oo {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const im = new Oo();
class JB {
  /// @internal
  constructor(e, t) {
    this.input = e, this.ranges = t, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = im, this.rangeIndex = 0, this.pos = this.chunkPos = t[0].from, this.range = t[0], this.end = t[t.length - 1].to, this.readNext();
  }
  resolveOffset(e, t) {
    let i = this.range, s = this.rangeIndex, n = this.pos + e;
    for (; n < i.from; ) {
      if (!s)
        return null;
      let o = this.ranges[--s];
      n -= i.from - o.to, i = o;
    }
    for (; t < 0 ? n > i.to : n >= i.to; ) {
      if (s == this.ranges.length - 1)
        return null;
      let o = this.ranges[++s];
      n += o.from - i.to, i = o;
    }
    return n;
  }
  /// Look at a code unit near the stream position. `.peek(0)` equals
  /// `.next`, `.peek(-1)` gives you the previous character, and so
  /// on.
  ///
  /// Note that looking around during tokenizing creates dependencies
  /// on potentially far-away content, which may reduce the
  /// effectiveness incremental parsing—when looking forward—or even
  /// cause invalid reparses when looking backward more than 25 code
  /// units, since the library does not track lookbehind.
  peek(e) {
    let t = this.chunkOff + e, i, s;
    if (t >= 0 && t < this.chunk.length)
      i = this.pos + e, s = this.chunk.charCodeAt(t);
    else {
      let n = this.resolveOffset(e, 1);
      if (n == null)
        return -1;
      if (i = n, i >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length)
        s = this.chunk2.charCodeAt(i - this.chunk2Pos);
      else {
        let o = this.rangeIndex, l = this.range;
        for (; l.to <= i; )
          l = this.ranges[++o];
        this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > l.to && (this.chunk2 = this.chunk2.slice(0, l.to - i)), s = this.chunk2.charCodeAt(0);
      }
    }
    return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), s;
  }
  /// Accept a token. By default, the end of the token is set to the
  /// current stream position, but you can pass an offset (relative to
  /// the stream position) to change that.
  acceptToken(e, t = 0) {
    let i = t ? this.resolveOffset(t, -1) : this.pos;
    if (i == null || i < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = i;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: t } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = t, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), t = this.pos + e.length;
      this.chunk = t > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /// Move the stream forward N (defaults to 1) code units. Returns
  /// the new value of [`next`](#lr.InputStream.next).
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /// @internal
  reset(e, t) {
    if (t ? (this.token = t, t.start = e, t.lookAhead = e + 1, t.value = t.extended = -1) : this.token = im, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /// @internal
  read(e, t) {
    if (e >= this.chunkPos && t <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, t - this.chunkPos);
    if (e >= this.chunk2Pos && t <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, t - this.chunk2Pos);
    if (e >= this.range.from && t <= this.range.to)
      return this.input.read(e, t);
    let i = "";
    for (let s of this.ranges) {
      if (s.from >= t)
        break;
      s.to > e && (i += this.input.read(Math.max(s.from, e), Math.min(s.to, t)));
    }
    return i;
  }
}
class xo {
  constructor(e, t) {
    this.data = e, this.id = t;
  }
  token(e, t) {
    ez(this.data, e, t, this.id);
  }
}
xo.prototype.contextual = xo.prototype.fallback = xo.prototype.extend = !1;
class ji {
  /// Create a tokenizer. The first argument is the function that,
  /// given an input stream, scans for the types of tokens it
  /// recognizes at the stream's position, and calls
  /// [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  /// one.
  constructor(e, t = {}) {
    this.token = e, this.contextual = !!t.contextual, this.fallback = !!t.fallback, this.extend = !!t.extend;
  }
}
function ez(a, e, t, i) {
  let s = 0, n = 1 << i, { parser: o } = t.p, { dialect: l } = o;
  e:
    for (; n & a[s]; ) {
      let c = a[s + 1];
      for (let d = s + 3; d < c; d += 2)
        if ((a[d + 1] & n) > 0) {
          let f = a[d];
          if (l.allows(f) && (e.token.value == -1 || e.token.value == f || o.overrides(f, e.token.value))) {
            e.acceptToken(f);
            break;
          }
        }
      for (let d = e.next, f = 0, p = a[s + 2]; f < p; ) {
        let m = f + p >> 1, v = c + m + (m << 1), r = a[v], h = a[v + 1];
        if (d < r)
          p = m;
        else if (d >= h)
          f = m + 1;
        else {
          s = a[v + 2], e.advance();
          continue e;
        }
      }
      break;
    }
}
function oo(a, e = Uint16Array) {
  if (typeof a != "string")
    return a;
  let t = null;
  for (let i = 0, s = 0; i < a.length; ) {
    let n = 0;
    for (; ; ) {
      let o = a.charCodeAt(i++), l = !1;
      if (o == 126) {
        n = 65535;
        break;
      }
      o >= 92 && o--, o >= 34 && o--;
      let c = o - 32;
      if (c >= 46 && (c -= 46, l = !0), n += c, l)
        break;
      n *= 46;
    }
    t ? t[s++] = n : t = new e(n);
  }
  return t;
}
const wi = typeof process < "u" && /\bparse\b/.test(process.env.LOG);
let Yc = null;
var sm;
(function(a) {
  a[a.Margin = 25] = "Margin";
})(sm || (sm = {}));
function nm(a, e, t) {
  let i = a.fullCursor();
  for (i.moveTo(e); ; )
    if (!(t < 0 ? i.childBefore(e) : i.childAfter(e)))
      for (; ; ) {
        if ((t < 0 ? i.to < e : i.from > e) && !i.type.isError)
          return t < 0 ? Math.max(0, Math.min(
            i.to - 1,
            e - 25
            /* Margin */
          )) : Math.min(a.length, Math.max(
            i.from + 1,
            e + 25
            /* Margin */
          ));
        if (t < 0 ? i.prevSibling() : i.nextSibling())
          break;
        if (!i.parent())
          return t < 0 ? 0 : a.length;
      }
}
class tz {
  constructor(e, t) {
    this.fragments = e, this.nodeSet = t, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? nm(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? nm(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let t = this.trees.length - 1;
      if (t < 0)
        return this.nextFragment(), null;
      let i = this.trees[t], s = this.index[t];
      if (s == i.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let n = i.children[s], o = this.start[t] + i.positions[s];
      if (o > e)
        return this.nextStart = o, null;
      if (n instanceof it) {
        if (o == e) {
          if (o < this.safeFrom)
            return null;
          let l = o + n.length;
          if (l <= this.safeTo) {
            let c = n.prop(Ce.lookAhead);
            if (!c || l + c < this.fragment.to)
              return n;
          }
        }
        this.index[t]++, o + n.length >= Math.max(this.safeFrom, e) && (this.trees.push(n), this.start.push(o), this.index.push(0));
      } else
        this.index[t]++, this.nextStart = o + n.length;
    }
  }
}
class iz {
  constructor(e, t) {
    this.stream = t, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((i) => new Oo());
  }
  getActions(e) {
    let t = 0, i = null, { parser: s } = e.p, { tokenizers: n } = s, o = s.stateSlot(
      e.state,
      3
      /* TokenizerMask */
    ), l = e.curContext ? e.curContext.hash : 0, c = 0;
    for (let d = 0; d < n.length; d++) {
      if (!(1 << d & o))
        continue;
      let f = n[d], p = this.tokens[d];
      if (!(i && !f.fallback) && ((f.contextual || p.start != e.pos || p.mask != o || p.context != l) && (this.updateCachedToken(p, f, e), p.mask = o, p.context = l), p.lookAhead > p.end + 25 && (c = Math.max(p.lookAhead, c)), p.value != 0)) {
        let m = t;
        if (p.extended > -1 && (t = this.addActions(e, p.extended, p.end, t)), t = this.addActions(e, p.value, p.end, t), !f.extend && (i = p, t > m))
          break;
      }
    }
    for (; this.actions.length > t; )
      this.actions.pop();
    return c && e.setLookAhead(c), !i && e.pos == this.stream.end && (i = new Oo(), i.value = e.p.parser.eofTerm, i.start = i.end = e.pos, t = this.addActions(e, i.value, i.end, t)), this.mainToken = i, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let t = new Oo(), { pos: i, p: s } = e;
    return t.start = i, t.end = Math.min(i + 1, s.stream.end), t.value = i == s.stream.end ? s.parser.eofTerm : 0, t;
  }
  updateCachedToken(e, t, i) {
    if (t.token(this.stream.reset(i.pos, e), i), e.value > -1) {
      let { parser: s } = i.p;
      for (let n = 0; n < s.specialized.length; n++)
        if (s.specialized[n] == e.value) {
          let o = s.specializers[n](this.stream.read(e.start, e.end), i);
          if (o >= 0 && i.p.parser.dialect.allows(o >> 1)) {
            o & 1 ? e.extended = o >> 1 : e.value = o >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = Math.min(i.p.stream.end, i.pos + 1);
  }
  putAction(e, t, i, s) {
    for (let n = 0; n < s; n += 3)
      if (this.actions[n] == e)
        return s;
    return this.actions[s++] = e, this.actions[s++] = t, this.actions[s++] = i, s;
  }
  addActions(e, t, i, s) {
    let { state: n } = e, { parser: o } = e.p, { data: l } = o;
    for (let c = 0; c < 2; c++)
      for (let d = o.stateSlot(
        n,
        c ? 2 : 1
        /* Actions */
      ); ; d += 3) {
        if (l[d] == 65535)
          if (l[d + 1] == 1)
            d = qi(l, d + 2);
          else {
            s == 0 && l[d + 1] == 2 && (s = this.putAction(qi(l, d + 2), t, i, s));
            break;
          }
        l[d] == t && (s = this.putAction(qi(l, d + 1), t, i, s));
      }
    return s;
  }
}
var rm;
(function(a) {
  a[a.Distance = 5] = "Distance", a[a.MaxRemainingPerStep = 3] = "MaxRemainingPerStep", a[a.MinBufferLengthPrune = 500] = "MinBufferLengthPrune", a[a.ForceReduceLimit = 10] = "ForceReduceLimit", a[a.CutDepth = 15e3] = "CutDepth", a[a.CutTo = 9e3] = "CutTo";
})(rm || (rm = {}));
class sz {
  constructor(e, t, i, s) {
    this.parser = e, this.input = t, this.ranges = s, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.stream = new JB(t, s), this.tokens = new iz(e, this.stream), this.topTerm = e.top[1];
    let { from: n } = s[0];
    this.stacks = [il.start(this, e.top[0], n)], this.fragments = i.length && this.stream.end - n > e.bufferLength * 4 ? new tz(i, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, t = this.minStackPos, i = this.stacks = [], s, n;
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      for (; ; ) {
        if (this.tokens.mainToken = null, l.pos > t)
          i.push(l);
        else {
          if (this.advanceStack(l, i, e))
            continue;
          {
            s || (s = [], n = []), s.push(l);
            let c = this.tokens.getMainToken(l);
            n.push(c.value, c.end);
          }
        }
        break;
      }
    }
    if (!i.length) {
      let o = s && rz(s);
      if (o)
        return this.stackToTree(o);
      if (this.parser.strict)
        throw wi && s && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + t);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && s) {
      let o = this.stoppedAt != null && s[0].pos > this.stoppedAt ? s[0] : this.runRecovery(s, n, i);
      if (o)
        return this.stackToTree(o.forceAll());
    }
    if (this.recovering) {
      let o = this.recovering == 1 ? 1 : this.recovering * 3;
      if (i.length > o)
        for (i.sort((l, c) => c.score - l.score); i.length > o; )
          i.pop();
      i.some((l) => l.reducePos > t) && this.recovering--;
    } else if (i.length > 1)
      e:
        for (let o = 0; o < i.length - 1; o++) {
          let l = i[o];
          for (let c = o + 1; c < i.length; c++) {
            let d = i[c];
            if (l.sameState(d) || l.buffer.length > 500 && d.buffer.length > 500)
              if ((l.score - d.score || l.buffer.length - d.buffer.length) > 0)
                i.splice(c--, 1);
              else {
                i.splice(o--, 1);
                continue e;
              }
          }
        }
    this.minStackPos = i[0].pos;
    for (let o = 1; o < i.length; o++)
      i[o].pos < this.minStackPos && (this.minStackPos = i[o].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, t, i) {
    let s = e.pos, { parser: n } = this, o = wi ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && s > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let d = e.curContext && e.curContext.tracker.strict, f = d ? e.curContext.hash : 0;
      for (let p = this.fragments.nodeAt(s); p; ) {
        let m = this.parser.nodeSet.types[p.type.id] == p.type ? n.getGoto(e.state, p.type.id) : -1;
        if (m > -1 && p.length && (!d || (p.prop(Ce.contextHash) || 0) == f))
          return e.useNode(p, m), wi && console.log(o + this.stackID(e) + ` (via reuse of ${n.getName(p.type.id)})`), !0;
        if (!(p instanceof it) || p.children.length == 0 || p.positions[0] > 0)
          break;
        let v = p.children[0];
        if (v instanceof it && p.positions[0] == 0)
          p = v;
        else
          break;
      }
    }
    let l = n.stateSlot(
      e.state,
      4
      /* DefaultReduce */
    );
    if (l > 0)
      return e.reduce(l), wi && console.log(o + this.stackID(e) + ` (via always-reduce ${n.getName(
        l & 65535
        /* ValueMask */
      )})`), !0;
    if (e.stack.length >= 15e3)
      for (; e.stack.length > 9e3 && e.forceReduce(); )
        ;
    let c = this.tokens.getActions(e);
    for (let d = 0; d < c.length; ) {
      let f = c[d++], p = c[d++], m = c[d++], v = d == c.length || !i, r = v ? e : e.split();
      if (r.apply(f, p, m), wi && console.log(o + this.stackID(r) + ` (via ${f & 65536 ? `reduce of ${n.getName(
        f & 65535
        /* ValueMask */
      )}` : "shift"} for ${n.getName(p)} @ ${s}${r == e ? "" : ", split"})`), v)
        return !0;
      r.pos > s ? t.push(r) : i.push(r);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, t) {
    let i = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > i)
        return am(e, t), !0;
    }
  }
  runRecovery(e, t, i) {
    let s = null, n = !1;
    for (let o = 0; o < e.length; o++) {
      let l = e[o], c = t[o << 1], d = t[(o << 1) + 1], f = wi ? this.stackID(l) + " -> " : "";
      if (l.deadEnd && (n || (n = !0, l.restart(), wi && console.log(f + this.stackID(l) + " (restarted)"), this.advanceFully(l, i))))
        continue;
      let p = l.split(), m = f;
      for (let v = 0; p.forceReduce() && v < 10 && (wi && console.log(m + this.stackID(p) + " (via force-reduce)"), !this.advanceFully(p, i)); v++)
        wi && (m = this.stackID(p) + " -> ");
      for (let v of l.recoverByInsert(c))
        wi && console.log(f + this.stackID(v) + " (via recover-insert)"), this.advanceFully(v, i);
      this.stream.end > l.pos ? (d == l.pos && (d++, c = 0), l.recoverByDelete(c, d), wi && console.log(f + this.stackID(l) + ` (via recover-delete ${this.parser.getName(c)})`), am(l, i)) : (!s || s.score < l.score) && (s = l);
    }
    return s;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), it.build({
      buffer: sl.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let t = (Yc || (Yc = /* @__PURE__ */ new WeakMap())).get(e);
    return t || Yc.set(e, t = String.fromCodePoint(this.nextStackID++)), t + e;
  }
}
function am(a, e) {
  for (let t = 0; t < e.length; t++) {
    let i = e[t];
    if (i.pos == a.pos && i.sameState(a)) {
      e[t].score < a.score && (e[t] = a);
      return;
    }
  }
  e.push(a);
}
class nz {
  constructor(e, t, i) {
    this.source = e, this.flags = t, this.disabled = i;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const Vc = (a) => a;
class Fx {
  /// Define a context tracker.
  constructor(e) {
    this.start = e.start, this.shift = e.shift || Vc, this.reduce = e.reduce || Vc, this.reuse = e.reuse || Vc, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1;
  }
}
class Jn extends mO {
  /// @internal
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 13)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (13)`);
    let t = e.nodeNames.split(" ");
    this.minRepeatTerm = t.length;
    for (let l = 0; l < e.repeatNodeCount; l++)
      t.push("");
    let i = Object.keys(e.topRules).map((l) => e.topRules[l][1]), s = [];
    for (let l = 0; l < t.length; l++)
      s.push([]);
    function n(l, c, d) {
      s[l].push([c, c.deserialize(String(d))]);
    }
    if (e.nodeProps)
      for (let l of e.nodeProps) {
        let c = l[0];
        for (let d = 1; d < l.length; ) {
          let f = l[d++];
          if (f >= 0)
            n(f, c, l[d++]);
          else {
            let p = l[d + -f];
            for (let m = -f; m > 0; m--)
              n(l[d++], c, p);
            d++;
          }
        }
      }
    this.nodeSet = new qd(t.map((l, c) => Zt.define({
      name: c >= this.minRepeatTerm ? void 0 : l,
      id: c,
      props: s[c],
      top: i.indexOf(c) > -1,
      error: c == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(c) > -1
    }))), this.strict = !1, this.bufferLength = fO;
    let o = oo(e.tokenData);
    if (this.context = e.context, this.specialized = new Uint16Array(e.specialized ? e.specialized.length : 0), this.specializers = [], e.specialized)
      for (let l = 0; l < e.specialized.length; l++)
        this.specialized[l] = e.specialized[l].term, this.specializers[l] = e.specialized[l].get;
    this.states = oo(e.states, Uint32Array), this.data = oo(e.stateData), this.goto = oo(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((l) => typeof l == "number" ? new xo(o, l) : l), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, t, i) {
    let s = new sz(this, e, t, i);
    for (let n of this.wrappers)
      s = n(s, e, t, i);
    return s;
  }
  /// Get a goto table entry @internal
  getGoto(e, t, i = !1) {
    let s = this.goto;
    if (t >= s[0])
      return -1;
    for (let n = s[t + 1]; ; ) {
      let o = s[n++], l = o & 1, c = s[n++];
      if (l && i)
        return c;
      for (let d = n + (o >> 1); n < d; n++)
        if (s[n] == e)
          return c;
      if (l)
        return -1;
    }
  }
  /// Check if this state has an action for a given terminal @internal
  hasAction(e, t) {
    let i = this.data;
    for (let s = 0; s < 2; s++)
      for (let n = this.stateSlot(
        e,
        s ? 2 : 1
        /* Actions */
      ), o; ; n += 3) {
        if ((o = i[n]) == 65535)
          if (i[n + 1] == 1)
            o = i[n = qi(i, n + 2)];
          else {
            if (i[n + 1] == 2)
              return qi(i, n + 2);
            break;
          }
        if (o == t || o == 0)
          return qi(i, n + 1);
      }
    return 0;
  }
  /// @internal
  stateSlot(e, t) {
    return this.states[e * 6 + t];
  }
  /// @internal
  stateFlag(e, t) {
    return (this.stateSlot(
      e,
      0
      /* Flags */
    ) & t) > 0;
  }
  /// @internal
  validAction(e, t) {
    if (t == this.stateSlot(
      e,
      4
      /* DefaultReduce */
    ))
      return !0;
    for (let i = this.stateSlot(
      e,
      1
      /* Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = qi(this.data, i + 2);
        else
          return !1;
      if (t == qi(this.data, i + 1))
        return !0;
    }
  }
  /// Get the states that can follow this one through shift actions or
  /// goto jumps. @internal
  nextStates(e) {
    let t = [];
    for (let i = this.stateSlot(
      e,
      1
      /* Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = qi(this.data, i + 2);
        else
          break;
      if (!(this.data[i + 2] & 1)) {
        let s = this.data[i + 1];
        t.some((n, o) => o & 1 && n == s) || t.push(this.data[i], s);
      }
    }
    return t;
  }
  /// @internal
  overrides(e, t) {
    let i = om(this.data, this.tokenPrecTable, t);
    return i < 0 || om(this.data, this.tokenPrecTable, e) < i;
  }
  /// Configure the parser. Returns a new parser instance that has the
  /// given settings modified. Settings not provided in `config` are
  /// kept from the original parser.
  configure(e) {
    let t = Object.assign(Object.create(Jn.prototype), this);
    if (e.props && (t.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let i = this.topRules[e.top];
      if (!i)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      t.top = i;
    }
    return e.tokenizers && (t.tokenizers = this.tokenizers.map((i) => {
      let s = e.tokenizers.find((n) => n.from == i);
      return s ? s.to : i;
    })), e.contextTracker && (t.context = e.contextTracker), e.dialect && (t.dialect = this.parseDialect(e.dialect)), e.strict != null && (t.strict = e.strict), e.wrap && (t.wrappers = t.wrappers.concat(e.wrap)), e.bufferLength != null && (t.bufferLength = e.bufferLength), t;
  }
  /// Returns the name associated with a given term. This will only
  /// work for all terms when the parser was generated with the
  /// `--names` option. By default, only the names of tagged terms are
  /// stored.
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /// The eof term id is always allocated directly after the node
  /// types. @internal
  get eofTerm() {
    return this.maxNode + 1;
  }
  /// The type of top node produced by the parser.
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /// @internal
  dynamicPrecedence(e) {
    let t = this.dynamicPrecedences;
    return t == null ? 0 : t[e] || 0;
  }
  /// @internal
  parseDialect(e) {
    let t = Object.keys(this.dialects), i = t.map(() => !1);
    if (e)
      for (let n of e.split(" ")) {
        let o = t.indexOf(n);
        o >= 0 && (i[o] = !0);
      }
    let s = null;
    for (let n = 0; n < t.length; n++)
      if (!i[n])
        for (let o = this.dialects[t[n]], l; (l = this.data[o++]) != 65535; )
          (s || (s = new Uint8Array(this.maxTerm + 1)))[l] = 1;
    return new nz(e, i, s);
  }
  /// (used by the output of the parser generator) @internal
  static deserialize(e) {
    return new Jn(e);
  }
}
function qi(a, e) {
  return a[e] | a[e + 1] << 16;
}
function om(a, e, t) {
  for (let i = e, s; (s = a[i]) != 65535; i++)
    if (s == t)
      return i - e;
  return -1;
}
function rz(a) {
  let e = null;
  for (let t of a) {
    let i = t.p.stoppedAt;
    (t.pos == t.p.stream.end || i != null && t.pos > i) && t.p.parser.stateFlag(
      t.state,
      2
      /* Accepting */
    ) && (!e || e.score < t.score) && (e = t);
  }
  return e;
}
const lm = 279, cm = 1, az = 2, lo = 280, oz = 3, lz = 281, hm = 282, cz = 4, hz = 284, dz = 285, uz = 5, fz = 6, pz = 1, gz = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], Wx = 125, mz = 123, bz = 59, dm = 47, vz = 42, yz = 43, Oz = 45, xz = 36, wz = 96, Sz = 92, kz = new Fx({
  start: !1,
  shift(a, e) {
    return e == uz || e == fz || e == hz ? a : e == dz;
  },
  strict: !1
}), _z = new ji((a, e) => {
  let { next: t } = a;
  (t == Wx || t == -1 || e.context) && e.canShift(hm) && a.acceptToken(hm);
}, { contextual: !0, fallback: !0 }), Cz = new ji((a, e) => {
  let { next: t } = a, i;
  gz.indexOf(t) > -1 || t == dm && ((i = a.peek(1)) == dm || i == vz) || t != Wx && t != bz && t != -1 && !e.context && e.canShift(lm) && a.acceptToken(lm);
}, { contextual: !0 }), Tz = new ji((a, e) => {
  let { next: t } = a;
  if ((t == yz || t == Oz) && (a.advance(), t == a.next)) {
    a.advance();
    let i = !e.context && e.canShift(cm);
    a.acceptToken(i ? cm : az);
  }
}, { contextual: !0 }), Az = new ji((a) => {
  for (let e = !1, t = 0; ; t++) {
    let { next: i } = a;
    if (i < 0) {
      t && a.acceptToken(lo);
      break;
    } else if (i == wz) {
      t ? a.acceptToken(lo) : a.acceptToken(lz, 1);
      break;
    } else if (i == mz && e) {
      t == 1 ? a.acceptToken(oz, 1) : a.acceptToken(lo, -1);
      break;
    } else if (i == 10 && t) {
      a.advance(), a.acceptToken(lo);
      break;
    } else
      i == Sz && a.advance();
    e = i == xz, a.advance();
  }
});
function $z(a, e) {
  return a == "extends" && e.dialectEnabled(pz) ? cz : -1;
}
const Ez = { __proto__: null, export: 18, as: 23, from: 29, default: 32, async: 37, function: 38, this: 48, true: 56, false: 56, void: 66, typeof: 70, null: 86, super: 88, new: 122, await: 139, yield: 141, delete: 142, class: 152, extends: 154, public: 197, private: 197, protected: 197, readonly: 199, instanceof: 220, in: 222, const: 224, import: 256, keyof: 307, unique: 311, infer: 317, is: 351, abstract: 371, implements: 373, type: 375, let: 378, var: 380, interface: 387, enum: 391, namespace: 397, module: 399, declare: 403, global: 407, for: 428, of: 437, while: 440, with: 444, do: 448, if: 452, else: 454, switch: 458, case: 464, try: 470, catch: 472, finally: 474, return: 478, throw: 482, break: 486, continue: 490, debugger: 494 }, Pz = { __proto__: null, async: 109, get: 111, set: 113, public: 161, private: 161, protected: 161, static: 163, abstract: 165, override: 167, readonly: 173, new: 355 }, Lz = { __proto__: null, "<": 129 }, Mz = Jn.deserialize({
  version: 13,
  states: "$1jO`QYOOO'QQ!LdO'#ChO'XOSO'#DVO)dQYO'#D]O)tQYO'#DhO){QYO'#DrO-xQYO'#DxOOQO'#E]'#E]O.]QWO'#E[O.bQWO'#E[OOQ!LS'#Ef'#EfO0aQ!LdO'#IrO2wQ!LdO'#IsO3eQWO'#EzO3jQpO'#FaOOQ!LS'#FS'#FSO3rO!bO'#FSO4QQWO'#FhO5_QWO'#FgOOQ!LS'#Is'#IsOOQ!LQ'#Ir'#IrOOQQ'#J['#J[O5dQWO'#HnO5iQ!LYO'#HoOOQQ'#If'#IfOOQQ'#Hp'#HpQ`QYOOO){QYO'#DjO5qQWO'#G[O5vQ#tO'#CmO6UQWO'#EZO6aQWO'#EgO6fQ#tO'#FRO7QQWO'#G[O7VQWO'#G`O7bQWO'#G`O7pQWO'#GcO7pQWO'#GdO7pQWO'#GfO5qQWO'#GiO8aQWO'#GlO9oQWO'#CdO:PQWO'#GyO:XQWO'#HPO:XQWO'#HRO`QYO'#HTO:XQWO'#HVO:XQWO'#HYO:^QWO'#H`O:cQ!LZO'#HdO){QYO'#HfO:nQ!LZO'#HhO:yQ!LZO'#HjO5iQ!LYO'#HlO){QYO'#DWOOOS'#Hr'#HrO;UOSO,59qOOQ!LS,59q,59qO=gQbO'#ChO=qQYO'#HsO>UQWO'#ItO@TQbO'#ItO'dQYO'#ItO@[QWO,59wO@rQ&jO'#DbOAkQWO'#E]OAxQWO'#JPOBTQWO'#JOOBTQWO'#JOOB]QWO,5:yOBbQWO'#I}OBiQWO'#DyO5vQ#tO'#EZOBwQWO'#EZOCSQ`O'#FROOQ!LS,5:S,5:SOC[QYO,5:SOEYQ!LdO,5:^OEvQWO,5:dOFaQ!LYO'#I|O7VQWO'#I{OFhQWO'#I{OFpQWO,5:xOFuQWO'#I{OGTQYO,5:vOITQWO'#EWOJ_QWO,5:vOKnQWO'#DlOKuQYO'#DqOLPQ&jO,5;PO){QYO,5;POOQQ'#Er'#ErOOQQ'#Et'#EtO){QYO,5;RO){QYO,5;RO){QYO,5;RO){QYO,5;RO){QYO,5;RO){QYO,5;RO){QYO,5;RO){QYO,5;RO){QYO,5;RO){QYO,5;RO){QYO,5;ROOQQ'#Ex'#ExOLXQYO,5;cOOQ!LS,5;h,5;hOOQ!LS,5;i,5;iONXQWO,5;iOOQ!LS,5;j,5;jO){QYO'#H}ON^Q!LYO,5<TONxQWO,5;RO){QYO,5;fO! bQpO'#JTO! PQpO'#JTO! iQpO'#JTO! zQpO,5;qOOOO,5;{,5;{O!!YQYO'#FcOOOO'#H|'#H|O3rO!bO,5;nO!!aQpO'#FeOOQ!LS,5;n,5;nO!!}Q,UO'#CrOOQ!LS'#Cu'#CuO!#bQWO'#CuO!#gOSO'#CyO!$TQ#tO,5<QO!$[QWO,5<SO!%hQWO'#FrO!%uQWO'#FsO!%zQWO'#FwO!&|Q&jO'#F{O!'oQ,UO'#IoOOQ!LS'#Io'#IoO!'yQWO'#InO!(XQWO'#ImOOQ!LS'#Cs'#CsOOQ!LS'#C|'#C|O!(aQWO'#DOOJdQWO'#FjOJdQWO'#FlO!(fQWO'#FnO!(kQWO'#FoO!(pQWO'#FuOJdQWO'#FzO!(uQWO'#E^O!)^QWO,5<RO`QYO,5>YOOQQ'#Ii'#IiOOQQ,5>Z,5>ZOOQQ-E;n-E;nO!+YQ!LdO,5:UOOQ!LQ'#Cp'#CpO!+yQ#tO,5<vOOQO'#Cf'#CfO!,[QWO'#CqO!,dQ!LYO'#IjO5_QWO'#IjO:^QWO,59XO!,rQpO,59XO!,zQ#tO,59XO5vQ#tO,59XO!-VQWO,5:vO!-_QWO'#GxO!-mQWO'#J`O){QYO,5;kO!-uQ&jO,5;mO!-zQWO,5=cO!.PQWO,5=cO!.UQWO,5=cO5iQ!LYO,5=cO5qQWO,5<vO!.dQWO'#E_O!.xQ&jO'#E`OOQ!LQ'#I}'#I}O!/ZQ!LYO'#J]O5iQ!LYO,5<zO7pQWO,5=QOOQO'#Cr'#CrO!/fQpO,5<}O!/nQ#tO,5=OO!/yQWO,5=QO!0OQ`O,5=TO:^QWO'#GnO5qQWO'#GpO!0WQWO'#GpO5vQ#tO'#GsO!0]QWO'#GsOOQQ,5=W,5=WO!0bQWO'#GtO!0jQWO'#CmO!0oQWO,59OO!0yQWO,59OO!2{QYO,59OOOQQ,59O,59OO!3YQ!LYO,59OO){QYO,59OO!3eQYO'#G{OOQQ'#G|'#G|OOQQ'#G}'#G}O`QYO,5=eO!3uQWO,5=eO){QYO'#DxO`QYO,5=kO`QYO,5=mO!3zQWO,5=oO`QYO,5=qO!4PQWO,5=tO!4UQYO,5=zOOQQ,5>O,5>OO){QYO,5>OO5iQ!LYO,5>QOOQQ,5>S,5>SO!8VQWO,5>SOOQQ,5>U,5>UO!8VQWO,5>UOOQQ,5>W,5>WO!8[Q`O,59rOOOS-E;p-E;pOOQ!LS1G/]1G/]O!8aQbO,5>_O'dQYO,5>_OOQO,5>d,5>dO!8kQYO'#HsOOQO-E;q-E;qO!8xQWO,5?`O!9QQbO,5?`O!9XQWO,5?jOOQ!LS1G/c1G/cO!9aQpO'#DTOOQO'#Iv'#IvO){QYO'#IvO!:OQpO'#IvO!:mQpO'#DcO!;OQ&jO'#DcO!=ZQYO'#DcO!=bQWO'#IuO!=jQWO,59|O!=oQWO'#EaO!=}QWO'#JQO!>VQWO,5:zO!>mQ&jO'#DcO){QYO,5?kO!>wQWO'#HxOOQO-E;v-E;vO!9XQWO,5?jOOQ!LQ1G0e1G0eO!@TQ&jO'#D|OOQ!LS,5:e,5:eO){QYO,5:eOITQWO,5:eO!@[QWO,5:eO:^QWO,5:uO!,rQpO,5:uO!,zQ#tO,5:uO5vQ#tO,5:uOOQ!LS1G/n1G/nOOQ!LS1G0O1G0OOOQ!LQ'#EV'#EVO){QYO,5?hO!@gQ!LYO,5?hO!@xQ!LYO,5?hO!APQWO,5?gO!AXQWO'#HzO!APQWO,5?gOOQ!LQ1G0d1G0dO7VQWO,5?gOOQ!LS1G0b1G0bO!AsQ!LdO1G0bO!BdQ!LbO,5:rOOQ!LS'#Fq'#FqO!CQQ!LdO'#IoOGTQYO1G0bO!EPQ#tO'#IwO!EZQWO,5:WO!E`QbO'#IxO){QYO'#IxO!EjQWO,5:]OOQ!LS'#DT'#DTOOQ!LS1G0k1G0kO!EoQWO1G0kO!HQQ!LdO1G0mO!HXQ!LdO1G0mO!JlQ!LdO1G0mO!JsQ!LdO1G0mO!LzQ!LdO1G0mO!M_Q!LdO1G0mO#!OQ!LdO1G0mO#!VQ!LdO1G0mO#$jQ!LdO1G0mO#$qQ!LdO1G0mO#&fQ!LdO1G0mO#)`Q7^O'#ChO#+ZQ7^O1G0}O#-UQ7^O'#IsOOQ!LS1G1T1G1TO#-iQ!LdO,5>iOOQ!LQ-E;{-E;{O#.YQ!LdO1G0mOOQ!LS1G0m1G0mO#0[Q!LdO1G1QO#0{QpO,5;sO#1QQpO,5;tO#1VQpO'#F[O#1kQWO'#FZOOQO'#JU'#JUOOQO'#H{'#H{O#1pQpO1G1]OOQ!LS1G1]1G1]OOOO1G1f1G1fO#2OQ7^O'#IrO#2YQWO,5;}OLXQYO,5;}OOOO-E;z-E;zOOQ!LS1G1Y1G1YOOQ!LS,5<P,5<PO#2_QpO,5<POOQ!LS,59a,59aOITQWO'#C{OOOS'#Hq'#HqO#2dOSO,59eOOQ!LS,59e,59eO){QYO1G1lO!(kQWO'#IPO#2oQWO,5<eOOQ!LS,5<b,5<bOOQO'#GV'#GVOJdQWO,5<pOOQO'#GX'#GXOJdQWO,5<rOJdQWO,5<tOOQO1G1n1G1nO#2zQ`O'#CpO#3_Q`O,5<^O#3fQWO'#JXO5qQWO'#JXO#3tQWO,5<`OJdQWO,5<_O#3yQ`O'#FqO#4WQ`O'#JYO#4bQWO'#JYOITQWO'#JYO#4gQWO,5<cOOQ!LQ'#Dg'#DgO#4lQWO'#FtO#4wQpO'#F|O!&wQ&jO'#F|O!&wQ&jO'#GOO#5YQWO'#GPO!(pQWO'#GSOOQO'#IR'#IRO#5_Q&jO,5<gOOQ!LS,5<g,5<gO#5fQ&jO'#F|O#5tQ&jO'#F}O#5|Q&jO'#F}OOQ!LS,5<u,5<uOJdQWO,5?YOJdQWO,5?YO#6RQWO'#ISO#6^QWO,5?XOOQ!LS'#Ch'#ChO#7QQ#tO,59jOOQ!LS,59j,59jO#7sQ#tO,5<UO#8fQ#tO,5<WO#8pQWO,5<YOOQ!LS,5<Z,5<ZO#8uQWO,5<aO#8zQ#tO,5<fOGTQYO1G1mO#9[QWO1G1mOOQQ1G3t1G3tOOQ!LS1G/p1G/pONXQWO1G/pOOQQ1G2b1G2bOITQWO1G2bO){QYO1G2bOITQWO1G2bO#9aQWO1G2bO#9oQWO,59]O#:xQWO'#EWOOQ!LQ,5?U,5?UO#;SQ!LYO,5?UOOQQ1G.s1G.sO:^QWO1G.sO!,rQpO1G.sO!,zQ#tO1G.sO#;bQWO1G0bO#;gQWO'#ChO#;rQWO'#JaO#;zQWO,5=dO#<PQWO'#JaO#<UQWO'#JaO#<^QWO'#I[O#<lQWO,5?zO#<tQbO1G1VOOQ!LS1G1X1G1XO5qQWO1G2}O#<{QWO1G2}O#=QQWO1G2}O#=VQWO1G2}OOQQ1G2}1G2}O#=[Q#tO1G2bO7VQWO'#JOO7VQWO'#EaO7VQWO'#IUO#=mQ!LYO,5?wOOQQ1G2f1G2fO!/yQWO1G2lOITQWO1G2iO#=xQWO1G2iOOQQ1G2j1G2jOITQWO1G2jO#=}QWO1G2jO#>VQ&jO'#GhOOQQ1G2l1G2lO!&wQ&jO'#IWO!0OQ`O1G2oOOQQ1G2o1G2oOOQQ,5=Y,5=YO#>_Q#tO,5=[O5qQWO,5=[O#5YQWO,5=_O5_QWO,5=_O!,rQpO,5=_O!,zQ#tO,5=_O5vQ#tO,5=_O#>pQWO'#J_O#>{QWO,5=`OOQQ1G.j1G.jO#?QQ!LYO1G.jO#?]QWO1G.jO#?bQWO1G.jO5iQ!LYO1G.jO#?jQbO,5?|O#?tQWO,5?|O#@PQYO,5=gO#@WQWO,5=gO7VQWO,5?|OOQQ1G3P1G3PO`QYO1G3POOQQ1G3V1G3VOOQQ1G3X1G3XO:XQWO1G3ZO#@]QYO1G3]O#DWQYO'#H[OOQQ1G3`1G3`O:^QWO1G3fO#DeQWO1G3fO5iQ!LYO1G3jOOQQ1G3l1G3lOOQ!LQ'#Fx'#FxO5iQ!LYO1G3nO5iQ!LYO1G3pOOOS1G/^1G/^O#DmQ`O,5<TO#DuQbO1G3yOOQO1G4O1G4OO){QYO,5>_O#EPQWO1G4zO#EXQWO1G5UO#EaQWO,5?bOLXQYO,5:{O7VQWO,5:{O:^QWO,59}OLXQYO,59}O!,rQpO,59}O#EfQ7^O,59}OOQO,5:{,5:{O#EpQ&jO'#HtO#FWQWO,5?aOOQ!LS1G/h1G/hO#F`Q&jO'#HyO#FtQWO,5?lOOQ!LQ1G0f1G0fO!;OQ&jO,59}O#F|QbO1G5VO7VQWO,5>dOOQ!LQ'#ES'#ESO#GWQ!LrO'#ETO!?{Q&jO'#D}OOQO'#Hw'#HwO#GrQ&jO,5:hOOQ!LS,5:h,5:hO#GyQ&jO'#D}O#H[Q&jO'#D}O#HcQ&jO'#EYO#HfQ&jO'#ETO#HsQ&jO'#ETO!?{Q&jO'#ETO#IWQWO1G0PO#I]Q`O1G0POOQ!LS1G0P1G0PO){QYO1G0POITQWO1G0POOQ!LS1G0a1G0aO:^QWO1G0aO!,rQpO1G0aO!,zQ#tO1G0aO#IdQ!LdO1G5SO){QYO1G5SO#ItQ!LYO1G5SO#JVQWO1G5RO7VQWO,5>fOOQO,5>f,5>fO#J_QWO,5>fOOQO-E;x-E;xO#JVQWO1G5RO#JmQ!LdO,59jO#LlQ!LdO,5<UO#NnQ!LdO,5<WO$!pQ!LdO,5<fOOQ!LS7+%|7+%|O$$xQ!LdO7+%|O$%iQWO'#HuO$%sQWO,5?cOOQ!LS1G/r1G/rO$%{QYO'#HvO$&YQWO,5?dO$&bQbO,5?dOOQ!LS1G/w1G/wOOQ!LS7+&V7+&VO$&lQ7^O,5:^O){QYO7+&iO$&vQ7^O,5:UOOQO1G1_1G1_OOQO1G1`1G1`O$'TQMhO,5;vOLXQYO,5;uOOQO-E;y-E;yOOQ!LS7+&w7+&wOOOO7+'Q7+'QOOOO1G1i1G1iO$'`QWO1G1iOOQ!LS1G1k1G1kO$'eQ`O,59gOOOS-E;o-E;oOOQ!LS1G/P1G/PO$'lQ!LdO7+'WOOQ!LS,5>k,5>kO$(]QWO,5>kOOQ!LS1G2P1G2PP$(bQWO'#IPPOQ!LS-E;}-E;}O$)RQ#tO1G2[O$)tQ#tO1G2^O$*OQ#tO1G2`OOQ!LS1G1x1G1xO$*VQWO'#IOO$*eQWO,5?sO$*eQWO,5?sO$*mQWO,5?sO$*xQWO,5?sOOQO1G1z1G1zO$+WQ#tO1G1yO$+hQWO'#IQO$+xQWO,5?tOITQWO,5?tO$,QQ`O,5?tOOQ!LS1G1}1G1}O5iQ!LYO,5<hO5iQ!LYO,5<iO$,[QWO,5<iO#5TQWO,5<iO!,rQpO,5<hO$,aQWO,5<jO5iQ!LYO,5<kO$,[QWO,5<nOOQO-E<P-E<POOQ!LS1G2R1G2RO!&wQ&jO,5<hO$,iQWO,5<iO!&wQ&jO,5<jO!&wQ&jO,5<iO$,tQ#tO1G4tO$-OQ#tO1G4tOOQO,5>n,5>nOOQO-E<Q-E<QO!-uQ&jO,59lO){QYO,59lO$-]QWO1G1tOJdQWO1G1{O$-bQ!LdO7+'XOOQ!LS7+'X7+'XOGTQYO7+'XOOQ!LS7+%[7+%[O$.RQ`O'#JZO#IWQWO7+'|O$.]QWO7+'|O$.eQ`O7+'|OOQQ7+'|7+'|OITQWO7+'|O){QYO7+'|OITQWO7+'|OOQO1G.w1G.wO$.oQ!LbO'#ChO$/PQ!LbO,5<lO$/nQWO,5<lOOQ!LQ1G4p1G4pOOQQ7+$_7+$_O:^QWO7+$_O!,rQpO7+$_OGTQYO7+%|O$/sQWO'#IZO$0UQWO,5?{OOQO1G3O1G3OO5qQWO,5?{O$0UQWO,5?{O$0^QWO,5?{OOQO,5>v,5>vOOQO-E<Y-E<YOOQ!LS7+&q7+&qO$0cQWO7+(iO5iQ!LYO7+(iO5qQWO7+(iO$0hQWO7+(iO$0mQWO7+'|OOQ!LQ,5>p,5>pOOQ!LQ-E<S-E<SOOQQ7+(W7+(WO$0{Q!LbO7+(TOITQWO7+(TO$1VQ`O7+(UOOQQ7+(U7+(UOITQWO7+(UO$1^QWO'#J^O$1iQWO,5=SOOQO,5>r,5>rOOQO-E<U-E<UOOQQ7+(Z7+(ZO$2cQ&jO'#GqOOQQ1G2v1G2vOITQWO1G2vO){QYO1G2vOITQWO1G2vO$2jQWO1G2vO$2xQ#tO1G2vO5iQ!LYO1G2yO#5YQWO1G2yO5_QWO1G2yO!,rQpO1G2yO!,zQ#tO1G2yO$3ZQWO'#IYO$3fQWO,5?yO$3nQ&jO,5?yOOQ!LQ1G2z1G2zOOQQ7+$U7+$UO$3vQWO7+$UO5iQ!LYO7+$UO$3{QWO7+$UO){QYO1G5hO){QYO1G5iO$4QQYO1G3RO$4XQWO1G3RO$4^QYO1G3RO$4eQ!LYO1G5hOOQQ7+(k7+(kO5iQ!LYO7+(uO`QYO7+(wOOQQ'#Jd'#JdOOQQ'#I]'#I]O$4oQYO,5=vOOQQ,5=v,5=vO){QYO'#H]O$4|QWO'#H_OOQQ7+)Q7+)QO$5RQYO7+)QO7VQWO7+)QOOQQ7+)U7+)UOOQQ7+)Y7+)YOOQQ7+)[7+)[OOQO1G4|1G4|O$9PQ7^O1G0gO$9ZQWO1G0gOOQO1G/i1G/iO$9fQ7^O1G/iO:^QWO1G/iOLXQYO'#DcOOQO,5>`,5>`OOQO-E;r-E;rOOQO,5>e,5>eOOQO-E;w-E;wO!,rQpO1G/iO:^QWO,5:iOOQO,5:o,5:oO){QYO,5:oO$9pQ!LYO,5:oO$9{Q!LYO,5:oO!,rQpO,5:iOOQO-E;u-E;uOOQ!LS1G0S1G0SO!?{Q&jO,5:iO$:ZQ&jO,5:iO$:lQ!LrO,5:oO$;WQ&jO,5:iO!?{Q&jO,5:oOOQO,5:t,5:tO$;_Q&jO,5:oO$;lQ!LYO,5:oOOQ!LS7+%k7+%kO#IWQWO7+%kO#I]Q`O7+%kOOQ!LS7+%{7+%{O:^QWO7+%{O!,rQpO7+%{O$<QQ!LdO7+*nO){QYO7+*nOOQO1G4Q1G4QO7VQWO1G4QO$<bQWO7+*mO$<jQ!LdO1G2[O$>lQ!LdO1G2^O$@nQ!LdO1G1yO$BvQ#tO,5>aOOQO-E;s-E;sO$CQQbO,5>bO){QYO,5>bOOQO-E;t-E;tO$C[QWO1G5OO$CdQ7^O1G0bO$EkQ7^O1G0mO$ErQ7^O1G0mO$GsQ7^O1G0mO$GzQ7^O1G0mO$IoQ7^O1G0mO$JSQ7^O1G0mO$LaQ7^O1G0mO$LhQ7^O1G0mO$NiQ7^O1G0mO$NpQ7^O1G0mO%!eQ7^O1G0mO%!xQ!LdO<<JTO%#iQ7^O1G0mO%%XQ7^O'#IoO%'UQ7^O1G1QOLXQYO'#F^OOQO'#JV'#JVOOQO1G1b1G1bO%'cQWO1G1aO%'hQ7^O,5>iOOOO7+'T7+'TOOOS1G/R1G/ROOQ!LS1G4V1G4VOJdQWO7+'zO%'rQWO,5>jO5qQWO,5>jOOQO-E;|-E;|O%(QQWO1G5_O%(QQWO1G5_O%(YQWO1G5_O%(eQ`O,5>lO%(oQWO,5>lOITQWO,5>lOOQO-E<O-E<OO%(tQ`O1G5`O%)OQWO1G5`OOQO1G2S1G2SOOQO1G2T1G2TO5iQ!LYO1G2TO$,[QWO1G2TO5iQ!LYO1G2SO%)WQWO1G2UOITQWO1G2UOOQO1G2V1G2VO5iQ!LYO1G2YO!,rQpO1G2SO#5TQWO1G2TO%)]QWO1G2UO%)eQWO1G2TOJdQWO7+*`OOQ!LS1G/W1G/WO%)pQWO1G/WOOQ!LS7+'`7+'`O%)uQ#tO7+'gO%*VQ!LdO<<JsOOQ!LS<<Js<<JsOITQWO'#ITO%*vQWO,5?uOOQQ<<Kh<<KhOITQWO<<KhO#IWQWO<<KhO%+OQWO<<KhO%+WQ`O<<KhOITQWO1G2WOOQQ<<Gy<<GyO:^QWO<<GyO%+bQ!LdO<<IhOOQ!LS<<Ih<<IhOOQO,5>u,5>uO%,RQWO,5>uO%,WQWO,5>uOOQO-E<X-E<XO%,`QWO1G5gO%,`QWO1G5gO5qQWO1G5gO%,hQWO<<LTOOQQ<<LT<<LTO%,mQWO<<LTO5iQ!LYO<<LTO){QYO<<KhOITQWO<<KhOOQQ<<Ko<<KoO$0{Q!LbO<<KoOOQQ<<Kp<<KpO$1VQ`O<<KpO%,rQ&jO'#IVO%,}QWO,5?xOLXQYO,5?xOOQQ1G2n1G2nO#GWQ!LrO'#ETO!?{Q&jO'#GrOOQO'#IX'#IXO%-VQ&jO,5=]OOQQ,5=],5=]O%-^Q&jO'#ETO%-iQ&jO'#ETO%.QQ&jO'#ETO%.[Q&jO'#GrO%.mQWO7+(bO%.rQWO7+(bO%.zQ`O7+(bOOQQ7+(b7+(bOITQWO7+(bO){QYO7+(bOITQWO7+(bO%/UQWO7+(bOOQQ7+(e7+(eO5iQ!LYO7+(eO#5YQWO7+(eO5_QWO7+(eO!,rQpO7+(eO%/dQWO,5>tOOQO-E<W-E<WOOQO'#Gu'#GuO%/oQWO1G5eO5iQ!LYO<<GpOOQQ<<Gp<<GpO%/wQWO<<GpO%/|QWO7++SO%0RQWO7++TOOQQ7+(m7+(mO%0WQWO7+(mO%0]QYO7+(mO%0dQWO7+(mO){QYO7++SO){QYO7++TOOQQ<<La<<LaOOQQ<<Lc<<LcOOQQ-E<Z-E<ZOOQQ1G3b1G3bO%0iQWO,5=wOOQQ,5=y,5=yO:^QWO<<LlO%0nQWO<<LlOLXQYO7+&ROOQO7+%T7+%TO%0sQ7^O1G5VO:^QWO7+%TOOQO1G0T1G0TO%0}Q!LdO1G0ZOOQO1G0Z1G0ZO){QYO1G0ZO%1XQ!LYO1G0ZO:^QWO1G0TO!,rQpO1G0TO!?{Q&jO1G0TO%1dQ!LYO1G0ZO%1rQ&jO1G0TO%2TQ!LYO1G0ZO%2iQ!LrO1G0ZO%2sQ&jO1G0TO!?{Q&jO1G0ZOOQ!LS<<IV<<IVOOQ!LS<<Ig<<IgO:^QWO<<IgO%2zQ!LdO<<NYOOQO7+)l7+)lO%3[Q!LdO7+'gO%5dQbO1G3|O%5nQ7^O7+%|O%5{Q7^O,59jO%7xQ7^O,5<UO%9uQ7^O,5<WO%;rQ7^O,5<fO%=bQ7^O7+'WO%=oQ7^O7+'XO%=|QWO,5;xOOQO7+&{7+&{O%>RQ#tO<<KfOOQO1G4U1G4UO%>cQWO1G4UO%>nQWO1G4UO%>|QWO7+*yO%>|QWO7+*yOITQWO1G4WO%?UQ`O1G4WO%?`QWO7+*zOOQO7+'o7+'oO5iQ!LYO7+'oOOQO7+'n7+'nO$,[QWO7+'pO%?hQ`O7+'pOOQO7+'t7+'tO5iQ!LYO7+'nO$,[QWO7+'oO%?oQWO7+'pOITQWO7+'pO#5TQWO7+'oO%?tQ#tO<<MzOOQ!LS7+$r7+$rO%@OQ`O,5>oOOQO-E<R-E<RO#IWQWOANASOOQQANASANASOITQWOANASO%@YQ!LbO7+'rOOQQAN=eAN=eO5qQWO1G4aOOQO1G4a1G4aO%@gQWO1G4aO%@lQWO7++RO%@lQWO7++RO5iQ!LYOANAoO%@tQWOANAoOOQQANAoANAoO%@yQWOANASO%ARQ`OANASOOQQANAZANAZOOQQANA[ANA[O%A]QWO,5>qOOQO-E<T-E<TO%AhQ7^O1G5dO#5YQWO,5=^O5_QWO,5=^O!,rQpO,5=^OOQO-E<V-E<VOOQQ1G2w1G2wO$:lQ!LrO,5:oO!?{Q&jO,5=^O%ArQ&jO,5=^O%BTQ&jO,5:oOOQQ<<K|<<K|OITQWO<<K|O%.mQWO<<K|O%B_QWO<<K|O%BgQ`O<<K|O){QYO<<K|OITQWO<<K|OOQQ<<LP<<LPO5iQ!LYO<<LPO#5YQWO<<LPO5_QWO<<LPO%BqQ&jO1G4`O%ByQWO7++POOQQAN=[AN=[O5iQ!LYOAN=[OOQQ<<Nn<<NnOOQQ<<No<<NoOOQQ<<LX<<LXO%CRQWO<<LXO%CWQYO<<LXO%C_QWO<<NnO%CdQWO<<NoOOQQ1G3c1G3cOOQQANBWANBWO:^QWOANBWO%CiQ7^O<<ImOOQO<<Ho<<HoOOQO7+%u7+%uO%0}Q!LdO7+%uO){QYO7+%uOOQO7+%o7+%oO:^QWO7+%oO!,rQpO7+%oO%CsQ!LYO7+%uO!?{Q&jO7+%oO%DOQ!LYO7+%uO%D^Q&jO7+%oO%DoQ!LYO7+%uOOQ!LSAN?RAN?RO%ETQ!LdO<<KfO%G]Q7^O<<JTO%GjQ7^O1G1yO%IYQ7^O1G2[O%KVQ7^O1G2^O%MSQ7^O<<JsO%MaQ7^O<<IhOOQO1G1d1G1dOOQO7+)p7+)pO%MnQWO7+)pO%MyQWO<<NeO%NRQ`O7+)rOOQO<<KZ<<KZO5iQ!LYO<<K[O$,[QWO<<K[OOQO<<KY<<KYO5iQ!LYO<<KZO%N]Q`O<<K[O$,[QWO<<KZOOQQG26nG26nO#IWQWOG26nOOQO7+){7+){O5qQWO7+){O%NdQWO<<NmOOQQG27ZG27ZO5iQ!LYOG27ZOITQWOG26nOLXQYO1G4]O%NlQWO7++OO5iQ!LYO1G2xO#5YQWO1G2xO5_QWO1G2xO!,rQpO1G2xO!?{Q&jO1G2xO%2iQ!LrO1G0ZO%NtQ&jO1G2xO%.mQWOANAhOOQQANAhANAhOITQWOANAhO& VQWOANAhO& _Q`OANAhOOQQANAkANAkO5iQ!LYOANAkO#5YQWOANAkOOQO'#Gv'#GvOOQO7+)z7+)zOOQQG22vG22vOOQQANAsANAsO& iQWOANAsOOQQANDYANDYOOQQANDZANDZO& nQYOG27rOOQO<<Ia<<IaO%0}Q!LdO<<IaOOQO<<IZ<<IZO:^QWO<<IZO){QYO<<IaO!,rQpO<<IZO&%lQ!LYO<<IaO!?{Q&jO<<IZO&%wQ!LYO<<IaO&&VQ7^O7+'gOOQO<<M[<<M[OOQOAN@vAN@vO5iQ!LYOAN@vOOQOAN@uAN@uO$,[QWOAN@vO5iQ!LYOAN@uOOQQLD,YLD,YOOQO<<Mg<<MgOOQQLD,uLD,uO#IWQWOLD,YO&'uQ7^O7+)wOOQO7+(d7+(dO5iQ!LYO7+(dO#5YQWO7+(dO5_QWO7+(dO!,rQpO7+(dO!?{Q&jO7+(dOOQQG27SG27SO%.mQWOG27SOITQWOG27SOOQQG27VG27VO5iQ!LYOG27VOOQQG27_G27_O:^QWOLD-^OOQOAN>{AN>{OOQOAN>uAN>uO%0}Q!LdOAN>{O:^QWOAN>uO){QYOAN>{O!,rQpOAN>uO&(PQ!LYOAN>{O&([Q7^O<<KfOOQOG26bG26bO5iQ!LYOG26bOOQOG26aG26aOOQQ!$( t!$( tOOQO<<LO<<LOO5iQ!LYO<<LOO#5YQWO<<LOO5_QWO<<LOO!,rQpO<<LOOOQQLD,nLD,nO%.mQWOLD,nOOQQLD,qLD,qOOQQ!$(!x!$(!xOOQOG24gG24gOOQOG24aG24aO%0}Q!LdOG24gO:^QWOG24aO){QYOG24gOOQOLD+|LD+|OOQOANAjANAjO5iQ!LYOANAjO#5YQWOANAjO5_QWOANAjOOQQ!$(!Y!$(!YOOQOLD*RLD*ROOQOLD){LD){O%0}Q!LdOLD*ROOQOG27UG27UO5iQ!LYOG27UO#5YQWOG27UOOQO!$'Mm!$'MmOOQOLD,pLD,pO5iQ!LYOLD,pOOQO!$(![!$(![OLXQYO'#DrO&)zQbO'#IrOLXQYO'#DjO&*RQ!LdO'#ChO&*lQbO'#ChO&*|QYO,5:vOLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO,5;ROLXQYO'#H}O&,|QWO,5<TO&.`QWO,5;ROLXQYO,5;fO!(aQWO'#DOO!(aQWO'#DOOITQWO'#FjO&-UQWO'#FjOITQWO'#FlO&-UQWO'#FlOITQWO'#FzO&-UQWO'#FzOLXQYO,5?kO&*|QYO1G0bO&.gQ7^O'#ChOLXQYO1G1lOITQWO,5<pO&-UQWO,5<pOITQWO,5<rO&-UQWO,5<rOITQWO,5<_O&-UQWO,5<_O&*|QYO1G1mOLXQYO7+&iOITQWO1G1{O&-UQWO1G1{O&*|QYO7+'XO&*|QYO7+%|OITQWO7+'zO&-UQWO7+'zO&.qQWO'#E[O&.vQWO'#E[O&/OQWO'#EzO&/TQWO'#EgO&/YQWO'#JPO&/eQWO'#I}O&/pQWO,5:vO&/uQ#tO,5<QO&/|QWO'#FsO&0RQWO'#FsO&0WQWO,5<RO&0`QWO,5:vO&0hQ7^O1G0}O&0oQWO,5<aO&0tQWO,5<aO&0yQWO1G1mO&1OQWO1G0bO&1TQ#tO1G2`O&1[Q#tO1G2`O4QQWO'#FhO5_QWO'#FgOBwQWO'#EZOLXQYO,5;cO!(pQWO'#FuO!(pQWO'#FuOJdQWO,5<tOJdQWO,5<t",
  stateData: "&2X~O'WOS'XOSTOSUOS~OPTOQTOXyO]cO_hObnOcmOhcOjTOkcOlcOqTOsTOxRO{cO|cO}cO!TSO!_kO!dUO!gTO!hTO!iTO!jTO!kTO!nlO#dsO#tpO#x^O%PqO%RtO%TrO%UrO%XuO%ZvO%^wO%_wO%axO%nzO%t{O%v|O%x}O%z!OO%}!PO&T!QO&X!RO&Z!SO&]!TO&_!UO&a!VO'ZPO'dQO'mYO'zaO~OP[XZ[X_[Xj[Xu[Xv[Xx[X!R[X!a[X!b[X!d[X!j[X!{[X#WdX#[[X#][X#^[X#_[X#`[X#a[X#b[X#c[X#e[X#g[X#i[X#j[X#o[X'U[X'd[X'n[X'u[X'v[X~O!]$lX~P$zOR!WO'S!XO'T!ZO~OPTOQTO]cOb!kOc!jOhcOjTOkcOlcOqTOsTOxRO{cO|cO}cO!T!bO!_kO!dUO!gTO!hTO!iTO!jTO!kTO!n!iO#t!lO#x^O'Z![O'dQO'mYO'zaO~O!Q!`O!R!]O!O'hP!O'rP~P'dO!S!mO~P`OPTOQTO]cOb!kOc!jOhcOjTOkcOlcOqTOsTOxRO{cO|cO}cO!T!bO!_kO!dUO!gTO!hTO!iTO!jTO!kTO!n!iO#t!lO#x^O'Z9YO'dQO'mYO'zaO~OPTOQTO]cOb!kOc!jOhcOjTOkcOlcOqTOsTOxRO{cO|cO}cO!T!bO!_kO!dUO!gTO!hTO!iTO!jTO!kTO!n!iO#t!lO#x^O'dQO'mYO'zaO~O!Q!rO#U!uO#V!rO'Z9ZO!c'oP~P+{O#W!vO~O!]!wO#W!vO~OP#^OZ#dOj#ROu!{Ov!{Ox!|O!R#bO!a#TO!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO#a#TO#b#TO#c#TO#e#UO#g#WO#i#YO#j#ZO'dQO'n#[O'u!}O'v#OO~O_'fX'U'fX!c'fX!O'fX!T'fX%Q'fX!]'fX~P.jO!{#eO#o#eOP'gXZ'gX_'gXj'gXu'gXv'gXx'gX!R'gX!a'gX!b'gX!d'gX!j'gX#['gX#]'gX#^'gX#_'gX#`'gX#a'gX#b'gX#e'gX#g'gX#i'gX#j'gX'd'gX'n'gX'u'gX'v'gX~O#c'gX'U'gX!O'gX!c'gXn'gX!T'gX%Q'gX!]'gX~P0zO!{#eO~O#z#fO$R#jO~O!T#kO#x^O$U#lO$W#nO~O]#qOh$OOj#rOk#qOl#qOq$POs$QOx#xO!T#yO!_$VO!d#vO#V$WO#t$TO$_$RO$a$SO$d$UO'Z#pO'd#sO'_'aP~O!d$XO~O!]$ZO~O_$[O'U$[O~O'Z$`O~O!d$XO'Z$`O'[$bO'`$cO~Oc$iO!d$XO'Z$`O~O#c#TO~O]$rOu$nO!T$kO!d$mO%R$qO'Z$`O'[$bO^(SP~O!n$sO~Ox$tO!T$uO'Z$`O~Ox$tO!T$uO%Z$yO'Z$`O~O'Z$zO~O#dsO%RtO%TrO%UrO%XuO%ZvO%^wO%_wO~Ob%TOc%SO!n%QO%P%RO%c%PO~P7uOb%WOcmO!T%VO!nlO#dsO%PqO%TrO%UrO%XuO%ZvO%^wO%_wO%axO~O`%ZO!{%^O%R%XO'[$bO~P8tO!d%_O!g%cO~O!d%dO~O!TSO~O_$[O'R%lO'U$[O~O_$[O'R%oO'U$[O~O_$[O'R%qO'U$[O~OR!WO'S!XO'T%uO~OP[XZ[Xj[Xu[Xv[Xx[X!R[X!RdX!a[X!b[X!d[X!j[X!{[X!{dX#WdX#[[X#][X#^[X#_[X#`[X#a[X#b[X#c[X#e[X#g[X#i[X#j[X#o[X'd[X'n[X'u[X'v[X~O!O[X!OdX~P;aO!Q%wO!O&gX!O&lX!R&gX!R&lX~P'dO!R%yO!O'hX~OP#^OZ#dOj#ROu!{Ov!{Ox!|O!R%yO!a#TO!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO#a#TO#b#TO#c#TO#e#UO#g#WO#i#YO#j#ZO'dQO'n#[O'u!}O'v#OO~O!O'hX~P>^O!O&OO~Ox&RO!W&]O!X&UO!Y&UO'[$bO~O]&SOk&SO!Q&VO'e&PO!S'iP!S'tP~P@aO!O'qX!R'qX!]'qX!c'qX'n'qX~O!{'qX#W#PX!S'qX~PAYO!{&^O!O'sX!R'sX~O!R&_O!O'rX~O!O&bO~O!{#eO~PAYOS&fO!T&cO!o&eO'Z$`O~Oc&kO!d$XO'Z$`O~Ou$nO!d$mO~O!S&lO~P`Ou!{Ov!{Ox!|O!b!yO!d!zO'dQOP!faZ!faj!fa!R!fa!a!fa!j!fa#[!fa#]!fa#^!fa#_!fa#`!fa#a!fa#b!fa#c!fa#e!fa#g!fa#i!fa#j!fa'n!fa'u!fa'v!fa~O_!fa'U!fa!O!fa!c!fan!fa!T!fa%Q!fa!]!fa~PCcO!c&mO~O!]!wO!{&oO'n&nO!R'pX_'pX'U'pX~O!c'pX~PE{O!R&sO!c'oX~O!c&uO~Ox$tO!T$uO#V&vO'Z$`O~OPTOQTO]cOb!kOc!jOhcOjTOkcOlcOqTOsTOxRO{cO|cO}cO!TSO!_kO!dUO!gTO!hTO!iTO!jTO!kTO!n!iO#t!lO#x^O'Z9YO'dQO'mYO'zaO~O]#qOh$OOj#rOk#qOl#qOq$POs9lOx#xO!T#yO!_:oO!d#vO#V9rO#t$TO$_9nO$a9pO$d$UO'Z&zO'd#sO~O#W&|O~O]#qOh$OOj#rOk#qOl#qOq$POs$QOx#xO!T#yO!_$VO!d#vO#V$WO#t$TO$_$RO$a$SO$d$UO'Z&zO'd#sO~O'_'kP~PJdO!Q'QO!c'lP~P){O'e'SO'mYO~OP9VOQ9VO]cOb:mOc!jOhcOj9VOkcOlcOq9VOs9VOxRO{cO|cO}cO!T!bO!_9XO!dUO!g9VO!h9VO!i9VO!j9VO!k9VO!n!iO#t!lO#x^O'Z'bO'dQO'mYO'z:kO~O!d!zO~O!R#bO_$]a'U$]a!c$]a!O$]a!T$]a%Q$]a!]$]a~O#d'iO~PITO!]'kO!T'wX#w'wX#z'wX$R'wX~Ou'lO~P! POu'lO!T'wX#w'wX#z'wX$R'wX~O!T'nO#w'rO#z'mO$R'sO~O!Q'vO~PLXO#z#fO$R'yO~Ou$eXx$eX!b$eX'n$eX'u$eX'v$eX~OSfX!RfX!{fX'_fX'_$eX~P!!iOk'{O~OR'|O'S'}O'T(PO~Ou(ROx(SO'n#[O'u(UO'v(WO~O'_(QO~P!#rO'_(ZO~O]#qOh$OOj#rOk#qOl#qOq$POs9lOx#xO!T#yO!_:oO!d#vO#V9rO#t$TO$_9nO$a9pO$d$UO'd#sO~O!Q(_O'Z([O!c'{P~P!$aO#W(aO~O!Q(eO'Z(bO!O'|P~P!$aO_(nOj(sOx(kO!W(qO!X(jO!Y(jO!d(hO!x(rO$w(mO'[$bO'e(gO~O!S(pO~P!&XO!b!yOu'cXx'cX'n'cX'u'cX'v'cX!R'cX!{'cX~O'_'cX#m'cX~P!'TOS(vO!{(uO!R'bX'_'bX~O!R(wO'_'aX~O'Z(yO~O!d)OO~O'Z&zO~O!d(hO~Ox$tO!Q!rO!T$uO#U!uO#V!rO'Z$`O!c'oP~O!]!wO#W)SO~OP#^OZ#dOj#ROu!{Ov!{Ox!|O!a#TO!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO#a#TO#b#TO#c#TO#e#UO#g#WO#i#YO#j#ZO'dQO'n#[O'u!}O'v#OO~O_!^a!R!^a'U!^a!O!^a!c!^an!^a!T!^a%Q!^a!]!^a~P!)fOS)[O!T&cO!o)ZO%Q)YO'`$cO~O'Z$zO'_'aP~O!])_O!T'^X_'^X'U'^X~O!d$XO'`$cO~O!d$XO'Z$`O'`$cO~O!]!wO#W&|O~O])jO%R)kO'Z)gO!S(TP~O!R)lO^(SX~O'e'SO~OZ)pO~O^)qO~O!T$kO'Z$`O'[$bO^(SP~Ox$tO!Q)vO!R&_O!T$uO'Z$`O!O'rP~O]&YOk&YO!Q)wO'e'SO!S'tP~O!R)xO_(PX'U(PX~O!{)|O'`$cO~OS*PO!T#yO'`$cO~O!T*RO~Ou*TO!TSO~O!n*YO~Oc*_O~O'Z(yO!S(RP~Oc$iO~O%RtO'Z$zO~P8tOZ*eO^*dO~OPTOQTO]cObnOcmOhcOjTOkcOlcOqTOsTOxRO{cO|cO}cO!_kO!dUO!gTO!hTO!iTO!jTO!kTO!nlO#x^O%PqO'dQO'mYO'zaO~O!T!bO#t!lO'Z9YO~P!1RO^*dO_$[O'U$[O~O_*iO#d*kO%T*kO%U*kO~P){O!d%_O~O%t*pO~O!T*rO~O&U*uO&V*tOP&SaQ&SaX&Sa]&Sa_&Sab&Sac&Sah&Saj&Sak&Sal&Saq&Sas&Sax&Sa{&Sa|&Sa}&Sa!T&Sa!_&Sa!d&Sa!g&Sa!h&Sa!i&Sa!j&Sa!k&Sa!n&Sa#d&Sa#t&Sa#x&Sa%P&Sa%R&Sa%T&Sa%U&Sa%X&Sa%Z&Sa%^&Sa%_&Sa%a&Sa%n&Sa%t&Sa%v&Sa%x&Sa%z&Sa%}&Sa&T&Sa&X&Sa&Z&Sa&]&Sa&_&Sa&a&Sa'Q&Sa'Z&Sa'd&Sa'm&Sa'z&Sa!S&Sa%{&Sa`&Sa&Q&Sa~O'Z*xO~On*{O~O!O&ga!R&ga~P!)fO!Q+PO!O&gX!R&gX~P){O!R%yO!O'ha~O!O'ha~P>^O!R&_O!O'ra~O!RwX!R!ZX!SwX!S!ZX!]wX!]!ZX!d!ZX!{wX'`!ZX~O!]+UO!{+TO!R#TX!R'jX!S#TX!S'jX!]'jX!d'jX'`'jX~O!]+WO!d$XO'`$cO!R!VX!S!VX~O]&QOk&QOx&RO'e(gO~OP9VOQ9VO]cOb:mOc!jOhcOj9VOkcOlcOq9VOs9VOxRO{cO|cO}cO!T!bO!_9XO!dUO!g9VO!h9VO!i9VO!j9VO!k9VO!n!iO#t!lO#x^O'dQO'mYO'z:kO~O'Z9vO~P!;^O!R+[O!S'iX~O!S+^O~O!]+UO!{+TO!R#TX!S#TX~O!R+_O!S'tX~O!S+aO~O]&QOk&QOx&RO'[$bO'e(gO~O!X+bO!Y+bO~P!>[Ox$tO!Q+dO!T$uO'Z$`O!O&lX!R&lX~O_+hO!W+kO!X+gO!Y+gO!r+oO!s+mO!t+nO!u+lO!x+pO'[$bO'e(gO'm+eO~O!S+jO~P!?]OS+uO!T&cO!o+tO~O!{+{O!R'pa!c'pa_'pa'U'pa~O!]!wO~P!@gO!R&sO!c'oa~Ox$tO!Q,OO!T$uO#U,QO#V,OO'Z$`O!R&nX!c&nX~O_#Oi!R#Oi'U#Oi!O#Oi!c#Oin#Oi!T#Oi%Q#Oi!]#Oi~P!)fO#W!za!R!za!c!za!{!za!T!za_!za'U!za!O!za~P!#rO#W'cXP'cXZ'cX_'cXj'cXv'cX!a'cX!d'cX!j'cX#['cX#]'cX#^'cX#_'cX#`'cX#a'cX#b'cX#c'cX#e'cX#g'cX#i'cX#j'cX'U'cX'd'cX!c'cX!O'cX!T'cXn'cX%Q'cX!]'cX~P!'TO!R,ZO'_'kX~P!#rO'_,]O~O!R,^O!c'lX~P!)fO!c,aO~O!O,bO~OP#^Ou!{Ov!{Ox!|O!b!yO!d!zO!j#^O'dQOZ#Zi_#Zij#Zi!R#Zi!a#Zi#]#Zi#^#Zi#_#Zi#`#Zi#a#Zi#b#Zi#c#Zi#e#Zi#g#Zi#i#Zi#j#Zi'U#Zi'n#Zi'u#Zi'v#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~O#[#Zi~P!EtO#[#PO~P!EtOP#^Ou!{Ov!{Ox!|O!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO'dQOZ#Zi_#Zi!R#Zi!a#Zi#`#Zi#a#Zi#b#Zi#c#Zi#e#Zi#g#Zi#i#Zi#j#Zi'U#Zi'n#Zi'u#Zi'v#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~Oj#Zi~P!H`Oj#RO~P!H`OP#^Oj#ROu!{Ov!{Ox!|O!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO'dQO_#Zi!R#Zi#e#Zi#g#Zi#i#Zi#j#Zi'U#Zi'n#Zi'u#Zi'v#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~OZ#Zi!a#Zi#a#Zi#b#Zi#c#Zi~P!JzOZ#dO!a#TO#a#TO#b#TO#c#TO~P!JzOP#^OZ#dOj#ROu!{Ov!{Ox!|O!a#TO!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO#a#TO#b#TO#c#TO#e#UO'dQO_#Zi!R#Zi#g#Zi#i#Zi#j#Zi'U#Zi'n#Zi'v#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~O'u#Zi~P!MrO'u!}O~P!MrOP#^OZ#dOj#ROu!{Ov!{Ox!|O!a#TO!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO#a#TO#b#TO#c#TO#e#UO#g#WO'dQO'u!}O_#Zi!R#Zi#i#Zi#j#Zi'U#Zi'n#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~O'v#Zi~P#!^O'v#OO~P#!^OP#^OZ#dOj#ROu!{Ov!{Ox!|O!a#TO!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO#a#TO#b#TO#c#TO#e#UO#g#WO#i#YO'dQO'u!}O'v#OO~O_#Zi!R#Zi#j#Zi'U#Zi'n#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~P#$xOP[XZ[Xj[Xu[Xv[Xx[X!a[X!b[X!d[X!j[X!{[X#WdX#[[X#][X#^[X#_[X#`[X#a[X#b[X#c[X#e[X#g[X#i[X#j[X#o[X'd[X'n[X'u[X'v[X!R[X!S[X~O#m[X~P#']OP#^OZ9jOj9_Ou!{Ov!{Ox!|O!a9aO!b!yO!d!zO!j#^O#[9]O#]9^O#^9^O#_9^O#`9`O#a9aO#b9aO#c9aO#e9bO#g9dO#i9fO#j9gO'dQO'n#[O'u!}O'v#OO~O#m,dO~P#)gOP'gXZ'gXj'gXu'gXv'gXx'gX!a'gX!b'gX!d'gX!j'gX#['gX#]'gX#^'gX#_'gX#`'gX#a'gX#b'gX#e'gX#g'gX#i'gX#j'gX'd'gX'n'gX'u'gX'v'gX!R'gX~O!{9kO#o9kO#c'gX#m'gX!S'gX~P#+bO_&qa!R&qa'U&qa!c&qan&qa!O&qa!T&qa%Q&qa!]&qa~P!)fOP#ZiZ#Zi_#Zij#Ziv#Zi!R#Zi!a#Zi!b#Zi!d#Zi!j#Zi#[#Zi#]#Zi#^#Zi#_#Zi#`#Zi#a#Zi#b#Zi#c#Zi#e#Zi#g#Zi#i#Zi#j#Zi'U#Zi'd#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~P!#rO_#ni!R#ni'U#ni!O#ni!c#nin#ni!T#ni%Q#ni!]#ni~P!)fO#z,fO~O#z,gO~O!]'kO!{,hO!T$OX#w$OX#z$OX$R$OX~O!Q,iO~O!T'nO#w,kO#z'mO$R,lO~O!R9hO!S'fX~P#)gO!S,mO~O$R,oO~OR'|O'S'}O'T,rO~O],uOk,uO!O,vO~O!RdX!]dX!cdX!c$eX'ndX~P!!iO!c,|O~P!#rO!R,}O!]!wO'n&nO!c'{X~O!c-SO~O!O$eX!R$eX!]$lX~P!!iO!R-UO!O'|X~P!#rO!]-WO~O!O-YO~O!Q(_O'Z$`O!c'{P~Oj-^O!]!wO!d$XO'`$cO'n&nO~O!])_O~O!S-dO~P!&XO!X-eO!Y-eO'[$bO'e(gO~Ox-gO'e(gO~O!x-hO~O'Z$zO!R&vX'_&vX~O!R(wO'_'aa~Ou-mOv-mOx-nO'nra'ura'vra!Rra!{ra~O'_ra#mra~P#6fOu(ROx(SO'n$^a'u$^a'v$^a!R$^a!{$^a~O'_$^a#m$^a~P#7[Ou(ROx(SO'n$`a'u$`a'v$`a!R$`a!{$`a~O'_$`a#m$`a~P#7}O]-oO~O#W-pO~O'_$na!R$na#m$na!{$na~P!#rO#W-sO~OS-|O!T&cO!o-{O%Q-zO~O'_-}O~O]#qOj#rOk#qOl#qOq$POs9lOx#xO!T#yO!_:oO!d#vO#V9rO#t$TO$_9nO$a9pO$d$UO'd#sO~Oh.PO'Z.OO~P#9tO!])_O!T'^a_'^a'U'^a~O#W.VO~OZ[X!RdX!SdX~O!R.WO!S(TX~O!S.YO~OZ.ZO~O].]O'Z)gO~O!T$kO'Z$`O^'OX!R'OX~O!R)lO^(Sa~O!c.`O~P!)fO].bO~OZ.cO~O^.dO~OS-|O!T&cO!o-{O%Q-zO'`$cO~O!R)xO_(Pa'U(Pa~O!{.jO~OS.mO!T#yO~O'e'SO!S(QP~OS.wO!T.sO!o.vO%Q.uO'`$cO~OZ/RO!R/PO!S(RX~O!S/SO~O^/UO_$[O'U$[O~O]/VO~O]/WO'Z(yO~O#c/XO%r/YO~P0zO!{#eO#c/XO%r/YO~O_/ZO~P){O_/]O~O%{/aOP%yiQ%yiX%yi]%yi_%yib%yic%yih%yij%yik%yil%yiq%yis%yix%yi{%yi|%yi}%yi!T%yi!_%yi!d%yi!g%yi!h%yi!i%yi!j%yi!k%yi!n%yi#d%yi#t%yi#x%yi%P%yi%R%yi%T%yi%U%yi%X%yi%Z%yi%^%yi%_%yi%a%yi%n%yi%t%yi%v%yi%x%yi%z%yi%}%yi&T%yi&X%yi&Z%yi&]%yi&_%yi&a%yi'Q%yi'Z%yi'd%yi'm%yi'z%yi!S%yi`%yi&Q%yi~O`/gO!S/eO&Q/fO~P`O!TSO!d/jO~O!R#bOn$]a~O!O&gi!R&gi~P!)fO!R%yO!O'hi~O!R&_O!O'ri~O!O/nO~O!R!Va!S!Va~P#)gO]&QOk&QO!Q/tO'e(gO!R&hX!S&hX~P@aO!R+[O!S'ia~O]&YOk&YO!Q)wO'e'SO!R&mX!S&mX~O!R+_O!S'ta~O!O'si!R'si~P!)fO_$[O!]!wO!d$XO!j0OO!{/|O'U$[O'`$cO'n&nO~O!S0RO~P!?]O!X0SO!Y0SO'[$bO'e(gO'm+eO~O!W0TO~P#GyO!TSO!W0TO!u0VO!x0WO~P#GyO!W0TO!s0YO!t0YO!u0VO!x0WO~P#GyO!T&cO~O!T&cO~P!#rO!R'pi!c'pi_'pi'U'pi~P!)fO!{0cO!R'pi!c'pi_'pi'U'pi~O!R&sO!c'oi~Ox$tO!T$uO#V0eO'Z$`O~O#WraPraZra_rajra!ara!bra!dra!jra#[ra#]ra#^ra#_ra#`ra#ara#bra#cra#era#gra#ira#jra'Ura'dra!cra!Ora!Tranra%Qra!]ra~P#6fO#W$^aP$^aZ$^a_$^aj$^av$^a!a$^a!b$^a!d$^a!j$^a#[$^a#]$^a#^$^a#_$^a#`$^a#a$^a#b$^a#c$^a#e$^a#g$^a#i$^a#j$^a'U$^a'd$^a!c$^a!O$^a!T$^an$^a%Q$^a!]$^a~P#7[O#W$`aP$`aZ$`a_$`aj$`av$`a!a$`a!b$`a!d$`a!j$`a#[$`a#]$`a#^$`a#_$`a#`$`a#a$`a#b$`a#c$`a#e$`a#g$`a#i$`a#j$`a'U$`a'd$`a!c$`a!O$`a!T$`an$`a%Q$`a!]$`a~P#7}O#W$naP$naZ$na_$naj$nav$na!R$na!a$na!b$na!d$na!j$na#[$na#]$na#^$na#_$na#`$na#a$na#b$na#c$na#e$na#g$na#i$na#j$na'U$na'd$na!c$na!O$na!T$na!{$nan$na%Q$na!]$na~P!#rO_#Oq!R#Oq'U#Oq!O#Oq!c#Oqn#Oq!T#Oq%Q#Oq!]#Oq~P!)fO!R&iX'_&iX~PJdO!R,ZO'_'ka~O!Q0mO!R&jX!c&jX~P){O!R,^O!c'la~O!R,^O!c'la~P!)fO#m!fa!S!fa~PCcO#m!^a!R!^a!S!^a~P#)gO!T1QO#x^O$P1RO~O!S1VO~On1WO~P!#rO_$Yq!R$Yq'U$Yq!O$Yq!c$Yqn$Yq!T$Yq%Q$Yq!]$Yq~P!)fO!O1XO~O],uOk,uO~Ou(ROx(SO'v(WO'n$xi'u$xi!R$xi!{$xi~O'_$xi#m$xi~P$(jOu(ROx(SO'n$zi'u$zi'v$zi!R$zi!{$zi~O'_$zi#m$zi~P$)]O#m1YO~P!#rO!Q1[O'Z$`O!R&rX!c&rX~O!R,}O!c'{a~O!R,}O!]!wO!c'{a~O!R,}O!]!wO'n&nO!c'{a~O'_$gi!R$gi#m$gi!{$gi~P!#rO!Q1cO'Z(bO!O&tX!R&tX~P!$aO!R-UO!O'|a~O!R-UO!O'|a~P!#rO!]!wO~O!]!wO#c1mO~Oj1qO!]!wO'n&nO~O!R'bi'_'bi~P!#rO!{1tO!R'bi'_'bi~P!#rO!c1wO~O_$Zq!R$Zq'U$Zq!O$Zq!c$Zqn$Zq!T$Zq%Q$Zq!]$Zq~P!)fO!R1{O!T'}X~P!#rO!T&cO%Q2OO~O!T&cO%Q2OO~P!#rO!T$eX$u[X_$eX'U$eX~P!!iO$u2SOugXxgX!TgX'ngX'ugX'vgX_gX'UgX~O$u2SO~O]2YO%R2ZO'Z)gO!R&}X!S&}X~O!R.WO!S(Ta~OZ2_O~O^2`O~O]2cO~OS2eO!T&cO!o2dO%Q2OO~O_$[O'U$[O~P!#rO!T#yO~P!#rO!R2jO!{2lO!S(QX~O!S2mO~Ox(kO!W2vO!X2oO!Y2oO!r2uO!s2tO!t2tO!x2sO'[$bO'e(gO'm+eO~O!S2rO~P$1nOS2}O!T.sO!o2|O%Q2{O~OS2}O!T.sO!o2|O%Q2{O'`$cO~O'Z(yO!R&|X!S&|X~O!R/PO!S(Ra~O]3XO'e3WO~O]3YO~O^3[O~O!c3_O~P){O_3aO~O_3aO~P){O#c3cO%r3dO~PE{O`/gO!S3hO&Q/fO~P`O!]3jO~O&V3kOP&SqQ&SqX&Sq]&Sq_&Sqb&Sqc&Sqh&Sqj&Sqk&Sql&Sqq&Sqs&Sqx&Sq{&Sq|&Sq}&Sq!T&Sq!_&Sq!d&Sq!g&Sq!h&Sq!i&Sq!j&Sq!k&Sq!n&Sq#d&Sq#t&Sq#x&Sq%P&Sq%R&Sq%T&Sq%U&Sq%X&Sq%Z&Sq%^&Sq%_&Sq%a&Sq%n&Sq%t&Sq%v&Sq%x&Sq%z&Sq%}&Sq&T&Sq&X&Sq&Z&Sq&]&Sq&_&Sq&a&Sq'Q&Sq'Z&Sq'd&Sq'm&Sq'z&Sq!S&Sq%{&Sq`&Sq&Q&Sq~O!R#Ti!S#Ti~P#)gO!{3mO!R#Ti!S#Ti~O!R!Vi!S!Vi~P#)gO_$[O!{3tO'U$[O~O_$[O!]!wO!{3tO'U$[O~O!X3xO!Y3xO'[$bO'e(gO'm+eO~O_$[O!]!wO!d$XO!j3yO!{3tO'U$[O'`$cO'n&nO~O!W3zO~P$:ZO!W3zO!u3}O!x4OO~P$:ZO_$[O!]!wO!j3yO!{3tO'U$[O'n&nO~O!R'pq!c'pq_'pq'U'pq~P!)fO!R&sO!c'oq~O#W$xiP$xiZ$xi_$xij$xiv$xi!a$xi!b$xi!d$xi!j$xi#[$xi#]$xi#^$xi#_$xi#`$xi#a$xi#b$xi#c$xi#e$xi#g$xi#i$xi#j$xi'U$xi'd$xi!c$xi!O$xi!T$xin$xi%Q$xi!]$xi~P$(jO#W$ziP$ziZ$zi_$zij$ziv$zi!a$zi!b$zi!d$zi!j$zi#[$zi#]$zi#^$zi#_$zi#`$zi#a$zi#b$zi#c$zi#e$zi#g$zi#i$zi#j$zi'U$zi'd$zi!c$zi!O$zi!T$zin$zi%Q$zi!]$zi~P$)]O#W$giP$giZ$gi_$gij$giv$gi!R$gi!a$gi!b$gi!d$gi!j$gi#[$gi#]$gi#^$gi#_$gi#`$gi#a$gi#b$gi#c$gi#e$gi#g$gi#i$gi#j$gi'U$gi'd$gi!c$gi!O$gi!T$gi!{$gin$gi%Q$gi!]$gi~P!#rO!R&ia'_&ia~P!#rO!R&ja!c&ja~P!)fO!R,^O!c'li~O#m#Oi!R#Oi!S#Oi~P#)gOP#^Ou!{Ov!{Ox!|O!b!yO!d!zO!j#^O'dQOZ#Zij#Zi!a#Zi#]#Zi#^#Zi#_#Zi#`#Zi#a#Zi#b#Zi#c#Zi#e#Zi#g#Zi#i#Zi#j#Zi#m#Zi'n#Zi'u#Zi'v#Zi!R#Zi!S#Zi~O#[#Zi~P$CqO#[9]O~P$CqOP#^Ou!{Ov!{Ox!|O!b!yO!d!zO!j#^O#[9]O#]9^O#^9^O#_9^O'dQOZ#Zi!a#Zi#`#Zi#a#Zi#b#Zi#c#Zi#e#Zi#g#Zi#i#Zi#j#Zi#m#Zi'n#Zi'u#Zi'v#Zi!R#Zi!S#Zi~Oj#Zi~P$EyOj9_O~P$EyOP#^Oj9_Ou!{Ov!{Ox!|O!b!yO!d!zO!j#^O#[9]O#]9^O#^9^O#_9^O#`9`O'dQO#e#Zi#g#Zi#i#Zi#j#Zi#m#Zi'n#Zi'u#Zi'v#Zi!R#Zi!S#Zi~OZ#Zi!a#Zi#a#Zi#b#Zi#c#Zi~P$HROZ9jO!a9aO#a9aO#b9aO#c9aO~P$HROP#^OZ9jOj9_Ou!{Ov!{Ox!|O!a9aO!b!yO!d!zO!j#^O#[9]O#]9^O#^9^O#_9^O#`9`O#a9aO#b9aO#c9aO#e9bO'dQO#g#Zi#i#Zi#j#Zi#m#Zi'n#Zi'v#Zi!R#Zi!S#Zi~O'u#Zi~P$JgO'u!}O~P$JgOP#^OZ9jOj9_Ou!{Ov!{Ox!|O!a9aO!b!yO!d!zO!j#^O#[9]O#]9^O#^9^O#_9^O#`9`O#a9aO#b9aO#c9aO#e9bO#g9dO'dQO'u!}O#i#Zi#j#Zi#m#Zi'n#Zi!R#Zi!S#Zi~O'v#Zi~P$LoO'v#OO~P$LoOP#^OZ9jOj9_Ou!{Ov!{Ox!|O!a9aO!b!yO!d!zO!j#^O#[9]O#]9^O#^9^O#_9^O#`9`O#a9aO#b9aO#c9aO#e9bO#g9dO#i9fO'dQO'u!}O'v#OO~O#j#Zi#m#Zi'n#Zi!R#Zi!S#Zi~P$NwO_#ky!R#ky'U#ky!O#ky!c#kyn#ky!T#ky%Q#ky!]#ky~P!)fOP#ZiZ#Zij#Ziv#Zi!a#Zi!b#Zi!d#Zi!j#Zi#[#Zi#]#Zi#^#Zi#_#Zi#`#Zi#a#Zi#b#Zi#c#Zi#e#Zi#g#Zi#i#Zi#j#Zi#m#Zi'd#Zi!R#Zi!S#Zi~P!#rO!b!yOP'cXZ'cXj'cXu'cXv'cXx'cX!a'cX!d'cX!j'cX#['cX#]'cX#^'cX#_'cX#`'cX#a'cX#b'cX#c'cX#e'cX#g'cX#i'cX#j'cX#m'cX'd'cX'n'cX'u'cX'v'cX!R'cX!S'cX~O#m#ni!R#ni!S#ni~P#)gO!S4`O~O!R&qa!S&qa~P#)gO!]!wO'n&nO!R&ra!c&ra~O!R,}O!c'{i~O!R,}O!]!wO!c'{i~O!O&ta!R&ta~P!#rO!]4gO~O!R-UO!O'|i~P!#rO!R-UO!O'|i~O!O4mO~O!]!wO#c4sO~Oj4tO!]!wO'n&nO~O!O4vO~O'_$iq!R$iq#m$iq!{$iq~P!#rO_$Zy!R$Zy'U$Zy!O$Zy!c$Zyn$Zy!T$Zy%Q$Zy!]$Zy~P!)fO!R1{O!T'}a~O!T&cO%Q4{O~O!T&cO%Q4{O~P!#rO_#Oy!R#Oy'U#Oy!O#Oy!c#Oyn#Oy!T#Oy%Q#Oy!]#Oy~P!)fOZ5OO~O]5QO'Z)gO~O!R.WO!S(Ti~O]5TO~O^5UO~O'e'SO!R&yX!S&yX~O!R2jO!S(Qa~O!S5cO~P$1nOx-gO'e(gO'm+eO~O!W5fO!X5eO!Y5eO!x0WO'[$bO'e(gO'm+eO~O!s5gO!t5gO~P%-iO!X5eO!Y5eO'[$bO'e(gO'm+eO~O!T.sO~O!T.sO%Q5iO~O!T.sO%Q5iO~P!#rOS5nO!T.sO!o5mO%Q5iO~OZ5sO!R&|a!S&|a~O!R/PO!S(Ri~O]5vO~O!c5wO~O!c5xO~O!c5yO~O!c5yO~P){O_5{O~O!]6OO~O!c6QO~O!R'si!S'si~P#)gO_$[O'U$[O~P!)fO_$[O!{6VO'U$[O~O_$[O!]!wO!{6VO'U$[O~O!X6[O!Y6[O'[$bO'e(gO'm+eO~O_$[O!]!wO!j6]O!{6VO'U$[O'n&nO~O!d$XO'`$cO~P%2TO!W6^O~P%1rO!R'py!c'py_'py'U'py~P!)fO#W$iqP$iqZ$iq_$iqj$iqv$iq!R$iq!a$iq!b$iq!d$iq!j$iq#[$iq#]$iq#^$iq#_$iq#`$iq#a$iq#b$iq#c$iq#e$iq#g$iq#i$iq#j$iq'U$iq'd$iq!c$iq!O$iq!T$iq!{$iqn$iq%Q$iq!]$iq~P!#rO!R&ji!c&ji~P!)fO#m#Oq!R#Oq!S#Oq~P#)gOu-mOv-mOx-nOPraZrajra!ara!bra!dra!jra#[ra#]ra#^ra#_ra#`ra#ara#bra#cra#era#gra#ira#jra#mra'dra'nra'ura'vra!Rra!Sra~Ou(ROx(SOP$^aZ$^aj$^av$^a!a$^a!b$^a!d$^a!j$^a#[$^a#]$^a#^$^a#_$^a#`$^a#a$^a#b$^a#c$^a#e$^a#g$^a#i$^a#j$^a#m$^a'd$^a'n$^a'u$^a'v$^a!R$^a!S$^a~Ou(ROx(SOP$`aZ$`aj$`av$`a!a$`a!b$`a!d$`a!j$`a#[$`a#]$`a#^$`a#_$`a#`$`a#a$`a#b$`a#c$`a#e$`a#g$`a#i$`a#j$`a#m$`a'd$`a'n$`a'u$`a'v$`a!R$`a!S$`a~OP$naZ$naj$nav$na!a$na!b$na!d$na!j$na#[$na#]$na#^$na#_$na#`$na#a$na#b$na#c$na#e$na#g$na#i$na#j$na#m$na'd$na!R$na!S$na~P!#rO#m$Yq!R$Yq!S$Yq~P#)gO#m$Zq!R$Zq!S$Zq~P#)gO!S6hO~O'_$|y!R$|y#m$|y!{$|y~P!#rO!]!wO!R&ri!c&ri~O!]!wO'n&nO!R&ri!c&ri~O!R,}O!c'{q~O!O&ti!R&ti~P!#rO!R-UO!O'|q~O!O6oO~P!#rO!O6oO~O!R'by'_'by~P!#rO!R&wa!T&wa~P!#rO!T$tq_$tq'U$tq~P!#rOZ6wO~O!R.WO!S(Tq~O]6zO~O!T&cO%Q6{O~O!T&cO%Q6{O~P!#rO!{6|O!R&ya!S&ya~O!R2jO!S(Qi~P#)gO!X7SO!Y7SO'[$bO'e(gO'm+eO~O!W7UO!x4OO~P%ArO!T.sO%Q7XO~O!T.sO%Q7XO~P!#rO]7`O'e7_O~O!R/PO!S(Rq~O!c7bO~O!c7bO~P){O!c7dO~O!c7eO~O!R#Ty!S#Ty~P#)gO_$[O!{7kO'U$[O~O_$[O!]!wO!{7kO'U$[O~O!X7nO!Y7nO'[$bO'e(gO'm+eO~O_$[O!]!wO!j7oO!{7kO'U$[O'n&nO~O#W$|yP$|yZ$|y_$|yj$|yv$|y!R$|y!a$|y!b$|y!d$|y!j$|y#[$|y#]$|y#^$|y#_$|y#`$|y#a$|y#b$|y#c$|y#e$|y#g$|y#i$|y#j$|y'U$|y'd$|y!c$|y!O$|y!T$|y!{$|yn$|y%Q$|y!]$|y~P!#rO#m#ky!R#ky!S#ky~P#)gOP$giZ$gij$giv$gi!a$gi!b$gi!d$gi!j$gi#[$gi#]$gi#^$gi#_$gi#`$gi#a$gi#b$gi#c$gi#e$gi#g$gi#i$gi#j$gi#m$gi'd$gi!R$gi!S$gi~P!#rOu(ROx(SO'v(WOP$xiZ$xij$xiv$xi!a$xi!b$xi!d$xi!j$xi#[$xi#]$xi#^$xi#_$xi#`$xi#a$xi#b$xi#c$xi#e$xi#g$xi#i$xi#j$xi#m$xi'd$xi'n$xi'u$xi!R$xi!S$xi~Ou(ROx(SOP$ziZ$zij$ziv$zi!a$zi!b$zi!d$zi!j$zi#[$zi#]$zi#^$zi#_$zi#`$zi#a$zi#b$zi#c$zi#e$zi#g$zi#i$zi#j$zi#m$zi'd$zi'n$zi'u$zi'v$zi!R$zi!S$zi~O#m$Zy!R$Zy!S$Zy~P#)gO#m#Oy!R#Oy!S#Oy~P#)gO!]!wO!R&rq!c&rq~O!R,}O!c'{y~O!O&tq!R&tq~P!#rO!O7uO~P!#rO!R.WO!S(Ty~O!R2jO!S(Qq~O!X8RO!Y8RO'[$bO'e(gO'm+eO~O!T.sO%Q8UO~O!T.sO%Q8UO~P!#rO!c8XO~O&V8YOP&S!ZQ&S!ZX&S!Z]&S!Z_&S!Zb&S!Zc&S!Zh&S!Zj&S!Zk&S!Zl&S!Zq&S!Zs&S!Zx&S!Z{&S!Z|&S!Z}&S!Z!T&S!Z!_&S!Z!d&S!Z!g&S!Z!h&S!Z!i&S!Z!j&S!Z!k&S!Z!n&S!Z#d&S!Z#t&S!Z#x&S!Z%P&S!Z%R&S!Z%T&S!Z%U&S!Z%X&S!Z%Z&S!Z%^&S!Z%_&S!Z%a&S!Z%n&S!Z%t&S!Z%v&S!Z%x&S!Z%z&S!Z%}&S!Z&T&S!Z&X&S!Z&Z&S!Z&]&S!Z&_&S!Z&a&S!Z'Q&S!Z'Z&S!Z'd&S!Z'm&S!Z'z&S!Z!S&S!Z%{&S!Z`&S!Z&Q&S!Z~O_$[O!{8_O'U$[O~O_$[O!]!wO!{8_O'U$[O~OP$iqZ$iqj$iqv$iq!a$iq!b$iq!d$iq!j$iq#[$iq#]$iq#^$iq#_$iq#`$iq#a$iq#b$iq#c$iq#e$iq#g$iq#i$iq#j$iq#m$iq'd$iq!R$iq!S$iq~P!#rO!R&yq!S&yq~P#)gO_$[O!{8tO'U$[O~OP$|yZ$|yj$|yv$|y!a$|y!b$|y!d$|y!j$|y#[$|y#]$|y#^$|y#_$|y#`$|y#a$|y#b$|y#c$|y#e$|y#g$|y#i$|y#j$|y#m$|y'd$|y!R$|y!S$|y~P!#rOn'fX~P.jOn[X!O[X!c[X%r[X!T[X%Q[X!][X~P$zO!]dX!c[X!cdX'ndX~P;aOP9VOQ9VO]cOb:mOc!jOhcOj9VOkcOlcOq9VOs9VOxRO{cO|cO}cO!TSO!_9XO!dUO!g9VO!h9VO!i9VO!j9VO!k9VO!n!iO#t!lO#x^O'Z'bO'dQO'mYO'z:kO~O!R9hO!S$]a~O]#qOh$OOj#rOk#qOl#qOq$POs9mOx#xO!T#yO!_:pO!d#vO#V9sO#t$TO$_9oO$a9qO$d$UO'Z&zO'd#sO~O#d'iO~P&-UO!S[X!SdX~P;aO#W9[O~O!]!wO#W9[O~O!{9kO~O#c9aO~O!{9tO!R'sX!S'sX~O!{9kO!R'qX!S'qX~O#W9uO~O'_9wO~P!#rO#W9|O~O#W9}O~O!]!wO#W:OO~O!]!wO#W9uO~O#m:PO~P#)gO#W:QO~O#W:RO~O#W:SO~O#W:TO~O#m:UO~P!#rO#m:VO~P!#rO#x~!b!r!t!u#U#V'z$_$a$d$u%P%Q%R%X%Z%^%_%a%c~UT#x'z#]}'W'X#z'W'Z'e~",
  goto: "#Ed(XPPPPPPPP(YP(jP*^PPPP-uPP.[3n5b5uP5uPPP5uP7c5uP5uP7gPP7lP8Q<cPPPP<gPPPP<g?XPPP?_AjP<gPDTPPPPE{<gPPPPPGt<gPPJuKrPPPPKvM`PMhNiPKr<g<g!#p!&k!+^!+^!.mPPP!.t!1j<gPPPPPPPPPP!4aP!5rPP<g!7PP<gP<g<g<g<gP<g!9dPP!<]P!?Q!?Y!?^!?^P!<YP!?b!?bP!BVP!BZ<g<g!Ba!ET5uP5uP5u5uP!FW5u5u!HO5u!JQ5u!Kr5u5u!L`!NY!NY!N^!NY!NfP!NYP5u# b5u#!l5u5u-uPPP##yPP#$c#$cP#$cP#$x#$cPP#%OP#$uP#$u#%bMd#$u#&P#&V#&Y(Y#&](YP#&d#&d#&dP(YP(YP(YP(YPP(YP#&j#&mP#&m(YPPP(YP(YP(YP(YP(YP(Y(Y#&q#&{#'R#'X#'g#'m#'s#'}#(T#(d#(j#(x#)O#)U#)d#)y#+]#+k#+q#+w#+}#,T#,_#,e#,k#,u#-X#-_PPPPPPPP#-ePP#.X#2VPP#3m#3t#3|PP#8Y#:m#@i#@l#@o#@z#@}PP#AQ#AU#As#Bj#Bn#CSPP#CW#C^#CbP#Ce#Ci#Cl#D[#Dr#Dw#Dz#D}#ET#EW#E[#E`mhOSj}!n$Z%b%e%f%h*m*r/a/dQ$hmQ$opQ%YyS&U!b+[Q&j!jS(j#y(oQ)e$iQ)r$qQ*^%SQ+b&]S+g&c+iQ+y&kQ-e(qQ/O*_Y0S+k+l+m+n+oS2o.s2qU3x0T0V0YU5e2t2u2vS6[3z3}S7S5f5gQ7n6^R8R7U$p[ORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$Z$m%Z%^%b%d%e%f%h%l%w%y&R&^&e&o&|'Q(Q)S)Z*i*m*r+P+t+{,^,d-n-s-{.V.v/X/Y/Z/]/a/d/f/|0c0m2d2|3a3c3d3t5m5{6V7k8_8t!j'd#]#k&V'v+T+W,i/t1Q2l3m6|9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nQ(z$QQ)j$kQ*`%VQ*g%_Q,T9lQ.Q)_Q.])kQ/W*eQ2Y.WQ3U/PQ4X9mR5Q2ZpeOSjy}!n$Z%X%b%e%f%h*m*r/a/dR*b%Z&WVOSTjkn}!S!W!k!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k$Z$m%Z%^%_%b%d%e%f%h%l%y&R&^&e&o&|'Q'v(Q)S)Z*i*m*r+P+T+W+t+{,^,d,i-n-s-{.V.v/X/Y/Z/]/a/d/f/t/|0c0m1Q2d2l2|3a3c3d3m3t5m5{6V6|7k8_8t9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:m:n[!cRU!]!`%w&VQ$alQ$gmS$lp$qv$vrs!r!u$X$t&_&s&v)v)w)x*k+U+d,O,Q/j0eQ%OwQ&g!iQ&i!jS(^#v(hS)d$h$iQ)h$kQ)u$sQ*X%QQ*]%SS+x&j&kQ-R(_Q.U)eQ.[)kQ.^)lQ.a)pQ.y*YS.}*^*_Q0a+yQ1Z,}Q2X.WQ2].ZQ2b.cQ3T/OQ4d1[Q5P2ZQ5S2_Q6v5OR7x6w!Y$em!j$g$h$i&T&i&j&k(i)d)e+X+f+x+y-_.U/y0P0U0a1p3w3|6Y7l8`Q)]$aQ)}${Q*Q$|Q*[%SQ.e)uQ.x*XU.|*]*^*_Q3O.yS3S.}/OQ5`2nQ5r3TS7Q5a5dS8P7R7TQ8j8QR8y8kW#|a$c(w:kS${t%XQ$|uQ$}vR){$y$V#{a!w!y#d#v#x$R$S$W&f'|(V(X(Y(a(e(u(v)Y)[)_)|*P+u,Z-U-W-p-z-|.j.m.u.w1Y1c1m1t1{2O2S2e2{2}4g4s4{5i5n6{7X8U9j9n9o9p9q9r9s9x9y9z9{9|9}:Q:R:U:V:k:q:rT'}#s(OV({$Q9l9mU&Y!b$u+_Q'T!{Q)o$nQ.n*RQ1u-mR5[2j&^cORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&V&^&e&o&|'Q'v(Q)S)Z*i*m*r+P+T+W+t+{,^,d,i-n-s-{.V.v/X/Y/Z/]/a/d/f/t/|0c0m1Q2d2l2|3a3c3d3m3t5m5{6V6|7k8_8t9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:n$]#aZ!_!o$_%v%|&x'P'V'W'X'Y'Z'[']'^'_'`'a'c'f'j't)n*}+Y+c+z,Y,`,c,e,s-q/o/r0b0l0p0q0r0s0t0u0v0w0x0y0z0{0|1P1U1y2V3o3r4S4V4W4]4^5^6R6U6b6f6g7h7{8]8r8}9W:dT!XQ!Y&_cORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&V&^&e&o&|'Q'v(Q)S)Z*i*m*r+P+T+W+t+{,^,d,i-n-s-{.V.v/X/Y/Z/]/a/d/f/t/|0c0m1Q2d2l2|3a3c3d3m3t5m5{6V6|7k8_8t9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nQ&W!bR/u+[Y&Q!b&U&]+[+bS(i#y(oS+f&c+iS-_(j(qQ-`(kQ-f(rQ.p*TU0P+g+k+lU0U+m+n+oS0Z+p2sQ1p-eQ1r-gQ1s-hS2n.s2qU3w0S0T0VQ3{0WQ3|0YS5a2o2vS5d2t2uU6Y3x3z3}Q6_4OS7R5e5fQ7T5gS7l6[6^S8Q7S7UQ8`7nR8k8RlhOSj}!n$Z%b%e%f%h*m*r/a/dQ%j!QS&w!v9[Q)b$fQ*V%OQ*W%PQ+v&hS,X&|9uS-r)S:OQ.S)cQ.r*UQ/h*tQ/i*uQ/q+VQ0X+mQ0_+wS1z-s:SQ2T.TS2W.V:TQ3n/sQ3q/zQ4Q0`Q4}2UQ6P3kQ6S3pQ6W3vQ6`4RQ7f6QQ7i6XQ8[7jQ8o8YQ8q8^R8|8s$W#`Z!_!o%v%|&x'P'V'W'X'Y'Z'[']'^'_'`'a'c'f'j't)n*}+Y+c+z,Y,`,c,s-q/o/r0b0l0p0q0r0s0t0u0v0w0x0y0z0{0|1P1U1y2V3o3r4S4V4W4]4^5^6R6U6b6f6g7h7{8]8r8}9W:dU(t#z&{1OT)W$_,e$W#_Z!_!o%v%|&x'P'V'W'X'Y'Z'[']'^'_'`'a'c'f'j't)n*}+Y+c+z,Y,`,c,s-q/o/r0b0l0p0q0r0s0t0u0v0w0x0y0z0{0|1P1U1y2V3o3r4S4V4W4]4^5^6R6U6b6f6g7h7{8]8r8}9W:dQ'e#`S)V$_,eR-t)W&^cORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&V&^&e&o&|'Q'v(Q)S)Z*i*m*r+P+T+W+t+{,^,d,i-n-s-{.V.v/X/Y/Z/]/a/d/f/t/|0c0m1Q2d2l2|3a3c3d3m3t5m5{6V6|7k8_8t9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nQ%e{Q%f|Q%h!OQ%i!PR/`*pQ&d!iQ)X$aQ+s&gS-y)])uS0[+q+rW1}-v-w-x.eS4P0]0^U4z2P2Q2RU6t4y5W5XQ7w6uR8f7zT+h&c+iS+f&c+iU0P+g+k+lU0U+m+n+oS0Z+p2sS2n.s2qU3w0S0T0VQ3{0WQ3|0YS5a2o2vS5d2t2uU6Y3x3z3}Q6_4OS7R5e5fQ7T5gS7l6[6^S8Q7S7UQ8`7nR8k8RS+h&c+iT2p.s2qS&q!q/^Q-Q(^Q-](iS0O+f2nQ1`-RS1j-^-fU3y0U0Z5dQ4c1ZS4q1q1sU6]3{3|7TQ6j4dQ6s4tR7o6_Q!xXS&p!q/^Q)T$YQ)`$dQ)f$jQ+|&qQ-P(^Q-[(iQ-a(lQ.R)aQ.z*ZS/}+f2nS1_-Q-RS1i-]-fQ1l-`Q1o-bQ3Q.{W3u0O0U0Z5dQ4b1ZQ4f1`S4k1j1sQ4r1rQ5p3RW6Z3y3{3|7TS6i4c4dQ6n4mQ6q4qQ7O5_Q7]5qS7m6]6_Q7q6jQ7s6oQ7v6sQ7}7PQ8W7^Q8a7oQ8d7uQ8h8OQ8w8iQ9P8xQ9T9QQ:^:XQ:g:bR:h:c$rWORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&^&e&o&|'Q(Q)S)Z*i*m*r+P+t+{,^,d-n-s-{.V.v/X/Y/Z/]/a/d/f/|0c0m2d2|3a3c3d3t5m5{6V7k8_8tS!xn!k!j:W#]#k&V'v+T+W,i/t1Q2l3m6|9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nR:^:m$rXORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&^&e&o&|'Q(Q)S)Z*i*m*r+P+t+{,^,d-n-s-{.V.v/X/Y/Z/]/a/d/f/|0c0m2d2|3a3c3d3t5m5{6V7k8_8tQ$Yb!Y$dm!j$g$h$i&T&i&j&k(i)d)e+X+f+x+y-_.U/y0P0U0a1p3w3|6Y7l8`S$jn!kQ)a$eQ*Z%SW.{*[*]*^*_U3R.|.}/OQ5_2nS5q3S3TU7P5`5a5dQ7^5rU8O7Q7R7TS8i8P8QS8x8j8kQ9Q8y!j:X#]#k&V'v+T+W,i/t1Q2l3m6|9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nQ:b:lR:c:m$f]OSTjk}!S!W!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$Z$m%Z%^%b%d%e%f%h%l%y&R&^&e&o&|'Q(Q)S)Z*i*m*r+P+t+{,^,d-n-s-{.V.v/X/Y/Z/]/a/d/f/|0c0m2d2|3a3c3d3t5m5{6V7k8_8tY!hRU!]!`%wv$vrs!r!u$X$t&_&s&v)v)w)x*k+U+d,O,Q/j0eQ*h%_!h:Y#]#k'v+T+W,i/t1Q2l3m6|9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nR:]&VS&Z!b$uR/w+_$p[ORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$Z$m%Z%^%b%d%e%f%h%l%w%y&R&^&e&o&|'Q(Q)S)Z*i*m*r+P+t+{,^,d-n-s-{.V.v/X/Y/Z/]/a/d/f/|0c0m2d2|3a3c3d3t5m5{6V7k8_8t!j'd#]#k&V'v+T+W,i/t1Q2l3m6|9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nR*g%_$roORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&^&e&o&|'Q(Q)S)Z*i*m*r+P+t+{,^,d-n-s-{.V.v/X/Y/Z/]/a/d/f/|0c0m2d2|3a3c3d3t5m5{6V7k8_8tQ'T!{!k:Z#]#k&V'v+T+W,i/t1Q2l3m6|9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:n!h#VZ!_$_%v%|&x'P'^'_'`'a'f'j)n*}+c+z,Y,`,s-q0b0l0|1y2V3r4S4V6U7h8]8r8}9W!R9c'c't+Y,e/o/r0p0x0y0z0{1P1U3o4W4]4^5^6R6b6f6g7{:d!d#XZ!_$_%v%|&x'P'`'a'f'j)n*}+c+z,Y,`,s-q0b0l0|1y2V3r4S4V6U7h8]8r8}9W}9e'c't+Y,e/o/r0p0z0{1P1U3o4W4]4^5^6R6b6f6g7{:d!`#]Z!_$_%v%|&x'P'f'j)n*}+c+z,Y,`,s-q0b0l0|1y2V3r4S4V6U7h8]8r8}9Wl(Y#t&})R,{-T-i-j0j1x4a4u:_:i:jx:n'c't+Y,e/o/r0p1P1U3o4W4]4^5^6R6b6f6g7{:d!`:q&y'h(](c+r,W,p-X-u-x.i.k0^0i1a1e2R2g2i2y4U4h4n4w4|5X5l6a6l6r7ZZ:r0}4[6c7p8b&^cORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&V&^&e&o&|'Q'v(Q)S)Z*i*m*r+P+T+W+t+{,^,d,i-n-s-{.V.v/X/Y/Z/]/a/d/f/t/|0c0m1Q2d2l2|3a3c3d3m3t5m5{6V6|7k8_8t9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nS#l`#mR1R,h&e_ORSTU`jk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k#m$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&V&^&e&o&|'Q'v(Q)S)Z*i*m*r+P+T+W+t+{,^,d,h,i-n-s-{.V.v/X/Y/Z/]/a/d/f/t/|0c0m1Q2d2l2|3a3c3d3m3t5m5{6V6|7k8_8t9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nS#g^#nT'm#i'qT#h^#nT'o#i'q&e`ORSTU`jk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k#m$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&V&^&e&o&|'Q'v(Q)S)Z*i*m*r+P+T+W+t+{,^,d,h,i-n-s-{.V.v/X/Y/Z/]/a/d/f/t/|0c0m1Q2d2l2|3a3c3d3m3t5m5{6V6|7k8_8t9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:nT#l`#mQ#o`R'x#m$rbORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$Z$m%Z%^%_%b%d%e%f%h%l%w%y&R&^&e&o&|'Q(Q)S)Z*i*m*r+P+t+{,^,d-n-s-{.V.v/X/Y/Z/]/a/d/f/|0c0m2d2|3a3c3d3t5m5{6V7k8_8t!k:l#]#k&V'v+T+W,i/t1Q2l3m6|9V9X9[9]9^9_9`9a9b9c9d9e9f9g9h9k9t9u9w:O:P:S:T:n#RdOSUj}!S!W!n!|#k$Z%Z%^%_%b%d%e%f%h%l&R&e'v)Z*i*m*r+t,i-n-{.v/X/Y/Z/]/a/d/f1Q2d2|3a3c3d5m5{t#za!y$R$S$W(V(X(Y(a(u(v,Z-p1Y1t:k:q:r!|&{!w#d#v#x&f'|(e)Y)[)_)|*P+u-U-W-z-|.j.m.u.w1c1m1{2O2S2e2{2}4g4s4{5i5n6{7X8U9n9p9r9x9z9|:Q:UQ)P$UQ,t(Rc1O9j9o9q9s9y9{9}:R:Vt#wa!y$R$S$W(V(X(Y(a(u(v,Z-p1Y1t:k:q:rS(l#y(oQ)Q$VQ-b(m!|:`!w#d#v#x&f'|(e)Y)[)_)|*P+u-U-W-z-|.j.m.u.w1c1m1{2O2S2e2{2}4g4s4{5i5n6{7X8U9n9p9r9x9z9|:Q:Ub:a9j9o9q9s9y9{9}:R:VQ:e:oR:f:pt#za!y$R$S$W(V(X(Y(a(u(v,Z-p1Y1t:k:q:r!|&{!w#d#v#x&f'|(e)Y)[)_)|*P+u-U-W-z-|.j.m.u.w1c1m1{2O2S2e2{2}4g4s4{5i5n6{7X8U9n9p9r9x9z9|:Q:Uc1O9j9o9q9s9y9{9}:R:VlfOSj}!n$Z%b%e%f%h*m*r/a/dQ(d#xQ*y%oQ*z%qR1b-U$U#{a!w!y#d#v#x$R$S$W&f'|(V(X(Y(a(e(u(v)Y)[)_)|*P+u,Z-U-W-p-z-|.j.m.u.w1Y1c1m1t1{2O2S2e2{2}4g4s4{5i5n6{7X8U9j9n9o9p9q9r9s9x9y9z9{9|9}:Q:R:U:V:k:q:rQ*O$|Q.l*QQ2h.kR5Z2iT(n#y(oS(n#y(oT2p.s2qQ)`$dQ-a(lQ.R)aQ.z*ZQ3Q.{Q5p3RQ7O5_Q7]5qQ7}7PQ8W7^Q8h8OQ8w8iQ9P8xR9T9Ql(V#t&})R,{-T-i-j0j1x4a4u:_:i:j!`9x&y'h(](c+r,W,p-X-u-x.i.k0^0i1a1e2R2g2i2y4U4h4n4w4|5X5l6a6l6r7ZZ9y0}4[6c7p8bn(X#t&})R,y,{-T-i-j0j1x4a4u:_:i:j!b9z&y'h(](c+r,W,p-X-u-x.i.k0^0g0i1a1e2R2g2i2y4U4h4n4w4|5X5l6a6l6r7Z]9{0}4[6c6d7p8bpeOSjy}!n$Z%X%b%e%f%h*m*r/a/dQ%UxR*i%_peOSjy}!n$Z%X%b%e%f%h*m*r/a/dR%UxQ*S$}R.h){qeOSjy}!n$Z%X%b%e%f%h*m*r/a/dQ.t*XS2z.x.yW5h2w2x2y3OU7W5j5k5lU8S7V7Y7ZQ8l8TR8z8mQ%]yR*c%XR3X/RR7`5sS$lp$qR.^)lQ%bzR*m%cR*s%iT/b*r/dQjOQ!nST$^j!nQ(O#sR,q(OQ!YQR%t!YQ!^RU%z!^%{+QQ%{!_R+Q%|Q+]&WR/v+]Q,[&}R0k,[Q,_'PS0n,_0oR0o,`Q+i&cR0Q+iS!eR$tU&`!e&a+RQ&a!fR+R%}Q+`&ZR/x+`Q&t!sQ+}&rU,R&t+}0fR0f,SQ'q#iR,j'qQ#m`R'w#mQ#cZU'g#c*|9iQ*|9WR9i'tQ-O(^W1]-O1^4e6kU1^-P-Q-RS4e1_1`R6k4f#q(T#t&y&}'h(](c(|(})R+r,U,V,W,p,y,z,{-T-X-i-j-u-x.i.k0^0g0h0i0j0}1a1e1x2R2g2i2y4U4Y4Z4[4a4h4n4u4w4|5X5l6a6c6d6e6l6r7Z7p8b:_:i:jQ-V(cU1d-V1f4iQ1f-XR4i1eQ(o#yR-c(oQ(x#}R-l(xQ1|-uR4x1|Q)y$wR.g)yQ2k.nS5]2k6}R6}5^Q*U%OR.q*UQ2q.sR5b2qQ/Q*`S3V/Q5tR5t3XQ.X)hW2[.X2^5R6xQ2^.[Q5R2]R6x5SQ)m$lR._)mQ/d*rR3g/dWiOSj!nQ%g}Q)U$ZQ*l%bQ*n%eQ*o%fQ*q%hQ/_*mS/b*r/dR3f/aQ$]gQ%k!RQ%n!TQ%p!UQ%r!VQ)t$rQ)z$xQ*b%]Q*w%mS/T*c*fQ/k*vQ/l*yQ/m*zS/{+f2nQ1g-ZQ1h-[Q1n-aQ2a.bQ2f.iQ3P.zQ3Z/VQ3e/`Y3s/}0O0U0Z5dQ4j1iQ4l1kQ4o1oQ5V2cQ5Y2gQ5o3QQ5u3Y[6T3r3u3y3{3|7TQ6m4kQ6p4pQ6y5TQ7[5pQ7a5vW7g6U6Z6]6_Q7r6nQ7t6qQ7y6zQ7|7OQ8V7]U8Z7h7m7oQ8c7sQ8e7vQ8g7}Q8n8WS8p8]8aQ8u8dQ8v8hQ8{8rQ9O8wQ9R8}Q9S9PR9U9TQ$fmQ&h!jU)c$g$h$iQ+V&TU+w&i&j&kQ-Z(iS.T)d)eQ/s+XQ/z+fS0`+x+yQ1k-_Q2U.UQ3p/yS3v0P0UQ4R0aQ4p1pS6X3w3|Q7j6YQ8^7lR8s8`S#ua:kR)^$cU#}a$c:kR-k(wQ#taS&y!w)_Q&}!yQ'h#dQ(]#vQ(c#xQ(|$RQ(}$SQ)R$WQ+r&fQ,U9nQ,V9pQ,W9rQ,p'|Q,y(VQ,z(XQ,{(YQ-T(aQ-X(eQ-i(uQ-j(vd-u)Y-z.u2O2{4{5i6{7X8UQ-x)[Q.i)|Q.k*PQ0^+uQ0g9xQ0h9zQ0i9|Q0j,ZQ0}9jQ1a-UQ1e-WQ1x-pQ2R-|Q2g.jQ2i.mQ2y.wQ4U:QQ4Y9oQ4Z9qQ4[9sQ4a1YQ4h1cQ4n1mQ4u1tQ4w1{Q4|2SQ5X2eQ5l2}Q6a:UQ6c9}Q6d9yQ6e9{Q6l4gQ6r4sQ7Z5nQ7p:RQ8b:VQ:_:kQ:i:qR:j:rlgOSj}!n$Z%b%e%f%h*m*r/a/dS!pU%dQ%m!SQ%s!WQ'U!|Q'u#kS*f%Z%^Q*j%_Q*v%lQ+S&RQ+q&eQ,n'vQ-w)ZQ/[*iQ0]+tQ1T,iQ1v-nQ2Q-{Q2x.vQ3]/XQ3^/YQ3`/ZQ3b/]Q3i/fQ4_1QQ5W2dQ5k2|Q5z3aQ5|3cQ5}3dQ7Y5mR7c5{!vZOSUj}!S!n!|$Z%Z%^%_%b%d%e%f%h%l&R&e)Z*i*m*r+t-n-{.v/X/Y/Z/]/a/d/f2d2|3a3c3d5m5{Q!_RQ!oTQ$_kS%v!]%yQ%|!`Q&x!vQ'P!zQ'V#PQ'W#QQ'X#RQ'Y#SQ'Z#TQ'[#UQ']#VQ'^#WQ'_#XQ'`#YQ'a#ZQ'c#]Q'f#bQ'j#eW't#k'v,i1QQ)n$mS*}%w+PS+Y&V/tQ+c&^Q+z&oQ,Y&|Q,`'QQ,c9VQ,e9XQ,s(QQ-q)SQ/o+TQ/r+WQ0b+{Q0l,^Q0p9[Q0q9]Q0r9^Q0s9_Q0t9`Q0u9aQ0v9bQ0w9cQ0x9dQ0y9eQ0z9fQ0{9gQ0|,dQ1P9kQ1U9hQ1y-sQ2V.VQ3o9tQ3r/|Q4S0cQ4V0mQ4W9uQ4]9wQ4^:OQ5^2lQ6R3mQ6U3tQ6b:PQ6f:SQ6g:TQ7h6VQ7{6|Q8]7kQ8r8_Q8}8tQ9W!WR:d:nR!aRR&X!bS&T!b+[S+X&U&]R/y+bR'O!yR'R!zT!tU$XS!sU$XU$wrs*kS&r!r!uQ,P&sQ,S&vQ.f)xS0d,O,QR4T0e`!dR!]!`$t%w&_)v+dh!qUrs!r!u$X&s&v)x,O,Q0eQ/^*kQ/p+UQ3l/jT:[&V)wT!gR$tS!fR$tS%x!]&_S%}!`)vS+O%w+dT+Z&V)wT&[!b$uQ#i^R'z#nT'p#i'qR1S,hT(`#v(hR(f#xQ-v)YQ2P-zQ2w.uQ4y2OQ5j2{Q6u4{Q7V5iQ7z6{Q8T7XR8m8UlhOSj}!n$Z%b%e%f%h*m*r/a/dQ%[yR*b%XV$xrs*kR.o*RR*a%VQ$ppR)s$qR)i$kT%`z%cT%az%cT/c*r/d",
  nodeNames: "⚠ ArithOp ArithOp InterpolationStart extends LineComment BlockComment Script ExportDeclaration export Star as VariableName String from ; default FunctionDeclaration async function VariableDefinition TypeParamList TypeDefinition ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Interpolation null super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression await yield delete LogicOp BitOp ParenthesizedExpression ClassExpression class extends ClassBody MethodDeclaration Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression PrivatePropertyName BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXStartTag JSXSelfClosingTag JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody MethodDeclaration AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try catch finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement",
  maxTerm: 330,
  context: kz,
  nodeProps: [
    [Ce.closedBy, 3, "InterpolationEnd", 40, "]", 51, "}", 66, ")", 132, "JSXSelfCloseEndTag JSXEndTag", 146, "JSXEndTag"],
    [Ce.group, -26, 8, 15, 17, 58, 184, 188, 191, 192, 194, 197, 200, 211, 213, 219, 221, 223, 225, 228, 234, 238, 240, 242, 244, 246, 248, 249, "Statement", -30, 12, 13, 24, 27, 28, 41, 43, 44, 45, 47, 52, 60, 68, 74, 75, 91, 92, 101, 103, 119, 122, 124, 125, 126, 127, 129, 130, 148, 149, 151, "Expression", -22, 23, 25, 29, 32, 34, 152, 154, 156, 157, 159, 160, 161, 163, 164, 165, 167, 168, 169, 178, 180, 182, 183, "Type", -3, 79, 85, 90, "ClassItem"],
    [Ce.openedBy, 30, "InterpolationStart", 46, "[", 50, "{", 65, "(", 131, "JSXStartTag", 141, "JSXStartTag JSXStartCloseTag"]
  ],
  skippedNodes: [0, 5, 6],
  repeatNodeCount: 28,
  tokenData: "!C}~R!`OX%TXY%cYZ'RZ[%c[]%T]^'R^p%Tpq%cqr'crs(kst0htu2`uv4pvw5ewx6cxy<yyz=Zz{=k{|>k|}?O}!O>k!O!P?`!P!QCl!Q!R!0[!R![!1q![!]!7s!]!^!8V!^!_!8g!_!`!9d!`!a!:[!a!b!<R!b!c%T!c!}2`!}#O!=d#O#P%T#P#Q!=t#Q#R!>U#R#S2`#S#T!>i#T#o2`#o#p!>y#p#q!?O#q#r!?f#r#s!?x#s$f%T$f$g%c$g#BY2`#BY#BZ!@Y#BZ$IS2`$IS$I_!@Y$I_$I|2`$I|$I}!Bq$I}$JO!Bq$JO$JT2`$JT$JU!@Y$JU$KV2`$KV$KW!@Y$KW&FU2`&FU&FV!@Y&FV?HT2`?HT?HU!@Y?HU~2`W%YR$UWO!^%T!_#o%T#p~%T,T%jg$UW'W+{OX%TXY%cYZ%TZ[%c[p%Tpq%cq!^%T!_#o%T#p$f%T$f$g%c$g#BY%T#BY#BZ%c#BZ$IS%T$IS$I_%c$I_$JT%T$JT$JU%c$JU$KV%T$KV$KW%c$KW&FU%T&FU&FV%c&FV?HT%T?HT?HU%c?HU~%T,T'YR$UW'X+{O!^%T!_#o%T#p~%T$T'jS$UW!j#{O!^%T!_!`'v!`#o%T#p~%T$O'}S#e#v$UWO!^%T!_!`(Z!`#o%T#p~%T$O(bR#e#v$UWO!^%T!_#o%T#p~%T'u(rZ$UW]!ROY(kYZ)eZr(krs*rs!^(k!^!_+U!_#O(k#O#P-b#P#o(k#o#p+U#p~(k&r)jV$UWOr)ers*Ps!^)e!^!_*a!_#o)e#o#p*a#p~)e&r*WR$P&j$UWO!^%T!_#o%T#p~%T&j*dROr*ars*ms~*a&j*rO$P&j'u*{R$P&j$UW]!RO!^%T!_#o%T#p~%T'm+ZV]!ROY+UYZ*aZr+Urs+ps#O+U#O#P+w#P~+U'm+wO$P&j]!R'm+zROr+Urs,Ts~+U'm,[U$P&j]!ROY,nZr,nrs-Vs#O,n#O#P-[#P~,n!R,sU]!ROY,nZr,nrs-Vs#O,n#O#P-[#P~,n!R-[O]!R!R-_PO~,n'u-gV$UWOr(krs-|s!^(k!^!_+U!_#o(k#o#p+U#p~(k'u.VZ$P&j$UW]!ROY.xYZ%TZr.xrs/rs!^.x!^!_,n!_#O.x#O#P0S#P#o.x#o#p,n#p~.x!Z/PZ$UW]!ROY.xYZ%TZr.xrs/rs!^.x!^!_,n!_#O.x#O#P0S#P#o.x#o#p,n#p~.x!Z/yR$UW]!RO!^%T!_#o%T#p~%T!Z0XT$UWO!^.x!^!_,n!_#o.x#o#p,n#p~.xy0mZ$UWOt%Ttu1`u!^%T!_!c%T!c!}1`!}#R%T#R#S1`#S#T%T#T#o1`#p$g%T$g~1`y1g]$UW'mqOt%Ttu1`u!Q%T!Q![1`![!^%T!_!c%T!c!}1`!}#R%T#R#S1`#S#T%T#T#o1`#p$g%T$g~1`&i2k_$UW#zS'Z%k'epOt%Ttu2`u}%T}!O3j!O!Q%T!Q![2`![!^%T!_!c%T!c!}2`!}#R%T#R#S2`#S#T%T#T#o2`#p$g%T$g~2`[3q_$UW#zSOt%Ttu3ju}%T}!O3j!O!Q%T!Q![3j![!^%T!_!c%T!c!}3j!}#R%T#R#S3j#S#T%T#T#o3j#p$g%T$g~3j$O4wS#^#v$UWO!^%T!_!`5T!`#o%T#p~%T$O5[R$UW#o#vO!^%T!_#o%T#p~%T%r5lU'v%j$UWOv%Tvw6Ow!^%T!_!`5T!`#o%T#p~%T$O6VS$UW#i#vO!^%T!_!`5T!`#o%T#p~%T'u6jZ$UW]!ROY6cYZ7]Zw6cwx*rx!^6c!^!_8T!_#O6c#O#P:T#P#o6c#o#p8T#p~6c&r7bV$UWOw7]wx*Px!^7]!^!_7w!_#o7]#o#p7w#p~7]&j7zROw7wwx*mx~7w'm8YV]!ROY8TYZ7wZw8Twx+px#O8T#O#P8o#P~8T'm8rROw8Twx8{x~8T'm9SU$P&j]!ROY9fZw9fwx-Vx#O9f#O#P9}#P~9f!R9kU]!ROY9fZw9fwx-Vx#O9f#O#P9}#P~9f!R:QPO~9f'u:YV$UWOw6cwx:ox!^6c!^!_8T!_#o6c#o#p8T#p~6c'u:xZ$P&j$UW]!ROY;kYZ%TZw;kwx/rx!^;k!^!_9f!_#O;k#O#P<e#P#o;k#o#p9f#p~;k!Z;rZ$UW]!ROY;kYZ%TZw;kwx/rx!^;k!^!_9f!_#O;k#O#P<e#P#o;k#o#p9f#p~;k!Z<jT$UWO!^;k!^!_9f!_#o;k#o#p9f#p~;k%V=QR!d$}$UWO!^%T!_#o%T#p~%TZ=bR!cR$UWO!^%T!_#o%T#p~%T%R=tU'[!R#_#v$UWOz%Tz{>W{!^%T!_!`5T!`#o%T#p~%T$O>_S#[#v$UWO!^%T!_!`5T!`#o%T#p~%T$u>rSj$m$UWO!^%T!_!`5T!`#o%T#p~%T&i?VR!R&a$UWO!^%T!_#o%T#p~%T&i?gVu%n$UWO!O%T!O!P?|!P!Q%T!Q![@r![!^%T!_#o%T#p~%Ty@RT$UWO!O%T!O!P@b!P!^%T!_#o%T#p~%Ty@iR!Qq$UWO!^%T!_#o%T#p~%Ty@yZ$UWkqO!Q%T!Q![@r![!^%T!_!g%T!g!hAl!h#R%T#R#S@r#S#X%T#X#YAl#Y#o%T#p~%TyAqZ$UWO{%T{|Bd|}%T}!OBd!O!Q%T!Q![CO![!^%T!_#R%T#R#SCO#S#o%T#p~%TyBiV$UWO!Q%T!Q![CO![!^%T!_#R%T#R#SCO#S#o%T#p~%TyCVV$UWkqO!Q%T!Q![CO![!^%T!_#R%T#R#SCO#S#o%T#p~%T,TCs`$UW#]#vOYDuYZ%TZzDuz{Jl{!PDu!P!Q!-e!Q!^Du!^!_Fx!_!`!.^!`!a!/]!a!}Du!}#OHq#O#PJQ#P#oDu#o#pFx#p~DuXD|[$UW}POYDuYZ%TZ!PDu!P!QEr!Q!^Du!^!_Fx!_!}Du!}#OHq#O#PJQ#P#oDu#o#pFx#p~DuXEy_$UW}PO!^%T!_#Z%T#Z#[Er#[#]%T#]#^Er#^#a%T#a#bEr#b#g%T#g#hEr#h#i%T#i#jEr#j#m%T#m#nEr#n#o%T#p~%TPF}V}POYFxZ!PFx!P!QGd!Q!}Fx!}#OG{#O#PHh#P~FxPGiU}P#Z#[Gd#]#^Gd#a#bGd#g#hGd#i#jGd#m#nGdPHOTOYG{Z#OG{#O#PH_#P#QFx#Q~G{PHbQOYG{Z~G{PHkQOYFxZ~FxXHvY$UWOYHqYZ%TZ!^Hq!^!_G{!_#OHq#O#PIf#P#QDu#Q#oHq#o#pG{#p~HqXIkV$UWOYHqYZ%TZ!^Hq!^!_G{!_#oHq#o#pG{#p~HqXJVV$UWOYDuYZ%TZ!^Du!^!_Fx!_#oDu#o#pFx#p~Du,TJs^$UW}POYJlYZKoZzJlz{NQ{!PJl!P!Q!,R!Q!^Jl!^!_!!]!_!}Jl!}#O!'|#O#P!+a#P#oJl#o#p!!]#p~Jl,TKtV$UWOzKoz{LZ{!^Ko!^!_M]!_#oKo#o#pM]#p~Ko,TL`X$UWOzKoz{LZ{!PKo!P!QL{!Q!^Ko!^!_M]!_#oKo#o#pM]#p~Ko,TMSR$UWU+{O!^%T!_#o%T#p~%T+{M`ROzM]z{Mi{~M]+{MlTOzM]z{Mi{!PM]!P!QM{!Q~M]+{NQOU+{,TNX^$UW}POYJlYZKoZzJlz{NQ{!PJl!P!Q! T!Q!^Jl!^!_!!]!_!}Jl!}#O!'|#O#P!+a#P#oJl#o#p!!]#p~Jl,T! ^_$UWU+{}PO!^%T!_#Z%T#Z#[Er#[#]%T#]#^Er#^#a%T#a#bEr#b#g%T#g#hEr#h#i%T#i#jEr#j#m%T#m#nEr#n#o%T#p~%T+{!!bY}POY!!]YZM]Zz!!]z{!#Q{!P!!]!P!Q!&x!Q!}!!]!}#O!$`#O#P!&f#P~!!]+{!#VY}POY!!]YZM]Zz!!]z{!#Q{!P!!]!P!Q!#u!Q!}!!]!}#O!$`#O#P!&f#P~!!]+{!#|UU+{}P#Z#[Gd#]#^Gd#a#bGd#g#hGd#i#jGd#m#nGd+{!$cWOY!$`YZM]Zz!$`z{!${{#O!$`#O#P!&S#P#Q!!]#Q~!$`+{!%OYOY!$`YZM]Zz!$`z{!${{!P!$`!P!Q!%n!Q#O!$`#O#P!&S#P#Q!!]#Q~!$`+{!%sTU+{OYG{Z#OG{#O#PH_#P#QFx#Q~G{+{!&VTOY!$`YZM]Zz!$`z{!${{~!$`+{!&iTOY!!]YZM]Zz!!]z{!#Q{~!!]+{!&}_}POzM]z{Mi{#ZM]#Z#[!&x#[#]M]#]#^!&x#^#aM]#a#b!&x#b#gM]#g#h!&x#h#iM]#i#j!&x#j#mM]#m#n!&x#n~M],T!(R[$UWOY!'|YZKoZz!'|z{!(w{!^!'|!^!_!$`!_#O!'|#O#P!*o#P#QJl#Q#o!'|#o#p!$`#p~!'|,T!(|^$UWOY!'|YZKoZz!'|z{!(w{!P!'|!P!Q!)x!Q!^!'|!^!_!$`!_#O!'|#O#P!*o#P#QJl#Q#o!'|#o#p!$`#p~!'|,T!*PY$UWU+{OYHqYZ%TZ!^Hq!^!_G{!_#OHq#O#PIf#P#QDu#Q#oHq#o#pG{#p~Hq,T!*tX$UWOY!'|YZKoZz!'|z{!(w{!^!'|!^!_!$`!_#o!'|#o#p!$`#p~!'|,T!+fX$UWOYJlYZKoZzJlz{NQ{!^Jl!^!_!!]!_#oJl#o#p!!]#p~Jl,T!,Yc$UW}POzKoz{LZ{!^Ko!^!_M]!_#ZKo#Z#[!,R#[#]Ko#]#^!,R#^#aKo#a#b!,R#b#gKo#g#h!,R#h#iKo#i#j!,R#j#mKo#m#n!,R#n#oKo#o#pM]#p~Ko,T!-lV$UWT+{OY!-eYZ%TZ!^!-e!^!_!.R!_#o!-e#o#p!.R#p~!-e+{!.WQT+{OY!.RZ~!.R$P!.g[$UW#o#v}POYDuYZ%TZ!PDu!P!QEr!Q!^Du!^!_Fx!_!}Du!}#OHq#O#PJQ#P#oDu#o#pFx#p~Du]!/f[#wS$UW}POYDuYZ%TZ!PDu!P!QEr!Q!^Du!^!_Fx!_!}Du!}#OHq#O#PJQ#P#oDu#o#pFx#p~Duy!0cd$UWkqO!O%T!O!P@r!P!Q%T!Q![!1q![!^%T!_!g%T!g!hAl!h#R%T#R#S!1q#S#U%T#U#V!3X#V#X%T#X#YAl#Y#b%T#b#c!2w#c#d!4m#d#l%T#l#m!5{#m#o%T#p~%Ty!1x_$UWkqO!O%T!O!P@r!P!Q%T!Q![!1q![!^%T!_!g%T!g!hAl!h#R%T#R#S!1q#S#X%T#X#YAl#Y#b%T#b#c!2w#c#o%T#p~%Ty!3OR$UWkqO!^%T!_#o%T#p~%Ty!3^W$UWO!Q%T!Q!R!3v!R!S!3v!S!^%T!_#R%T#R#S!3v#S#o%T#p~%Ty!3}Y$UWkqO!Q%T!Q!R!3v!R!S!3v!S!^%T!_#R%T#R#S!3v#S#b%T#b#c!2w#c#o%T#p~%Ty!4rV$UWO!Q%T!Q!Y!5X!Y!^%T!_#R%T#R#S!5X#S#o%T#p~%Ty!5`X$UWkqO!Q%T!Q!Y!5X!Y!^%T!_#R%T#R#S!5X#S#b%T#b#c!2w#c#o%T#p~%Ty!6QZ$UWO!Q%T!Q![!6s![!^%T!_!c%T!c!i!6s!i#R%T#R#S!6s#S#T%T#T#Z!6s#Z#o%T#p~%Ty!6z]$UWkqO!Q%T!Q![!6s![!^%T!_!c%T!c!i!6s!i#R%T#R#S!6s#S#T%T#T#Z!6s#Z#b%T#b#c!2w#c#o%T#p~%T%w!7|R!]V$UW#m%hO!^%T!_#o%T#p~%T!P!8^R_w$UWO!^%T!_#o%T#p~%T+c!8rR'`d!a%Y#x&s'zP!P!Q!8{!^!_!9Q!_!`!9_W!9QO$WW#v!9VP#`#v!_!`!9Y#v!9_O#o#v#v!9dO#a#v%w!9kT!{%o$UWO!^%T!_!`'v!`!a!9z!a#o%T#p~%T$P!:RR#W#w$UWO!^%T!_#o%T#p~%T%w!:gT'_!s#a#v$RS$UWO!^%T!_!`!:v!`!a!;W!a#o%T#p~%T$O!:}R#a#v$UWO!^%T!_#o%T#p~%T$O!;_T#`#v$UWO!^%T!_!`5T!`!a!;n!a#o%T#p~%T$O!;uS#`#v$UWO!^%T!_!`5T!`#o%T#p~%T%w!<YV'n%o$UWO!O%T!O!P!<o!P!^%T!_!a%T!a!b!=P!b#o%T#p~%T$`!<vRv$W$UWO!^%T!_#o%T#p~%T$O!=WS$UW#j#vO!^%T!_!`5T!`#o%T#p~%T&e!=kRx&]$UWO!^%T!_#o%T#p~%TZ!={R!OR$UWO!^%T!_#o%T#p~%T$O!>]S#g#v$UWO!^%T!_!`5T!`#o%T#p~%T$P!>pR$UW'd#wO!^%T!_#o%T#p~%T~!?OO!T~%r!?VT'u%j$UWO!^%T!_!`5T!`#o%T#p#q!=P#q~%T$u!?oR!S$knQ$UWO!^%T!_#o%T#p~%TX!@PR!kP$UWO!^%T!_#o%T#p~%T,T!@gr$UW'W+{#zS'Z%k'epOX%TXY%cYZ%TZ[%c[p%Tpq%cqt%Ttu2`u}%T}!O3j!O!Q%T!Q![2`![!^%T!_!c%T!c!}2`!}#R%T#R#S2`#S#T%T#T#o2`#p$f%T$f$g%c$g#BY2`#BY#BZ!@Y#BZ$IS2`$IS$I_!@Y$I_$JT2`$JT$JU!@Y$JU$KV2`$KV$KW!@Y$KW&FU2`&FU&FV!@Y&FV?HT2`?HT?HU!@Y?HU~2`,T!CO_$UW'X+{#zS'Z%k'epOt%Ttu2`u}%T}!O3j!O!Q%T!Q![2`![!^%T!_!c%T!c!}2`!}#R%T#R#S2`#S#T%T#T#o2`#p$g%T$g~2`",
  tokenizers: [Cz, Tz, Az, 0, 1, 2, 3, 4, 5, 6, 7, 8, _z],
  topRules: { Script: [0, 7] },
  dialects: { jsx: 11335, ts: 11337 },
  dynamicPrecedences: { 149: 1, 176: 1 },
  specialized: [{ term: 287, get: (a, e) => $z(a, e) << 1 }, { term: 287, get: (a) => Ez[a] || -1 }, { term: 297, get: (a) => Pz[a] || -1 }, { term: 63, get: (a) => Lz[a] || -1 }],
  tokenPrec: 11358
}), Dz = [
  /* @__PURE__ */ Xs("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Xs("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Xs("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Xs(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ Xs(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Xs('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ Xs('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], er = /* @__PURE__ */ Un.define({
  parser: /* @__PURE__ */ Mz.configure({
    props: [
      /* @__PURE__ */ Pl.add({
        IfStatement: /* @__PURE__ */ vo({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ vo({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: ON,
        SwitchBody: (a) => {
          let e = a.textAfter, t = /^\s*\}/.test(e), i = /^\s*(case|default)\b/.test(e);
          return a.baseIndent + (t ? 0 : i ? 1 : 2) * a.unit;
        },
        Block: /* @__PURE__ */ yN({ closing: "}" }),
        ArrowFunction: (a) => a.baseIndent + a.unit,
        "TemplateString BlockComment": () => -1,
        "Statement Property": /* @__PURE__ */ vo({ except: /^{/ }),
        JSXElement(a) {
          let e = /^\s*<\//.test(a.textAfter);
          return a.lineIndent(a.node.from) + (e ? 0 : a.unit);
        },
        JSXEscape(a) {
          let e = /\s*\}/.test(a.textAfter);
          return a.lineIndent(a.node.from) + (e ? 0 : a.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(a) {
          return a.column(a.node.from) + a.unit;
        }
      }),
      /* @__PURE__ */ Ll.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression": OO,
        BlockComment(a) {
          return { from: a.from + 2, to: a.to - 2 };
        }
      }),
      /* @__PURE__ */ xu({
        "get set async static": Y.modifier,
        "for while do if else switch try catch finally return throw break continue default case": Y.controlKeyword,
        "in of await yield void typeof delete instanceof": Y.operatorKeyword,
        "let var const function class extends": Y.definitionKeyword,
        "import export from": Y.moduleKeyword,
        "with debugger as new": Y.keyword,
        TemplateString: /* @__PURE__ */ Y.special(Y.string),
        Super: Y.atom,
        BooleanLiteral: Y.bool,
        this: Y.self,
        null: Y.null,
        Star: Y.modifier,
        VariableName: Y.variableName,
        "CallExpression/VariableName TaggedTemplateExpression/VariableName": /* @__PURE__ */ Y.function(Y.variableName),
        VariableDefinition: /* @__PURE__ */ Y.definition(Y.variableName),
        Label: Y.labelName,
        PropertyName: Y.propertyName,
        PrivatePropertyName: /* @__PURE__ */ Y.special(Y.propertyName),
        "CallExpression/MemberExpression/PropertyName": /* @__PURE__ */ Y.function(Y.propertyName),
        "FunctionDeclaration/VariableDefinition": /* @__PURE__ */ Y.function(/* @__PURE__ */ Y.definition(Y.variableName)),
        "ClassDeclaration/VariableDefinition": /* @__PURE__ */ Y.definition(Y.className),
        PropertyDefinition: /* @__PURE__ */ Y.definition(Y.propertyName),
        PrivatePropertyDefinition: /* @__PURE__ */ Y.definition(/* @__PURE__ */ Y.special(Y.propertyName)),
        UpdateOp: Y.updateOperator,
        LineComment: Y.lineComment,
        BlockComment: Y.blockComment,
        Number: Y.number,
        String: Y.string,
        ArithOp: Y.arithmeticOperator,
        LogicOp: Y.logicOperator,
        BitOp: Y.bitwiseOperator,
        CompareOp: Y.compareOperator,
        RegExp: Y.regexp,
        Equals: Y.definitionOperator,
        "Arrow : Spread": Y.punctuation,
        "( )": Y.paren,
        "[ ]": Y.squareBracket,
        "{ }": Y.brace,
        "InterpolationStart InterpolationEnd": /* @__PURE__ */ Y.special(Y.brace),
        ".": Y.derefOperator,
        ", ;": Y.separator,
        TypeName: Y.typeName,
        TypeDefinition: /* @__PURE__ */ Y.definition(Y.typeName),
        "type enum interface implements namespace module declare": Y.definitionKeyword,
        "abstract global Privacy readonly override": Y.modifier,
        "is keyof unique infer": Y.operatorKeyword,
        JSXAttributeValue: Y.attributeValue,
        JSXText: Y.content,
        "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": Y.angleBracket,
        "JSXIdentifier JSXNameSpacedName": Y.tagName,
        "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": Y.attributeName
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), Rz = /* @__PURE__ */ er.configure({ dialect: "ts" }), Iz = /* @__PURE__ */ er.configure({ dialect: "jsx" }), Qz = /* @__PURE__ */ er.configure({ dialect: "jsx ts" });
function Bx(a = {}) {
  let e = a.jsx ? a.typescript ? Qz : Iz : a.typescript ? Rz : er;
  return new iu(e, er.data.of({
    autocomplete: DW(["LineComment", "BlockComment", "String"], wx(Dz))
  }));
}
const Nz = 53, Fz = 1, Wz = 54, Bz = 2, zz = 55, Xz = 3, nl = 4, zx = 5, Xx = 6, Yx = 7, Vx = 8, Yz = 9, Vz = 10, Hz = 11, Hc = 56, Gz = 12, um = 57, jz = 18, Uz = 27, Zz = 30, qz = 33, Kz = 35, Jz = 0, eX = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, tX = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, fm = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function iX(a) {
  return a == 45 || a == 46 || a == 58 || a >= 65 && a <= 90 || a == 95 || a >= 97 && a <= 122 || a >= 161;
}
function Hx(a) {
  return a == 9 || a == 10 || a == 13 || a == 32;
}
let pm = null, gm = null, mm = 0;
function hd(a, e) {
  let t = a.pos + e;
  if (mm == t && gm == a)
    return pm;
  let i = a.peek(e);
  for (; Hx(i); )
    i = a.peek(++e);
  let s = "";
  for (; iX(i); )
    s += String.fromCharCode(i), i = a.peek(++e);
  return gm = a, mm = t, pm = s ? s.toLowerCase() : i == nX || i == rX ? void 0 : null;
}
const Gx = 60, sX = 62, jx = 47, nX = 63, rX = 33;
function bm(a, e) {
  this.name = a, this.parent = e, this.hash = e ? e.hash : 0;
  for (let t = 0; t < a.length; t++)
    this.hash += (this.hash << 4) + a.charCodeAt(t) + (a.charCodeAt(t) << 8);
}
const aX = [nl, Vx, zx, Xx, Yx], oX = new Fx({
  start: null,
  shift(a, e, t, i) {
    return aX.indexOf(e) > -1 ? new bm(hd(i, 1) || "", a) : a;
  },
  reduce(a, e) {
    return e == jz && a ? a.parent : a;
  },
  reuse(a, e, t, i) {
    let s = e.type.id;
    return s == nl || s == Kz ? new bm(hd(i, 1) || "", a) : a;
  },
  hash(a) {
    return a ? a.hash : 0;
  },
  strict: !1
}), lX = new ji((a, e) => {
  if (a.next != Gx) {
    a.next < 0 && e.context && a.acceptToken(Hc);
    return;
  }
  a.advance();
  let t = a.next == jx;
  t && a.advance();
  let i = hd(a, 0);
  if (i === void 0)
    return;
  if (!i)
    return a.acceptToken(t ? Gz : nl);
  let s = e.context ? e.context.name : null;
  if (t) {
    if (i == s)
      return a.acceptToken(Yz);
    if (s && tX[s])
      return a.acceptToken(Hc, -2);
    if (e.dialectEnabled(Jz))
      return a.acceptToken(Vz);
    for (let n = e.context; n; n = n.parent)
      if (n.name == i)
        return;
    a.acceptToken(Hz);
  } else {
    if (i == "script")
      return a.acceptToken(zx);
    if (i == "style")
      return a.acceptToken(Xx);
    if (i == "textarea")
      return a.acceptToken(Yx);
    if (eX.hasOwnProperty(i))
      return a.acceptToken(Vx);
    s && fm[s] && fm[s][i] ? a.acceptToken(Hc, -1) : a.acceptToken(nl);
  }
}, { contextual: !0 }), cX = new ji((a) => {
  for (let e = 0, t = 0; ; t++) {
    if (a.next < 0) {
      t && a.acceptToken(um);
      break;
    }
    if (a.next == "-->".charCodeAt(e)) {
      if (e++, e == 3) {
        t > 3 && a.acceptToken(um, -2);
        break;
      }
    } else
      e = 0;
    a.advance();
  }
});
function Su(a, e, t) {
  let i = 2 + a.length;
  return new ji((s) => {
    for (let n = 0, o = 0, l = 0; ; l++) {
      if (s.next < 0) {
        l && s.acceptToken(e);
        break;
      }
      if (n == 0 && s.next == Gx || n == 1 && s.next == jx || n >= 2 && n < i && s.next == a.charCodeAt(n - 2))
        n++, o++;
      else if ((n == 2 || n == i) && Hx(s.next))
        o++;
      else if (n == i && s.next == sX) {
        l > o ? s.acceptToken(e, -o) : s.acceptToken(t, -(o - 2));
        break;
      } else if ((s.next == 10 || s.next == 13) && l) {
        s.acceptToken(e, 1);
        break;
      } else
        n = o = 0;
      s.advance();
    }
  });
}
const hX = Su("script", Nz, Fz), dX = Su("style", Wz, Bz), uX = Su("textarea", zz, Xz), fX = Jn.deserialize({
  version: 13,
  states: ",xOVOxOOO!WQ!bO'#CoO!]Q!bO'#CyO!bQ!bO'#C|O!gQ!bO'#DPO!lQ!bO'#DRO!qOXO'#CnO!|OYO'#CnO#XO[O'#CnO$eOxO'#CnOOOW'#Cn'#CnO$lO!rO'#DSO$tQ!bO'#DUO$yQ!bO'#DVOOOW'#Dj'#DjOOOW'#DX'#DXQVOxOOO%OQ#tO,59ZO%WQ#tO,59eO%`Q#tO,59hO%hQ#tO,59kO%pQ#tO,59mOOOX'#D]'#D]O%xOXO'#CwO&TOXO,59YOOOY'#D^'#D^O&]OYO'#CzO&hOYO,59YOOO['#D_'#D_O&pO[O'#C}O&{O[O,59YOOOW'#D`'#D`O'TOxO,59YO'[Q!bO'#DQOOOW,59Y,59YOOO`'#Da'#DaO'aO!rO,59nOOOW,59n,59nO'iQ!bO,59pO'nQ!bO,59qOOOW-E7V-E7VO'sQ#tO'#CqOOQO'#DY'#DYO(OQ#tO1G.uOOOX1G.u1G.uO(WQ#tO1G/POOOY1G/P1G/PO(`Q#tO1G/SOOO[1G/S1G/SO(hQ#tO1G/VOOOW1G/V1G/VO(pQ#tO1G/XOOOW1G/X1G/XOOOX-E7Z-E7ZO(xQ!bO'#CxOOOW1G.t1G.tOOOY-E7[-E7[O(}Q!bO'#C{OOO[-E7]-E7]O)SQ!bO'#DOOOOW-E7^-E7^O)XQ!bO,59lOOO`-E7_-E7_OOOW1G/Y1G/YOOOW1G/[1G/[OOOW1G/]1G/]O)^Q&jO,59]OOQO-E7W-E7WOOOX7+$a7+$aOOOY7+$k7+$kOOO[7+$n7+$nOOOW7+$q7+$qOOOW7+$s7+$sO)iQ!bO,59dO)nQ!bO,59gO)sQ!bO,59jOOOW1G/W1G/WO)xO,UO'#CtO*WO7[O'#CtOOQO1G.w1G.wOOOW1G/O1G/OOOOW1G/R1G/ROOOW1G/U1G/UOOOO'#DZ'#DZO*fO,UO,59`OOQO,59`,59`OOOO'#D['#D[O*tO7[O,59`OOOO-E7X-E7XOOQO1G.z1G.zOOOO-E7Y-E7Y",
  stateData: "+[~O!]OS~OSSOTPOUQOVROWTOY]OZ[O[^O^^O_^O`^Oa^Ow^Oz_O!cZO~OdaO~OdbO~OdcO~OddO~OdeO~O!VfOPkP!YkP~O!WiOQnP!YnP~O!XlORqP!YqP~OSSOTPOUQOVROWTOXqOY]OZ[O[^O^^O_^O`^Oa^Ow^O!cZO~O!YrO~P#dO!ZsO!duO~OdvO~OdwO~OfyOj|O~OfyOj!OO~OfyOj!QO~OfyOj!SO~OfyOj!UO~O!VfOPkX!YkX~OP!WO!Y!XO~O!WiOQnX!YnX~OQ!ZO!Y!XO~O!XlORqX!YqX~OR!]O!Y!XO~O!Y!XO~P#dOd!_O~O!ZsO!d!aO~Oj!bO~Oj!cO~Og!dOfeXjeX~OfyOj!fO~OfyOj!gO~OfyOj!hO~OfyOj!iO~OfyOj!jO~Od!kO~Od!lO~Od!mO~Oj!nO~Oi!qO!_!oO!a!pO~Oj!rO~Oj!sO~Oj!tO~O_!uO`!uO!_!wO!`!uO~O_!xO`!xO!a!wO!b!xO~O_!uO`!uO!_!{O!`!uO~O_!xO`!xO!a!{O!b!xO~O`_a!cwz!c~",
  goto: "%o!_PPPPPPPPPPPPPPPPPP!`!fP!lPP!xPP!{#O#R#X#[#_#e#h#k#q#w!`P!`!`P#}$T$k$q$w$}%T%Z%aPPPPPPPP%gX^OX`pXUOX`pezabcde{}!P!R!TR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!TeZ!e{}!P!R!TQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "⚠ StartCloseTag StartCloseTag StartCloseTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue EndTag ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 66,
  context: oX,
  nodeProps: [
    [Ce.closedBy, -11, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, "EndTag", -4, 19, 29, 32, 35, "CloseTag"],
    [Ce.group, -9, 12, 15, 16, 17, 18, 38, 39, 40, 41, "Entity", 14, "Entity TextContent", -3, 27, 30, 33, "TextContent Entity"],
    [Ce.openedBy, 26, "StartTag StartCloseTag", -4, 28, 31, 34, 36, "OpenTag"]
  ],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!#b!aR!WOX$kXY)sYZ)sZ]$k]^)s^p$kpq)sqr$krs*zsv$kvw+dwx2yx}$k}!O3f!O!P$k!P!Q7_!Q![$k![!]8u!]!^$k!^!_>b!_!`!!p!`!a8T!a!c$k!c!}8u!}#R$k#R#S8u#S#T$k#T#o8u#o$f$k$f$g&R$g%W$k%W%o8u%o%p$k%p&a8u&a&b$k&b1p8u1p4U$k4U4d8u4d4e$k4e$IS8u$IS$I`$k$I`$Ib8u$Ib$Kh$k$Kh%#t8u%#t&/x$k&/x&Et8u&Et&FV$k&FV;'S8u;'S;:j<t;:j?&r$k?&r?Ah8u?Ah?BY$k?BY?Mn8u?Mn~$k!Z$vc^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g~$k!R&[V^P!``!bpOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&Rq&xT^P!bpOv&qwx'Xx!^&q!^!_'g!_~&qP'^R^POv'Xw!^'X!_~'Xp'lQ!bpOv'gx~'ga'yU^P!``Or'rrs'Xsv'rw!^'r!^!_(]!_~'r`(bR!``Or(]sv(]w~(]!Q(rT!``!bpOr(krs'gsv(kwx(]x~(kW)WXiWOX)RZ])R^p)Rqr)Rsw)Rx!P)R!Q!^)R!a$f)R$g~)R!a*O^^P!``!bp!]^OX&RXY)sYZ)sZ]&R]^)s^p&Rpq)sqr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!Z+TT!_h^P!bpOv&qwx'Xx!^&q!^!_'g!_~&q!Z+kbiWaPOX,sXZ.QZ],s]^.Q^p,sqr,srs.Qst/]tw,swx.Qx!P,s!P!Q.Q!Q!],s!]!^)R!^!a.Q!a$f,s$f$g.Q$g~,s!Z,xbiWOX,sXZ.QZ],s]^.Q^p,sqr,srs.Qst)Rtw,swx.Qx!P,s!P!Q.Q!Q!],s!]!^.i!^!a.Q!a$f,s$f$g.Q$g~,s!R.TTOp.Qqs.Qt!].Q!]!^.d!^~.Q!R.iO_!R!Z.pXiW_!ROX)RZ])R^p)Rqr)Rsw)Rx!P)R!Q!^)R!a$f)R$g~)R!Z/baiWOX0gXZ1qZ]0g]^1q^p0gqr0grs1qsw0gwx1qx!P0g!P!Q1q!Q!]0g!]!^)R!^!a1q!a$f0g$f$g1q$g~0g!Z0laiWOX0gXZ1qZ]0g]^1q^p0gqr0grs1qsw0gwx1qx!P0g!P!Q1q!Q!]0g!]!^2V!^!a1q!a$f0g$f$g1q$g~0g!R1tSOp1qq!]1q!]!^2Q!^~1q!R2VO`!R!Z2^XiW`!ROX)RZ])R^p)Rqr)Rsw)Rx!P)R!Q!^)R!a$f)R$g~)R!Z3SU!ax^P!``Or'rrs'Xsv'rw!^'r!^!_(]!_~'r!]3qe^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx}$k}!O5S!O!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g~$k!]5_d^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!`&R!`!a6m!a$f$k$f$g&R$g~$k!T6xV^P!``!bp!dQOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!X7hX^P!``!bpOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_!`&R!`!a8T!a~&R!X8`VjU^P!``!bpOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!a9U!YfSdQ^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx}$k}!O8u!O!P8u!P!Q&R!Q![8u![!]8u!]!^$k!^!_(k!_!a&R!a!c$k!c!}8u!}#R$k#R#S8u#S#T$k#T#o8u#o$f$k$f$g&R$g$}$k$}%O8u%O%W$k%W%o8u%o%p$k%p&a8u&a&b$k&b1p8u1p4U8u4U4d8u4d4e$k4e$IS8u$IS$I`$k$I`$Ib8u$Ib$Je$k$Je$Jg8u$Jg$Kh$k$Kh%#t8u%#t&/x$k&/x&Et8u&Et&FV$k&FV;'S8u;'S;:j<t;:j?&r$k?&r?Ah8u?Ah?BY$k?BY?Mn8u?Mn~$k!a=Pe^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g;=`$k;=`<%l8u<%l~$k!R>iW!``!bpOq(kqr?Rrs'gsv(kwx(]x!a(k!a!bKj!b~(k!R?YZ!``!bpOr(krs'gsv(kwx(]x}(k}!O?{!O!f(k!f!gAR!g#W(k#W#XGz#X~(k!R@SV!``!bpOr(krs'gsv(kwx(]x}(k}!O@i!O~(k!R@rT!``!bp!cPOr(krs'gsv(kwx(]x~(k!RAYV!``!bpOr(krs'gsv(kwx(]x!q(k!q!rAo!r~(k!RAvV!``!bpOr(krs'gsv(kwx(]x!e(k!e!fB]!f~(k!RBdV!``!bpOr(krs'gsv(kwx(]x!v(k!v!wBy!w~(k!RCQV!``!bpOr(krs'gsv(kwx(]x!{(k!{!|Cg!|~(k!RCnV!``!bpOr(krs'gsv(kwx(]x!r(k!r!sDT!s~(k!RD[V!``!bpOr(krs'gsv(kwx(]x!g(k!g!hDq!h~(k!RDxW!``!bpOrDqrsEbsvDqvwEvwxFfx!`Dq!`!aGb!a~DqqEgT!bpOvEbvxEvx!`Eb!`!aFX!a~EbPEyRO!`Ev!`!aFS!a~EvPFXOzPqF`Q!bpzPOv'gx~'gaFkV!``OrFfrsEvsvFfvwEvw!`Ff!`!aGQ!a~FfaGXR!``zPOr(]sv(]w~(]!RGkT!``!bpzPOr(krs'gsv(kwx(]x~(k!RHRV!``!bpOr(krs'gsv(kwx(]x#c(k#c#dHh#d~(k!RHoV!``!bpOr(krs'gsv(kwx(]x#V(k#V#WIU#W~(k!RI]V!``!bpOr(krs'gsv(kwx(]x#h(k#h#iIr#i~(k!RIyV!``!bpOr(krs'gsv(kwx(]x#m(k#m#nJ`#n~(k!RJgV!``!bpOr(krs'gsv(kwx(]x#d(k#d#eJ|#e~(k!RKTV!``!bpOr(krs'gsv(kwx(]x#X(k#X#YDq#Y~(k!RKqW!``!bpOrKjrsLZsvKjvwLowxNPx!aKj!a!b! g!b~KjqL`T!bpOvLZvxLox!aLZ!a!bM^!b~LZPLrRO!aLo!a!bL{!b~LoPMORO!`Lo!`!aMX!a~LoPM^OwPqMcT!bpOvLZvxLox!`LZ!`!aMr!a~LZqMyQ!bpwPOv'gx~'gaNUV!``OrNPrsLosvNPvwLow!aNP!a!bNk!b~NPaNpV!``OrNPrsLosvNPvwLow!`NP!`!a! V!a~NPa! ^R!``wPOr(]sv(]w~(]!R! nW!``!bpOrKjrsLZsvKjvwLowxNPx!`Kj!`!a!!W!a~Kj!R!!aT!``!bpwPOr(krs'gsv(kwx(]x~(k!V!!{VgS^P!``!bpOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R",
  tokenizers: [hX, dX, uX, lX, cX, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 13] },
  dialects: { noMatch: 0 },
  tokenPrec: 464
});
function pX(a, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let i of a.firstChild.getChildren("Attribute")) {
    let s = i.getChild("AttributeName"), n = i.getChild("AttributeValue") || i.getChild("UnquotedAttributeValue");
    s && (t[e.read(s.from, s.to)] = n ? n.name == "AttributeValue" ? e.read(n.from + 1, n.to - 1) : e.read(n.from, n.to) : "");
  }
  return t;
}
function Gc(a, e, t) {
  let i;
  for (let s of t)
    if (!s.attrs || s.attrs(i || (i = pX(a.node.parent, e))))
      return { parser: s.parser };
  return null;
}
function gX(a) {
  let e = [], t = [], i = [];
  for (let s of a) {
    let n = s.tag == "script" ? e : s.tag == "style" ? t : s.tag == "textarea" ? i : null;
    if (!n)
      throw new RangeError("Only script, style, and textarea tags can host nested parsers");
    n.push(s);
  }
  return tN((s, n) => {
    let o = s.type.id;
    return o == Uz ? Gc(s, n, e) : o == Zz ? Gc(s, n, t) : o == qz ? Gc(s, n, i) : null;
  });
}
const mX = 93, vm = 1, bX = 94, vX = 95, ym = 2, Ux = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], yX = 58, OX = 40, Zx = 95, xX = 91, wo = 45, wX = 46, SX = 35, kX = 37;
function rl(a) {
  return a >= 65 && a <= 90 || a >= 97 && a <= 122 || a >= 161;
}
function _X(a) {
  return a >= 48 && a <= 57;
}
const CX = new ji((a, e) => {
  for (let t = !1, i = 0, s = 0; ; s++) {
    let { next: n } = a;
    if (rl(n) || n == wo || n == Zx || t && _X(n))
      !t && (n != wo || s > 0) && (t = !0), i === s && n == wo && i++, a.advance();
    else {
      t && a.acceptToken(n == OX ? bX : i == 2 && e.canShift(ym) ? ym : vX);
      break;
    }
  }
}), TX = new ji((a) => {
  if (Ux.includes(a.peek(-1))) {
    let { next: e } = a;
    (rl(e) || e == Zx || e == SX || e == wX || e == xX || e == yX || e == wo) && a.acceptToken(mX);
  }
}), AX = new ji((a) => {
  if (!Ux.includes(a.peek(-1))) {
    let { next: e } = a;
    if (e == kX && (a.advance(), a.acceptToken(vm)), rl(e)) {
      do
        a.advance();
      while (rl(a.next));
      a.acceptToken(vm);
    }
  }
}), $X = { __proto__: null, lang: 32, "nth-child": 32, "nth-last-child": 32, "nth-of-type": 32, dir: 32, url: 60, "url-prefix": 60, domain: 60, regexp: 60, selector: 134 }, EX = { __proto__: null, "@import": 114, "@media": 138, "@charset": 142, "@namespace": 146, "@keyframes": 152, "@supports": 164 }, PX = { __proto__: null, not: 128, only: 128, from: 158, to: 160 }, LX = Jn.deserialize({
  version: 13,
  states: "7WOYQ[OOOOQP'#Cd'#CdOOQP'#Cc'#CcO!ZQ[O'#CfO!}QXO'#CaO#UQ[O'#ChO#aQ[O'#DPO#fQ[O'#DTOOQP'#Ec'#EcO#kQdO'#DeO$VQ[O'#DrO#kQdO'#DtO$hQ[O'#DvO$sQ[O'#DyO$xQ[O'#EPO%WQ[O'#EROOQS'#Eb'#EbOOQS'#ES'#ESQYQ[OOOOQP'#Cg'#CgOOQP,59Q,59QO!ZQ[O,59QO%_Q[O'#EVO%yQWO,58{O&RQ[O,59SO#aQ[O,59kO#fQ[O,59oO%_Q[O,59sO%_Q[O,59uO%_Q[O,59vO'bQ[O'#D`OOQS,58{,58{OOQP'#Ck'#CkOOQO'#C}'#C}OOQP,59S,59SO'iQWO,59SO'nQWO,59SOOQP'#DR'#DROOQP,59k,59kOOQO'#DV'#DVO'sQ`O,59oOOQS'#Cp'#CpO#kQdO'#CqO'{QvO'#CsO)VQtO,5:POOQO'#Cx'#CxO'iQWO'#CwO)kQWO'#CyOOQS'#Ef'#EfOOQO'#Dh'#DhO)pQ[O'#DoO*OQWO'#EiO$xQ[O'#DmO*^QWO'#DpOOQO'#Ej'#EjO%|QWO,5:^O*cQpO,5:`OOQS'#Dx'#DxO*kQWO,5:bO*pQ[O,5:bOOQO'#D{'#D{O*xQWO,5:eO*}QWO,5:kO+VQWO,5:mOOQS-E8Q-E8QOOQP1G.l1G.lO+yQXO,5:qOOQO-E8T-E8TOOQS1G.g1G.gOOQP1G.n1G.nO'iQWO1G.nO'nQWO1G.nOOQP1G/V1G/VO,WQ`O1G/ZO,qQXO1G/_O-XQXO1G/aO-oQXO1G/bO.VQXO'#CdO.zQWO'#DaOOQS,59z,59zO/PQWO,59zO/XQ[O,59zO/`QdO'#CoO/gQ[O'#DOOOQP1G/Z1G/ZO#kQdO1G/ZO/nQpO,59]OOQS,59_,59_O#kQdO,59aO/vQWO1G/kOOQS,59c,59cO/{Q!bO,59eO0TQWO'#DhO0`QWO,5:TO0eQWO,5:ZO$xQ[O,5:VO$xQ[O'#EYO0mQWO,5;TO0xQWO,5:XO%_Q[O,5:[OOQS1G/x1G/xOOQS1G/z1G/zOOQS1G/|1G/|O1ZQWO1G/|O1`QdO'#D|OOQS1G0P1G0POOQS1G0V1G0VOOQS1G0X1G0XOOQP7+$Y7+$YOOQP7+$u7+$uO#kQdO7+$uO#kQdO,59{O1nQ[O'#EXO1xQWO1G/fOOQS1G/f1G/fO1xQWO1G/fO2QQtO'#ETO2uQdO'#EeO3PQWO,59ZO3UQXO'#EhO3]QWO,59jO3bQpO7+$uOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%V7+%VO3jQWO1G/PO#kQdO1G/oOOQO1G/u1G/uOOQO1G/q1G/qO3oQWO,5:tOOQO-E8W-E8WO3}QXO1G/vOOQS7+%h7+%hO4UQYO'#CsO%|QWO'#EZO4^QdO,5:hOOQS,5:h,5:hO4lQpO<<HaO4tQtO1G/gOOQO,5:s,5:sO5XQ[O,5:sOOQO-E8V-E8VOOQS7+%Q7+%QO5cQWO7+%QOOQS-E8R-E8RO#kQdO'#EUO5kQWO,5;POOQT1G.u1G.uO5sQWO,5;SOOQP1G/U1G/UOOQP<<Ha<<HaOOQS7+$k7+$kO5{QdO7+%ZOOQO7+%b7+%bOOQS,5:u,5:uOOQS-E8X-E8XOOQS1G0S1G0SOOQPAN={AN={O6SQtO'#EWO#kQdO'#EWO6}QdO7+%ROOQO7+%R7+%ROOQO1G0_1G0_OOQS<<Hl<<HlO7_QdO,5:pOOQO-E8S-E8SOOQO<<Hu<<HuO7iQtO,5:rOOQS-E8U-E8UOOQO<<Hm<<Hm",
  stateData: "8j~O#TOSROS~OUWOXWO]TO^TOtUOxVO!Y_O!ZXO!gYO!iZO!k[O!n]O!t^O#RPO#WRO~O#RcO~O]hO^hOpfOtiOxjO|kO!PmO#PlO#WeO~O!RnO~P!`O`sO#QqO#RpO~O#RuO~O#RwO~OQ!QObzOf!QOh!QOn!PO#Q}O#RyO#Z{O~Ob!SO!b!UO!e!VO#R!RO!R#]P~Oh![On!PO#R!ZO~O#R!^O~Ob!SO!b!UO!e!VO#R!RO~O!W#]P~P$VOUWOXWO]TO^TOtUOxVO#RPO#WRO~OpfO!RnO~O`!hO#QqO#RpO~OQ!pOUWOXWO]TO^TOtUOxVO!Y_O!ZXO!gYO!iZO!k[O!n]O!t^O#R!oO#WRO~O!Q!qO~P&^Ob!tO~Ob!uO~Ov!vOz!wO~OP!yObgXjgX!WgX!bgX!egX#RgXagXQgXfgXhgXngXpgX#QgX#ZgXvgX!QgX!VgX~Ob!SOj!zO!b!UO!e!VO#R!RO!W#]P~Ob!}O~Ob!SO!b!UO!e!VO#R#OO~Op#SO!`#RO!R#]X!W#]X~Ob#VO~Oj!zO!W#XO~O!W#YO~Oh#ZOn!PO~O!R#[O~O!RnO!`#RO~O!RnO!W#_O~O]hO^hOtiOxjO|kO!PmO#PlO#WeO~Op!ya!R!yaa!ya~P+_Ov#aOz#bO~O]hO^hOtiOxjO#WeO~Op{i|{i!P{i!R{i#P{ia{i~P,`Op}i|}i!P}i!R}i#P}ia}i~P,`Op!Oi|!Oi!P!Oi!R!Oi#P!Oia!Oi~P,`O]WX]!UX^WXpWXtWXxWX|WX!PWX!RWX#PWX#WWX~O]#cO~O!Q#fO!W#dO~O!Q#fO~P&^Oa#XP~P#kOa#[P~P%_Oa#nOj!zO~O!W#pO~Oh#qOo#qO~O]!^Xa![X!`![X~O]#rO~Oa#sO!`#RO~Op#SO!R#]a!W#]a~O!`#ROp!aa!R!aa!W!aaa!aa~O!W#xO~O!Q#|O!q#zO!r#zO#Z#yO~O!Q!{X!W!{X~P&^O!Q$SO!W#dO~Oj!zOQ!wXa!wXb!wXf!wXh!wXn!wXp!wX#Q!wX#R!wX#Z!wX~Op$VOa#XX~P#kOa$XO~Oa#[X~P!`Oa$ZO~Oj!zOv$[O~Oa$]O~O!`#ROp!|a!R!|a!W!|a~Oa$_O~P+_OP!yO!RgX~O!Q$bO!q#zO!r#zO#Z#yO~Oj!zOv$cO~Oj!zOp$eO!V$gO!Q!Ti!W!Ti~P#kO!Q!{a!W!{a~P&^O!Q$iO!W#dO~Op$VOa#Xa~OpfOa#[a~Oa$lO~P#kOj!zOQ!zXb!zXf!zXh!zXn!zXp!zX!Q!zX!V!zX!W!zX#Q!zX#R!zX#Z!zX~Op$eO!V$oO!Q!Tq!W!Tq~P#kOa!xap!xa~P#kOj!zOQ!zab!zaf!zah!zan!zap!za!Q!za!V!za!W!za#Q!za#R!za#Z!za~Oo#Zj!Pj~",
  goto: ",O#_PPPPP#`P#h#vP#h$U#hPP$[PPP$b$k$kP$}P$kP$k%e%wPPP&a&g#hP&mP#hP&sP#hP#h#hPPP&y']'iPP#`PP'o'o'y'oP'oP'o'oP#`P#`P#`P'|#`P(P(SPP#`P#`(V(e(s(y)T)Z)e)kPPPPPP)q)yP*e*hP+^+a+j]`Obn!s#d$QiWObfklmn!s!u#V#d$QiQObfklmn!s!u#V#d$QQdRR!ceQrTR!ghQ!gsQ!|!OR#`!hq!QXZz!t!w!z#b#c#i#r$O$V$^$e$f$jp!QXZz!t!w!z#b#c#i#r$O$V$^$e$f$jT#z#[#{q!OXZz!t!w!z#b#c#i#r$O$V$^$e$f$jp!QXZz!t!w!z#b#c#i#r$O$V$^$e$f$jQ![[R#Z!]QtTR!ihQ!gtR#`!iQvUR!jiQxVR!kjQoSQ!fgQ#W!XQ#^!`Q#_!aR$`#zQ!rnQ#g!sQ$P#dR$h$QX!pn!s#d$Qa!WY^_|!S!U#R#SR#P!SR!][R!_]R#]!_QbOU!bb!s$QQ!snR$Q#dQ#i!tU$U#i$^$jQ$^#rR$j$VQ$W#iR$k$WQgSS!eg$YR$Y#kQ$f$OR$n$fQ#e!rS$R#e$TR$T#gQ#T!TR#v#TQ#{#[R$a#{]aObn!s#d$Q[SObn!s#d$QQ!dfQ!lkQ!mlQ!nmQ#k!uR#w#VR#j!tQ|XQ!YZQ!xz[#h!t#i#r$V$^$jQ#m!wQ#o!zQ#}#bQ$O#cS$d$O$fR$m$eR#l!uQ!XYQ!a_R!{|U!TY_|Q!`^Q#Q!SQ#U!UQ#t#RR#u#S",
  nodeNames: "⚠ Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent , PseudoClassName ArgList IdSelector # IdName ] AttributeSelector [ AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList from to SupportsStatement supports AtRule",
  maxTerm: 106,
  nodeProps: [
    [Ce.openedBy, 17, "(", 48, "{"],
    [Ce.closedBy, 18, ")", 49, "}"]
  ],
  skippedNodes: [0, 3],
  repeatNodeCount: 8,
  tokenData: "Ay~R![OX$wX^%]^p$wpq%]qr(crs+}st,otu2Uuv$wvw2rwx2}xy3jyz3uz{3z{|4_|}8U}!O8a!O!P8x!P!Q9Z!Q![;e![!]<Y!]!^<x!^!_$w!_!`=T!`!a=`!a!b$w!b!c>O!c!}$w!}#O?[#O#P$w#P#Q?g#Q#R2U#R#T$w#T#U?r#U#c$w#c#d@q#d#o$w#o#pAQ#p#q2U#q#rA]#r#sAh#s#y$w#y#z%]#z$f$w$f$g%]$g#BY$w#BY#BZ%]#BZ$IS$w$IS$I_%]$I_$I|$w$I|$JO%]$JO$JT$w$JT$JU%]$JU$KV$w$KV$KW%]$KW&FU$w&FU&FV%]&FV~$wW$zQOy%Qz~%QW%VQoWOy%Qz~%Q~%bf#T~OX%QX^&v^p%Qpq&vqy%Qz#y%Q#y#z&v#z$f%Q$f$g&v$g#BY%Q#BY#BZ&v#BZ$IS%Q$IS$I_&v$I_$I|%Q$I|$JO&v$JO$JT%Q$JT$JU&v$JU$KV%Q$KV$KW&v$KW&FU%Q&FU&FV&v&FV~%Q~&}f#T~oWOX%QX^&v^p%Qpq&vqy%Qz#y%Q#y#z&v#z$f%Q$f$g&v$g#BY%Q#BY#BZ&v#BZ$IS%Q$IS$I_&v$I_$I|%Q$I|$JO&v$JO$JT%Q$JT$JU&v$JU$KV%Q$KV$KW&v$KW&FU%Q&FU&FV&v&FV~%Q^(fSOy%Qz#]%Q#]#^(r#^~%Q^(wSoWOy%Qz#a%Q#a#b)T#b~%Q^)YSoWOy%Qz#d%Q#d#e)f#e~%Q^)kSoWOy%Qz#c%Q#c#d)w#d~%Q^)|SoWOy%Qz#f%Q#f#g*Y#g~%Q^*_SoWOy%Qz#h%Q#h#i*k#i~%Q^*pSoWOy%Qz#T%Q#T#U*|#U~%Q^+RSoWOy%Qz#b%Q#b#c+_#c~%Q^+dSoWOy%Qz#h%Q#h#i+p#i~%Q^+wQ!VUoWOy%Qz~%Q~,QUOY+}Zr+}rs,ds#O+}#O#P,i#P~+}~,iOh~~,lPO~+}_,tWtPOy%Qz!Q%Q!Q![-^![!c%Q!c!i-^!i#T%Q#T#Z-^#Z~%Q^-cWoWOy%Qz!Q%Q!Q![-{![!c%Q!c!i-{!i#T%Q#T#Z-{#Z~%Q^.QWoWOy%Qz!Q%Q!Q![.j![!c%Q!c!i.j!i#T%Q#T#Z.j#Z~%Q^.qWfUoWOy%Qz!Q%Q!Q![/Z![!c%Q!c!i/Z!i#T%Q#T#Z/Z#Z~%Q^/bWfUoWOy%Qz!Q%Q!Q![/z![!c%Q!c!i/z!i#T%Q#T#Z/z#Z~%Q^0PWoWOy%Qz!Q%Q!Q![0i![!c%Q!c!i0i!i#T%Q#T#Z0i#Z~%Q^0pWfUoWOy%Qz!Q%Q!Q![1Y![!c%Q!c!i1Y!i#T%Q#T#Z1Y#Z~%Q^1_WoWOy%Qz!Q%Q!Q![1w![!c%Q!c!i1w!i#T%Q#T#Z1w#Z~%Q^2OQfUoWOy%Qz~%QY2XSOy%Qz!_%Q!_!`2e!`~%QY2lQzQoWOy%Qz~%QX2wQXPOy%Qz~%Q~3QUOY2}Zw2}wx,dx#O2}#O#P3d#P~2}~3gPO~2}_3oQbVOy%Qz~%Q~3zOa~_4RSUPjSOy%Qz!_%Q!_!`2e!`~%Q_4fUjS!PPOy%Qz!O%Q!O!P4x!P!Q%Q!Q![7_![~%Q^4}SoWOy%Qz!Q%Q!Q![5Z![~%Q^5bWoW#ZUOy%Qz!Q%Q!Q![5Z![!g%Q!g!h5z!h#X%Q#X#Y5z#Y~%Q^6PWoWOy%Qz{%Q{|6i|}%Q}!O6i!O!Q%Q!Q![6z![~%Q^6nSoWOy%Qz!Q%Q!Q![6z![~%Q^7RSoW#ZUOy%Qz!Q%Q!Q![6z![~%Q^7fYoW#ZUOy%Qz!O%Q!O!P5Z!P!Q%Q!Q![7_![!g%Q!g!h5z!h#X%Q#X#Y5z#Y~%Q_8ZQpVOy%Qz~%Q^8fUjSOy%Qz!O%Q!O!P4x!P!Q%Q!Q![7_![~%Q_8}S#WPOy%Qz!Q%Q!Q![5Z![~%Q~9`RjSOy%Qz{9i{~%Q~9nSoWOy9iyz9zz{:o{~9i~9}ROz9zz{:W{~9z~:ZTOz9zz{:W{!P9z!P!Q:j!Q~9z~:oOR~~:tUoWOy9iyz9zz{:o{!P9i!P!Q;W!Q~9i~;_QR~oWOy%Qz~%Q^;jY#ZUOy%Qz!O%Q!O!P5Z!P!Q%Q!Q![7_![!g%Q!g!h5z!h#X%Q#X#Y5z#Y~%QX<_S]POy%Qz![%Q![!]<k!]~%QX<rQ^PoWOy%Qz~%Q_<}Q!WVOy%Qz~%QY=YQzQOy%Qz~%QX=eS|POy%Qz!`%Q!`!a=q!a~%QX=xQ|PoWOy%Qz~%QX>RUOy%Qz!c%Q!c!}>e!}#T%Q#T#o>e#o~%QX>lY!YPoWOy%Qz}%Q}!O>e!O!Q%Q!Q![>e![!c%Q!c!}>e!}#T%Q#T#o>e#o~%QX?aQxPOy%Qz~%Q^?lQvUOy%Qz~%QX?uSOy%Qz#b%Q#b#c@R#c~%QX@WSoWOy%Qz#W%Q#W#X@d#X~%QX@kQ!`PoWOy%Qz~%QX@tSOy%Qz#f%Q#f#g@d#g~%QXAVQ!RPOy%Qz~%Q_AbQ!QVOy%Qz~%QZAmS!PPOy%Qz!_%Q!_!`2e!`~%Q",
  tokenizers: [TX, AX, CX, 0, 1, 2, 3],
  topRules: { StyleSheet: [0, 4] },
  specialized: [{ term: 94, get: (a) => $X[a] || -1 }, { term: 56, get: (a) => EX[a] || -1 }, { term: 95, get: (a) => PX[a] || -1 }],
  tokenPrec: 1078
});
let jc = null;
function Uc() {
  if (!jc && typeof document == "object" && document.body) {
    let a = [];
    for (let e in document.body.style)
      /[A-Z]|^-|^(item|length)$/.test(e) || a.push(e);
    jc = a.sort().map((e) => ({ type: "property", label: e }));
  }
  return jc || [];
}
const Om = /* @__PURE__ */ [
  "active",
  "after",
  "before",
  "checked",
  "default",
  "disabled",
  "empty",
  "enabled",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "lang",
  "last-child",
  "last-of-type",
  "link",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-of-type",
  "only-child",
  "optional",
  "out-of-range",
  "placeholder",
  "read-only",
  "read-write",
  "required",
  "root",
  "selection",
  "target",
  "valid",
  "visited"
].map((a) => ({ type: "class", label: a })), xm = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((a) => ({ type: "keyword", label: a })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((a) => ({ type: "constant", label: a }))), MX = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((a) => ({ type: "type", label: a })), bs = /^[\w-]*/, DX = (a) => {
  let { state: e, pos: t } = a, i = pt(e).resolveInner(t, -1);
  if (i.name == "PropertyName")
    return { from: i.from, options: Uc(), span: bs };
  if (i.name == "ValueName")
    return { from: i.from, options: xm, span: bs };
  if (i.name == "PseudoClassName")
    return { from: i.from, options: Om, span: bs };
  if (i.name == "TagName") {
    for (let { parent: o } = i; o; o = o.parent)
      if (o.name == "Block")
        return { from: i.from, options: Uc(), span: bs };
    return { from: i.from, options: MX, span: bs };
  }
  if (!a.explicit)
    return null;
  let s = i.resolve(t), n = s.childBefore(t);
  return n && n.name == ":" && s.name == "PseudoClassSelector" ? { from: t, options: Om, span: bs } : n && n.name == ":" && s.name == "Declaration" || s.name == "ArgList" ? { from: t, options: xm, span: bs } : s.name == "Block" ? { from: t, options: Uc(), span: bs } : null;
}, ku = /* @__PURE__ */ Un.define({
  parser: /* @__PURE__ */ LX.configure({
    props: [
      /* @__PURE__ */ Pl.add({
        Declaration: /* @__PURE__ */ vo()
      }),
      /* @__PURE__ */ Ll.add({
        Block: OO
      }),
      /* @__PURE__ */ xu({
        "import charset namespace keyframes": Y.definitionKeyword,
        "media supports": Y.controlKeyword,
        "from to selector": Y.keyword,
        NamespaceName: Y.namespace,
        KeyframeName: Y.labelName,
        TagName: Y.tagName,
        ClassName: Y.className,
        PseudoClassName: /* @__PURE__ */ Y.constant(Y.className),
        IdName: Y.labelName,
        "FeatureName PropertyName": Y.propertyName,
        AttributeName: Y.attributeName,
        NumberLiteral: Y.number,
        KeywordQuery: Y.keyword,
        UnaryQueryOp: Y.operatorKeyword,
        "CallTag ValueName": Y.atom,
        VariableName: Y.variableName,
        Callee: Y.operatorKeyword,
        Unit: Y.unit,
        "UniversalSelector NestingSelector": Y.definitionOperator,
        AtKeyword: Y.keyword,
        MatchOp: Y.compareOperator,
        "ChildOp SiblingOp, LogicOp": Y.logicOperator,
        BinOp: Y.arithmeticOperator,
        Important: Y.modifier,
        Comment: Y.blockComment,
        ParenthesizedContent: /* @__PURE__ */ Y.special(Y.name),
        ColorLiteral: Y.color,
        StringLiteral: Y.string,
        ":": Y.punctuation,
        "PseudoOp #": Y.derefOperator,
        "; ,": Y.separator,
        "( )": Y.paren,
        "[ ]": Y.squareBracket,
        "{ }": Y.brace
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
}), RX = /* @__PURE__ */ ku.data.of({ autocomplete: DX });
function qx() {
  return new iu(ku, RX);
}
const xr = ["_blank", "_self", "_top", "_parent"], Zc = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], qc = ["get", "post", "put", "delete"], Kc = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], Kt = ["true", "false"], ce = {}, Xl = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: xr,
      hreflang: null
    }
  },
  abbr: ce,
  acronym: ce,
  address: ce,
  applet: ce,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: ce,
  aside: ce,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: ce,
  base: { attrs: { href: null, target: xr } },
  basefont: ce,
  bdi: ce,
  bdo: ce,
  big: ce,
  blockquote: { attrs: { cite: null } },
  body: ce,
  br: ce,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: Kc,
      formmethod: qc,
      formnovalidate: ["novalidate"],
      formtarget: xr,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: ce,
  center: ce,
  cite: ce,
  code: ce,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: ce,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: ce,
  dir: ce,
  div: ce,
  dl: ce,
  dt: ce,
  em: ce,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: ce,
  figure: ce,
  font: ce,
  footer: ce,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": Zc,
      autocomplete: ["on", "off"],
      enctype: Kc,
      method: qc,
      novalidate: ["novalidate"],
      target: xr
    }
  },
  frame: ce,
  frameset: ce,
  h1: ce,
  h2: ce,
  h3: ce,
  h4: ce,
  h5: ce,
  h6: ce,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: ce,
  hgroup: ce,
  hr: ce,
  html: {
    attrs: { manifest: null }
  },
  i: ce,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: Kc,
      formmethod: qc,
      formnovalidate: ["novalidate"],
      formtarget: xr,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: ce,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: ce,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: ce,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: Zc,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: ce,
  noframes: ce,
  noscript: ce,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: ce,
  param: { attrs: { name: null, value: null } },
  pre: ce,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: ce,
  rt: ce,
  ruby: ce,
  s: ce,
  samp: ce,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: Zc
    }
  },
  section: ce,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  small: ce,
  source: { attrs: { src: null, type: null, media: null } },
  span: ce,
  strike: ce,
  strong: ce,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: ce,
  summary: ce,
  sup: ce,
  table: ce,
  tbody: ce,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: ce,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: ce,
  time: { attrs: { datetime: null } },
  title: ce,
  tr: ce,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  tt: ce,
  u: ce,
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: ce,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: ce
}, Kx = {
  accesskey: null,
  class: null,
  contenteditable: Kt,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: Kt,
  autocorrect: Kt,
  autocapitalize: Kt,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  onclick: null,
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": Kt,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": Kt,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": Kt,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": Kt,
  "aria-hidden": Kt,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": Kt,
  "aria-multiselectable": Kt,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": Kt,
  "aria-relevant": null,
  "aria-required": Kt,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, IX = /* @__PURE__ */ Object.keys(Xl), wm = /* @__PURE__ */ Object.keys(Kx);
function tr(a, e, t = a.length) {
  if (!e)
    return "";
  let i = e.firstChild, s = i && i.getChild("TagName");
  return s ? a.sliceString(s.from, Math.min(s.to, t)) : "";
}
function Yl(a, e = !1) {
  for (let t = a.parent; t; t = t.parent)
    if (t.name == "Element")
      if (e)
        e = !1;
      else
        return t;
  return null;
}
function Jx(a, e) {
  let t = Xl[tr(a, Yl(e, !0))];
  return (t == null ? void 0 : t.children) || IX;
}
function _u(a, e) {
  let t = [];
  for (let i = e; i = Yl(i); ) {
    let s = tr(a, i);
    if (s && i.lastChild.name == "CloseTag")
      break;
    s && t.indexOf(s) < 0 && (e.name == "EndTag" || e.from >= i.firstChild.to) && t.push(s);
  }
  return t;
}
const e0 = /^[:\-\.\w\u00b7-\uffff]+$/;
function Sm(a, e, t, i) {
  let s = /\s*>/.test(a.sliceDoc(i, i + 5)) ? "" : ">";
  return {
    from: t,
    to: i,
    options: Jx(a.doc, e).map((n) => ({ label: n, type: "type" })).concat(_u(a.doc, e).map((n, o) => ({ label: "/" + n, apply: "/" + n + s, type: "type", boost: 99 - o }))),
    span: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function km(a, e, t, i) {
  let s = /\s*>/.test(a.sliceDoc(i, i + 5)) ? "" : ">";
  return {
    from: t,
    to: i,
    options: _u(a.doc, e).map((n, o) => ({ label: n, apply: n + s, type: "type", boost: 99 - o })),
    span: e0
  };
}
function QX(a, e, t) {
  let i = [], s = 0;
  for (let n of Jx(a.doc, e))
    i.push({ label: "<" + n, type: "type" });
  for (let n of _u(a.doc, e))
    i.push({ label: "</" + n + ">", type: "type", boost: 99 - s++ });
  return { from: t, to: t, options: i, span: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function NX(a, e, t, i) {
  let s = Yl(e), n = s ? Xl[tr(a.doc, s)] : null, o = n && n.attrs ? Object.keys(n.attrs).concat(wm) : wm;
  return {
    from: t,
    to: i,
    options: o.map((l) => ({ label: l, type: "property" })),
    span: e0
  };
}
function FX(a, e, t, i) {
  var s;
  let n = (s = e.parent) === null || s === void 0 ? void 0 : s.getChild("AttributeName"), o = [], l;
  if (n) {
    let c = a.sliceDoc(n.from, n.to), d = Kx[c];
    if (!d) {
      let f = Yl(e), p = f ? Xl[tr(a.doc, f)] : null;
      d = (p == null ? void 0 : p.attrs) && p.attrs[c];
    }
    if (d) {
      let f = a.sliceDoc(t, i).toLowerCase(), p = '"', m = '"';
      /^['"]/.test(f) ? (l = f[0] == '"' ? /^[^"]*$/ : /^[^']*$/, p = "", m = a.sliceDoc(i, i + 1) == f[0] ? "" : f[0], f = f.slice(1), t++) : l = /^[^\s<>='"]*$/;
      for (let v of d)
        o.push({ label: v, apply: p + v + m, type: "constant" });
    }
  }
  return { from: t, to: i, options: o, span: l };
}
function WX(a) {
  let { state: e, pos: t } = a, i = pt(e).resolveInner(t), s = i.resolve(t, -1);
  for (let n = t, o; i == s && (o = s.childBefore(n)); ) {
    let l = o.lastChild;
    if (!l || !l.type.isError || l.from < l.to)
      break;
    i = s = o, n = l.from;
  }
  return s.name == "TagName" ? s.parent && /CloseTag$/.test(s.parent.name) ? km(e, s, s.from, t) : Sm(e, s, s.from, t) : s.name == "StartTag" ? Sm(e, s, t, t) : s.name == "StartCloseTag" || s.name == "IncompleteCloseTag" ? km(e, s, t, t) : a.explicit && (s.name == "OpenTag" || s.name == "SelfClosingTag") || s.name == "AttributeName" ? NX(e, s, s.name == "AttributeName" ? s.from : t, t) : s.name == "Is" || s.name == "AttributeValue" || s.name == "UnquotedAttributeValue" ? FX(e, s, s.name == "Is" ? t : s.from, t) : a.explicit && (i.name == "Element" || i.name == "Text" || i.name == "Document") ? QX(e, s, t) : null;
}
const Vl = /* @__PURE__ */ Un.define({
  parser: /* @__PURE__ */ fX.configure({
    props: [
      /* @__PURE__ */ Pl.add({
        Element(a) {
          let e = /^(\s*)(<\/)?/.exec(a.textAfter);
          return a.node.to <= a.pos + e[0].length ? a.continue() : a.lineIndent(a.node.from) + (e[2] ? 0 : a.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(a) {
          return a.column(a.node.from) + a.unit;
        },
        Document(a) {
          if (a.pos + /\s*/.exec(a.textAfter)[0].length < a.node.to)
            return a.continue();
          let e = null, t;
          for (let i = a.node; ; ) {
            let s = i.lastChild;
            if (!s || s.name != "Element" || s.to != i.to)
              break;
            e = i = s;
          }
          return e && !((t = e.lastChild) && (t.name == "CloseTag" || t.name == "SelfClosingTag")) ? a.lineIndent(e.from) + a.unit : null;
        }
      }),
      /* @__PURE__ */ Ll.add({
        Element(a) {
          let e = a.firstChild, t = a.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: t.name == "CloseTag" ? t.from : a.to };
        }
      }),
      /* @__PURE__ */ xu({
        "Text RawText": Y.content,
        "StartTag StartCloseTag SelfCloserEndTag EndTag SelfCloseEndTag": Y.angleBracket,
        TagName: Y.tagName,
        "MismatchedCloseTag/TagName": [Y.tagName, Y.invalid],
        AttributeName: Y.attributeName,
        "AttributeValue UnquotedAttributeValue": Y.attributeValue,
        Is: Y.definitionOperator,
        "EntityReference CharacterReference": Y.character,
        Comment: Y.blockComment,
        ProcessingInst: Y.processingInstruction,
        DoctypeDecl: Y.documentMeta
      })
    ],
    wrap: /* @__PURE__ */ gX([
      {
        tag: "script",
        attrs(a) {
          return !a.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(a.type);
        },
        parser: er.parser
      },
      {
        tag: "style",
        attrs(a) {
          return (!a.lang || a.lang == "css") && (!a.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(a.type));
        },
        parser: ku.parser
      }
    ])
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
}), BX = /* @__PURE__ */ Vl.data.of({ autocomplete: WX });
function zX(a = {}) {
  let e = Vl;
  return a.matchClosingTags === !1 && (e = e.configure({ dialect: "noMatch" })), new iu(e, [
    BX,
    a.autoCloseTags !== !1 ? XX : [],
    Bx().support,
    qx().support
  ]);
}
const XX = /* @__PURE__ */ Oe.inputHandler.of((a, e, t, i) => {
  if (a.composing || a.state.readOnly || e != t || i != ">" && i != "/" || !Vl.isActiveAt(a.state, e, -1))
    return !1;
  let { state: s } = a, n = s.changeByRange((o) => {
    var l, c, d;
    let { head: f } = o, p = pt(s).resolveInner(f, -1), m;
    if ((p.name == "TagName" || p.name == "StartTag") && (p = p.parent), i == ">" && p.name == "OpenTag") {
      if (((c = (l = p.parent) === null || l === void 0 ? void 0 : l.lastChild) === null || c === void 0 ? void 0 : c.name) != "CloseTag" && (m = tr(s.doc, p.parent, f)))
        return { range: ee.cursor(f + 1), changes: { from: f, insert: `></${m}>` } };
    } else if (i == "/" && p.name == "OpenTag") {
      let v = p.parent, r = v == null ? void 0 : v.parent;
      if (v.from == f - 1 && ((d = r.lastChild) === null || d === void 0 ? void 0 : d.name) != "CloseTag" && (m = tr(s.doc, r, f))) {
        let h = `/${m}>`;
        return { range: ee.cursor(f + h.length), changes: { from: f, insert: h } };
      }
    }
    return { range: o };
  });
  return n.changes.empty ? !1 : (a.dispatch(n, { userEvent: "input.type", scrollIntoView: !0 }), !0);
});
const HH = j({
  __name: "Codemirror",
  props: {
    modelValue: {},
    config: {}
  },
  emits: ["update:modelValue"],
  setup(a, { emit: e }) {
    var f;
    const t = new ka(), i = Re.transactionExtender.of((p) => {
      if (!p.docChanged)
        return null;
      let m = /^\s*</.test(p.newDoc.sliceString(0, 100)), v = p.startState.facet(as) == Vl;
      return m == v ? null : {
        effects: t.reconfigure(m ? zX() : Bx())
      };
    }), s = a, n = e, o = Z(), l = Ci(), c = Ci(), d = `ui-codemirror-${(f = yt()) == null ? void 0 : f.uid}`;
    return at(() => {
      const p = document.querySelector(`#${d}`), m = Oe.updateListener.of((r) => {
        if (r.docChanged && !c.value) {
          v();
          const h = r.state.doc, g = Array(h).join(`
`);
          n("update:modelValue", g);
        }
        c.value = !1;
      });
      p && (l.value = new Oe({
        parent: p,
        state: Re.create({
          doc: s.modelValue,
          extensions: [
            // myTheme,
            m,
            oO(),
            Rx,
            qB,
            t.of(qx()),
            i,
            Ta.of([...rx, ...uO, QF])
          ]
        })
      }));
      const v = Lt(() => {
        const r = l.value.state.update({
          changes: { from: 0, to: l.value.state.doc.length, insert: s.modelValue }
        });
        c.value = !0, l.value.update([r]);
      });
    }), (p, m) => (M(), D("div", {
      id: d,
      ref_key: "editorRef",
      ref: o,
      class: "ui-codemirror"
    }, null, 512));
  }
});
const YX = {}, VX = { class: "ui-breadcrumb" };
function HX(a, e) {
  return M(), D("div", VX, [
    te(a.$slots, "default")
  ]);
}
const GX = /* @__PURE__ */ gt(YX, [["render", HX]]);
const jX = { class: "ui-breadcrumb-item" }, Jc = j({
  __name: "BreadcrumbItem",
  props: {
    to: {}
  },
  setup(a) {
    return (e, t) => {
      const i = ud("router-link");
      return M(), D("div", jX, [
        e.to ? (M(), q(i, {
          key: 0,
          to: e.to
        }, {
          default: U(() => [
            te(e.$slots, "default")
          ]),
          _: 3
        }, 8, ["to"])) : te(e.$slots, "default", { key: 1 })
      ]);
    };
  }
});
var $r = /* @__PURE__ */ ((a) => (a.dark = "dark", a.light = "light", a))($r || {});
const _m = {
  get() {
    const a = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    return localStorage.getItem("ds_color_scheme") ?? a;
  }
}, UX = "ds_color_scheme", ZX = j({
  __name: "ButtonDarkmode",
  emits: ["changeSchemeColor"],
  setup(a, { emit: e }) {
    const t = e, i = Z("dark_mode"), s = (o) => {
      document.documentElement.setAttribute("data-theme", o), o == $r.dark ? i.value = "light_mode" : i.value = "dark_mode";
    }, n = () => {
      const o = _m.get() === $r.dark ? $r.light : $r.dark;
      t("changeSchemeColor", o), localStorage.setItem(UX, o), s(o);
    };
    return at(() => {
      s(_m.get());
    }), (o, l) => (M(), D("span", { onClick: n }, [
      te(o.$slots, "default", {}, () => [
        B(Ti, {
          icon: i.value,
          variant: "plain"
        }, null, 8, ["icon"])
      ])
    ]));
  }
});
const qX = {
  class: "ui-topbar",
  id: "ui-topbar"
}, KX = { class: "ui-topbar-wrapper" }, JX = { class: "ui-topbar-content" }, eY = { class: "ui-topbar-mobile" }, tY = /* @__PURE__ */ I("span", null, "voltar", -1), iY = /* @__PURE__ */ I("span", null, "Início", -1), sY = { class: "ui-topbar-actions" }, nY = { class: "ui-topbar-actions" }, GH = j({
  __name: "Topbar",
  props: {
    slug: {},
    backlink: {},
    breadcrumb: {},
    notifications: {},
    dropdown: { default: () => [] }
  },
  emits: ["toggleMenu", "toggleNotification", "changeSchemeColor"],
  setup(a, { emit: e }) {
    const t = a, i = e, s = la("menu");
    ge(() => Vv(t.user.name));
    const n = () => {
      i("toggleMenu"), s && s.toggle();
    }, o = () => i("changeSchemeColor");
    return (l, c) => (M(), D("div", qX, [
      I("div", KX, [
        I("div", JX, [
          I("div", eY, [
            I("button", {
              class: "ui-topbar-menu",
              onClick: n
            }, [
              B(Pe, { name: "menu" })
            ]),
            te(l.$slots, "logo-mobile")
          ]),
          B(GX, null, {
            default: U(() => [
              l.backlink ? (M(), q(Jc, {
                key: 0,
                to: { name: l.backlink.to },
                class: "btn-back"
              }, {
                default: U(() => [
                  B(Pe, { name: "arrow_back" }),
                  tY
                ]),
                _: 1
              }, 8, ["to"])) : X("", !0),
              B(Jc, { to: { name: "home" } }, {
                default: U(() => [
                  iY
                ]),
                _: 1
              }),
              (M(!0), D(ke, null, Ae(l.breadcrumb, (d) => (M(), q(Jc, {
                to: { name: d.to },
                key: d.name
              }, {
                default: U(() => [
                  I("span", null, ne(d.name), 1)
                ]),
                _: 2
              }, 1032, ["to"]))), 128))
            ]),
            _: 1
          })
        ]),
        I("div", sY, [
          I("div", nY, [
            te(l.$slots, "topbar-actions"),
            B(ZX, { onOnChangedTheme: o })
          ])
        ])
      ])
    ]));
  }
}), rY = {}, aY = { class: "ui-alert-title" };
function oY(a, e) {
  return M(), D("p", aY, [
    te(a.$slots, "default")
  ]);
}
const lY = /* @__PURE__ */ gt(rY, [["render", oY]]);
const Er = j({
  __name: "FormLayoutItem",
  props: {
    group: { type: Boolean }
  },
  setup(a) {
    return (e, t) => (M(), D("div", {
      class: he(["ui-form-layout-item", { "-group": e.group }])
    }, [
      te(e.$slots, "default")
    ], 2));
  }
});
const cY = { class: "ui-seo-card" }, hY = { class: "ui-seo-title" }, dY = { key: 0 }, uY = { class: "ui-seo-domain" }, fY = {
  key: 0,
  class: "ui-seo-description"
}, pY = /* @__PURE__ */ I("ul", null, [
  /* @__PURE__ */ I("li", null, [
    /* @__PURE__ */ I("b", null, "Meta title"),
    /* @__PURE__ */ ye(": até 90 caracteres; Google exibe somente 63")
  ]),
  /* @__PURE__ */ I("li", null, [
    /* @__PURE__ */ I("b", null, "Meta description"),
    /* @__PURE__ */ ye(": até 250 caracteres; Google exibe somente 160")
  ]),
  /* @__PURE__ */ I("li", null, [
    /* @__PURE__ */ I("b", null, "Meta keywords"),
    /* @__PURE__ */ ye(": até 200 caracteres, separados por vírgula")
  ])
], -1), gY = " | ", Cm = j({
  __name: "Seo",
  props: {
    title: {},
    domain: {},
    modelValue: {},
    viewOnly: { type: Boolean },
    writeOnly: { type: Boolean },
    isMetaTitle: { type: Boolean },
    gray: { type: Boolean },
    slugify: { type: Boolean, default: !0 },
    keyTitle: { default: "meta_title" },
    keySubTitle: { default: "meta_subtitle" },
    keyDescription: { default: "meta_description" },
    metaTitle: {}
  },
  emits: ["update:modelValue"],
  setup(a, { emit: e }) {
    const t = a, i = Z(""), s = Z(""), n = Z(""), o = ge(() => {
      const p = f(t.modelValue[t.keyDescription] || "");
      return PM(p, 250, "...");
    }), l = e, c = ge({
      get() {
        return t.modelValue;
      },
      set(p) {
        l("update:modelValue", p);
      }
    }), d = (p) => (p && t.metaTitle && !t.isMetaTitle && (p = p + gY + t.metaTitle), p), f = (p) => (p && (p = p.replace(/(<([^>]+)>)/gi, "")), p);
    return Lt(() => {
      t.modelValue && (i.value = d(t.modelValue[t.keyTitle] || t.modelValue.name || i.value), s.value = t.modelValue[t.keySubTitle] || null, n.value = t.modelValue.slug ? Mo(t.modelValue.slug) : Mo(i.value));
    }), (p, m) => (M(), D("div", {
      class: he(["ui-seo", { "-gray": p.gray }])
    }, [
      B(wl, null, {
        default: U(() => [
          p.viewOnly ? X("", !0) : (M(), q(rn, { key: 0 }, {
            default: U(() => [
              B(Er, null, {
                default: U(() => [
                  B(hi, {
                    modelValue: c.value.meta_title,
                    "onUpdate:modelValue": m[0] || (m[0] = (v) => c.value.meta_title = v),
                    placeholder: "Meta title",
                    label: "Meta title"
                  }, null, 8, ["modelValue"])
                ]),
                _: 1
              }),
              B(Er, null, {
                default: U(() => [
                  B(hi, {
                    modelValue: c.value.meta_description,
                    "onUpdate:modelValue": m[1] || (m[1] = (v) => c.value.meta_description = v),
                    placeholder: "Meta description",
                    label: "Meta description",
                    maxlength: "250",
                    type: "textarea"
                  }, null, 8, ["modelValue"])
                ]),
                _: 1
              }),
              B(Er, null, {
                default: U(() => [
                  B(hi, {
                    modelValue: c.value.meta_keywords,
                    "onUpdate:modelValue": m[2] || (m[2] = (v) => c.value.meta_keywords = v),
                    placeholder: "Ex: palavra1, palavra2",
                    label: "Meta keywords",
                    maxlength: "200"
                  }, null, 8, ["modelValue"])
                ]),
                _: 1
              }),
              B(Er, null, {
                default: U(() => [
                  B(hi, {
                    modelValue: c.value.slug,
                    "onUpdate:modelValue": m[3] || (m[3] = (v) => c.value.slug = v),
                    placeholder: "Ex: minha-url-amigavel",
                    label: "Url amigável"
                  }, null, 8, ["modelValue"])
                ]),
                _: 1
              })
            ]),
            _: 1
          })),
          p.writeOnly ? X("", !0) : (M(), q(rn, { key: 1 }, {
            default: U(() => [
              I("div", cY, [
                I("b", hY, [
                  ye(ne(i.value) + " ", 1),
                  s.value ? (M(), D("span", dY, "- " + ne(s.value), 1)) : X("", !0)
                ]),
                I("span", uY, [
                  ye(" https://" + ne(p.domain), 1),
                  Ze(I("span", null, "/" + ne(n.value), 513), [
                    [bt, n.value && p.slugify === !0]
                  ])
                ]),
                o.value ? (M(), D("div", fY, ne(o.value), 1)) : X("", !0)
              ])
            ]),
            _: 1
          }))
        ]),
        _: 1
      }),
      B(ih, {
        show: !p.viewOnly,
        class: "mt-4"
      }, {
        default: U(() => [
          B(lY, null, {
            default: U(() => [
              ye("Dicas de cadastro")
            ]),
            _: 1
          }),
          pY
        ]),
        _: 1
      }, 8, ["show"]),
      B(ih, {
        variant: "warning",
        show: !p.viewOnly,
        icon: "warning",
        last: ""
      }, {
        default: U(() => [
          ye(" Importante: a plataforma se encarrega de preencher estes dados básicos automaticamente. Caso você opte por preenchê-los manualmente, o sistema irá ignorar os dados gerados de forma dinâmica e exibirá os dados que você cadastrou. ")
        ]),
        _: 1
      }, 8, ["show"])
    ], 2));
  }
}), jH = j({
  __name: "CardSeo",
  props: {
    modelValue: {},
    keyTitle: {},
    keySubTitle: {},
    keyDescription: {},
    domain: {}
  },
  emits: ["update:modelValue"],
  setup(a, { emit: e }) {
    const t = a, i = e, s = ge({
      get() {
        return t.modelValue;
      },
      set(n) {
        i("update:modelValue", n);
      }
    });
    return (n, o) => (M(), q(Oa, {
      dropdown: "",
      class: "card-seo",
      dropdownLabel: "Editar",
      title: "Pré-visualização no Google",
      dropdownClosed: ""
    }, {
      "header-caption": U(() => [
        B(Cm, {
          modelValue: s.value,
          "onUpdate:modelValue": o[0] || (o[0] = (l) => s.value = l),
          keyTitle: n.keyTitle,
          keySubTitle: n.keySubTitle,
          keyDescription: n.keyDescription,
          domain: n.domain,
          viewOnly: "",
          gray: ""
        }, null, 8, ["modelValue", "keyTitle", "keySubTitle", "keyDescription", "domain"])
      ]),
      default: U(() => [
        B(Cm, {
          modelValue: s.value,
          "onUpdate:modelValue": o[1] || (o[1] = (l) => s.value = l),
          "write-only": "",
          gray: ""
        }, null, 8, ["modelValue"])
      ]),
      _: 1
    }));
  }
}), mY = {}, bY = { class: "ui-card-item" };
function vY(a, e) {
  return M(), D("div", bY, [
    te(a.$slots, "default")
  ]);
}
const UH = /* @__PURE__ */ gt(mY, [["render", vY]]), yY = { class: "ui-card-section" }, OY = {
  key: 0,
  class: "ui-card-section-header"
}, xY = { class: "ui-card-section-title" }, wY = {
  key: 0,
  class: "ui-card-section-actions"
}, SY = { class: "ui-card-section-content" }, ZH = j({
  __name: "CardSection",
  props: {
    title: {},
    actions: {}
  },
  setup(a) {
    return (e, t) => (M(), D("div", yY, [
      e.title ? (M(), D("div", OY, [
        I("h6", xY, ne(e.title), 1),
        e.actions ? (M(), D("div", wY, [
          (M(!0), D(ke, null, Ae(e.actions, (i) => (M(), q(Ai, {
            key: i.label,
            onClick: i.onAction
          }, {
            default: U(() => [
              ye(ne(i.label), 1)
            ]),
            _: 2
          }, 1032, ["onClick"]))), 128))
        ])) : X("", !0)
      ])) : X("", !0),
      I("div", SY, [
        te(e.$slots, "default")
      ])
    ]));
  }
}), kY = {}, _Y = { class: "ui-card-title" };
function CY(a, e) {
  return M(), D("h4", _Y, [
    te(a.$slots, "default")
  ]);
}
const qH = /* @__PURE__ */ gt(kY, [["render", CY]]);
const TY = ["src"], KH = j({
  __name: "ColorThumb",
  props: {
    hexadecimal: {},
    hexadecimalSecondary: {},
    image: {},
    size: { default: "md" },
    width: {}
  },
  setup(a) {
    const e = a, t = ge(() => {
      let s = [];
      return e.size && s.push(`-size-${e.size}`), s;
    }), i = ge(() => {
      const s = {};
      return e.width && (s.width = `${e.width}px`), s;
    });
    return (s, n) => (M(), D("span", {
      class: he(["ui-color-thumb", t.value]),
      style: wt(i.value)
    }, [
      s.image ? (M(), D("img", {
        key: 0,
        src: s.image.src,
        class: "ui-color-thumb-image"
      }, null, 8, TY)) : (M(), D(ke, { key: 1 }, [
        I("span", {
          class: "ui-color-thumb-color",
          style: wt({ backgroundColor: s.hexadecimal })
        }, null, 4),
        I("span", {
          class: "ui-color-thumb-color -secondary",
          style: wt({ backgroundColor: s.hexadecimalSecondary })
        }, null, 4)
      ], 64))
    ], 6));
  }
});
const AY = {}, $Y = { class: "button-action-list" };
function EY(a, e) {
  return M(), D("div", $Y, [
    te(a.$slots, "default")
  ]);
}
const JH = /* @__PURE__ */ gt(AY, [["render", EY]]);
const PY = { class: "table-responsive" }, LY = {
  key: 0,
  class: "ui-table-header"
}, MY = { class: "ui-table-row -head" }, e5 = j({
  __name: "Table",
  props: {
    hover: { type: Boolean },
    noPadding: { type: Boolean },
    tiny: { type: Boolean }
  },
  emits: ["click"],
  setup(a) {
    return (e, t) => (M(), D("div", PY, [
      I("div", {
        class: he(["ui-table", { "-hover": e.hover, "-no-padding": e.noPadding, "-tiny": e.tiny }])
      }, [
        e.$slots.header ? (M(), D("div", LY, [
          I("div", MY, [
            te(e.$slots, "header")
          ])
        ])) : X("", !0),
        te(e.$slots, "body"),
        te(e.$slots, "default")
      ], 2)
    ]));
  }
}), t5 = j({
  __name: "TableRow",
  props: {
    to: {},
    head: { type: Boolean }
  },
  setup(a) {
    const e = a, t = () => e.to ? "router-link" : "div";
    return (i, s) => (M(), q(Ut(t()), {
      class: he(["ui-table-row", { "-head": i.head }]),
      to: i.to
    }, {
      default: U(() => [
        te(i.$slots, "default")
      ]),
      _: 3
    }, 8, ["to", "class"]));
  }
}), i5 = j({
  __name: "TableCell",
  props: {
    action: { type: Boolean },
    drag: { type: Boolean },
    auto: { type: Boolean },
    handle: { type: Boolean },
    width: {},
    noWrap: { type: Boolean }
  },
  setup(a) {
    const e = a, t = Z([]), i = Z({});
    return at(() => {
      e.onAction && t.value.push("-auto"), e.drag && t.value.push("-drag"), e.handle && t.value.push("-handle"), e.auto && t.value.push("-auto"), e.noWrap && t.value.push("-nowrap"), e.width && (i.value.width = `${e.width}px`);
    }), (s, n) => (M(), D("div", {
      class: he(["ui-table-cell", t.value]),
      style: wt(i.value)
    }, [
      te(s.$slots, "default")
    ], 6));
  }
}), DY = {}, RY = { class: "ui-table-cell -head" };
function IY(a, e) {
  return M(), D("div", RY, [
    te(a.$slots, "default")
  ]);
}
const s5 = /* @__PURE__ */ gt(DY, [["render", IY]]);
const QY = ["id"], NY = { class: "ui-modal-content" }, FY = {
  key: 0,
  class: "ui-modal-header"
}, WY = { class: "ui-modal-header-wrapper" }, BY = { class: "ui-modal-title" }, zY = {
  key: 0,
  class: "ui-modal-caption"
}, XY = { class: "ui-modal-body" }, YY = {
  key: 1,
  class: "ui-modal-footer"
}, t0 = j({
  __name: "Modal",
  props: {
    caption: {},
    centered: { type: Boolean },
    class: {},
    hideHeader: { type: Boolean },
    hideFooter: { type: Boolean },
    id: {},
    inner: { type: Boolean },
    modelValue: { type: Boolean },
    noCloseOnBackdrop: { type: Boolean },
    params: {},
    scrollable: { type: Boolean },
    show: { type: Boolean },
    size: {},
    title: {},
    width: {}
  },
  emits: ["update:modelValue", "close", "open"],
  setup(a, { emit: e }) {
    var r;
    const t = a, i = e, s = oa(), n = Z(!1), o = Z([]), l = Z(t.title), c = Z({}), d = () => {
      t.noCloseOnBackdrop || p();
    }, f = Ci(t.id);
    t.id || (f.value = `modal-${(r = yt()) == null ? void 0 : r.uid}`);
    const p = () => {
      n.value = !1, setTimeout(() => {
        i("update:modelValue", !1), i("close");
      }, 300);
    }, m = (h) => !!s[h];
    t.size && o.value.push(`-${t.size}`), t.class && o.value.push(t.class), t.width && (c.value.maxWidth = `${t.width}px`);
    const v = (h) => {
      h.key == "Escape" && d();
    };
    return Lt(() => {
      t.modelValue ? (window.addEventListener("keydown", v, !1), document.body.classList.add("modal-open"), n.value = !0, i("open")) : (window.removeEventListener("keydown", v, !1), document.body.classList.remove("modal-open"));
    }), (h, u) => (M(), q(Am, { to: "body" }, [
      h.modelValue ? (M(), D("div", {
        key: 0,
        id: f.value,
        class: he(["ui-modal", [
          o.value,
          {
            "-hide": !n.value,
            "-scrollable": h.scrollable,
            "-inner": h.inner
          }
        ]])
      }, [
        I("div", {
          class: he(["ui-modal-overlay", { "-closable": !h.noCloseOnBackdrop }]),
          onClick: d
        }, null, 2),
        I("div", {
          class: "ui-modal-dialog",
          style: wt(c.value)
        }, [
          I("div", NY, [
            h.hideHeader ? X("", !0) : (M(), D("div", FY, [
              I("div", WY, [
                I("h4", BY, ne(l.value), 1),
                h.caption ? (M(), D("span", zY, ne(h.caption), 1)) : X("", !0)
              ]),
              B(Ti, {
                class: "ui-modal-close",
                id: "btn-close",
                onClick: p,
                size: "md",
                variant: "plain",
                icon: "close"
              })
            ])),
            I("div", XY, [
              h.modelValue ? te(h.$slots, "default", E0(al({ key: 0 }, h.params))) : X("", !0)
            ]),
            m("footer") ? (M(), D("div", YY, [
              te(h.$slots, "footer")
            ])) : X("", !0)
          ])
        ], 4)
      ], 10, QY)) : X("", !0)
    ]));
  }
}), VY = {}, HY = { class: "ui-modal-item" };
function GY(a, e) {
  return M(), D("div", HY, [
    te(a.$slots, "default")
  ]);
}
const n5 = /* @__PURE__ */ gt(VY, [["render", GY]]);
const jY = { class: "ui-timeline ui-timeline-avatar" }, UY = {
  key: 0,
  class: "ui-timeline-input"
}, ZY = { class: "ui-timeline-list" }, qY = { class: "ui-timeline-item-wrapper" }, KY = { class: "ui-timeline-item-content" }, JY = { class: "ui-timeline-info" }, eV = { class: "ui-timeline-item-title-wrapper" }, tV = { class: "ui-timeline-item-text" }, iV = { class: "ui-timeline-item-date" }, r5 = j({
  __name: "Timeline",
  props: {
    modelValue: {},
    inputMessage: { type: Boolean }
  },
  emits: ["onAddMessage", "onRemoveMessage"],
  setup(a, { emit: e }) {
    const t = e, i = Ci();
    function s(o) {
      return { template: o.textRaw };
    }
    function n() {
      t("onAddMessage", i.value), i.value = null;
    }
    return (o, l) => (M(), D("div", jY, [
      o.inputMessage ? (M(), D("div", UY, [
        I("form", {
          action: "",
          onSubmit: Xt(n, ["prevent"]),
          autocomplete: "off"
        }, [
          B(Lm, { spacing: "sm" }, {
            default: U(() => [
              B(hi, {
                required: "",
                modelValue: i.value,
                "onUpdate:modelValue": l[0] || (l[0] = (c) => i.value = c),
                placeholder: "Escreva um comentário..."
              }, null, 8, ["modelValue"]),
              B(Le, {
                variant: "primary",
                type: "submit",
                label: "Postar"
              })
            ]),
            _: 1
          })
        ], 32)
      ])) : X("", !0),
      I("ul", ZY, [
        (M(!0), D(ke, null, Ae(o.modelValue, (c, d) => (M(), D("li", {
          class: "ui-timeline-item",
          key: d
        }, [
          I("div", qY, [
            I("div", KY, [
              I("div", JY, [
                I("div", eV, [
                  c.title ? (M(), q(Ut(c.titleTo ? Ai : "div"), {
                    key: 0,
                    to: c.titleTo,
                    class: "ui-timeline-item-title"
                  }, {
                    default: U(() => [
                      ye(ne(c.title), 1)
                    ]),
                    _: 2
                  }, 1032, ["to"])) : X("", !0)
                ]),
                I("div", tV, [
                  c.textRaw ? (M(), q(Ut(s(c)), { key: 0 })) : X("", !0),
                  ye(" " + ne(c.text), 1)
                ]),
                I("small", iV, ne(c.date), 1)
              ]),
              B(Ti, {
                onClick: (f) => o.$emit("onRemoveMessage", c),
                icon: "close",
                size: "sm",
                variant: "plain"
              }, null, 8, ["onClick"])
            ])
          ])
        ]))), 128))
      ])
    ]));
  }
}), sV = { class: "ui-dropdown-item-wrapper" }, nV = ["href", "target"], rV = {
  key: 2,
  class: "ui-dropdown-item"
}, aV = j({
  __name: "DropdownItem",
  props: {
    href: {},
    to: {},
    label: {},
    target: { default: "_self" }
  },
  setup(a) {
    return (e, t) => {
      const i = ud("router-link");
      return M(), D("div", sV, [
        e.href ? (M(), D("a", {
          key: 0,
          href: e.href,
          target: e.target,
          class: "ui-dropdown-item"
        }, [
          te(e.$slots, "default", {}, () => [
            ye(ne(e.label), 1)
          ])
        ], 8, nV)) : e.to ? (M(), q(i, {
          key: 1,
          to: e.to,
          class: "ui-dropdown-item"
        }, {
          default: U(() => [
            te(e.$slots, "default", {}, () => [
              ye(ne(e.label), 1)
            ])
          ]),
          _: 3
        }, 8, ["to"])) : (M(), D("span", rV, [
          te(e.$slots, "default", {}, () => [
            ye(ne(e.label), 1)
          ])
        ]))
      ]);
    };
  }
}), oV = {}, lV = { class: "ui-dropdown-divider" };
function cV(a, e) {
  return M(), D("div", lV);
}
const hV = /* @__PURE__ */ gt(oV, [["render", cV]]);
const dV = { class: "ui-gmaps" }, uV = ["href"], fV = ["src"], pV = /* @__PURE__ */ I("div", { class: "overlay" }, [
  /* @__PURE__ */ I("small", null, "Ver no"),
  /* @__PURE__ */ I("b", null, "Google Maps")
], -1), a5 = j({
  __name: "Gmaps",
  props: {
    address: {},
    linkOnly: { type: Boolean },
    style: {},
    width: { default: 720 },
    height: { default: 360 },
    zoom: { default: 20 }
  },
  setup(a) {
    const e = a, t = Z(null);
    let i;
    const s = (o) => {
      if (o) {
        const l = `${o.city} - ${o.state}`;
        return [o.street, o.number, l, o.zipcode].join("+").replace(/\++$/, "");
      }
    }, n = () => `https://www.google.com.br/maps/place/${s(e.address)}`;
    return Lt(() => {
      clearTimeout(i), i = setTimeout(() => {
        const o = s(e.address), l = "";
        t.value = `https://maps.googleapis.com/maps/api/staticmap?zoom=${e.zoom}&size=${e.width}x${e.height}&maptype=roadmap&format=png&visual_refresh=true&markers=color:0x00b7ff%7C40${o}&key=AIzaSyARh-u6T7Ux8wueTasFON8k0GiZRbMejDo${l}`;
      }, 1e3);
    }), (o, l) => (M(), D("div", dV, [
      o.linkOnly ? (M(), q(Ai, {
        key: 0,
        href: n,
        target: "_blank"
      }, {
        default: U(() => [
          ye(" ver no mapa ")
        ]),
        _: 1
      })) : X("", !0),
      !o.linkOnly && t.value ? (M(), D("a", {
        key: 1,
        href: n(),
        target: "_blank",
        class: "ui-gmaps-link"
      }, [
        I("img", {
          class: "",
          src: t.value,
          alt: "Google Maps"
        }, null, 8, fV),
        pV
      ], 8, uV)) : X("", !0)
    ]));
  }
});
const gV = { class: "ui-rating" }, mV = ["onClick"], o5 = j({
  __name: "RatingStar",
  props: {
    modelValue: { default: 1 },
    size: {}
  },
  emits: ["update:modelValue", "update"],
  setup(a, { emit: e }) {
    const t = e, i = a, s = (o) => o > i.modelValue ? "star-border" : "star", n = (o) => {
      t("update:modelValue", o), t("update", o);
    };
    return (o, l) => (M(), D("div", gV, [
      (M(), D(ke, null, Ae(5, (c) => I("span", {
        class: he(s(c)),
        key: c,
        onClick: Xt((d) => n(c), ["stop"])
      }, [
        B(Pe, {
          name: "star_rate",
          filled: "",
          type: "rounded",
          size: o.size
        }, null, 8, ["size"]),
        B(Pe, {
          name: "star_rate",
          type: "rounded",
          size: o.size
        }, null, 8, ["size"])
      ], 10, mV)), 64))
    ]));
  }
});
const bV = { class: "ui-callout-card-content" }, vV = { class: "ui-callout-card-header" }, yV = {
  key: 0,
  class: "ui-callout-card-title"
}, OV = { class: "ui-callout-card-text" }, l5 = j({
  __name: "CalloutCard",
  props: {
    title: {},
    icon: {},
    primaryAction: {},
    justifyCardActions: {},
    bgColorIconPrimary: { type: Boolean }
  },
  setup(a) {
    return (e, t) => (M(), q(Oa, { class: "ui-callout-card" }, {
      default: U(() => {
        var i, s, n;
        return [
          e.icon ? (M(), D("div", {
            key: 0,
            class: he(["ui-callout-card-icon", { "-bg-primary": e.bgColorIconPrimary }])
          }, [
            B(Pe, {
              name: e.icon,
              size: "30"
            }, null, 8, ["name"])
          ], 2)) : X("", !0),
          I("div", bV, [
            I("div", vV, [
              e.title ? (M(), D("h5", yV, ne(e.title), 1)) : X("", !0),
              te(e.$slots, "append-to-header")
            ]),
            I("div", OV, [
              te(e.$slots, "default")
            ]),
            e.primaryAction ? (M(), D("div", {
              key: 0,
              class: "ui-callout-card-actions",
              style: wt({ "justify-content": e.justifyCardActions || "flex-end" })
            }, [
              B(Le, {
                to: e.primaryAction.to,
                variant: (i = e.primaryAction) == null ? void 0 : i.variant,
                label: (s = e.primaryAction) == null ? void 0 : s.label,
                onClick: (n = e.primaryAction) == null ? void 0 : n.onAction,
                leadingIcon: e.primaryAction.leadingIcon
              }, null, 8, ["to", "variant", "label", "onClick", "leadingIcon"])
            ], 4)) : X("", !0)
          ])
        ];
      }),
      _: 3
    }));
  }
}), xV = {}, wV = { class: "ui-form-layout" };
function SV(a, e) {
  return M(), D("div", wV, [
    te(a.$slots, "default")
  ]);
}
const c5 = /* @__PURE__ */ gt(xV, [["render", SV]]);
const kV = {}, _V = { class: "ui-list-group" };
function CV(a, e) {
  return M(), D("div", _V, [
    te(a.$slots, "default")
  ]);
}
const h5 = /* @__PURE__ */ gt(kV, [["render", CV]]);
const TV = {}, AV = { class: "ui-list-group-item" };
function $V(a, e) {
  return M(), D("div", AV, [
    te(a.$slots, "default")
  ]);
}
const d5 = /* @__PURE__ */ gt(TV, [["render", $V]]);
const EV = {
  key: 0,
  class: "ui-media-card-video"
}, PV = ["src"], LV = ["src"], MV = {
  key: 1,
  class: "ui-media-card-image"
}, DV = ["href"], RV = ["src"], IV = { class: "ui-media-card-info" }, QV = ["textContent"], NV = { class: "ui-media-card-info-buttons" }, u5 = j({
  __name: "MediaCard",
  props: {
    title: {},
    text: {},
    video: {},
    image: {},
    imageHref: {},
    inverse: { type: Boolean },
    buttons: {}
  },
  setup(a) {
    const e = a, t = Z(!1), i = Z([]);
    return e.inverse && i.value.push("-inverted"), e.video && i.value.push("-video"), (s, n) => (M(), D("div", {
      class: he(["ui-media-card", i.value])
    }, [
      s.video ? (M(), D("div", EV, [
        I("img", {
          src: `https://img.youtube.com/vi/${s.video}/mqdefault.jpg`,
          onClick: n[0] || (n[0] = (o) => t.value = !t.value)
        }, null, 8, PV),
        B(t0, {
          modelValue: t.value,
          "onUpdate:modelValue": n[1] || (n[1] = (o) => t.value = o)
        }, {
          default: U(() => [
            I("iframe", {
              src: "https://www.youtube.com/embed/" + s.video + "?autoplay=1",
              frameborder: "0",
              allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",
              allowfullscreen: "",
              style: { height: "70vh" }
            }, null, 8, LV)
          ]),
          _: 1
        }, 8, ["modelValue"]),
        B(Pe, {
          name: "play_arrow",
          onClick: n[2] || (n[2] = (o) => t.value = !t.value)
        })
      ])) : (M(), D("div", MV, [
        I("a", { href: s.imageHref }, [
          I("img", { src: s.image }, null, 8, RV)
        ], 8, DV)
      ])),
      B(Oa, { title: s.title }, {
        default: U(() => [
          I("div", IV, [
            I("p", {
              class: "ui-media-card-info-text",
              textContent: ne(s.text)
            }, null, 8, QV),
            I("div", NV, [
              (M(!0), D(ke, null, Ae(s.buttons, (o) => (M(), q(Le, {
                key: o.label,
                href: o.to,
                target: o.target,
                size: "sm",
                label: o.label,
                variant: o.variant
              }, null, 8, ["href", "target", "label", "variant"]))), 128))
            ])
          ])
        ]),
        _: 1
      }, 8, ["title"])
    ], 2));
  }
});
const FV = { class: "user-card-btn-wrapper" }, WV = { class: "user-card-btn-avatar" }, BV = ["src"], zV = { key: 1 }, XV = {
  key: 0,
  class: "user-card-btn-text"
}, YV = { class: "user-card-btn-text-info" }, VV = { class: "name" }, HV = {
  key: 0,
  class: "user-card-btn-text-caption"
}, GV = { class: "icon-arrow-up" }, jV = j({
  __name: "UserButton",
  props: {
    userName: {},
    caption: {},
    image: {},
    hideIcon: { type: Boolean }
  },
  setup(a) {
    const e = a, t = ge(() => Vv(e.userName));
    return (i, s) => (M(), D("div", FV, [
      I("div", WV, [
        i.image ? (M(), D("img", {
          key: 0,
          src: i.image
        }, null, 8, BV)) : (M(), D("span", zV, ne(t.value), 1))
      ]),
      i.userName ? (M(), D("div", XV, [
        I("div", YV, [
          I("span", VV, ne(i.userName), 1),
          i.caption ? (M(), D("span", HV, ne(i.caption), 1)) : X("", !0)
        ]),
        I("span", GV, [
          i.hideIcon ? X("", !0) : (M(), q(Pe, {
            key: 0,
            name: "keyboard_arrow_up",
            size: "sm"
          }))
        ])
      ])) : X("", !0)
    ]));
  }
}), UV = /* @__PURE__ */ gt(jV, [["__scopeId", "data-v-dd6e8f3a"]]);
const ZV = { class: "user-card" }, qV = {
  key: 0,
  class: "user-card-label"
}, KV = { class: "user-card-btn" }, JV = { class: "dropdown-item" }, eH = {
  key: 0,
  class: "dropdown-item-caption"
}, f5 = j({
  __name: "UserProfileCard",
  props: {
    user: {},
    caption: {},
    dropdown: {},
    label: {},
    dropUp: { type: Boolean }
  },
  setup(a) {
    const e = a, t = ge(() => {
      var i;
      return (i = e.dropdown) == null ? void 0 : i.map((s) => (s.text ? s.to || s.href ? s.component = aV : s.component = kl : s.component = hV, s));
    });
    return (i, s) => (M(), D("div", ZV, [
      i.label ? (M(), D("small", qV, ne(i.label), 1)) : X("", !0),
      I("div", KV, [
        B(et(ya), {
          "no-close-on-click-tag": "SMALL",
          "close-on": "",
          right: "",
          "drop-up": i.dropUp
        }, {
          "button-content": U(() => {
            var n;
            return [
              B(UV, {
                "user-name": i.user.name,
                image: (n = i.user.image) == null ? void 0 : n.src,
                caption: i.caption
              }, null, 8, ["user-name", "image", "caption"])
            ];
          }),
          default: U(() => [
            te(i.$slots, "user-links"),
            (M(!0), D(ke, null, Ae(t.value, (n) => (M(), D("div", JV, [
              n.caption ? (M(), D("small", eH, ne(n.caption), 1)) : X("", !0),
              (M(), q(Ut(n.component), al({
                key: n,
                target: n.target,
                onClick: n.onAction
              }, n), {
                default: U(() => [
                  n.icon ? (M(), q(Pe, {
                    key: 0,
                    name: n.icon
                  }, null, 8, ["name"])) : X("", !0),
                  I("span", null, ne(n.text), 1)
                ]),
                _: 2
              }, 1040, ["target", "onClick"]))
            ]))), 256))
          ]),
          _: 3
        }, 8, ["drop-up"])
      ])
    ]));
  }
}), tH = 768;
const p5 = j({
  __name: "QuickSearch",
  props: {
    title: { default: "Busca rápida" },
    caption: { default: "Encontre o que precisa na sua loja virtual." },
    searchOptions: {},
    modelValue: { type: Boolean },
    placeholder: { default: "Ex: Camiseta Bagy" },
    buttonLabel: { default: "Pesquisar" }
  },
  emits: ["onSubmit", "update:modelValue", "onChangeOption"],
  setup(a, { emit: e }) {
    const t = a, i = e, s = es(tH), n = ge({
      get: () => t.modelValue,
      set: (f) => {
        i("update:modelValue", f);
      }
    }), o = Z({
      searchKey: "",
      searchType: t.searchOptions[0].value
    });
    function l() {
      o.value = {
        searchKey: "",
        searchType: t.searchOptions[0].value
      };
    }
    function c() {
      i("onSubmit", o.value), l();
    }
    function d(f) {
      i("onChangeOption", f);
    }
    return (f, p) => (M(), q(t0, {
      class: "modal-container",
      modelValue: n.value,
      "onUpdate:modelValue": p[2] || (p[2] = (m) => n.value = m),
      title: f.title,
      caption: f.caption
    }, {
      default: U(() => [
        I("form", {
          onSubmit: Xt(c, ["prevent"])
        }, [
          B(Lm, { class: "form" }, {
            default: U(() => [
              B(Er, null, {
                default: U(() => [
                  B(NP, {
                    modelValue: o.value.searchType,
                    "onUpdate:modelValue": p[0] || (p[0] = (m) => o.value.searchType = m),
                    options: f.searchOptions,
                    name: "searchType",
                    onUpdate: d
                  }, null, 8, ["modelValue", "options"])
                ]),
                _: 1
              }),
              B(hi, {
                modelValue: o.value.searchKey,
                "onUpdate:modelValue": p[1] || (p[1] = (m) => o.value.searchKey = m),
                name: "searchKey",
                placeholder: f.placeholder,
                autofocus: ""
              }, null, 8, ["modelValue", "placeholder"]),
              B(Le, {
                leadingIcon: "search",
                type: "submit",
                block: et(s),
                variant: "primary"
              }, {
                default: U(() => [
                  ye(ne(f.buttonLabel), 1)
                ]),
                _: 1
              }, 8, ["block"])
            ]),
            _: 1
          }),
          te(f.$slots, "default")
        ], 32)
      ]),
      _: 3
    }, 8, ["modelValue", "title", "caption"]));
  }
});
export {
  fd as $dialog,
  Q0 as $toast,
  ih as Alert,
  MH as Apexchart,
  ll as Aside,
  Fu as AsideSection,
  gH as Avatar,
  Xw as Badge,
  hD as BrowserSelect,
  Le as Button,
  WM as ButtonAction,
  JH as ButtonActionList,
  oH as ButtonGroup,
  l5 as CalloutCard,
  Oa as Card,
  WH as CardActive,
  jP as CardAnnotation,
  UH as CardItem,
  ZH as CardSection,
  jH as CardSeo,
  qH as CardTitle,
  HH as Codemirror,
  rn as Col,
  KH as ColorThumb,
  c2 as Container,
  xM as CustomScroll,
  rH as DescriptionList,
  aH as DescriptionListItem,
  mw as Dialog,
  dH as Divider,
  ya as Dropdown,
  hV as DropdownDivider,
  aV as DropdownItem,
  kl as DropdownItemButton,
  TD as DropdownSection,
  DH as EmptyData,
  uH as FormAutocomplete,
  ir as FormCheckbox,
  xH as FormColorpicker,
  hH as FormCurrency,
  DP as FormDatepicker,
  pH as FormHelper,
  pd as FormLabel,
  c5 as FormLayout,
  Er as FormLayoutItem,
  Mm as FormRadio,
  cH as FormRange,
  RH as FormRegister,
  wH as FormRichtext,
  NP as FormSelect,
  kH as FormSelectOption,
  fH as FormSpinbutton,
  yH as FormTags,
  lH as FormTextarea,
  hi as FormTextfield,
  Ob as FormValidation,
  CH as FrameAnnotation,
  a5 as Gmaps,
  Pe as Icon,
  Ti as IconButton,
  vH as Image,
  HM as InfiniteScroll,
  _H as Layout,
  Ai as Link,
  h5 as ListGroup,
  d5 as ListGroupItem,
  u5 as MediaCard,
  t0 as Modal,
  n5 as ModalItem,
  NH as Page,
  OH as PageActions,
  gR as PageHelper,
  lR as PageHelperVideo,
  uR as PageMessageSupport,
  mH as ProgressBar,
  p5 as QuickSearch,
  o5 as RatingStar,
  wl as Row,
  FH as RowExclude,
  f2 as Savebar,
  uH as Select,
  Cm as Seo,
  IH as Sidebar,
  wn as Skeleton,
  bH as SkeletonList,
  VA as SkeletonTable,
  dn as Spinner,
  Lm as Stack,
  BH as StatsGroup,
  ER as StatsItem,
  wM as Tab,
  dp as TabItem,
  e5 as Table,
  i5 as TableCell,
  s5 as TableHeadCell,
  QH as TableList,
  GD as TableListEmptyMessage,
  Ha as TableListItem,
  TM as TableListTable,
  t5 as TableRow,
  qA as Tag,
  t$ as TagList,
  Hr as TextStyle,
  r5 as Timeline,
  n2 as Titlebar,
  D0 as Toast,
  GH as Topbar,
  UV as UserButton,
  f5 as UserProfileCard
};
